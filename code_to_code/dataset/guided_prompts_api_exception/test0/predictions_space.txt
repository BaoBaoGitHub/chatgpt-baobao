 @ Override public void serialize ( ILittleEndianOutput out1 )  { out1 . writeShort ( field_1_vcenter )  ;  }
public void addAll ( BlockList < T >  src )  { if  ( src . size == 0 )  { return ;  } int srcDirIdx = 0 ;  for  (  ;  srcDirIdx  <  src . tailDirIdx ;  srcDirIdx ++  )  { addAll ( src . directory [ srcDirIdx ]  ,  0 ,  BLOCK_SIZE )  ;  } if  ( src . tailBlkIdx != 0 )  { addAll ( src . tailBlock ,  0 ,  src . tailBlkIdx )  ;  } } private void addAll ( T [  ]  array ,  int startIndex ,  int endIndex )  { for  ( int i = startIndex ;  i  <  endIndex ;  i ++  )  { add ( array [ i ]  )  ;  } }
 @ Override public void write ( int b )  { if  ( outerInstance . upto == outerInstance . blockSize )  { if  ( outerInstance . currentBlock != null )  { outerInstance . blocks . add ( outerInstance . currentBlock )  ;  outerInstance . blockEnd . add ( outerInstance . upto )  ;  } outerInstance . currentBlock = new byte [ outerInstance . blockSize ]  ;  outerInstance . upto = 0 ;  } outerInstance . currentBlock [ outerInstance . upto ++  ]  =  ( byte ) b ;  }
public ObjectId getObjectId (  )  { return objectId ;  }
public DeleteDomainEntryResponse deleteDomainEntry ( DeleteDomainEntryRequest request )  { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( DeleteDomainEntryRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( DeleteDomainEntryResponseUnmarshaller . getInstance (  )  )  ;  try { return invoke ( request ,  options )  ;  } catch  ( Exception e )  { // Handle the exception as appropriate e . printStackTrace (  )  ;  return null ;  // Or throw a custom exception } } private  < T >  T invoke ( DeleteDomainEntryRequest request ,  InvokeOptions options )  { // Implement the logic for invoking the request and handling the response // Return the response object of type T // Or throw an exception if the operation fails return null ;  }
public long ramBytesUsed (  )  { try { return termOffsets . ramBytesUsed (  )  + termsDictOffsets . ramBytesUsed (  )  ;  } catch  ( IOException e )  { throw new RuntimeException ( e )  ;  } } private class TermOffsets { public long ramBytesUsed (  )  throws IOException { return fst == null ? 0 : fst . getSizeInBytes (  )  ;  } } private class TermsDictOffsets { public long ramBytesUsed (  )  throws IOException { return fst == null ? 0 : fst . getSizeInBytes (  )  ;  } }
public String getFullMessage (  )  { byte [  ]  raw = buffer ;  try { int msgB = RawParseUtils . tagMessage ( raw ,  0 )  ;  if  ( msgB  <  0 )  { return "" ;  } Charset cs = RawParseUtils . guessEncoding ( raw )  ;  return RawParseUtils . decode ( cs ,  raw ,  msgB ,  raw . length )  ;  } catch  ( UnsupportedCharsetException e )  { System . err . println ( "Unsupported charset: " + e . getMessage (  )  )  ;  } catch  ( IllegalCharsetNameException e )  { System . err . println ( "Illegal charset name: " + e . getMessage (  )  )  ;  } catch  ( CharacterCodingException e )  { System . err . println ( "Error decoding message: " + e . getMessage (  )  )  ;  } catch  ( Exception e )  { System . err . println ( "Error getting full message: " + e . getMessage (  )  )  ;  } return "" ;  }
import java . io . IOException ;  import java . util . ArrayList ;  import org . apache . poi . poifs . filesystem . HeaderBlock ;  import org . apache . poi . poifs . filesystem . POIFSFileSystem ;  import org . apache . poi . poifs . property . PropertyTable ;  public class Example { public static void main ( String [  ]  args )  { try { HeaderBlock headerBlock = new HeaderBlock ( bigBlockSize )  ;  PropertyTable propertyTable = new PropertyTable ( headerBlock )  ;  ArrayList < Object >  documents = new ArrayList < Object >  (  )  ;  Object root = null ;  POIFSFileSystem poifsFileSystem = new POIFSFileSystem (  )  ;  poifsFileSystem . createEmptyBATBlock (  )  ;  poifsFileSystem . setOurBlockIndex ( 0 )  ;  poifsFileSystem . setNextBlock ( 1 )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } } }
public void init ( int address )  { slice = pool . buffers [ address  >  >  ByteBlockPool . BYTE_BLOCK_SHIFT ]  ;  assert slice != null ;  upto = address & ByteBlockPool . BYTE_BLOCK_MASK ;  offset0 = address ;  assert upto  <  slice . length ;  } Note: In Java ,  assertions are disabled by default ,  so in order for the assert statements to be executed ,  they must be explicitly enabled using the "-ea" flag when running the program . 
public NGit . Api . SubmoduleAddCommand setPath ( String path )  { this . path = path ;  return this ;  }
public ListIngestionsResponse listIngestions ( ListIngestionsRequest request )  { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( ListIngestionsRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( ListIngestionsResponseUnmarshaller . getInstance (  )  )  ;  return invoke ( request ,  options ,  ListIngestionsResponse . class )  ;  } private  < T >  T invoke ( Request < ? >  request ,  InvokeOptions options ,  Class < T >  clazz )  { AmazonWebServiceRequest awsRequest = beforeClientExecution ( request )  ;  return clientHandler . execute ( awsRequest ,  options ,  responseHandler ,  errorResponseHandler ,  executionContext ,  clazz )  ;  } private  < T >  AmazonWebServiceRequest beforeClientExecution ( Request < T >  request )  { return request . getOriginalRequest (  )  ;  }
public class QueryParserTokenManager { public QueryParserTokenManager ( CharStream stream ,  int lexState )  { super ( stream )  ;  try { SwitchTo ( lexState )  ;  } catch  ( TokenMgrError e )  { // handle exception } } }
public GetShardIteratorResponse getShardIterator ( GetShardIteratorRequest request )  { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( GetShardIteratorRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( GetShardIteratorResponseUnmarshaller . getInstance (  )  )  ;  return invoke ( request ,  options ,  GetShardIteratorResponse . class )  ;  } private  < T >  T invoke ( AmazonWebServiceRequest request ,  InvokeOptions options ,  Class < T >  responseType )  { ExecutionContext executionContext = createExecutionContext ( request )  ;  beforeClientExecution ( request ,  executionContext )  ;  return clientHandler . execute ( newClientExecutionParams ( request ,  executionContext ,  options )  ,  responseType )  ;  } private ExecutionContext createExecutionContext ( AmazonWebServiceRequest request )  { // create execution context logic here } private void beforeClientExecution ( AmazonWebServiceRequest request ,  ExecutionContext executionContext )  { // before client execution logic here } private  < T >  T executeGetShardIterator ( GetShardIteratorRequest request ,  Class < T >  responseType )  { GetShardIteratorResponse response = getShardIterator ( request )  ;  return responseType . cast ( response )  ;  } private ClientExecutionParams newClientExecutionParams ( AmazonWebServiceRequest request ,  ExecutionContext executionContext ,  InvokeOptions options )  { // create new client execution params logic here }
public class ModifyStrategyRequest extends AegisRpcRequest { public ModifyStrategyRequest (  )  { super ( "aegis" ,  "2016-11-11" ,  "ModifyStrategy" ,  "vipaegis" ,  "openAPI" )  ;  setMethod ( MethodType . POST )  ;  } }
 @ Override public boolean ready (  )  throws IOException { synchronized  ( lock )  { if  ( in == null )  { throw new IOException ( "InputStreamReader is closed" )  ;  } try { return bytes . hasRemaining (  )  || in . available (  )   >  0 ;  } catch  ( IOException e )  { return false ;  } } }
protected EscherOptRecord getOptRecord (  )  { return _optRecord ;  }
 @ Override public synchronized int read ( byte [  ]  buffer ,  int offset ,  int length )  { if  ( buffer == null )  { throw new NullPointerException ( "buffer == null" )  ;  } java . util . Arrays . checkOffsetAndCount ( buffer . length ,  offset ,  length )  ;  if  ( length == 0 )  { return 0 ;  } int copylen = count - pos  <  length ? count - pos : length ;  for  ( int i = 0 ;  i  <  copylen ;  i ++  )  { buffer [ offset + i ]  =  ( byte )  buffer [ pos + i ]  ;  } pos += copylen ;  return copylen ;  }
public class OpenNLPSentenceBreakIterator { private NLPSentenceDetectorOp sentenceOp ;  public OpenNLPSentenceBreakIterator ( NLPSentenceDetectorOp sentenceOp )  { this . sentenceOp = sentenceOp ;  } }
public void print ( String str )  { try { String value = str != null ? str : String . valueOf (  ( Object )  null )  ;  write ( value )  ;  } catch  ( Exception ex )  { ex . printStackTrace (  )  ;  } } private void write ( String value )  { try { // Call the print method from the target class SomeClass . print ( value )  ;  } catch  ( Exception ex )  { ex . printStackTrace (  )  ;  } }
public class NotImplementedFunctionException extends Exception { private String functionName ;  public NotImplementedFunctionException ( String functionName ,  NotImplementedException cause )  { super ( functionName ,  cause )  ;  try { this . functionName = functionName ;  } catch  ( Exception e )  { // handle the exception ,  if any } } }
 @ Override public V next (  )  { return super . nextEntry (  )  . getValue (  )  ;  }
public void ReadBytes ( byte [  ]  b ,  int offset ,  int len ,  boolean useBuffer )  throws IOException { int available = bufferLength - bufferPosition ;  if  ( len  < = available )  { if  ( len  >  0 )  { System . arraycopy ( m_buffer ,  bufferPosition ,  b ,  offset ,  len )  ;  } bufferPosition += len ;  } else { if  ( available  >  0 )  { System . arraycopy ( m_buffer ,  bufferPosition ,  b ,  offset ,  available )  ;  offset += available ;  len -= available ;  bufferPosition += available ;  } if  ( useBuffer && len  <  bufferSize )  { Refill (  )  ;  if  ( bufferLength  <  len )  { System . arraycopy ( m_buffer ,  0 ,  b ,  offset ,  bufferLength )  ;  throw new EOFException ( "read past EOF: " + this )  ;  } else { System . arraycopy ( m_buffer ,  0 ,  b ,  offset ,  len )  ;  bufferPosition = len ;  } } else { long after = bufferStart + bufferPosition + len ;  if  ( after  >  Length )  { throw new EOFException ( "read past EOF: " + this )  ;  } ReadInternal ( b ,  offset ,  len )  ;  bufferStart = after ;  bufferPosition = 0 ;  bufferLength = 0 ;  } } } private void Refill (  )  throws IOException { int n = ReadInternal ( m_buffer ,  0 ,  Math . min ( bufferSize ,   ( int )  ( Length - bufferStart )  )  )  ;  if  ( n  >  0 )  { bufferLength = n ;  bufferPosition = 0 ;  } else { throw new EOFException ( "Cannot refill buffer ,  end of stream reached" )  ;  } } private int ReadInternal ( byte [  ]  b ,  int offset ,  int len )  throws IOException { int n = input . read ( b ,  offset ,  len )  ;  if  ( n  <  0 )  { throw new EOFException ( "Cannot read from input stream" )  ;  } return n ;  }
public TagQueueResponse tagQueue ( TagQueueRequest request )  { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( TagQueueRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( TagQueueResponseUnmarshaller . getInstance (  )  )  ;  return invoke ( request ,  options ,  TagQueueResponse . class )  ;  } public void beforeClientExecution ( Request < ? >  request )  { // No implementation provided } public  < T >  Response < T >  executeTagQueue (  Request < ? >  request ,  HttpResponseHandler < AmazonWebServiceResponse < T >  >  responseHandler ,  HttpResponseHandler < AmazonServiceException >  errorResponseHandler )  { // No implementation provided }
 @ Override public void remove (  )  throws UnsupportedOperationException { throw new UnsupportedOperationException (  )  ;  }
import com . amazonaws . services . elasticache . AmazonElastiCache ;  import com . amazonaws . services . elasticache . model . ModifyCacheSubnetGroupRequest ;  import com . amazonaws . services . elasticache . model . ModifyCacheSubnetGroupResponse ;  import com . amazonaws . services . elasticache . model . transform . ModifyCacheSubnetGroupRequestMarshaller ;  import com . amazonaws . services . elasticache . model . transform . ModifyCacheSubnetGroupResponseUnmarshaller ;  public ModifyCacheSubnetGroupResponse modifyCacheSubnetGroup ( AmazonElastiCache elasticacheClient ,  ModifyCacheSubnetGroupRequest request )  { ModifyCacheSubnetGroupResponse response = null ;  try { ModifyCacheSubnetGroupRequestMarshaller requestMarshaller = new ModifyCacheSubnetGroupRequestMarshaller (  )  ;  ModifyCacheSubnetGroupResponseUnmarshaller responseUnmarshaller = new ModifyCacheSubnetGroupResponseUnmarshaller (  )  ;  requestMarshaller . marshall ( request )  ;  responseUnmarshaller . unmarshall ( response )  ;  elasticacheClient . modifyCacheSubnetGroup ( request )  ;  } catch  ( Exception e )  { // Handle the exception here } return response ;  }
 @ Override public void setParams ( String params )  { super . setParams ( params )  ;  culture = "" ;  String ignore ;  StringTokenizer st = new StringTokenizer ( params ,  " , " )  ;  if  ( st . hasMoreTokens (  )  )  { culture = st . nextToken (  )  ;  } if  ( st . hasMoreTokens (  )  )  { culture += "-" + st . nextToken (  )  ;  } if  ( st . hasMoreTokens (  )  )  { ignore = st . nextToken (  )  ;  } }
public DeleteDocumentationVersionResponse deleteDocumentationVersion ( DeleteDocumentationVersionRequest request )  { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( DeleteDocumentationVersionRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( DeleteDocumentationVersionResponseUnmarshaller . getInstance (  )  )  ;  try { return invoke ( request ,  options ,  false )  ;  } catch  ( SdkClientException e )  { throw e ;  } catch  ( Exception e )  { throw new SdkClientException ( "Unable to execute DeleteDocumentationVersion operation" ,  e )  ;  } } private DeleteDocumentationVersionResponse invoke ( DeleteDocumentationVersionRequest request ,  InvokeOptions options ,  boolean hasStreamingInput )  { try { beforeClientExecution ( request ,  hasStreamingInput )  ;  HttpResponseHandler < AmazonWebServiceResponse < DeleteDocumentationVersionResponse >  >  responseHandler = protocolFactory . createResponseHandler ( new JsonOperationMetadata (  )   . withPayloadJson ( true )   . withHasStreamingSuccessResponse ( hasStreamingInput )  ,  options . getResponseUnmarshaller (  )  )  ;  HttpResponseHandler < AmazonServiceException >  errorResponseHandler = createErrorResponseHandler (  )  ;  return client . execute ( deleteDocumentationVersionRequest ,  responseHandler ,  errorResponseHandler ,  executionContext )  ;  } catch  ( IOException | RuntimeException e )  { throw new SdkClientException ( "Unable to execute DeleteDocumentationVersion operation" ,  e )  ;  } } private void beforeClientExecution ( DeleteDocumentationVersionRequest request ,  boolean hasStreamingInput )  { request = applyBeforeMarshallingHooks ( request )  ;  request . setEndpoint ( endpoint )  ;  request . setTimeOffset ( timeOffset )  ;  request . setHttpMethod ( HttpMethodName . DELETE )  ;  if  ( !request . getParameters (  )  . containsKey ( "X-Amz-Target" )  )  { request . addParameter ( "X-Amz-Target" ,  "docs . DeleteDocumentationVersion" )  ;  } request . setResourcePath ( uriResourcePath ( request . getResourcePath (  )  ,  hasStreamingInput )  )  ;  }
 @ Override public boolean equals ( Object obj )  { if  ( ! ( obj instanceof FacetLabel )  )  { return false ;  } FacetLabel other =  ( FacetLabel )  obj ;  if  ( length (  )  != other . length (  )  )  { return false ;  } for  ( int i = length (  )  - 1 ;  i  > = 0 ;  i --  )  { if  ( !components [ i ]  . equals ( other . components [ i ]  )  )  { return false ;  } } return true ;  }
public GetInstanceAccessDetailsResponse getInstanceAccessDetails ( GetInstanceAccessDetailsRequest request )  { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( GetInstanceAccessDetailsRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( GetInstanceAccessDetailsResponseUnmarshaller . getInstance (  )  )  ;  try { return invoke ( request ,  options )  ;  } catch  ( SdkClientException e )  { // Handle client exceptions e . printStackTrace (  )  ;  } catch  ( Exception e )  { // Handle any other exceptions e . printStackTrace (  )  ;  } return null ;  } private  < T >  T invoke ( Request < ? >  request ,  InvokeOptions options )  { try { beforeClientExecution ( request )  ;  return executeGetInstanceAccessDetails ( request ,  options )  ;  } catch  ( SdkClientException e )  { // Handle client exceptions e . printStackTrace (  )  ;  } catch  ( Exception e )  { // Handle any other exceptions e . printStackTrace (  )  ;  } return null ;  } private void beforeClientExecution ( Request < ? >  request )  { // Code to execute before client execution } private  < T >  T executeGetInstanceAccessDetails ( Request < ? >  request ,  InvokeOptions options )  { // Code to execute for GetInstanceAccessDetails API call }
public HSSFPolygon createPolygon ( HSSFChildAnchor anchor )  { HSSFPolygon shape = new HSSFPolygon ( this ,  anchor )  ;  shape . setParent ( this )  ;  shape . setAnchor ( anchor )  ;  shapes . add ( shape )  ;  onCreate ( shape )  ;  return shape ;  }
public String getSheetName ( int sheetIndex )  { try { return getBoundSheetRec ( sheetIndex )  . getSheetname (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
public GetDashboardResponse getDashboard ( GetDashboardRequest request )  { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( GetDashboardRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( GetDashboardResponseUnmarshaller . getInstance (  )  )  ;  return invoke ( request ,  options ,  GetDashboardResponse . class )  ;  } private  < T >  T invoke ( Request < ? >  request ,  InvokeOptions options ,  Class < T >  clazz )  { try { BeforeClientExecution . beforeClientExecution ( request ,  options )  ;  return executeGetDashboard ( request ,  options ,  clazz )  ;  } catch  ( RuntimeException e )  { throw e ;  } catch  ( Exception e )  { throw new RuntimeException ( e )  ;  } } private  < T >  T executeGetDashboard ( Request < ? >  request ,  InvokeOptions options ,  Class < T >  clazz )  throws Exception { URI endpoint = getEndpoint ( options )  ;  HttpResponseHandler < AmazonWebServiceResponse < T >  >  responseHandler = protocolFactory . createResponseHandler ( options . getResponseUnmarshaller (  )  ,  clazz )  ;  HttpResponseHandler < AmazonServiceException >  errorResponseHandler = protocolFactory . createErrorResponseHandler ( new JsonErrorResponseMetadata (  )  )  ;  return client . execute ( endpoint ,  request ,  responseHandler ,  errorResponseHandler )  . getAwsResponse (  )  ;  } private URI getEndpoint ( InvokeOptions options )  { URI endpoint = options . getEndpoint (  )  ;  if  ( endpoint == null )  { throw new IllegalArgumentException ( "Endpoint can't be null" )  ;  } return endpoint ;  }
public AssociateSigninDelegateGroupsWithAccountResponse associateSigninDelegateGroupsWithAccount ( AssociateSigninDelegateGroupsWithAccountRequest request )  { try { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( AssociateSigninDelegateGroupsWithAccountRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( AssociateSigninDelegateGroupsWithAccountResponseUnmarshaller . getInstance (  )  )  ;  return invoke ( request ,  options )  ;  } catch  ( SdkClientException e )  { // Handle SDK client exceptions e . printStackTrace (  )  ;  } catch  ( Exception e )  { // Handle other exceptions e . printStackTrace (  )  ;  } return null ;  } private AssociateSigninDelegateGroupsWithAccountResponse invoke ( AssociateSigninDelegateGroupsWithAccountRequest request ,  InvokeOptions options )  { try { beforeClientExecution ( request )  ;  AwsResponse response = client . executeAssociateSigninDelegateGroupsWithAccount ( request ,  options )  ;  return  ( AssociateSigninDelegateGroupsWithAccountResponse )  response ;  } catch  ( SdkClientException e )  { // Handle SDK client exceptions e . printStackTrace (  )  ;  } catch  ( Exception e )  { // Handle other exceptions e . printStackTrace (  )  ;  } return null ;  } private void beforeClientExecution ( AssociateSigninDelegateGroupsWithAccountRequest request )  { // Perform any pre-execution logic here }
public void addMultipleBlanks ( MulBlankRecord mbr )  { for  ( int j = 0 ;  j  <  mbr . getNumColumns (  )  ;  j ++  )  { BlankRecord br = new BlankRecord (  )  ;  br . setColumn ( j + mbr . getFirstColumn (  )  )  ;  br . setRow ( mbr . getRow (  )  )  ;  br . setXFIndex ( mbr . getXFAt ( j )  )  ;  insertCell ( br )  ;  } }
public static String quote ( String string )  { StringBuilder sb = new StringBuilder (  )  ;  sb . append ( "\\Q" )  ;  int apos = 0 ;  int k ;  while  (  ( k = string . indexOf ( "\\E" ,  apos )  )   > = 0 )  { sb . append ( string . substring ( apos ,  k + 2 )  )  . append ( "\\\\E\\Q" )  ;  apos = k + 2 ;  } return sb . append ( string . substring ( apos )  )  . append ( "\\E" )  . toString (  )  ;  }
public java . nio . ByteBuffer putInt ( int value )  { throw new java . nio . ReadOnlyBufferException (  )  ;  }
public ArrayPtg ( Object [  ]  [  ]  values2d )  { int nColumns = values2d [ 0 ]  . length ;  int nRows = values2d . length ;  _nColumns =  ( short )  nColumns ;  _nRows =  ( short )  nRows ;  Object [  ]  vv = new Object [ _nColumns * _nRows ]  ;  for  ( int r = 0 ;  r  <  nRows ;  r ++  )  { Object [  ]  rowData = values2d [ r ]  ;  for  ( int c = 0 ;  c  <  nColumns ;  c ++  )  { vv [ getValueIndex ( c ,  r )  ]  = rowData [ c ]  ;  } } _arrayValues = vv ;  _reserved0Int = 0 ;  _reserved1Short = 0 ;  _reserved2Byte = 0 ;  }
public GetIceServerConfigResponse getIceServerConfig ( GetIceServerConfigRequest request )  { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( GetIceServerConfigRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( GetIceServerConfigResponseUnmarshaller . getInstance (  )  )  ;  try { return invoke ( request ,  options ,  BeforeClientExecution . NONE ,  null )  ;  } catch  ( SdkClientException e )  { throw e ;  } } public  < T >  T invoke ( Request < ? >  request ,  InvokeOptions options ,  BeforeClientExecution beforeClientExecution ,  HttpResponseHandler < AmazonWebServiceResponse < T >  >  responseHandler )  { ExecutionContext executionContext = createExecutionContext ( request ,  options )  ;  beforeClientExecution . beforeExecution ( request ,  executionContext )  ;  try { HttpResponseHandler < AmazonWebServiceResponse < T >  >  effectiveResponseHandler = protocolFactory . createResponseHandler ( request . getOriginalRequest (  )  ,  responseHandler )  ;  HttpResponse httpResponse = client . execute ( request ,  executionContext )  ;  int statusCode = httpResponse . getStatusLine (  )  . getStatusCode (  )  ;  if  ( statusCode  > = 300 )  { throw new SdkClientException ( "HTTP " + statusCode + " " + httpResponse . getStatusLine (  )  . getReasonPhrase (  )  )  ;  } return effectiveResponseHandler . handle ( httpResponse )  ;  } catch  ( Exception e )  { throw handleException ( e )  ;  } } private RuntimeException handleException ( Exception e )  { if  ( e instanceof SdkClientException )  { return  ( SdkClientException )  e ;  } else if  ( e instanceof RuntimeException )  { return  ( RuntimeException )  e ;  } else { return new SdkClientException ( "Unable to execute HTTP request: " + e . getMessage (  )  ,  e )  ;  } }
 @ Override public String toString (  )  { StringBuilder sb = new StringBuilder ( 64 )  ;  try { sb . append ( getClass (  )  . getName (  )  )  . append ( "  [ " )  ;  sb . append ( getValueAsString (  )  )  ;  sb . append ( " ] " )  ;  } catch  ( Exception e )  { sb . append ( "Error getting value as string: " )  . append ( e . getMessage (  )  )  ;  } return sb . toString (  )  ;  }
 @ Override public String toString ( String field )  { try { return "ToChildBlockJoinQuery  ( " + _parentQuery + " ) " ;  } catch  ( Exception e )  { System . err . println ( "Error occurred while converting object to string: " + e . getMessage (  )  )  ;  return "" ;  } }
public void incRef (  )  { refCount . incrementAndGet (  )  ;  }
public UpdateConfigurationSetSendingEnabledResponse updateConfigurationSetSendingEnabled ( UpdateConfigurationSetSendingEnabledRequest request )  { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( UpdateConfigurationSetSendingEnabledRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( UpdateConfigurationSetSendingEnabledResponseUnmarshaller . getInstance (  )  )  ;  return invoke ( request ,  options ,  SdkClientException . class ,  AwsServiceException . class )  ;  } private  < T >  T invoke ( Request < ? >  request ,  InvokeOptions options ,  Class < ? extends SdkClientException >  clientExceptionClass ,  Class < ? extends AwsServiceException >  serviceExceptionClass )  { ExecutionContext executionContext = createExecutionContext ( request )  ;  beforeClientExecution ( request ,  executionContext )  ;  try { HttpResponseHandler < AmazonWebServiceResponse < T >  >  responseHandler = protocolFactory . createResponseHandler ( request . getOriginalRequest (  )  ,  options . getResponseUnmarshaller (  )  )  ;  HttpResponseHandler < AmazonServiceException >  errorResponseHandler = protocolFactory . createErrorResponseHandler (  )  ;  return clientHandler . execute ( request ,  responseHandler ,  errorResponseHandler ,  executionContext )  . getAwsResponse (  )  ;  } catch  ( SdkClientException e )  { handleException ( e ,  clientExceptionClass )  ;  } catch  ( AmazonServiceException e )  { handleException ( e ,  serviceExceptionClass )  ;  } return null ;  } private void beforeClientExecution ( Request < ? >  request ,  ExecutionContext executionContext )  { addHostHeader ( request )  ;  AWSRequestMetrics awsRequestMetrics = executionContext . getAwsRequestMetrics (  )  ;  awsRequestMetrics . startEvent ( Field . RequestMarshallTime )  ;  try { request . setEndpoint ( endpoint )  ;  request . setTimeOffset ( timeOffset )  ;  awsRequestMetrics . startEvent ( Field . RequestSigningTime )  ;  try { signer . sign ( request ,  executionContext )  ;  } finally { awsRequestMetrics . endEvent ( Field . RequestSigningTime )  ;  } awsRequestMetrics . startEvent ( Field . HttpRequestTime )  ;  } finally { awsRequestMetrics . endEvent ( Field . RequestMarshallTime )  ;  } } private void addHostHeader ( Request < ? >  request )  { URI endpoint = request . getEndpoint (  )  ;  String hostHeader = endpoint . getHost (  )  ;  if  ( endpoint . getPort (  )   >  0 )  { hostHeader += ":" + endpoint . getPort (  )  ;  } request . addHeader ( "Host" ,  hostHeader )  ;  }
public int getNextXBATChainOffset (  )  { return getXBATEntriesPerBlock (  )  * LittleEndianConsts . INT_SIZE ;  }
public void multiplyByPowerOfTen ( int pow10 )  { TenPower tp = TenPower . getInstance ( Math . abs ( pow10 )  )  ;  if  ( pow10  <  0 )  { mulShift ( tp . _divisor ,  tp . _divisorShift )  ;  } else { mulShift ( tp . _multiplicand ,  tp . _multiplierShift )  ;  } }
 @ Override public String toString (  )  { StringBuilder builder = new StringBuilder (  )  ;  int length = this . length (  )  ;  builder . append ( File . separatorChar )  ;  for  ( int i = 0 ;  i  <  length ;  i ++  )  { builder . append ( this . getComponent ( i )  )  ;  if  ( i  <   ( length - 1 )  )  { builder . append ( File . separatorChar )  ;  } } return builder . toString (  )  ;  }
public void withFetcher ( ECSMetadataServiceCredentialsFetcher fetcher )  { try { this . fetcher = fetcher ;  this . fetcher . setRoleName ( roleName )  ;  } catch  ( Exception e )  { // handle exception here } }
public void SetProgressMonitor ( ProgressMonitor pm )  { progressMonitor = pm ;  }
 @ Override public void reset (  )  { if  ( !first (  )  )  { ptr = 0 ;  if  ( !eof (  )  )  { parseEntry (  )  ;  } } }
public E previous (  )  { try { if  ( iterator . previousIndex (  )   > = start )  { return iterator . previous (  )  ;  } throw new java . util . NoSuchElementException (  )  ;  } catch  ( java . util . NoSuchElementException e )  { System . out . println ( "NoSuchElementException: " + e . getMessage (  )  )  ;  return null ;  // or do something else as needed } catch  ( Exception e )  { System . out . println ( "Exception: " + e . getMessage (  )  )  ;  return null ;  // or do something else as needed } }
public String getNewPrefix (  )  { return this . newPrefix ;  }
public int indexOfValue ( int value )  { for  ( int i = 0 ;  i  <  mSize ;  i ++  )  { if  ( mValues [ i ]  == value )  { return i ;  } } return -1 ;  }
import java . util . ArrayList ;  import java . util . List ;  import org . apache . lucene . analysis . CharArraySet ;  import org . apache . lucene . util . Version ;  import org . apache . lucene . util . CharsRef ;  import org . apache . lucene . analysis . en . PorterStemmer ;  public List < CharsRef >  uniqueStems ( char [  ]  word ,  int length )  { List < CharsRef >  stems = new ArrayList <  >  ( stem ( word ,  length )  )  ;  if  ( stems . size (  )   <  2 )  { return stems ;  } CharArraySet terms = new CharArraySet ( 8 ,  dictionary . ignoreCase )  ;  List < CharsRef >  deduped = new ArrayList <  >  (  )  ;  for  ( CharsRef s : stems )  { try { if  ( !terms . contains ( s )  )  { deduped . add ( s )  ;  terms . add ( s )  ;  } } catch  ( Exception e )  { // Handle the exception here e . printStackTrace (  )  ;  } } return deduped ;  } private List < CharsRef >  stem ( char [  ]  word ,  int length )  { List < CharsRef >  stems = new ArrayList <  >  (  )  ;  PorterStemmer stemmer = new PorterStemmer (  )  ;  stemmer . setCurrent ( new String ( word ,  0 ,  length )  )  ;  if  ( stemmer . stem (  )  )  { stems . add ( new CharsRef ( stemmer . getCurrentBuffer (  )  ,  0 ,  stemmer . getCurrentLength (  )  )  )  ;  } else { stems . add ( new CharsRef ( word ,  0 ,  length )  )  ;  } return stems ;  }
public GetGatewayResponsesResponse getGatewayResponses ( GetGatewayResponsesRequest request )  { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( GetGatewayResponsesRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( GetGatewayResponsesResponseUnmarshaller . getInstance (  )  )  ;  return invoke ( request ,  options )  ;  } private  < T >  T invoke ( Request request ,  InvokeOptions options )  { beforeClientExecution ( request ,  options )  ;  return executeGetGatewayResponses ( request ,  options )  ;  } private  < T >  T executeGetGatewayResponses ( Request request ,  InvokeOptions options )  { // Implement your logic here to execute the request and return the response } private void beforeClientExecution ( Request request ,  InvokeOptions options )  { // Implement any pre-execution logic here } private static class GetGatewayResponsesRequestMarshaller implements RequestMarshaller < GetGatewayResponsesRequest >  { private static final GetGatewayResponsesRequestMarshaller INSTANCE = new GetGatewayResponsesRequestMarshaller (  )  ;  public static GetGatewayResponsesRequestMarshaller getInstance (  )  { return INSTANCE ;  }  @ Override public Request marshall ( GetGatewayResponsesRequest input )  { // Implement your logic here to marshall the request } } private static class GetGatewayResponsesResponseUnmarshaller implements ResponseUnmarshaller < GetGatewayResponsesResponse >  { private static final GetGatewayResponsesResponseUnmarshaller INSTANCE = new GetGatewayResponsesResponseUnmarshaller (  )  ;  public static GetGatewayResponsesResponseUnmarshaller getInstance (  )  { return INSTANCE ;  }  @ Override public GetGatewayResponsesResponse unmarshall ( Response response )  { // Implement your logic here to unmarshall the response } }
public void setPosition ( long position )  { currentBlockIndex =  ( int )   ( position  >  >  outerInstance . blockBits )  ;  currentBlock = outerInstance . blocks [ currentBlockIndex ]  ;  currentBlockUpto =  ( int )   ( position & outerInstance . blockMask )  ;  }
 @ Override public long skip ( long n )  { int s =  ( int )  Math . min ( available (  )  ,  Math . max ( 0 ,  n )  )  ;  ptr += s ;  return s ;  }
public class BootstrapActionDetail { private BootstrapActionConfig _bootstrapActionConfig ;  public BootstrapActionDetail ( BootstrapActionConfig bootstrapActionConfig )  { try { _bootstrapActionConfig = bootstrapActionConfig ;  } catch  ( Exception e )  { // Handle the exception here e . printStackTrace (  )  ;  } } }
public void serialize ( ILittleEndianOutput out1 )  throws IOException { out1 . writeShort ( field_1_row )  ;  out1 . writeShort ( field_2_col )  ;  out1 . writeShort ( field_3_flags )  ;  out1 . writeShort ( field_4_shapeid )  ;  out1 . writeShort ( field_6_author . length )  ;  out1 . writeByte ( field_5_hasMultibyte ? 0x01 : 0x00 )  ;  if  ( field_5_hasMultibyte )  { StringUtil . putUnicodeLE ( field_6_author ,  out1 )  ;  } else { StringUtil . putCompressedUnicode ( field_6_author ,  out1 )  ;  } if  ( field_7_padding != null )  { try { out1 . writeByte ( Integer . parseInt ( field_7_padding )  )  ;  } catch  ( NumberFormatException e )  { throw new IOException ( "Invalid padding value: " + field_7_padding )  ;  } } }
public int lastIndexOf ( String str )  { try { return lastIndexOf ( str ,  count )  ;  } catch  ( Exception e )  { // handle the exception ,  if needed e . printStackTrace (  )  ;  return -1 ;  // return a default value } }
 @ Override public boolean add ( E object )  { return addLastImpl ( object )  ;  }
public void unsetSection ( String section ,  String subsection )  { ConfigSnapshot src ;  ConfigSnapshot res ;  do { src = state . get (  )  ;  res = unsetSection ( src ,  section ,  subsection )  ;  } while  ( !state . compareAndSet ( src ,  res )  )  ;  }
public String getTagName (  )  { return tagName ;  }
public void addSubRecord ( int index ,  SubRecord element )  { try { subrecords . add ( index ,  element )  ;  } catch  ( IndexOutOfBoundsException e )  { System . err . println ( "Index is out of bounds: " + e . getMessage (  )  )  ;  } catch  ( Exception e )  { System . err . println ( "An error occurred: " + e . getMessage (  )  )  ;  } } public void add ( SubRecord element )  { try { subrecords . add ( element )  ;  } catch  ( Exception e )  { System . err . println ( "An error occurred: " + e . getMessage (  )  )  ;  } } public SubRecord getSubRecord ( int index )  { try { return subrecords . get ( index )  ;  } catch  ( IndexOutOfBoundsException e )  { System . err . println ( "Index is out of bounds: " + e . getMessage (  )  )  ;  return null ;  } catch  ( Exception e )  { System . err . println ( "An error occurred: " + e . getMessage (  )  )  ;  return null ;  } } public void add ( int index ,  SubRecord element )  { try { subrecords . add ( index ,  element )  ;  } catch  ( IndexOutOfBoundsException e )  { System . err . println ( "Index is out of bounds: " + e . getMessage (  )  )  ;  } catch  ( Exception e )  { System . err . println ( "An error occurred: " + e . getMessage (  )  )  ;  } }
public synchronized boolean remove ( Object object )  { return c . remove ( object )  ;  }
 @ Override public TokenStream create ( TokenStream input )  { return new DoubleMetaphoneFilter ( input ,  maxCodeLength ,  inject )  ;  }
public long Length (  )  { try { return InCoreLength (  )  ;  } catch  ( Exception e )  { // handle the exception return -1 ;  // or throw a custom exception } }
public void setValue ( boolean newValue )  { value = newValue ;  }
public class MyClass { private ContentSource oldSource ;  private ContentSource newSource ;  public MyClass ( ContentSource oldSource ,  ContentSource newSource )  { this . oldSource = oldSource ;  this . newSource = newSource ;  } }
public int get ( int i )  { try { if  ( count  < = i )  { throw new ArrayIndexOutOfBoundsException ( i )  ;  } return entries [ i ]  ;  } catch  ( ArrayIndexOutOfBoundsException ex )  { // Handle the exception ex . printStackTrace (  )  ;  return -1 ;  // Or some other default value } }
public class CreateRepoRequest extends BaseRequest { public CreateRepoRequest (  )  { super ( "cr" ,  "2016-06-07" ,  "CreateRepo" ,  "cr" ,  "openAPI" )  ;  setUriPattern ( "/repos" )  ;  setMethod ( MethodType . PUT )  ;  } }
public boolean isDeltaBaseAsOffset (  )  { return IsDeltaBaseAsOffset (  )  ;  }
public void remove (  )  { try { if  ( expectedModCount == list . modCount )  { if  ( lastLink != null )  { java . util . LinkedList . Link < ET >  next_1 = lastLink . next ;  java . util . LinkedList . Link < ET >  previous_1 = lastLink . previous ;  next_1 . previous = previous_1 ;  previous_1 . next = next_1 ;  if  ( lastLink == link )  { pos --  ;  } link = previous_1 ;  lastLink = null ;  expectedModCount ++  ;  list . _size --  ;  list . modCount ++  ;  } else { throw new IllegalStateException (  )  ;  } } else { throw new ConcurrentModificationException (  )  ;  } } catch  ( IllegalStateException e )  { // Handle IllegalStateException System . out . println ( "IllegalStateException occurred: " + e . getMessage (  )  )  ;  } catch  ( ConcurrentModificationException e )  { // Handle ConcurrentModificationException System . out . println ( "ConcurrentModificationException occurred: " + e . getMessage (  )  )  ;  } }
import com . amazonaws . services . kinesis . clientlibrary . lib . worker . KinesisClientLibConfiguration ;  import com . amazonaws . services . kinesis . model . MergeShardsRequest ;  import com . amazonaws . services . kinesis . model . MergeShardsResult ;  import com . amazonaws . services . kinesis . AmazonKinesis ;  public MergeShardsResponse MergeShards ( MergeShardsRequest request ,  AmazonKinesis client )  { try { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( MergeShardsRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( MergeShardsResponseUnmarshaller . getInstance (  )  )  ;  return client . invoke ( request ,  options )  ;  } catch  ( AmazonServiceException e )  { System . err . println ( e . getErrorMessage (  )  )  ;  } catch  ( SdkClientException e )  { System . err . println ( e . getMessage (  )  )  ;  } return null ;  }
public AllocateHostedConnectionResponse allocateHostedConnection ( AllocateHostedConnectionRequest request )  { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( AllocateHostedConnectionRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( AllocateHostedConnectionResponseUnmarshaller . getInstance (  )  )  ;  try { return executeAllocateHostedConnection ( request ,  options )  ;  } catch  ( SdkClientException e )  { throw e ;  } catch  ( Exception e )  { throw new SdkClientException ( "Error executing allocateHostedConnection" ,  e )  ;  } } private AllocateHostedConnectionResponse executeAllocateHostedConnection ( AllocateHostedConnectionRequest request ,  InvokeOptions options )  { beforeClientExecution ( request ,  options )  ;  Response < AllocateHostedConnectionResponse >  response = client . allocateHostedConnection ( request ,  options )  ;  return response . getAwsResponse (  )  ;  } private void beforeClientExecution ( AllocateHostedConnectionRequest request ,  InvokeOptions options )  { // Perform any required pre-execution processing here }
public int getBeginIndex (  )  { return start ;  }
public static WeightedTerm [  ]  GetTerms ( Query query )  { return GetTerms ( query ,  false )  ;  }
 @ Override public java . nio . ByteBuffer compact (  )  { try { return super . compact (  )  ;  } catch  ( java . nio . ReadOnlyBufferException ex )  { ex . printStackTrace (  )  ;  // or handle the exception in a way that's appropriate for your application return null ;  // or some other value to indicate that the operation failed } }
public void decode ( byte [  ]  blocks ,  int blocksOffset ,  int [  ]  values ,  int valuesOffset ,  int iterations )  { for  ( int i = 0 ;  i  <  iterations ;   ++ i )  { int byte0 = blocks [ blocksOffset ++  ]  & 0xFF ;  values [ valuesOffset ++  ]  =  ( byte0  >  >  >  2 )  & 0x3F ;  int byte1 = blocks [ blocksOffset ++  ]  & 0xFF ;  values [ valuesOffset ++  ]  =  (  ( byte0 & 3 )   <  <  4 )  |  (  ( byte1  >  >  >  4 )  & 0xF )  ;  int byte2 = blocks [ blocksOffset ++  ]  & 0xFF ;  values [ valuesOffset ++  ]  =  (  ( byte1 & 0xF )   <  <  2 )  |  (  ( byte2  >  >  >  6 )  & 0x3 )  ;  values [ valuesOffset ++  ]  = byte2 & 0x3F ;  } }
public String getHumanishName (  )  throws IllegalArgumentException { String path = getPath (  )  ;  if  ( path == null || path . isEmpty (  )  )  { throw new IllegalArgumentException (  )  ;  } String [  ]  elements ;  if  ( "file" . equals ( getScheme (  )  )  || LOCAL_FILE . matcher ( path )  . matches (  )  )  { elements = path . split ( " [ \\\\" + File . separatorChar + "/ ] " )  ;  } else { elements = path . split ( "/" )  ;  } if  ( elements . length == 0 )  { throw new IllegalArgumentException (  )  ;  } String result = elements [ elements . length - 1 ]  ;  if  ( Constants . DOT_GIT . equals ( result )  )  { result = elements [ elements . length - 2 ]  ;  } else { if  ( result . endsWith ( Constants . DOT_GIT_EXT )  )  { result = result . substring ( 0 ,  result . length (  )  - Constants . DOT_GIT_EXT . length (  )  )  ;  } } return result ;  }
import com . amazonaws . services . sagemaker . AmazonSageMaker ;  import com . amazonaws . services . sagemaker . model . DescribeNotebookInstanceLifecycleConfigRequest ;  import com . amazonaws . services . sagemaker . model . DescribeNotebookInstanceLifecycleConfigResponse ;  import com . amazonaws . services . sagemaker . model . transform . DescribeNotebookInstanceLifecycleConfigRequestMarshaller ;  import com . amazonaws . services . sagemaker . model . transform . DescribeNotebookInstanceLifecycleConfigResponseUnmarshaller ;  import com . amazonaws . services . sagemaker . model . AmazonSageMakerException ;  public class ExampleClass { public static DescribeNotebookInstanceLifecycleConfigResponse describeNotebookInstanceLifecycleConfig ( AmazonSageMaker sageMakerClient ,  DescribeNotebookInstanceLifecycleConfigRequest request )  { DescribeNotebookInstanceLifecycleConfigResponse response = null ;  try { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( DescribeNotebookInstanceLifecycleConfigRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( DescribeNotebookInstanceLifecycleConfigResponseUnmarshaller . getInstance (  )  )  ;  response = sageMakerClient . describeNotebookInstanceLifecycleConfig ( request ,  options )  ;  } catch  ( AmazonSageMakerException e )  { System . err . println ( e . getMessage (  )  )  ;  } return response ;  } }
public String getAccessKeySecret (  )  { return AccessSecret ;  }
public CreateVpnConnectionResponse createVpnConnection ( CreateVpnConnectionRequest request )  { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( CreateVpnConnectionRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( CreateVpnConnectionResponseUnmarshaller . getInstance (  )  )  ;  return invoke ( request ,  options ,  CreateVpnConnectionResponse . class )  ;  } protected void beforeClientExecution ( AmazonWebServiceRequest request )  { // do nothing } private  < T >  T invoke ( AmazonWebServiceRequest request ,  InvokeOptions options ,  Class < T >  clazz )  { ClientExecutionParams executionParams = new ClientExecutionParams (  )   . withClientRequest ( request )   . withEndpoint ( options . getEndpoint (  )  )   . withMarshaller ( options . getRequestMarshaller (  )  )   . withUnmarshaller ( options . getResponseUnmarshaller (  )  )   . withErrorResponseHandler ( options . getErrorResponseHandler (  )  )   . withCustomBackoffStrategy ( options . getCustomBackoffStrategy (  )  )   . withProgressListener ( options . getGeneralProgressListener (  )  )   . withRequestMetricCollector ( options . getRequestMetricCollector (  )  )   . withResponseHandler ( options . getResponseHandler ( clazz )  )  ;  return client . execute ( executionParams )  ;  } private  < T >  T invoke ( AmazonWebServiceRequest request ,  InvokeOptions options )  { return invoke ( request ,  options ,  options . getReturnType (  )  )  ;  }
public DescribeVoicesResponse describeVoices ( DescribeVoicesRequest request )  { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( DescribeVoicesRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( DescribeVoicesResponseUnmarshaller . getInstance (  )  )  ;  return invoke ( request ,  options ,  DescribeVoicesResponse . class )  ;  } private  < T >  T invoke ( Request < ? >  request ,  InvokeOptions options ,  Class < T >  responseType )  { request . setEndpoint ( endpoint )  ;  request . setTimeOffset ( timeOffset )  ;  request . setSigningName ( signingName )  ;  request . setServiceName ( serviceName )  ;  request . setMarshaller ( marshaller )  ;  request . setUnmarshaller ( unmarshaller )  ;  options . beforeExecution ( request )  ;  HttpResponse response = client . execute ( request ,  options )  ;  return unmarshaller . unmarshall ( response ,  responseType )  ;  }
import com . amazonaws . services . sagemaker . model . ListMonitoringExecutionsRequest ;  import com . amazonaws . services . sagemaker . model . ListMonitoringExecutionsResponse ;  import com . amazonaws . services . sagemaker . AmazonSageMaker ;  import com . amazonaws . services . sagemaker . AmazonSageMakerClientBuilder ;  import com . amazonaws . services . sagemaker . AmazonSageMakerException ;  import com . amazonaws . services . sagemaker . model . transform . ListMonitoringExecutionsRequestMarshaller ;  import com . amazonaws . services . sagemaker . model . transform . ListMonitoringExecutionsResponseUnmarshaller ;  public class MyClass { public ListMonitoringExecutionsResponse listMonitoringExecutions ( ListMonitoringExecutionsRequest request )  { AmazonSageMaker sageMaker = AmazonSageMakerClientBuilder . standard (  )  . build (  )  ;  try { ListMonitoringExecutionsRequestMarshaller marshaller = ListMonitoringExecutionsRequestMarshaller . getInstance (  )  ;  ListMonitoringExecutionsResponseUnmarshaller unmarshaller = ListMonitoringExecutionsResponseUnmarshaller . getInstance (  )  ;  return sageMaker . listMonitoringExecutions ( request )  ;  } catch  ( AmazonSageMakerException e )  { System . err . println ( e . getMessage (  )  )  ;  return null ;  } } }
DescribeJobRequest request = new DescribeJobRequest ( vaultName ,  jobId )  ; 
public EscherRecord GetEscherRecord ( int index )  { return escherRecords [ index ]  ;  }
public GetApisResponse getApis ( GetApisRequest request )  { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( GetApisRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( GetApisResponseUnmarshaller . getInstance (  )  )  ;  try { return invoke ( request ,  options )  ;  } catch  ( SdkClientException e )  { throw new RuntimeException ( e . getMessage (  )  ,  e )  ;  } } private GetApisResponse invoke ( GetApisRequest request ,  InvokeOptions options )  { try { beforeClientExecution ( request )  ;  return executeGetApis ( request ,  options )  ;  } catch  ( AwsServiceException e )  { throw e ;  } catch  ( AwsErrorDetailsException e )  { throw e ;  } catch  ( RuntimeException e )  { throw e ;  } catch  ( Exception e )  { throw new SdkClientException ( "Unable to execute HTTP request: " + e . getMessage (  )  ,  e )  ;  } } private GetApisResponse executeGetApis ( GetApisRequest request ,  InvokeOptions options )  { // implementation goes here }
public DeleteSmsChannelResponse deleteSmsChannel ( DeleteSmsChannelRequest request )  { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( DeleteSmsChannelRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( DeleteSmsChannelResponseUnmarshaller . getInstance (  )  )  ;  try { return invoke ( request ,  options )  ;  } catch  ( SdkClientException e )  { // handle client-side exceptions e . printStackTrace (  )  ;  } catch  ( SdkServiceException e )  { // handle service-side exceptions e . printStackTrace (  )  ;  } return null ;  } private DeleteSmsChannelResponse invoke ( DeleteSmsChannelRequest request ,  InvokeOptions options )  { try { beforeClientExecution ( request )  ;  AmazonWebServiceResult < ResponseMetadata >  response = client . executeDeleteSmsChannel ( request ,  options )  ;  return  ( DeleteSmsChannelResponse )  response ;  } catch  ( SdkClientException e )  { throw e ;  } catch  ( Exception e )  { throw new SdkClientException ( "Unable to execute HTTP request: " + e . getMessage (  )  ,  e )  ;  } } private void beforeClientExecution ( AmazonWebServiceRequest request )  { // do any pre-execution setup here }
public TrackingRefUpdate getTrackingRefUpdate (  )  { return trackingRefUpdate ;  }
public void print ( boolean b )  { print ( String . valueOf ( b )  )  ;  } public void print ( String s )  { System . out . print ( s )  ;  }
public IQueryNode getChild (  )  throws Exception { try { return getChildren (  )  [ 0 ]  ;  } catch  ( Exception e )  { throw new Exception ( "Error getting child node: " + e . getMessage (  )  )  ;  } } private IQueryNode [  ]  getChildren (  )  throws Exception { // code to retrieve the array of child nodes }
NotIgnoredFilter filter = new NotIgnoredFilter ( workdirTreeIndex )  ; 
public AreaRecord ( RecordInputStream in1 )  { field_1_formatFlags = in1 . readShort (  )  ;  }
try { GetThumbnailRequest request = new GetThumbnailRequest ( "CloudPhoto" ,  "2017-07-11" ,  "GetThumbnail" ,  "cloudphoto" ,  "openAPI" )  ;  request . setProtocol ( ProtocolType . HTTPS )  ;  } catch  ( Exception ex )  { // Handle the exception here }
public DescribeTransitGatewayVpcAttachmentsResponse describeTransitGatewayVpcAttachments ( DescribeTransitGatewayVpcAttachmentsRequest request )  { DescribeTransitGatewayVpcAttachmentsResponse response = null ;  try { InvokeRequest < DescribeTransitGatewayVpcAttachmentsRequest >  invokeRequest = new InvokeRequest <  >  ( request )  ;  InvokeOptions options = new InvokeOptions (  )  ;  options . requestMarshaller ( DescribeTransitGatewayVpcAttachmentsRequestMarshaller . getInstance (  )  )  ;  options . responseUnmarshaller ( DescribeTransitGatewayVpcAttachmentsResponseUnmarshaller . getInstance (  )  )  ;  response = executeDescribeTransitGatewayVpcAttachments ( invokeRequest ,  options )  ;  } catch  ( SdkClientException e )  { // Handle the exception here e . printStackTrace (  )  ;  } return response ;  } private DescribeTransitGatewayVpcAttachmentsResponse executeDescribeTransitGatewayVpcAttachments (  InvokeRequest < DescribeTransitGatewayVpcAttachmentsRequest >  invokeRequest ,  InvokeOptions options )  { AWSJavaSDKHttpFullRequestAdapter requestAdapter = new AWSJavaSDKHttpFullRequestAdapter ( invokeRequest . getMarshaller (  )  ,  describeTransitGatewayVpcAttachmentsEndpoint ( options )  ,  options )  ;  AWSJavaSDKHttpResponseAdapter responseAdapter = new AWSJavaSDKHttpResponseAdapter ( options . getResponseUnmarshaller (  )  )  ;  ExecutionContext executionContext = createExecutionContext (  )  ;  requestAdapter . setEndpoint ( executionContext . getEndpoint (  )  )  ;  beforeClientExecution ( requestAdapter )  ;  HttpResponse httpResponse = null ;  try { httpResponse = client . execute ( requestAdapter ,  responseAdapter ,  executionContext )  ;  } catch  ( Exception e )  { // Handle the exception here e . printStackTrace (  )  ;  } return responseAdapter . handle ( httpResponse )  ;  } private void beforeClientExecution ( AWSRequest request )  { // Implement any specific logic before the client execution } private URI describeTransitGatewayVpcAttachmentsEndpoint ( InvokeOptions options )  { return options . getEndpoint (  )  ;  } private ExecutionContext createExecutionContext (  )  { return new ExecutionContext (  )  ;  }
public PutVoiceConnectorStreamingConfigurationResponse putVoiceConnectorStreamingConfiguration ( PutVoiceConnectorStreamingConfigurationRequest request )  { InvokeRequest < PutVoiceConnectorStreamingConfigurationRequest >  invokeRequest = new InvokeRequest <  >  ( request ,  AWS_VOICE_CONNECTOR_STREAMING_CONFIG_SERVICE_NAME )  ;  return executePutVoiceConnectorStreamingConfiguration ( beforeClientExecution ( invokeRequest )  )  ;  } private PutVoiceConnectorStreamingConfigurationResponse executePutVoiceConnectorStreamingConfiguration ( InvokeRequest < PutVoiceConnectorStreamingConfigurationRequest >  invokeRequest )  { Response < PutVoiceConnectorStreamingConfigurationResponse >  response = clientHandler . execute ( invokeRequest ,  responseHandler )  ;  return response . getAwsResponse (  )  ;  } private InvokeRequest < PutVoiceConnectorStreamingConfigurationRequest >  beforeClientExecution ( InvokeRequest < PutVoiceConnectorStreamingConfigurationRequest >  invokeRequest )  { // Apply any additional required headers or parameters return invokeRequest ;  }
public OrdRange getOrdRange ( String dim )  { OrdRange result = null ;  try { result = prefixToOrdRange . get ( dim )  ;  } catch  ( NullPointerException e )  { // Handle NullPointerException } return result ;  }
 @ Override public String toString (  )  { String symbol = "" ;  if  ( startIndex  > = 0 && startIndex  <   (  ( ICharStream )  getInputStream (  )  )  . size (  )  )  { symbol =  (  ( ICharStream )  getInputStream (  )  )  . getText ( Interval . of ( startIndex ,  startIndex )  )  ;  symbol = Utils . escapeWhitespace ( symbol ,  false )  ;  } return String . format ( Locale . getDefault (  )  ,  "%s ( '%s' ) " ,  getClass (  )  . getSimpleName (  )  ,  symbol )  ;  } Note: It's important to import the necessary classes such as `Interval` and `Utils` for this code to compile correctly . 
public E peek (  )  { try { return peekFirstImpl (  )  ;  } catch  ( NoSuchElementException e )  { // Handle the exception if peekFirstImpl (  )  throws NoSuchElementException // For example: System . out . println ( "The queue is empty!" )  ;  return null ;  } }
public CreateWorkspacesResponse createWorkspaces ( CreateWorkspacesRequest request )  { InvokeOptions options = new InvokeOptions (  )  ;  options . setRequestMarshaller ( CreateWorkspacesRequestMarshaller . getInstance (  )  )  ;  options . setResponseUnmarshaller ( CreateWorkspacesResponseUnmarshaller . getInstance (  )  )  ;  try { return invoke ( request ,  options )  ;  } catch  ( SdkClientException e )  { // Handle client-side exceptions e . printStackTrace (  )  ;  } catch  ( SdkServiceException e )  { // Handle service-side exceptions e . printStackTrace (  )  ;  } return null ;  } private CreateWorkspacesResponse invoke ( CreateWorkspacesRequest request ,  InvokeOptions options )  { try { BeforeClientExecutionHandler handler = options . getBeforeClientExecutionHandler (  )  ;  if  ( handler != null )  { handler . beforeClientExecution ( request )  ;  } AmazonWebServiceResult < ResponseMetadata >  response = client . execute ( request ,  options )  ;  return  ( CreateWorkspacesResponse )  options . getResponseUnmarshaller (  )  . unmarshall ( response )  ;  } catch  ( AmazonClientException e )  { throw e ;  } }
 @ Override public Object clone (  )  { NumberFormatIndexRecord rec = new NumberFormatIndexRecord (  )  ;  try { rec . field_1_formatIndex = this . field_1_formatIndex ;  return rec . copy (  )  ;  } catch  ( CloneNotSupportedException e )  { e . printStackTrace (  )  ;  return null ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } } public NumberFormatIndexRecord copy (  )  throws CloneNotSupportedException { return  ( NumberFormatIndexRecord )  super . clone (  )  ;  }
