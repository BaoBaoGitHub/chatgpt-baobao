void function ( ScriptOrFnNode arg0 )  { collectFuncNodes ( arg0 ,  loc0 ,  null )  ;  }
Sha256Hash function ( byte [  ]  arg0 )  { FileInputStream loc0 = null ;  try { loc0 = new FileInputStream ( new File ( new String ( arg0 )  )  )  ;  byte [  ]  loc1 = ByteStreams . toByteArray ( loc0 )  ;  Sha256Hash loc2 = Sha256Hash . create ( loc1 )  ;  return loc2 ;  } catch  ( IOException e )  { throw new RuntimeException ( "Error reading file: " + new String ( arg0 )  ,  e )  ;  } finally { try { if  ( loc0 != null )  { loc0 . close (  )  ;  } } catch  ( IOException e )  { } } }
String function ( Object arg0 ,  boolean arg1 )  { String loc0 = readObjectID ( arg0 )  ;  if  ( loc0 == null && arg1 )  { loc0 = createObjectID ( arg0 )  ;  } return loc0 ;  }
import org . hamcrest . Matcher ;  import org . hamcrest . number . OrderingComparison . ComparatorMatcherBuilder ;  public class OrderingComparison { public static  < T extends Comparable < T >  >  Matcher < T >  function ( T arg0 )  { return ComparatorMatcherBuilder . usingNaturalOrdering (  )  . greaterThan ( arg0 )  ;  } }
int function (  )  { return denom ;  }
String function ( String arg0 ,  String arg1 )  { GenericJSONBuilder loc0 = builder (  )  ;  loc0 . function ( arg0 )  ;  loc0 . function ( "image" ,  arg1 )  ;  return loc0 . function ( "this" )  ;  }
class XMPPServiceActivator { IEnvironments environments = null ;  HashMap < String ,  XMPPConnectionFactory >  factories = new HashMap < String ,  XMPPConnectionFactory >  (  )  ;  AutoSIMXMPPConfig config = null ;  void start ( BundleContext context )  { } void function ( BundleContext arg0 )  { deregisterConnectionFactory (  )  ;  factories . remove ( "key" )  ;  } void deregisterConnectionFactory (  )  { } }
void function (  )  { long arg0 = 10 ;  mTestStream . seek ( arg0 )  ;  long loc0 = mTestStream . getPosition (  )  ;  assertEquals ( arg0 ,  loc0 )  ;  long arg1 = 5 ;  mTestStream . seek ( arg1 )  ;  long loc1 = mTestStream . getPosition (  )  ;  assertEquals ( arg1 ,  loc1 )  ;  long arg2 = mBlockSize * 2 ;  mTestStream . seek ( arg2 )  ;  long loc2 = mTestStream . getPosition (  )  ;  assertEquals ( arg2 ,  loc2 )  ;  long arg3 = mBlockSize + mBufferSize / 2 ;  mTestStream . seek ( arg3 )  ;  long loc3 = mTestStream . getPosition (  )  ;  assertEquals ( arg3 ,  loc3 )  ;  long arg4 = mBlockSize * 3 + mBufferSize + 10 ;  mTestStream . seek ( arg4 )  ;  long loc4 = mTestStream . getPosition (  )  ;  assertEquals ( arg4 ,  loc4 )  ;  byte [  ]  buffer = new byte [ 5 ]  ;  int bytesRead = mTestStream . read ( buffer )  ;  assertEquals ( bytesRead ,  buffer . length )  ;  assertArrayEquals ( new byte [  ] {buffer [ 0 ]  ,  buffer [ 1 ]  ,  buffer [ 2 ]  ,  buffer [ 3 ]  ,  buffer [ 4 ] } ,  new byte [  ] {0 ,  0 ,  3 ,  0 ,  4} )  ;  }
void function ( CountDownLatch arg0 ,  WeakReference < ? >  arg1 )  { try { System . gc (  )  ;  System . runFinalization (  )  ;  boolean cleared = false ;  boolean finalized = false ;  long startTime = System . nanoTime (  )  ;  while  ( !cleared || !finalized )  { if  ( !cleared && arg1 . get (  )  == null )  { cleared = true ;  arg0 . countDown (  )  ;  } if  ( !finalized )  { Runtime . getRuntime (  )  . runFinalization (  )  ;  finalized = true ;  } if  ( !cleared || !finalized )  { Thread . sleep ( 10 )  ;  } long elapsedTime = System . nanoTime (  )  - startTime ;  if  ( elapsedTime  >  timeoutSeconds (  )  * 1000000000L )  { throw formatRuntimeException ( "Timed out waiting for GC and finalization to complete" )  ;  } } } catch  ( InterruptedException e )  { Thread . currentThread (  )  . interrupt (  )  ;  } catch  ( Exception e )  { throw formatRuntimeException ( "Unexpected exception while waiting for GC and finalization" ,  e )  ;  } }
void function (  )  { MockedClass mockedObj = mock ( MockedClass . class )  ;  TransferManager loc0 = mock ( TransferManager . class )  ;  S3ObjectOutputStream loc1 = mock ( S3ObjectOutputStream . class )  ;  when ( loc0 . upload ( any ( PutObjectRequest . class )  )  )  . thenReturn ( loc1 )  ;  mManager = loc0 ;  mStream = new S3ADirectOutputStream ( BUCKET_NAME ,  KEY ,  mManager )  ;  }
public String function ( Object arg0 ,  String arg1 ,  String arg2 ,  String arg3 ,  String arg4 )  { String docs = getComments ( arg0 ,  null ,  null ,  null )  ;  String cleanedDocs = docs . replaceAll ( "/\\*\\*" ,  "" )   . replaceAll ( "\\*/" ,  "" )   . replaceAll ( "\\*\\s+" ,  "" )   . replaceAll ( " @ summary . *" + LINE_SEPARATOR ,  "" )   . replaceAll ( " @ throws . *" + LINE_SEPARATOR ,  "" )   . replaceAll ( " ( ?m ) ^\\s*\\*" ,  "" )   . replaceAll ( " ( ?m ) ^\\s*\\*" ,  "" )   . replaceAll ( " ( ?m ) ^\\s*$" + LINE_SEPARATOR ,  "" )  ;  return cleanedDocs ;  }
import java . util . logging . Level ;  import java . util . logging . Logger ;  class AbstractStaticFailoverStrategy { long delayBetweenRetries ;  List < String >  alternateAddresses ;  Logger LOG = LogUtils . getL7dLogger ( AbstractStaticFailoverStrategy . class )  ;  long getDelayBetweenRetries (  )  { return delayBetweenRetries ;  } void setAlternateAddresses ( List < String >  alternateAddresses )  { this . alternateAddresses = alternateAddresses ;  } List < String >  getAlternateAddresses ( Exchange exchange )  { return null ;  } String selectAlternateAddress ( List < String >  alternates )  { return null ;  } T getNextAlternate ( List < T >  alternates )  { return null ;  } List < Endpoint >  getAlternateEndpoints ( Exchange exchange )  { return null ;  } Endpoint selectAlternateEndpoint ( List < Endpoint >  alternates )  { return null ;  } void setDelayBetweenRetries ( long delay )  { this . delayBetweenRetries = delay ;  } List < Endpoint >  getEndpoints ( Exchange exchange ,  boolean acceptCandidatesWithSameAddress )  { return null ;  } Level function (  )  { return Level . WARNING ;  } }
public String function ( String arg0 )  { TSTNode loc0 = search ( root ,  arg0 . toCharArray (  )  ,  0 )  ;  if  ( loc0 == null || !loc0 . is_End_Of_String )  { return "Word not found" ;  } return "Word found" ;  }
void function ( Object arg0 ,  Object arg1 ,  Object arg2 ,  int arg3 ,  Object arg4 ,  int arg5 ,  int arg6 ,  Object arg7 )  { Scan loc0 = null ;  Transaction loc1 = null ;  TableInfo loc2 = null ;  Scan loc3 = null ;  try { if  ( rhsscan != null )  { rhsscan . close (  )  ;  } if  ( tx != null )  { tx . commit (  )  ;  } if  ( ti != null )  { ti . close (  )  ;  } if  ( lhsscan != null )  { lhsscan . close (  )  ;  } if  ( prodscan != null )  { prodscan . close (  )  ;  } } finally { if  ( rhsscan != null )  { rhsscan . close (  )  ;  } if  ( tx != null )  { tx . commit (  )  ;  } if  ( ti != null )  { ti . close (  )  ;  } if  ( lhsscan != null )  { lhsscan . close (  )  ;  } if  ( prodscan != null )  { prodscan . close (  )  ;  } } }
Map < String ,  String >  function ( String [  ]  arg0 )  { Map < String ,  String >  loc0 = new HashMap <  >  (  )  ;  for  ( String arg : arg0 )  { String [  ]  loc1 = arg . split ( "#" )  ;  loc0 . put ( loc1 [ 0 ]  ,  loc1 [ 1 ]  )  ;  } return loc0 ;  }
import org . w3c . dom . Node ;  public T [  ]  function ( String arg0 ,  Map < String ,  String >  arg1 ,  Class < T >  arg2 )  { try { T [  ]  loc0 = getNodes ( arg0 ,  arg1 ,  arg2 )  ;  List < T >  loc1 = new ArrayList <  >  (  )  ;  for  ( T loc2 : loc0 )  { if  ( ! ( loc2 instanceof Node )  )  { continue ;  } Node loc3 =  ( Node )  loc2 ;  if  ( loc3 . getNodeType (  )  == Node . COMMENT_NODE ||  ( loc3 . getParentNode (  )  != null && loc3 . getParentNode (  )  . getNodeName (  )  . equals ( "summary" )  )  )  { continue ;  } if  ( loc3 . getNodeType (  )  == Node . ATTRIBUTE_NODE || loc3 . getNodeType (  )  == Node . TEXT_NODE )  { loc1 . add ( loc2 )  ;  } } T [  ]  loc4 =  ( T [  ]  )  Array . newInstance ( arg2 ,  loc1 . size (  )  )  ;  return loc1 . toArray ( loc4 )  ;  } catch  ( Exception loc5 )  { throw new RuntimeException ( loc5 )  ;  } }
boolean function ( Collection < Source >  arg0 )  { runToGoal ( arg0 ,  new GoalFactory (  )  {  @ Override public Goal createGoal ( Job job )  { return sourceExtension (  )  . getValidationGoal ( job )  ;  } } )  ;  return true ;  }
class SystemCommands { Context context ;  boolean getGPS (  )  { } void reboot (  )  { } void function ( boolean arg0 )  { ContentResolver loc0 = context . getContentResolver (  )  ;  loc0 . setLocationProviderEnabled ( LocationManager . GPS_PROVIDER ,  arg0 )  ;  } }
boolean function ( View arg0 )  { if  ( Build . VERSION . SDK_INT  > = Build . VERSION_CODES . JELLY_BEAN_MR1 )  { return arg0 . getLayoutDirection (  )  == View . LAYOUT_DIRECTION_RTL ;  } else { return false ;  } }
Class < ? >  function ( Object arg0 )  { Class < ? >  loc0 = arg0 . getClass (  )  ;  Checklist loc1 = lookupChecklist ( loc0 )  ;  while  ( loc1 == null && loc0 != Object . class )  { loc0 = loc0 . getSuperclass (  )  ;  loc1 = lookupChecklist ( loc0 )  ;  } return loc0 ;  }
void function (  )  { try { int loc0 = 32 ;  // or any other value you want to test instance . setDay ( loc0 )  ;  fail ( "Expected IllegalArgumentException was not thrown . " )  ;  } catch  ( IllegalArgumentException loc1 )  { } }
int function ( int arg0 ,  int arg1 )  { int loc0 = 0 ;  int loc1 = BattleMap . HUMAN_PLAYER ;  int loc2 = 0 ;  int loc3 = -1 ;  for  ( int i = 0 ;  i  <  BattleMap . tiles . get ( loc0 )  . get ( arg0 )  . size ;  i ++  )  { if  ( BattleMap . tiles . get ( loc0 )  . get ( arg0 )  . get ( i )  == null )  { loc3 = i ;  break ;  } else if  ( BattleMap . tiles . get ( loc0 )  . get ( arg0 )  . get ( i )  . player == loc1 )  { loc2 = i ;  } } if  ( loc3 == -1 )  { return loc2 + 1 ;  } else { return loc3 ;  } }
public static Matrix function ( Matrix arg0 )  { Matrix loc0 = transpose ( arg0 )  ;  Matrix loc1 = cofactor ( loc0 )  ;  double loc2 = determinant ( loc0 )  ;  double loc3 = 1 . 0 / loc2 ;  Matrix loc4 = multiplyByConstant ( loc1 ,  loc3 )  ;  return loc4 ;  }
int function ( JobExitStatus arg0 ,  ExitStatus arg1 )  { JobExitStatus NO_NEW_FILES_FOUND = new JobExitStatus ( "NO_NEW_FILES_FOUND" ,  "No new files found in the source" )  ;  JobExitStatus WORK_AREA_NOT_ACCESSABLE = new JobExitStatus ( "WORK_AREA_NOT_ACCESSABLE" ,  "File system work area is not accessible .  Please contact support immediately" )  ;  JobExitStatus SOURCE_DELETION_ERRORS = new JobExitStatus ( "SOURCE_DELETION_ERRORS" ,  "There are some errors when deleting the file from publisher" )  ;  JobExitStatus MOVEFILES_WORKAREA_ERRORS = new JobExitStatus ( "MOVEFILES_WORKAREA_ERRORS" ,  "There are some files already exists in the destination" )  ;  JobExitStatus DB_NOT_ACCESSABLE = new JobExitStatus ( "DB_NOT_ACCESSABLE" ,  "Database is not accessible at this time .  Please contact support immediately" )  ;  JobExitStatus ANOTHER_FETCHER_IS_RUNNING = new JobExitStatus ( "ANOTHER_FETCHER_IS_RUNNING" ,  "Another Fetcher Already running" )  ;  JobExitStatus CONFIG_VALIDATION_FAIL = new JobExitStatus ( "CONFIG_VALIDATION_FAIL" ,  "The required parameters are not available or Invalid Parameters are Provided" )  ;  JobExitStatus UNKNOWN = new JobExitStatus ( "UNKNOWN" )  ;  List < JobExitStatus >  partialExitCodes = null ;  JobExitStatus NO_FILES_FOUND = new JobExitStatus ( "NO_FILES_FOUND" ,  "No files found in the source" )  ;  JobExitStatus MOVEFILES_DESTINATION_ERRORS = new JobExitStatus ( "MOVEFILES_DESTINATION_ERRORS" ,  "There are some files already exists in the destination" )  ;  JobExitStatus DESTINATION_NOT_ACCESSABLE = new JobExitStatus ( "DESTINATION_NOT_ACCESSABLE" ,  "Archive Filesystem ( I Drive? )  is not accessible .  Please contact support immediately" )  ;  JobExitStatus DELAYERING_ERRORS = new JobExitStatus ( "DELAYERING_ERRORS" ,  "There are some errors when delayering the file from publisher" )  ;  JobExitStatus SOURCE_NOT_ACCESSABLE = new JobExitStatus ( "SOURCE_NOT_ACCESSABLE" ,  "Source is not accessible at this time .  Please contact support immediately" )  ;  JobExitStatus NOOP = new JobExitStatus ( "NOOP" )  ;  JobExitStatus FILES_AVAILABLE = new JobExitStatus ( "FILES_AVAILABLE" ,  "Files avaialable to Process" )  ;  JobExitStatus CAPTURE_SOURCE_METADATA_ERRORS = new JobExitStatus ( "CAPTURE_SOURCE_METADATA_ERRORS" ,  "There are some errors when capturing the file metadata from publisher" )  ;  JobExitStatus RUNFAILED = new JobExitStatus ( "RUNFAILED" ,  "Current Run failed Due To Internal System Error" )  ;  JobExitStatus COMPLETED = new JobExitStatus ( "COMPLETED" ,  "Current Run was successful" )  ;  JobExitStatus DOWNLOAD_ERRORS = new JobExitStatus ( "DOWNLOAD_ERRORS" ,  "There are some errors when downloading the file from publisher" )  ;  JobExitStatus EXECUTING = new JobExitStatus ( "EXECUTING" )  ;  JobExitStatus MULTIPLE_PARTIAL_ERRORS = new JobExitStatus ( "MULTIPLE_PARTIAL_ERRORS" ,  "There are some errors while deleting or downloading the file from publisher" )  ;  JobExitStatus PROCESS_VALIDATION_FAIL = new JobExitStatus ( "PROCESS_VALIDATION_FAIL" ,  "Consistency check between work area and data unit failed .  Please Contact Support immediately " )  ;  return arg1 . getExitCode (  )  ;  }
boolean function ( Element arg0 )  { boolean loc0 = this . nsh != null ? this . nsh . isHover ( arg0 )  : false ;  if  ( !loc0 )  { loc0 = this . ui != null ? this . ui . isHover ( arg0 )  : false ;  } if  ( !loc0 )  { loc0 = this . uac != null ? this . uac . isHover ( arg0 )  : false ;  } return loc0 ;  }
List < AttributeStatementProvider >  function (  )  { try { List < AttributeStatementProvider >  loc0 = attributeStatementProviders ;  return loc0 ;  } catch  ( Exception e )  { LOG . error ( "Error getting the List of AttributeStatementProviders: " + e . getMessage (  )  )  ;  return null ;  } }
void function (  )  { Array < Asset >  loc0 = getAssets (  )  ;  unload ( loc0 )  ;  }
Map < String ,  ProjectModel >  function ( UserModel arg0 ,  boolean arg1 )  { Map < String ,  ProjectModel >  loc0 = new HashMap <  >  (  )  ;  List < ProjectModel >  loc1 = getProjectModels ( arg0 ,  arg1 )  ;  for  ( ProjectModel loc2 : loc1 )  { loc0 . put ( loc2 . getName (  )  ,  loc2 )  ;  } return loc0 ;  }
String function ( String arg0 )  { int r = Integer . parseInt ( arg0 . substring ( 0 ,  2 )  ,  16 )  ;  int g = Integer . parseInt ( arg0 . substring ( 2 ,  4 )  ,  16 )  ;  int b = Integer . parseInt ( arg0 . substring ( 4 ,  6 )  ,  16 )  ;  String namedColor = getClosestNamedColor ( r ,  g ,  b )  ;  return namedColor ;  }
public String function ( Object arg0 ,  Object arg1 ,  Object arg2 ,  Object arg3 )  { String suffix = getSuffixFromType (  )  ;  String result = String . format ( "%s . %s . %s%s" ,  getSchema (  )  ,  getType (  )  ,  getName (  )  ,  suffix )  ;  return result ;  }
int function (  )  { try { return port ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  return -1 ;  // or any default value } }
Set < String >  function ( Jedis jedis )  { Set < String >  result = new HashSet <  >  (  )  ;  try { result = jedis . keys ( "URLSet:*" )  ;  } catch  ( Exception e )  { System . err . println ( "Exception occurred: " + e . getMessage (  )  )  ;  } return result ;  }
void function (  )  { mBlocksToMoveIn . clear (  )  ;  mBlocksToMoveOut . clear (  )  ;  }
UserSubject function ( Token arg0 ,  String arg1 )  { UserSubject loc0 = arg0 . getSubject (  )  ;  return loc0 . function ( arg1 )  ;  }
int function ( boolean arg0 )  { int loc0 ;  try { loc0 = getIntFromFormat ( arg0 )  ;  } catch  ( Exception e )  { loc0 = 1 ;  } return loc0 ;  }
String function ( Long arg0 ,  Long arg1 ,  Long arg2 ,  Long arg3 ,  String arg4 ,  String arg5 ,  Long arg6 ,  String arg7 ,  String arg8 ,  Long arg9 ,  String arg10 ,  String arg11 )  { Long loc0 = arg0 ;  Long loc1 = arg1 ;  Long loc2 = arg2 ;  Long loc3 = arg3 ;  String loc4 = arg4 ;  String loc5 = arg5 ;  Long loc6 = arg6 ;  String loc7 = arg7 ;  String loc8 = arg8 ;  Long loc9 = arg9 ;  String loc10 = arg10 ;  String loc11 = arg11 ;  return loc7 ;  }
public boolean function ( String arg0 )  { HashMap < String ,  symbol >  loc0 = this . _all ;  return loc0 . containsKey ( arg0 )  ;  }
StringBuilder function ( Node arg0 )  { StringBuilder sb = new StringBuilder (  )  ;  NodeList childNodes = arg0 . getChildNodes (  )  ;  Text loc0 = null ;  CDATASection loc1 = null ;  for  ( int i = 0 ;  i  <  childNodes . getLength (  )  ;  i ++  )  { Node child = childNodes . item ( i )  ;  if  ( child instanceof Text )  { loc0 =  ( Text )  child ;  sb . append ( loc0 . getNodeValue (  )  )  ;  } else if  ( child instanceof CDATASection )  { loc1 =  ( CDATASection )  child ;  sb . append ( loc1 . getNodeValue (  )  )  ;  } } return sb ;  }
import java . util . * ;  public class MarshalRegistry { int nextId ;  Map < Object , String >  instances = new IdentityHashMap < Object , String >  (  )  ;  Map < String , Object >  notMarshalled = new LinkedHashMap < String , Object >  (  )  ;  public MarshalRegistry (  )  { nextId = 0 ;  } public String getInstanceId ( Object instance )  { if  ( !instances . containsKey ( instance )  )  { String id = Integer . toString ( nextId ++  )  ;  instances . put ( instance ,  id )  ;  } return instances . get ( instance )  ;  } public Iterator < Object >  iterator (  )  { return instances . keySet (  )  . iterator (  )  ;  } public void function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { Object loc0 = System . getProperty ( "marshalRegistry" )  ;  if  ( loc0 != null && loc0 instanceof MarshalRegistry )  {  (  ( MarshalRegistry )  loc0 )  . instances . putAll ( instances )  ;   (  ( MarshalRegistry )  loc0 )  . notMarshalled . putAll ( notMarshalled )  ;  } else { MarshalRegistry loc1 = new MarshalRegistry (  )  ;  loc1 . instances . putAll ( instances )  ;  loc1 . notMarshalled . putAll ( notMarshalled )  ;  System . setProperty ( "marshalRegistry" ,  loc1 . toString (  )  )  ;  } System . setProperty ( "property1" ,  arg0 . toString (  )  )  ;  System . setProperty ( "property2" ,  arg1 . toString (  )  )  ;  System . setProperty ( "property3" ,  arg2 . toString (  )  )  ;  } }
import java . util . ArrayList ;  import java . util . List ;  public class CollectionUtil { public static List < Object >  function ( Object arg0 ,  Object arg1 )  { List < Object >  locList = new ArrayList <  >  (  )  ;  try { locList . add ( arg0 )  ;  locList . add ( arg1 )  ;  } catch  ( Exception e )  { } return locList ;  } }
void function ( ParametersMetaData arg0 )  { try { setParametersMetaData ( arg0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
ArrayList function ( Object arg0 ,  int arg1 )  { ArrayList loc0 = new ArrayList (  )  ;  try { loc0 . add ( DeveloperModule . getInstance (  )  . getName (  )  )  ;  loc0 . add ( DeveloperModule . getInstance (  )  . getInfo ( arg1 )  )  ;  } catch  ( Exception e )  { DeveloperModule . LOG . error ( "Error retrieving details tab" ,  e )  ;  loc0 . add ( "Error retrieving details tab" )  ;  } return loc0 ;  }
void function ( String arg0 ,  byte [  ]  arg1 )  { try { writer . writeStartElement ( arg0 )  ;  String loc0 = new String ( arg1 )  ;  // Convert byte array directly to string writer . writeCharacters ( loc0 )  ;  writer . writeEndElement (  )  ;  } catch  ( XMLStreamException e )  { e . printStackTrace (  )  ;  } }
String function (  )  { PCLDataUnitEntity loc0 = new PCLDataUnitEntity (  )  ;  return loc0 . isActive (  )  ;  }
private void function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { try { Object loc0 = CommonUtils . createNewClassInstance ( Configuration . getClass ( "DataServer" )  )  ;  int loc1 =  (  ( DataServer )  loc0 )  . getPort (  )  ;  boolean loc2 =  (  ( DataServer )  loc0 )  . isClosed (  )  ;  String loc3 =  (  ( DataServer )  loc0 )  . getBindHost (  )  ;  } catch  ( Throwable loc4 )  { Throwables . propagate ( loc4 )  ;  } }
ECKey function ( List < ECKey >  arg0 ,  Script arg1 )  { try { for  ( ECKey loc0 : arg0 )  { loc0 . getPrivKey (  )  ;  return loc0 ;  } } catch  ( ECKey . MissingPrivateKeyException loc1 )  { } return null ;  }
void function ( Object arg0 ,  Object arg1 )  { InstrumentationService loc0 =  ( InstrumentationService )  arg0 ;  Services loc1 =  ( Services )  arg1 ;  loc0 . destroy (  )  ;  }
void function ( long arg0 )  { this . maximumKeySize = arg0 ;  }
String function ( String arg0 )  { String value ;  if  ( ts . hasField ( arg0 )  )  { value = ts . getVal ( arg0 )  ;  } else { value = s . getVal ( arg0 )  ;  } return value ;  }
public int function ( int arg0 ,  int arg1 ,  int arg2 )  { byte [  ]  loc0 = new byte [ 4 ]  ;  loc0 [ 0 ]  =  ( byte )   ( arg0  >  >  >  24 )  ;  loc0 [ 1 ]  =  ( byte )   ( arg1  >  >  >  16 )  ;  loc0 [ 2 ]  =  ( byte )   ( arg2  >  >  >  8 )  ;  loc0 [ 3 ]  =  ( byte )   ( arg2 )  ;  return ByteBuffer . wrap ( loc0 )  . getInt (  )  ;  }
long function ( Coin arg0 )  { Coin loc0 = arg0 . shiftLeft ( SMALLEST_UNIT_EXPONENT )  ;  return loc0 . longValue (  )  ;  }
void function ( MenuItem arg0 ,  int arg1 )  { arg0 . setActionView ( arg1 )  ;  }
void function ( ServerSession arg0 ,  ServerMessage arg1 )  { notificationController . deletePersistentNotification ( null ,  arg1 )  ;  }
void function ( double arg0 )  { try { seconds = arg0 ;  } catch  ( Exception loc0 )  { throw new IllegalArgumentException ( "srini_string" )  ;  } }
public void function ( ServiceID arg0 ,  ServalDatagramPacket packet )  { try { packet . setServiceID ( arg0 )  ;  } catch  ( Exception e )  { System . out . println ( "An exception occurred while setting the ServiceID: " + e . getMessage (  )  )  ;  } }
int function ( int arg0 ,  int arg1 ,  int arg2 )  { int loc0 = 32 + StoredBlock . COMPACT_SERIALIZED_SIZE ;  int loc1 = arg1 * loc0 + arg2 + arg0 ;  return loc1 ;  }
T function (  )  { T loc0 = mPayload ;  return loc0 ;  }
String function (  )  { return DateTime . formatUTCtoSqlUTC ( this . addedDate )  ;  }
List < DirectedAcyclicGraphNode < T >  >  function ( DirectedAcyclicGraphNode < T >  arg0 )  { List < DirectedAcyclicGraphNode < T >  >  mChildren = new ArrayList <  >  (  )  ;  try { mChildren = arg0 . mChildren ;  } catch  ( NullPointerException e )  { System . out . println ( "The node has no children . " )  ;  } return mChildren ;  }
View function ( RecyclerView arg0 ,  View arg1 ,  int arg2 ,  int arg3 )  { int childCount = arg0 . getChildCount (  )  ;  OrientationProvider loc0 = mOrientationProvider ;  StickyRecyclerHeadersAdapter loc1 = mAdapter ;  DimensionCalculator loc2 = mDimensionCalculator ;  HeaderProvider loc3 = mHeaderProvider ;  for  ( int i = 0 ;  i  <  childCount ;  i ++  )  { View child = arg0 . getChildAt ( i )  ;  if  ( loc1 . getHeaderId ( arg2 )  != loc1 . getHeaderId ( arg0 . getChildAdapterPosition ( child )  )  )  { View header = loc3 . getHeader ( arg0 ,  arg2 )  ;  boolean isObscured = itemIsObscuredByHeader ( arg0 ,  child ,  header ,  loc0 . getOrientation ( arg0 )  )  ;  if  ( !isObscured )  { return child ;  } } } return null ;  }
void function ( List < TestResultDetailsDTO >  arg0 )  { regTestResultDetailsLst = arg0 ;  }
public long function (  )  { long loc0 = 0 ;  try { loc0 = getTestId (  )  ;  } catch  ( Exception loc1 )  { System . err . println ( "Exception occurred while getting test id: " + loc1 . getMessage (  )  )  ;  } return loc0 ;  }
void function (  )  { Time loc0 = new Time (  )  ;  Time loc1 = new Time (  )  ;  loc0 . setTime ( 1651468800000L )  ;  time . setTime ( loc0 )  ;  Date arg0 = time . toDate (  )  ;  loc1 . setTime ( arg0 )  ;  assertEquals ( loc0 ,  loc1 )  ;  long arg1 = loc0 . getTime (  )  ;  long arg2 = loc1 . getTime (  )  ;  assertEquals ( arg1 ,  arg2 )  ;  }
void function ( BigDecimal arg0 )  { try { this . feedConfigId = arg0 ;  } catch  ( Exception loc0 )  { } }
String function ( String arg0 )  { ImageWriter loc0 = lookupImageWriterForFormat ( DEFAULT_IMAGE_FORMAT )  ;  ImageWriteParam loc1 = getImageWriteParameters ( loc0 )  ;  loc1 . setCompressionType ( arg0 )  ;  return writeCompressionType ;  }
boolean function ( RangeSet < C >  arg0 ,  Range < C >  arg1 )  { for  ( Range < C >  loc0 : arg0 . asRanges (  )  )  { if  ( loc0 . encloses ( arg1 )  )  { return true ;  } } return false ;  }
void function ( Map < String , Object >  arg0 )  { try { vars . putAll ( arg0 )  ;  } catch  ( Exception loc0 )  { System . out . println ( "Error: Could not add variables to the context . " )  ;  } }
void function ( ByteBuffer arg0 )  { arg0 . setOutputMode (  )  ;  if ( arg0 . hasRemaining (  )  )  { } }
void function ( int arg0 ,  int arg1 ,  String arg2 ,  Block arg3 ,  String arg4 )  { StringBuffer rec = new StringBuffer (  )  ;  rec . append ( "SETSTRING " )  ;  rec . append ( arg1 + " " )  ;  rec . append ( arg3 . fileName (  )  + " " )  ;  rec . append ( arg3 . number (  )  + " " )  ;  rec . append ( arg0 + " " )  ;  rec . append ( arg4 )  ;  byte [  ]  record = rec . toString (  )  . getBytes (  )  ;  int lsn = logMgr . append ( record )  ;  arg3 . setString ( arg0 ,  arg2 ,  arg1 ,  lsn )  ;  }
void function ( Object arg0 ,  Object arg1 ,  DataFlowHandler dataFlowHandler ,  Object arg3 ,  List < DataFlowNode >  dataFlow ,  Object arg5 )  { try { DataFlowNode loc0 = dataFlowHandler . createDataFlowNode (  )  ;  loc0 . setLine (  ( int ) arg0 )  ;  dataFlow . add ( loc0 )  ;  DataFlowNode loc1 = dataFlowHandler . createDataFlowNode (  )  ;  loc1 . setLine (  ( int ) arg1 )  ;  dataFlow . add ( loc1 )  ;  StackObject loc2 = new StackObject ( StackObject . CONTINUE_BREAK_RETURN )  ;  loc2 . setDataFlowNode ( loc0 )  ;  continueBreakReturnStack . push ( loc2 )  ;  StackObject loc3 = new StackObject ( StackObject . BRACE )  ;  loc3 . setDataFlowNode ( loc0 )  ;  braceStack . push ( loc3 )  ;  StackObject loc4 = new StackObject ( StackObject . BRACE )  ;  loc4 . setDataFlowNode ( loc1 )  ;  braceStack . push ( loc4 )  ;  StackObject loc5 = new StackObject ( StackObject . CONTINUE_BREAK_RETURN )  ;  loc5 . setDataFlowNode ( loc1 )  ;  continueBreakReturnStack . push ( loc5 )  ;  } catch  ( Exception e )  { LOGGER . log ( Level . SEVERE ,  "An error occurred while executing the function . " ,  e )  ;  } }
public static User function ( String arg0 ,  String arg1 )  { if  ( !SecurityUtils . isAuthenticationEnabled (  )  )  { throw new IOException ( ExceptionMessage . AUTHENTICATION_IS_NOT_ENABLED . getMessage (  )  )  ;  } try { User loc0 = sUserThreadLocal . get (  )  ;  sUserThreadLocal . remove (  )  ;  return loc0 ;  } catch  ( Exception loc1 )  { throw new RuntimeException ( "Failed to get authenticated user" ,  loc1 )  ;  } }
void function ( String arg0 )  { try { if  ( !selectedRecipients . contains ( arg0 )  )  { selectedRecipients . add ( arg0 )  ;  System . out . println ( "Recipient " + arg0 + " added to the required recipients list . " )  ;  } else { System . out . println ( "Recipient " + arg0 + " already exists in the required recipients list . " )  ;  } } catch  ( Exception e )  { System . err . println ( "An error occurred while trying to add the recipient " + arg0 + " to the required recipients list: " + e . getMessage (  )  )  ;  } }
import java . io . File ;  import org . junit . Assert ;  import org . junit . Rule ;  import org . junit . Test ;  import org . junit . rules . ExpectedException ;  import org . junit . rules . TemporaryFolder ;  public class FileUtilsTest {  @ Rule public ExpectedException mException = ExpectedException . none (  )  ;   @ Rule public TemporaryFolder mTestFolder = new TemporaryFolder (  )  ;   @ Test public void function (  )  { File loc0 = new File ( "non-existent-file . txt" )  ;  File loc1 = mTestFolder . getRoot (  )  ;  mException . expect ( IllegalArgumentException . class )  ;  FileUtils . delete ( loc0 . getAbsolutePath (  )  )  ;  Assert . fail ( "Expected an exception to be thrown when trying to delete a non-existent file . " )  ;  } }
boolean function ( String arg0 ,  OperationSigMask arg1 )  { if  ( arg0 == null || arg1 == null )  { return false ;  } for  ( OperationSignature loc0 : operations . keySet (  )  )  { if  ( arg0 . equals ( loc0 . getName (  )  )  && arg1 . covers ( loc0 )  )  { Map < String ,  OperationStats >  loc1 = operations . get ( loc0 )  ;  if  ( loc1 != null && !loc1 . isEmpty (  )  )  { return true ;  } } } return false ;  }
boolean function ( Collection < UserModel >  arg0 )  { userService . updateUserModels ( arg0 )  ;  return true ;  }
void function ( String arg0 ,  Object arg1 )  { try { this . config . getServletContext (  )  . log ( this . config . getFilterName (  )  + "srini_string" + arg0 ,  arg1 )  ;  } catch  ( Throwable loc0 )  { this . config . getServletContext (  )  . log ( this . config . getFilterName (  )  + "srini_string" + arg0 ,  loc0 )  ;  } }
 @ Override void function ( HttpServletRequest arg0 ,  HttpServletResponse arg1 )  { try { writeResponse ( arg0 ,  arg1 ,  "" )  ;  } catch  ( IOException e )  { Logger loc0 = LoggerFactory . getLogger ( JsonControllerUtils . class )  ;  loc0 . error ( "Error writing empty response: {}" ,  e . getMessage (  )  )  ;  } }
void function ( int arg0 ,  ProgressMonitor progressMonitor )  { progressMonitor . curValue = arg0 ;  }
String function ( String arg0 )  { String loc0 = null ;  try { loc0 = m_escapedJson ;  } catch  ( Exception e )  { m_log . error ( "Error accessing JSON string: " + e . getMessage (  )  )  ;  } return loc0 ;  }
boolean function ( NodeTester arg0 )  { NodeIterator loc0 = documentTraversal . createNodeIterator (  rootNode ,  NodeFilter . SHOW_ALL ,  arg0 ,  false )  ;  Node loc1 ;  while  (  ( loc1 = loc0 . nextNode (  )  )  != null )  { if  ( !acceptNodeType ( loc1 . getNodeType (  )  )  )  { continue ;  } short loc2 = acceptNode ( loc1 )  ;  if  ( loc2 == NodeFilter . FILTER_ACCEPT )  { continue ;  } if  ( loc2 == NodeFilter . FILTER_REJECT )  { return false ;  } } return true ;  }
BlockStoreContext function ( InetSocketAddress arg0 )  { BlockStoreContext loc0 = CACHED_CONTEXTS . get ( arg0 )  ;  if  ( loc0 == null )  { loc0 = new BlockStoreContext ( mBlockMasterClientPool ,  mHasLocalWorker )  ;  CACHED_CONTEXTS . put ( arg0 ,  loc0 )  ;  } return loc0 ;  }
ImageWriter function ( String arg0 ,  float arg1 ,  String arg2 ,  int arg3 )  { FSImageWriter writer = new FSImageWriter (  )  ;  writer . setWriteCompressionMode ( arg3 )  ;  writer . setWriteCompressionType ( arg2 )  ;  writer . setWriteCompressionQuality ( arg1 )  ;  String imageFormat = "jpeg" ;  ImageWriter imageWriter = writer . lookupImageWriterForFormat ( imageFormat )  ;  ImageWriteParam imageWriteParams = writer . getImageWriteParameters ( imageWriter )  ;  return imageWriter ;  }
String function ( String arg0 ,  String arg1 )  { String loc0 = conditionallyPrependHttp ( arg0 )  ;  String loc1 = getHost ( loc0 )  ;  String loc2 = getPath ( loc0 )  ;  String loc3 = getQuery ( loc0 )  ;  HashMap < String , String >  paramMap = getParameterMap ( loc3 . split ( "&" )  )  ;  ArrayList < String >  keyList = getKeyList ( paramMap )  ;  String loc4 = createOmaLink ( createQueryString ( keyList ,  paramMap )  )  ;  String loc5 = removePath ( loc4 )  ;  String loc6 = OMA_REDIRECT_LINK + SITE_PARAM + "=" + arg1 ;  return loc5 + loc6 ;  }
public void function ( Map < String ,  ThreadingParameters >  arg0 ,  JettyHTTPServerEngine engine )  { try { engine . getThreadingParametersMap (  )  . putAll ( arg0 )  ;  } catch  ( Exception e )  { System . err . println ( "An error occurred while setting the ThreadingParameters for the JettyHTTPServerEngine: " + e . getMessage (  )  )  ;  } }
void function ( Language arg0 ,  CodeGenerator arg1 )  { if  ( generators . containsKey ( arg0 )  )  { generators . remove ( arg0 )  ;  } generators . put ( arg0 ,  arg1 )  ;  LOG . debug ( "New generator registered for language: " + arg0 . getName (  )  )  ;  fireEvent ( new GeneratorRegisteredEvent ( arg0 )  )  ;  }
void function ( String arg0 ,  Object arg1 )  { try { current . get (  )  . setVariable ( arg0 ,  arg1 )  ;  } catch  ( Exception e )  { System . err . println ( "Error occurred while setting variable in ELEvaluator context: " + e . getMessage (  )  )  ;  } }
public int function ( int arg0 ,  int arg1 )  { int loc0 = -1 ;  try { if  ( arg0  <  0 || arg1  <  0 )  { throw new IllegalArgumentException ( "Arguments must be non-negative" )  ;  } if  ( arg0 == 0 )  { loc0 = arg1 / arg0 ;  // this will throw an ArithmeticException } loc0 = arg1 % arg0 ;  } catch  ( ArithmeticException e )  { System . err . println ( "Division by zero: " + e . getMessage (  )  )  ;  } catch  ( IllegalArgumentException e )  { System . err . println ( "Invalid arguments: " + e . getMessage (  )  )  ;  } return loc0 ;  }
void function ( int arg0 ,  int arg1 ,  ArrayList < Bullet >  arg2 )  { if ( arg0 - arg1  < = System . nanoTime (  )  && arg2 . size (  )   <  MAX_BULLETS )  { arg2 . add ( new Bullet ( xPos ,  yPos ,  zPos ,  heading )  )  ;  bulletTime = System . nanoTime (  )  ;  System . out . println ( "Fire a bullet . " )  ;  } }
GetOfferDetailsResponse . Return . DetailOfferData . OfferDisplay function (  )  { GetOfferDetailsResponse response = createGetOfferDetailsResponse (  )  ;  GetOfferDetailsResponse . Return responseReturn = response . createGetOfferDetailsResponseReturn (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData detailOfferData = responseReturn . createGetOfferDetailsResponseReturnDetailOfferData (  )  ;  return detailOfferData . createOfferDisplay (  )  ;  }
public static Long function ( RMConfiguration rmConfig )  { Long loc0 = null ;  try { loc0 = rmConfig != null && rmConfig . getAcknowledgementInterval (  )  != null ? rmConfig . getAcknowledgementInterval (  )  . longValue (  )  : null ;  } catch  ( Exception e )  { } return loc0 ;  }
void function (  )  { server . stopAsync (  )  ;  server . awaitTerminated (  )  ;  } This method closes all client connections currently connected gracefully ,  but it does not settle the actual payment channels  ( and broadcast payment transactions )  ,  which must be done using the { @ link StoredPaymentChannelServerStates} which manages the states for the associated wallet . 
String function ( String arg0 ,  String arg1 ,  int arg2 ,  String arg3 )  { StringBuffer loc0 = new StringBuffer (  )  ;  loc0 . append ( "This is the standard way to report debugging information in the compiler .   It reports a message of the specified level  ( which controls the presentation of the message .  To test whether such message should be reported ,  use \"should_report\" .  NOTE: This is a change of spec from earlier versions of Report .  NOTE: This version takes an explicit Position ,  so that position info gets properly associated with the ErrorInfo that gets created by enqueue (  )  . " )  ;  ErrorQueue eq = getQueue (  )  ;  ErrorInfo loc1 = new ErrorInfo ( DEBUG ,  arg0 ,  arg1 ,  eq . currentErrorLine (  )  ,  eq . currentErrorLinePos (  )  ,  arg2 ,  arg3 )  ;  eq . enqueue ( loc1 )  ;  return loc0 . toString (  )  ;  }
/** * Create an instance of { @ link Access} .  * *  @ param arg0 The access type *  @ param arg1 The access level *  @ return The created instance of { @ link Access} */
void function ( String arg0 )  { failedAttributeName = arg0 ;  }
List < String >  function ( String arg0 )  { List < String >  loc0 = CommonUtils . getUnixGroups ( arg0 )  ;  ArrayList < String >  loc1 = new ArrayList <  >  ( loc0 )  ;  LinkedHashSet < String >  loc2 = new LinkedHashSet <  >  ( loc1 )  ;  return new ArrayList <  >  ( loc2 )  ;  }
public void function (  )  { Socket loc0 = null ;  try { loc0 = this . getSocket (  )  ;  if  ( loc0 != null )  { loc0 . getOutputStream (  )  . flush (  )  ;  } } catch  ( IOException loc1 )  { logger . error ( "Exception occurred while flushing outstanding data: " ,  loc1 )  ;  } }
void function ( String arg0 ,  String arg1 )  { MetadataEditorCompat loc0 = editMetadata ( true )  ;  loc0 . putString ( arg0 ,  arg1 )  ;  }
void function (  )  { GeneralMotorCon loc0 = GeneralMotorCon . getInstance (  )  ;  loc0 . appendToConsole (  )  ;  loc0 . landing (  )  ;  loc0 . doFor ( arg0 ,  arg1 )  ;  }
Here's an implementation of the function you requested: ```java import java . util . Map ;  import com . google . common . base . MoreObjects . ToStringHelper ;  import com . google . common . collect . ImmutableMap ;  public class GroupConfiguration { private Map < String ,  String >  metadata ;  private int maxEntities ;  private int minEntities ;  private String name ;  private int cooldown ;  public String toString (  )  { ToStringHelper helper = com . google . common . base . MoreObjects . toStringHelper ( this )  ;  helper . add ( "metadata" ,  metadata )  ;  helper . add ( "maxEntities" ,  maxEntities )  ;  helper . add ( "minEntities" ,  minEntities )  ;  helper . add ( "name" ,  name )  ;  helper . add ( "cooldown" ,  cooldown )  ;  return helper . toString (  )  ;  } public static Builder metadata ( Map < String ,  String >  arg0 )  { return new Builder (  )  . metadata ( arg0 )  ;  } public String getName (  )  { return name ;  } public ToStringHelper string (  )  { return com . google . common . base . MoreObjects . toStringHelper ( this )  ;  } public static Builder maxEntities ( int arg0 )  { return new Builder (  )  . maxEntities ( arg0 )  ;  } public static Builder fromGroupConfiguration ( GroupConfiguration arg0 )  { return new Builder (  )  . fromGroupConfiguration ( arg0 )  ;  } public static Builder builder (  )  { return new Builder (  )  ;  } public Builder toBuilder (  )  { return new Builder (  )  . fromGroupConfiguration ( this )  ;  } public int getMaxEntities (  )  { return maxEntities ;  } public int getMinEntities (  )  { return minEntities ;  } public GroupConfiguration build (  )  { return new GroupConfiguration ( metadata ,  maxEntities ,  minEntities ,  name ,  cooldown )  ;  } public int hashCode (  )  { final int prime = 31 ;  int result = 1 ;  result = prime * result +  (  ( metadata == null )  ? 0 : metadata . hashCode (  )  )  ;  result = prime * result + maxEntities ;  result = prime * result + minEntities ;  result = prime * result +  (  ( name == null )  ? 0 : name . hashCode (  )  )  ;  result = prime * result + cooldown ;  return result ;  } public int compareTo ( GroupConfiguration that )  { if  ( this == that )  { return 0 ;  } int result = 0 ;  result = name . compareTo ( that . name )  ;  if  ( result != 0 )  { return result ;  } result = Integer . compare ( maxEntities ,  that . maxEntities )  ;  if  ( result != 0 )  { return result ;  } result = Integer . compare ( minEntities ,  that . minEntities )  ;  if  ( result != 0 )  { return result ;  } result = Integer . compare ( cooldown ,  that . cooldown )  ;  if  ( result != 0 )  { return result ;  } result = ImmutableMap . copyOf ( metadata )  . compareTo ( ImmutableMap . copyOf ( that . metadata )  )  ;  return result ;  } public int getCooldown (  )  { return cooldown ;  } public boolean equals ( Object obj )  { if  ( this == obj )  { return true ;  } if  ( obj == null )  { return false ;  } if  ( getClass (  )  != obj . getClass (  )  )  { return false ;  } GroupConfiguration other =  ( GroupConfiguration )  obj ;  if  ( metadata == null )  { if  ( other . metadata != null )  { return false ;  } } else if  ( !metadata . equals ( other . metadata )  )  { return false ;  } if  ( maxEntities != other . maxEntities )  { return false ;  } if  ( minEntities != other . minEntities )  { return false ;  } if  ( name == null )  { if  ( other . name != null )  { return false ;  } } else if
void function (  )  { setUp (  )  ;  rmc = new RMCParser (  )  ;  rmc . parse ( EXAMPLE )  ;  loc0 = rmc . getVariation (  )  ;  assertEquals ( "006 . 1" ,  loc0 )  ;  loc1 = rmc . getDirectionOfVariation (  )  ;  assertEquals ( "E" ,  loc1 )  ;  assertTrue ( true )  ;  }
public static String function ( String arg0 )  { String loc0 = arg0 ;  try { loc0 = StringEscapeUtils . escapeJavaScript ( loc0 )  ;  loc0 = loc0 . replaceAll ( " ( ?i ) javascript" ,  "" )  ;  loc0 = loc0 . replaceAll ( "/\\* [ \\s\\S ] *?\\*/" ,  "" )  ;  } catch  ( Exception e )  { } return loc0 ;  }
String function ( TokenReference arg0 )  { String loc0 = arg0 . wsseValueType ;  return loc0 ;  }
public static void function ( String arg0 ,  String arg1 )  { try { } catch  ( Exception e )  { } }
private void function ( Object arg0 ,  Object arg1 )  { try { LOGGER . info ( "Getting the resources" )  ;  setResources (  ( List < Resource >  )  arg0 )  ;  loadProperties (  )  ;  } catch  ( Exception loc0 )  { LOGGER . error ( "Failed to get the resources: " + loc0 . getMessage (  )  ,  loc0 )  ;  } }
public boolean function ( String arg0 ,  String arg1 )  { try { String loc0 = getString ( arg0 ,  null )  ;  return loc0 != null ;  } catch  ( Exception e )  { logger . error ( "Error testing existence of setting" ,  e )  ;  return false ;  } }
public static ResourceTypeHandler function ( String arg0 )  { ResourceTypeHandler loc0 = null ;  try { loc0 = ResourceTypeHandler . valueOf ( arg0 )  ;  } catch  ( IllegalArgumentException e )  { loc0 = null ;  } return loc0 ;  }
void function ( Notation arg0 ,  Node arg1 ,  NodeTest arg2 )  { try { unhandled ( arg1 )  ;  } catch  ( Exception loc0 )  { } }
public static long function (  )  { long loc0 = 0 ;  long loc1 = 0 ;  try { loc0 = SERVICE_STATISTICS . size (  )  ;  loc1 = getTotalElapsed (  )  ;  } catch  ( Exception e )  { System . out . println ( "An error occurred while calculating the average elapsed time . " )  ;  e . printStackTrace (  )  ;  } return loc1 / loc0 ;  }
void function (  )  { try { setErrorLevel ( 0 )  ;  setKO ( false )  ;  setWarning ( false )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
void function (  )  { double arg0 = 45 . 0 ;  RMBTest testObj = new RMBTest (  )  ;  try { testObj . setBearing ( arg0 )  ;  fail ( "Expected IllegalArgumentException was not thrown . " )  ;  } catch  ( IllegalArgumentException loc0 )  { assertTrue ( "Exception message does not contain expected string . " ,  loc0 . getMessage (  )  . contains ( "Invalid bearing value" )  )  ;  } }
AlluxioURI function ( long arg0 )  { AlluxioURI loc0 = null ;  try { loc0 = mFileSystemMaster . getPath ( arg0 )  ;  } catch  ( Exception e )  { } return loc0 ;  }
import java . util . Arrays ;  public class Sha256Hash { public static final Sha256Hash ZERO_HASH = new Sha256Hash ( new byte [ 32 ]  )  ;  private byte [  ]  bytes ;  public Sha256Hash ( byte [  ]  bytes )  { this . bytes = bytes ;  } public Sha256Hash hashFileContents ( File f )  { } public boolean equals ( Object o )  { } public static Sha256Hash create ( byte [  ]  contents )  { } public Sha256Hash duplicate (  )  { } public byte [  ]  getBytes (  )  { return bytes ;  } public static Sha256Hash createDouble ( byte [  ]  contents )  { } public BigInteger toBigInteger (  )  { } public String toString (  )  { } public int compareTo ( Sha256Hash o )  { } public int function ( int arg0 ,  int arg1 ,  int arg2 )  { int loc0 = Arrays . hashCode ( bytes )  & arg0 ;  int loc1 = loc0  <  <  arg1 ;  int loc2 = loc1 | arg2 ;  return loc2 ;  } }
byte function ( byte arg0 ,  Object arg1 )  { byte tag = arg0 ;  Object value = arg1 ;  return tag ;  }
Block getHeader (  )  { Block loc0 = header . cloneAsHeader (  )  ;  loc0 . clearTransactions (  )  ;  return loc0 ;  }
FCKeditorConfig function ( String arg0 ,  String arg1 )  { FCKeditorConfig loc0 = new FCKeditorConfig (  )  ;  loc0 . BasePath = basePath ;  loc0 . ToolbarSet = toolbarSet ;  loc0 . Width = width ;  loc0 . Height = height ;  loc0 . FileBrowserBrowseUrl = basePath + "browser . html?Connector=" + basePath + "connectors/jsp/connector" ;  loc0 . FileBrowserUploadUrl = basePath + "upload . html?Connector=" + basePath + "connectors/jsp/connector" ;  return loc0 ;  }
Difference function (  )  { Difference loc0 = this . additionDifference ;  return loc0 ;  }
String function (  )  { String loc0 = "" ;  try { loc0 = this . version ;  } catch  ( Exception loc1 )  { LOG . error ( "Error occurred while accessing language version" ,  loc1 )  ;  } return loc0 ;  }
private void function (  )  { int loc0 = real_stack . elementAt ( real_next )  ;  real_next ++  ;  vstack . push ( loc0 )  ;  int loc1 = vstack . size (  )  ;  parse_state ( loc1 ,  loc0 )  ;  }
void function ( CountDownLatch loc0 ,  ListenableFuture < ? >  loc1 ,  Object loc2 )  { try { Assert . assertTrue ( loc0 . await ( 30 ,  TimeUnit . SECONDS )  )  ;  Assert . assertEquals ( loc2 ,  loc1 . get (  )  )  ;  } catch  ( InterruptedException | ExecutionException loc3 )  { Throwable loc4 = loc3 . getCause (  )  ;  if  ( loc4 == null )  { loc4 = loc3 ;  } Assert . fail ( "Unexpected exception thrown: " + loc4 . getMessage (  )  )  ;  } }
void function ( int arg0 )  { try { this . gisticID = arg0 ;  } catch  ( Exception e )  { System . out . println ( "Error setting gisticID: " + e . getMessage (  )  )  ;  } }
long function ( K arg0 ,  long arg1 )  { try { return map . accumulateAndGet ( arg0 ,  arg1 ,  Long::sum )  ;  } catch  ( Exception e )  { } }
public static void function ( String [  ]  args )  { try { SshExample example = new SshExample (  )  ;  example . connected ( new SshConnectedEvent (  )  )  ;  example . disconnected ( new SshDisconnectedEvent (  )  )  ;  example . dataReceived ( new SshDataReceivedEvent (  )  )  ;  } catch  ( Exception e )  { System . err . println ( "Error in Main method for SshExample: " + e . getMessage (  )  )  ;  } }
void function ( AbstractPlugin arg0 )  { arg0 . removePluginObserver (  )  ;  PluginContainer loc0 = singleton . allPlugins ;  loc0 . remove ( arg0 )  ;  }
List < String >  function ( String arg0 )  { List < String >  loc0 = new ArrayList <  >  (  )  ;  try { loc0 = Lists . newArrayList ( arg1 . getGroups ( arg0 )  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
void function ( ServiceID arg0 )  { try { ServalNetworkStack loc0 = netImpl ;  loc0 . bind ( arg0 ,  address )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } }
void function (  )  { function (  )  ;  System . out . println (  )  ;  String loc0 = "srini_string" ;  String loc1 = instance . getResponseStringCsv (  )  ;  assertEquals ( arg0 ,  arg1 )  ;  }
Label function ( Label arg0 ,  float arg1 ,  float arg2 ,  float arg3 ,  float arg4 )  { arg0 . setX ( arg1 )  ;  arg0 . setY ( arg2 )  ;  arg0 . setWidth ( arg3 )  ;  arg0 . setHeight ( arg4 )  ;  arg0 . getStyle (  )  . set ( "color" ,  Color . BLACK )  ;  arg0 . getStyle (  )  . setFont ( Font . getDefault (  )  )  ;  return arg0 ;  }
Sha256Hash function (  )  { InputStream loc0 = new ByteArrayInputStream ( concatenateCheckpoints (  )  . getBytes (  )  )  ;  Sha256Hash loc1 = Sha256Hash . wrap ( Sha256Hash . hash ( loc0 )  )  ;  return loc1 ;  }
void function ( Object arg0 )  { checkType ( arg0 )  ;  long loc0 =  (  ( Number )  arg0 )  . longValue (  )  ;  packLong ( loc0 ,  false )  ;  }
void function (  )  { HDMSentence loc0 = new HDMSentence ( EXAMPLE )  ;  assertTrue ( loc0 != null )  ;  assertFalse ( loc0 . isTrue (  )  )  ;  loc0 . setHeading ( 45 . 0 )  ;  assertTrue ( loc0 . isTrue (  )  )  ;  loc0 . setHeadingTooHigh (  )  ;  assertFalse ( loc0 . isTrue (  )  )  ;  }
void function ( Signature . Visibility arg0 )  { visMask . removeAll ( Arrays . asList ( arg0 )  )  ;  }
class RequestInput { Scanner scanner = new Scanner ( System . in )  ;  String function ( String arg0 )  { System . out . print ( arg0 )  ;  String loc0 = scanner . nextLine (  )  ;  return loc0 ;  } }
Options function (  )  { Options options = null ;  try { options = new Options (  )  ;  options . addOption ( AbstractShellCommand . READONLY_OPTION )  ;  options . addOption ( AbstractShellCommand . MOUNT_SHARED_OPTION )  ;  options . addOption ( AbstractShellCommand . RECURSIVE_OPTION )  ;  options . addOption ( AbstractShellCommand . FORCE_OPTION )  ;  options . addOption ( AbstractShellCommand . PROPERTY_FILE_OPTION )  ;  } catch  ( Exception loc0 )  { } return options ;  }
public void function (  )  { try { double arg0 = 90 . 0 ;  vhw . setHeading ( arg0 )  ;  double loc0 = vhw . getHeading (  )  ;  double loc1 = arg0 ;  assertEquals ( loc1 ,  loc0 ,  0 . 1 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
public Variable function ( Constraint constraint ,  Variable var )  { List < Variable >  scope = constraint . getScope (  )  ;  int size = scope . size (  )  ;  Variable otherVar = null ;  for  ( int i = 0 ;  i  <  size ;  i ++  )  { Variable locVar = scope . get ( i )  ;  if  ( !locVar . equals ( var )  )  { otherVar = locVar ;  break ;  } } return otherVar ;  }
public double function (  )  { double loc0 = 0 . 0 ;  try { loc0 = getOccupancy (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
public String function ( int arg0 )  { try { ScopeKindEnum loc0 = SK_INSTANCE ;  if  ( arg0 == 1 )  { loc0 = SK_CLASSIFIER ;  } for  ( ScopeKindEnum loc1 : loc0 . typeName )  { if  ( loc1 . literalName . equals ( this . literalName )  )  { return loc1 . literalName ;  } } } catch  ( Exception loc2 )  { } return null ;  }
void function ( String arg0 )  { setDocument ( arg0 )  ;  Dimension loc0 = new Dimension ( panel . getWidth (  )  ,  panel . getHeight (  )  )  ;  layout (  ( Graphics2D )  panel . getGraphics (  )  ,  loc0 )  ;  Graphics2D loc1 =  ( Graphics2D )  panel . getGraphics (  )  ;  render ( loc1 )  ;  }
String function (  )  { String loc0 = ToDoItemXMLHelper . item . getHeadline (  )  ;  String loc1 = TodoParser . encode ( loc0 )  ;  return loc1 ;  }
public String function ( Bank bank )  { StringBuilder summary = new StringBuilder (  )  ;  for  ( Customer customer : bank . customers )  { summary . append ( "\n- " )   . append ( customer . getName (  )  )   . append ( "  ( " )   . append ( customer . getNumberOfAccounts (  )  )   . append ( " " )   . append ( bank . format ( customer . getNumberOfAccounts (  )  ,  "account" )  )   . append ( " ) " )  ;  } return summary . toString (  )  ;  }
public double function (  )  { checkState ( count  >  0 ,  "Cannot compute minimum on empty dataset" )  ;  double result = Double . POSITIVE_INFINITY ;  boolean finiteValuesExist = false ;  for  ( double loc0 : snapshot (  )  . getValues (  )  )  { if  ( Double . isNaN ( loc0 )  )  { return Double . NaN ;  } if  ( Double . isFinite ( loc0 )  )  { finiteValuesExist = true ;  if  ( loc0  <  result )  { result = loc0 ;  } } } if  ( Double . isInfinite ( result )  )  { if  ( finiteValuesExist )  { return Double . NEGATIVE_INFINITY ;  } else { return Double . POSITIVE_INFINITY ;  } } return result ;  }
void function (  )  { Device loc0 = new Device (  )  ;  loc0 . addCapability ( "testCapability" )  ;  loc0 . setDeviceName ( "testDeviceName" )  ;  String [  ]  loc1 = {"testImgName"} ;  loc0 . setImageNames ( loc1 )  ;  String [  ]  loc2 = {"testGetCapabilities"} ;  loc0 . setCapabilities ( loc2 )  ;  String loc3 = "testGetDeviceID" ;  loc0 . setDeviceID ( loc3 )  ;  String loc4 = "testGetAddress" ;  loc0 . setAddress ( loc4 )  ;  String loc5 = "testToString" ;  assertEquals ( loc5 ,  loc0 . toString (  )  )  ;  String loc6 = "testAddToPane" ;  loc0 . setAddToPane ( loc6 )  ;  String loc7 = "testGetCapabilityBlock" ;  assertEquals ( loc7 ,  loc0 . getCapabilityBlock (  )  )  ;  String loc8 = "Test of getDeviceBlock method ,  of class Device . " ;  System . out . println ( loc8 )  ;  fail ( "The test case is a prototype . " )  ;  }
void function (  )  { SpaceXGUI . getInstance (  )  . appendToConsole ( TAG ,  "srini_string" )  ;  cmd . down ( speed )  . doFor ( 1000 )  ;  cmd . hover (  )  . doFor ( hoverTime )  ;  cmd . waitFor ( 500 )  ;  cmd . land (  )  ;  }
public void function (  )  { try { bufferSize = 0 ;  buffer = new byte [ INITIAL_BUFFER_CAPACITY ]  ;  } catch  ( Exception e )  { } }
public ECKey function ( byte [  ]  arg0 )  { byte [  ]  loc0 = SATOSHI_KEY ;  return new ECKey ( null ,  loc0 )  ;  } Note: This method returns an ECKey object using the SATOSHI_KEY member variable as the private key for the key pair .  This key is used to sign AlertMessage objects in the Bitcoin protocol .  The method takes a byte array argument but it is not used in the implementation . 
String function ( Uri arg0 )  { SQLiteUriMatcher loc0 = instances . get ( mAuthority )  ;  if  ( loc0 == null )  { throw new IllegalArgumentException ( "No SQLiteUriMatcher instance found for authority: " + mAuthority )  ;  } SQLiteMatcherEntry loc1 = loc0 . getMatcherEntry ( arg0 )  ;  if  ( loc1 == null )  { throw new IllegalArgumentException ( "Unknown URI: " + arg0 )  ;  } SQLiteMatcherEntry . Type loc2 = loc0 . getBaseType (  )  ;  String loc3 = loc1 . getType (  )  ;  String loc4 = loc1 . getSubType (  )  ;  String mimeType = String . format ( "%s/%s . %s" ,  loc2 ,  loc3 ,  loc4 )  ;  return mimeType ;  }
void function ( final OutputStream arg0 ,  final short arg1 )  { arg0 . write (  ( byte )  arg1 )  ;  arg0 . write (  ( byte )   ( arg1  >  >  8 )  )  ;  }
public static void function ( DenseMatrix64F arg0 ,  DenseMatrix64F arg1 ,  DenseMatrix64F arg2 ,  double gamma ,  DenseMatrix64F u )  { int n = arg0 . getNumElements (  )  ;  DenseMatrix64F x = new DenseMatrix64F ( n ,  1 )  ;  DenseMatrix64F y = new DenseMatrix64F ( n ,  1 )  ;  for  ( int i = 0 ;  i  <  n ;  i ++  )  { x . set ( i ,  0 ,  arg0 . get ( i )  )  ;  } DenseMatrix64F uuT = new DenseMatrix64F ( n ,  n )  ;  CommonOps . multTransB ( u ,  u ,  uuT )  ;  CommonOps . scale ( gamma ,  uuT )  ;  CommonOps . add ( CommonOps . identity ( n )  ,  uuT ,  uuT )  ;  CommonOps . mult ( uuT ,  x ,  y )  ;  for  ( int i = 0 ;  i  <  n ;  i ++  )  { arg1 . set ( i ,  y . get ( i ,  0 )  )  ;  } CommonOps . multAddTransA ( gamma ,  y ,  u ,  arg2 )  ;  }
public static void function ( Repository arg0 ,  String arg1 ,  String arg2 ,  OutputStream arg3 ,  String compressionFormat )  { try { CompressionUtils compressionUtils = new CompressionUtils (  )  ;  boolean success ;  if  ( compressionFormat . equals ( CompressorStreamFactory . XZ )  )  { success = compressionUtils . tar ( compressionFormat ,  arg0 ,  arg1 ,  arg2 ,  arg3 )  ;  } else { success = compressionUtils . tar ( arg0 ,  arg1 ,  arg2 ,  arg3 )  ;  } if  ( success )  { LOGGER . info ( "Compression successful" )  ;  } else { LOGGER . error ( "Compression failed" )  ;  } } catch  ( Exception e )  { LOGGER . error ( "Error while compressing" ,  e )  ;  } }
import java . util . Collections ;  import java . util . Map ;  public class SearchConditionBuilder { private String FIQL = DEFAULT_LANGUAGE ;  private static String DEFAULT_LANGUAGE = "FIQL" ;  public String query (  )  { return "" ;  } public Map < String ,  String >  function ( String arg0 ,  String arg1 )  { Map < String ,  String >  loc0 = Collections . emptyMap (  )  ;  try { loc0 =  ( Map < String ,  String >  )  Class . forName ( arg0 )  . newInstance (  )  ;  } catch  ( ClassNotFoundException | IllegalAccessException | InstantiationException e )  { e . printStackTrace (  )  ;  } return loc0 ;  } }
class AbstractJspNodesTst { private Set < JspNode >  nodes = new HashSet <  >  (  )  ;  void function ( JspNode arg0 ,  Class < ? >  arg1 )  { if  ( arg0 != null )  { nodes . add ( arg0 )  ;  for  ( int loc0 = 0 ;  loc0  <  arg0 . jjtGetNumChildren (  )  ;  loc0 ++  )  { function ( arg0 . jjtGetChild ( loc0 )  ,  arg1 )  ;  } if  ( arg1 != null )  { Set < JspNode >  filteredNodes = new HashSet <  >  (  )  ;  for  ( JspNode node : nodes )  { if  ( arg1 . equals ( node . getClass (  )  )  )  { filteredNodes . add ( node )  ;  } } nodes = filteredNodes ;  } } } }
boolean function ( MotionEvent arg0 ,  TouchHandlerABC view ,  boolean onlyPenInput ,  Hardware isPenEvent )  { boolean loc0 = false ;  if  ( !onlyPenInput || isPenEvent . isPenEvent ( arg0 )  )  { loc0 = view . onTouchEvent ( arg0 )  ;  } return loc0 ;  }
private void function (  )  { try { SecurityContext loc0 = getMessageContext (  )  . getSecurityContext (  )  ;  boolean loc1 = loc0 . isSecure (  )  ;  if  ( !loc1 )  { warning ( "HTTPS is the default transport for OAuth 2 . 0 services .  By default this method will issue a warning for open endpoints" )  ;  } } catch  ( Exception e )  { throw toBadRequestException ( e . getMessage (  )  )  ;  } }
void function ( Object arg0 ,  Object arg1 )  { try { if  ( xmppConnection != null && workerPool != null && !workerPool . isShutdown (  )  )  { xmppConnection . disconnect (  )  ;  if  ( arg0 != null && arg1 != null )  { arg0 . method ( arg1 )  ;  } if  ( configurationContext != null )  { configurationContext . shutdown (  )  ;  } workerPool . shutdown (  )  ;  } } catch  ( Exception loc0 )  { log . error ( "Error stopping XMPP listener and disconnecting from XMPP servers" ,  loc0 )  ;  } }
String function ( String arg0 )  { String loc0 = "" ;  Object loc1 = mMap . get ( arg0 )  ;  if  ( loc1 != null )  { loc0 = loc1 . toString (  )  ;  } return loc0 ;  }
void function ( byte [  ]  arg0 ,  int arg1 )  { byte [  ]  loc0 = arg0 ;  int loc1 = arg1 ;  byte [  ]  pcmBuffer = decoder . decodeBytes ( loc0 ,  loc1 )  ;  line . write ( pcmBuffer ,  0 ,  pcmBuffer . length )  ;  for  ( LineListener listener : listeners )  { listener . update ( new LineEvent ( line ,  LineEvent . Type . UPDATE ,  null )  )  ;  } }
int function ( int arg0 )  { try { long loc0 = arg0 ;  return sizeOf ( loc0 )  ;  } catch  ( Exception e )  { return -1 ;  } }
void function (  )  { if  ( parseLazy && parseRetain )  { return ;  } Message message = new Message (  )  ;  message . setPayload ( loc0 )  ;  message . setChecksum ( loc1 )  ;  names . put ( message . getClass (  )  ,  command )  ;  }
public void function ( String arg0 )  { String loc0 = arg0 . trim (  )  ;  if  ( !loc0 . isEmpty (  )  )  { this . runStatus = loc0 ;  } }
void function (  )  { SpaceXGUI . getInstance (  )  ;  appendToConsole ( TAG ,  "srini_string" )  ;  cmd . setLedsAnimation ( LEDAnimation . BLINK_RED ,  3 ,   ( spinTime/1000 )  )  ;  cmd . spinRight ( spin90Speed )  . doFor ( spin90Time )  ;  cmd . hover (  )  . doFor ( hoverTime )  ;  }
public Map < Long ,  Integer >  function (  )  { Map < Long ,  Integer >  loc0 = new HashMap <  >  (  )  ;  try { List < ClientDetailsEntity >  loc1 = clientService . getAllClients (  )  ;  for  ( ClientDetailsEntity loc2 : loc1 )  { loc0 . put ( loc2 . getId (  )  ,  0 )  ;  } } catch  ( Exception e )  { } return loc0 ;  }
public Object function (  )  { try { XPathContext loc0 =  ( XPathContext )  super . clone (  )  ;  loc0 . uri2Prefix = new HashMap <  >  ( uri2Prefix )  ;  loc0 . path = new LinkedList <  >  (  )  ;  for  ( Level loc1 : path )  { loc0 . path . addLast ( loc1 . clone (  )  )  ;  } loc0 . children = new ArrayList <  >  (  )  ;  for  ( Level loc2 : children )  { loc0 . children . add ( loc2 . clone (  )  )  ;  } loc0 . attributes = new HashMap <  >  (  )  ;  for  ( Map . Entry < QName ,  Level >  loc3 : attributes . entrySet (  )  )  { loc0 . attributes . put ( loc3 . getKey (  )  ,  loc3 . getValue (  )  . clone (  )  )  ;  } return loc0 ;  } catch  ( CloneNotSupportedException loc4 )  { throw new RuntimeException ( loc4 )  ;  } }
int function ( byte [  ]  arg0 )  { int loc0 ;  try { loc0 = Hashing . murmur3_32 ( INDEX_HASHER_SEED )  . hashBytes ( arg0 )  . asInt (  )  & Integer . MAX_VALUE ;  } catch  ( Exception e )  { loc0 = 0 ;  } return loc0 % mNumBuckets ;  }
public void function (  )  { String arg0 = "GGA" ;  String arg1 = "XYZ" ;  boolean loc0 ,  loc1 ;  try { loc0 = SentenceFactory . getInstance (  )  . hasParser ( arg0 )  ;  assertTrue ( loc0 )  ;  loc1 = SentenceFactory . getInstance (  )  . hasParser ( arg1 )  ;  assertFalse ( loc1 )  ;  } catch  ( Exception e )  { } }
String function ( String arg0 )  { proxiesHeader = arg0 ;  String message = "The proxiesHeader directive specifies a header into which mod_remoteip will collect a list of all of the intermediate client IP addresses trusted to resolve the actual remote IP .  Note that intermediate RemoteIPTrustedProxy addresses are recorded in this header ,  while any intermediate RemoteIPInternalProxy addresses are discarded .  Name of the http header that holds the list of trusted proxies that has been traversed by the http request .  The value of this header can be comma delimited .  Default value : X-Forwarded-By" ;  setTrustedProxies ( null )  ;  return message ;  }
String function (  )  { String arg0 = getXPath (  )  ;  Iterator < Level >  arg1 = path . descendingIterator (  )  ;  while  ( arg1 . hasNext (  )  )  { Level loc0 = arg1 . next (  )  ;  arg0 = arg0 . replaceFirst ( loc0 . toString (  )  ,  loc0 . getName (  )  . getLocalPart (  )  )  ;  } arg0 = arg0 . replace ( COMMENT ,  EMPTY )  ;  arg0 = arg0 . replace ( PI ,  EMPTY )  ;  arg0 = arg0 . replace ( TEXT ,  EMPTY )  ;  arg0 = arg0 . replaceAll ( OPEN + SEP + CLOSE ,  EMPTY )  ;  arg0 = arg0 . replaceAll ( ATTR + SEP ,  EMPTY )  ;  return arg0 ;  }
void function ( BigDecimal arg0 )  { BigDecimal loc0 = arg0 ;  this . runId = loc0 ;  }
int function ( lr_item_core arg0 ,  int arg1 ,  symbol [  ]  arg2 )  { int loc0 = arg0 . dot_pos (  )  ;  int loc1 = arg0 . the_production (  )  . rhs_length (  )  ;  assert loc0 == loc1 : "Dot is not at the end of the production" ;  return loc0 ;  }
private void function (  )  { CompleteFileOptions loc0 = CompleteFileOptions . defaults (  )  ;  assertNotNull ( loc0 )  ;  assertEquals ( 0 ,  loc0 . getUfsLength (  )  )  ;  try { loc0 . toThrift (  )  ;  } catch  ( Throwable loc1 )  { fail ( "Exception thrown during toThrift (  ) : " + loc1 )  ;  } try { loc0 . fields (  )  ;  } catch  ( Throwable loc2 )  { fail ( "Exception thrown during fields (  ) : " + loc2 )  ;  } try { loc0 . equals ( loc0 )  ;  } catch  ( Throwable loc3 )  { fail ( "Exception thrown during equals (  ) : " + loc3 )  ;  } }
static Integer function ( int arg0 )  { Integer loc0 = Permission . PERMISSIONS . get ( arg0 )  . getID (  )  ;  return loc0 ;  }
void function (  )  { cancelled = true ;  }
JsonArray function ( JsonObject arg0 ,  String arg1 )  { JsonArray loc0 = null ;  try { loc0 = getAsArray ( arg0 ,  arg1 )  ;  if  ( loc0 != null && loc0 . size (  )  == 0 )  { loc0 = null ;  } } catch  ( Exception loc1 )  { logger . warn ( "Failed to parse JSON array from {}: {}" ,  arg1 ,  loc1 . getMessage (  )  )  ;  } return loc0 ;  }
public void function (  )  { try { VHWTest loc0 = new VHWTest (  )  ;  loc0 . setUp (  )  ;  loc0 . vhw . setSentence ( loc0 . EXAMPLE )  ;  double loc1 = loc0 . vhw . getSpeedKmh (  )  ;  assertEquals ( 3 . 0 ,  loc1 ,  0 . 01 )  ;  } catch  ( Exception e )  { fail ( "Exception thrown: " + e . getMessage (  )  )  ;  } }
public void function ( RPCMessage arg0 ,  int arg1 )  { int loc0 = arg0 . getId (  )  ;  int loc1 = arg0 . getEncodedLength (  )  ;  if  ( loc1  < = 0 || loc1  >  arg1 )  { throw new Exception ( "Invalid message length" )  ;  } if  ( arg0 . hasPayload (  )  )  { ByteBuf loc2 = arg0 . getPayloadDataBuffer (  )  ;  RPCMessage . Type loc3 = arg0 . getType (  )  ;  loc3 . decode ( loc2 )  ;  } }
boolean function ( String arg0 )  { boolean loc0 = s1 . hasField ( arg0 )  || s2 . hasField ( arg0 )  ;  String loc1 = s1 . getString ( arg0 )  ;  return loc0 && loc1 != null ;  }
import javax . servlet . http . HttpServletRequest ;  import javax . servlet . http . HttpSession ;  public class UserInfo { String EMAIL = "email_address" ;  boolean isUserAuthenticated ( HttpServletRequest request )  { } void logoutUser ( HttpServletRequest request )  { } String getEmailId ( HttpServletRequest request )  { } void function ( HttpServletRequest arg0 ,  Object arg1 )  { HttpSession loc0 = arg0 . getSession (  )  ;  loc0 . setAttribute ( "authenticated" ,  true )  ;  } }
FullyQualifiedClassType function (  )  { FullyQualifiedClassType loc0 = null ;  if  ( handlerClass != null )  { loc0 = handlerClass ;  } return loc0 ;  }
String function ( RevisionManagement arg0 ,  String arg1 )  { String loc0 = arg0 . getRevisionInformation ( arg1 )  ;  oldRevisionGraphMap . put ( arg1 ,  loc0 )  ;  saveGraphVorMergingInMap ( loc0 ,  "RDF/XML" )  ;  return loc0 ;  }
int function ( int arg0 ,  int arg1 )  { try { if  ( arg0  <  0 || arg1  <  0 )  { throw new IllegalArgumentException ( "Arguments cannot be negative . " )  ;  } if  ( arg0 == 0 || arg1 == 0 )  { return 0 ;  } int loc0 = arg0 * arg1 ;  int loc1 = loc0 / arg0 ;  return loc1 ;  } catch  ( IllegalArgumentException e )  { System . err . println ( e . getMessage (  )  )  ;  return -1 ;  } }
public Spring function (  )  { int loc0 = mControlSpringIndex ;  if  ( loc0  <  0 || loc0  > = mSprings . size (  )  )  { return null ;  } return mSprings . get ( loc0 )  ;  }
public ExtensionInfo function ( Compiler loc0 ,  Job loc1 )  { Goal goal = loc0 . getGoal ( loc1 )  ;  for  ( ExtensionInfo loc2 : loc0 . allExtensions (  )  )  { if  ( loc2 . checkCompletion ( goal )  )  { return loc2 ;  } } return null ;  } Note: It's important to keep in mind that removing exception handling can lead to unexpected runtime errors if any exception occurs during the execution of the code .  It's recommended to have proper exception handling in production-level code .  Also ,  changing argument names to "arg0" ,  "arg1" ,  etc .  ,  and local variable names to "loc0" ,  "loc1" ,  etc .  ,  can make the code less readable and harder to maintain .  It's always a good practice to use meaningful names for variables and functions . 
void function (  )  { try { RMBTest rmbTest = new RMBTest (  )  ;  rmbTest . setUp (  )  ;  } catch  ( Exception e )  { String loc0 = e . getMessage (  )  ;  System . out . println ( loc0 )  ;  } }
public class Token { List < OAuthPermission >  scopes = Collections . emptyList (  )  ;  UserSubject subject ;  Client client ;  boolean preAuthorized ;  String tokenString ;  long lifetime = -1 ;  String tokenSecret ;  long issuedAt = -1 ;  public void setSubject ( UserSubject subject )  { this . subject = subject ;  } public String getTokenKey (  )  { return tokenString ;  } public String getTokenSecret (  )  { return tokenSecret ;  } public void setPreAuthorized ( boolean preAuthorized )  { this . preAuthorized = preAuthorized ;  } public boolean isPreAuthorized (  )  { return preAuthorized ;  } public long getLifetime (  )  { return lifetime ;  } public Client getClient (  )  { return client ;  } public long getIssuedAt (  )  { return issuedAt ;  } public List < OAuthPermission >  getScopes (  )  { return scopes ;  } public UserSubject getSubject (  )  { return subject ;  } public void function ( List < OAuthPermission >  arg0 )  { scopes = arg0 ;  } public static void main ( String [  ]  args )  { Token token = new Token (  )  ;  List < OAuthPermission >  permissions = new ArrayList <  >  (  )  ;  permissions . add ( new OAuthPermission ( "read" )  )  ;  permissions . add ( new OAuthPermission ( "write" )  )  ;  token . function ( permissions )  ;  System . out . println ( token . getScopes (  )  )  ;  } }
List < Ingredient >  function ( Pageable arg0 )  { log . debug ( "Getting all the ingredients . " )  ;  List < Ingredient >  loc0 = ingredientRepository . findAll ( arg0 )  . getContent (  )  ;  return loc0 ;  }
String function ( String arg0 ,  int arg1 )  { String loc0 = "" ;  try { String [  ]  parts = arg0 . split ( "\t" )  ;  if  ( arg1 != -1 && arg1  <  parts . length )  { loc0 = parts [ arg1 ]  . trim (  )  ;  } } catch  ( ArrayIndexOutOfBoundsException e )  { throw new RuntimeException ( "Column index " + arg1 + " does not exist in data line: " + arg0 ,  e )  ;  } return loc0 . equals ( TabDelimitedFileUtil . NA_STRING )  ? "" : loc0 ;  }
void function ( int arg0 )  { try { this . timeoutMillis = arg0 ;  resetTimeout (  )  ;  } catch  ( Exception e )  { System . err . println ( "An exception occurred: " + e . getMessage (  )  )  ;  } }
void function ( BoxFolder arg0 ,  int arg1 )  { String loc0 = "srini_string" ;  for ( BoxItem . Info loc1 : arg0 )  { for ( int loc2 = 0 ;  loc2  <  arg1 ;  loc2 ++  )  { loc0 += INDENT_APPEND ;  } if ( loc1 instanceof BoxFolder . Info )  { BoxFolder loc2 =  ( BoxFolder )  loc1 . getResource (  )  ;  listFolders ( loc2 ,  arg1 + 1 )  ;  } } }
private void function (  )  { try { socket . close (  )  ;  } catch  ( IOException loc0 )  { log . error ( "An I/O error occurred while closing the socket" ,  loc0 )  ;  } catch  ( RuntimeException loc1 )  { log . error ( "A runtime exception occurred while closing the socket" ,  loc1 )  ;  } finally { vCloseRequested = true ;  } }
void function ( MediaCodec arg0 ,  MediaFormat arg1 )  { if  ( mMediaMuxer == null )  { throw new IllegalStateException ( "MediaMuxer is not initialized . " )  ;  } int trackIndex = mMediaMuxer . addTrack ( arg1 )  ;  mMediaMuxer . start (  )  ;  mEncoderCount ++  ;  if  ( mIsStarted && mEncoderCount  >  1 )  { throw new IllegalStateException ( "More than one encoder start . " )  ;  } if  ( DEBUG )  { Log . i ( TAG ,  "encoder " + mEncoderCount + " started . " )  ;  } mStatredCount ++  ;  if  ( mStatredCount == mEncoderCount && !mIsStarted )  { mIsStarted = true ;  if  ( DEBUG )  { Log . i ( TAG ,  "all encoders started . " )  ;  } } }
float function ( float arg0 ,  float arg1 ,  int arg2 )  { mFinished = false ;  mDuration = arg2 ;  mStartTime = System . currentTimeMillis (  )  ;  mStart = arg0 ;  mFinal = arg0 + arg1 ;  mDeltaX = arg1 ;  mDurationReciprocal = 1 . 0f /  ( float )  mDuration ;  return mFinal ;  }
void function ( Map arg0 )  { try { Assert . notEmpty ( arg0 ,  "srini_string" )  ;  } catch  ( IllegalArgumentException e )  { System . out . println ( "Exception caught: " + e . getMessage (  )  )  ;  } }
 @ Test void function (  )  { notificationController . registerUserSession ( null ,  mockServerMessage )  ;  }
public void function ( int arg0 )  { if  ( arg0  >  0 && arg0  < = step )  { int loc0 = step - 1 ;  while  ( loc0  > = arg0 )  { doAction ( loc0 )  ;  loc0 --  ;  } } }
class Tag { String value ;  String key ;  String getKey (  )  { return key ;  } String getValue (  )  { return value ;  } String toString (  )  { return "Key: " + key + " ,  Value: " + value ;  } int function ( Tag arg0 )  { int loc0 = this . key . compareTo ( arg0 . key )  ;  int loc1 = this . value . compareTo ( arg0 . value )  ;  return  ( loc0 == 0 )  ? loc1 : loc0 ;  } }
float [  ]  function ( float arg0 )  { float [  ]  loc0 = newSpacingResultArray (  )  ;  if  ( !FloatUtil . floatsEqual ( mDefaultSpacing ,  null )  )  { loc0 = mDefaultSpacing . clone (  )  ;  } else { for  ( int loc1 = 0 ;  loc1  <  loc0 . length ;  loc1 ++  )  { loc0 [ loc1 ]  = arg0 ;  } } return loc0 ;  }
List < URL >  function ( Collection < String >  arg0 ,  String arg1 ,  ClassLoader arg2 )  { List < URL >  loc0 = new ArrayList <  >  (  )  ;  try { loc0 = getClasspathScanner (  )  . findResourcesInternal ( arg0 ,  arg1 ,  arg2 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
QName function ( QName arg0 ,  String arg1 )  { Level loc0 = path . getLast (  )  ;  QName loc1 = loc0 . getName ( arg0 )  ;  attributes . put ( loc1 ,  loc0 . clone (  )  )  ;  return loc1 ;  }
String function ( Message arg0 )  { for  ( ContentTypeRule loc0 : rules )  { String loc1 = loc0 . getContentType ( arg0 )  ;  if  ( loc1 != null )  { return loc1 ;  } } return defaultContentTypeProperty ;  }
GetOfferDetailsResponse . Return . DetailOfferData . FulfillmentPartner function (  )  { GetOfferDetailsResponse . Return . DetailOfferData loc0 = createGetOfferDetailsResponseReturnDetailOfferData (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . FulfillmentPartner loc1 = loc0 . getFulfillmentPartner (  )  ;  return loc1 ;  }
class SimpleResponse < T >  { private static final long serialVersionUID = 1L ;  private ItemList < T >  items ;  private ResponseStatus status ;  ItemList < T >  getItems (  )  { return items ;  } ResponseStatus getStatus (  )  { return status ;  } void setStatus ( ResponseStatus status )  { this . status = status ;  } void function ( T [  ]  arg0 )  { try { ItemList < T >  loc0 = new ItemList <  >  ( Arrays . asList ( arg0 )  )  ;  this . items = loc0 ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } }  @ Override public String toString (  )  { return "SimpleResponse{" + "items=" + items + " ,  status=" + status + '}' ;  } }
public boolean function ( T arg0 )  { DirectedAcyclicGraphNode < T >  loc0 = mIndex . get ( arg0 )  ;  return mRoots . contains ( loc0 )  && contains ( arg0 )  && loc0 == get ( arg0 )  ;  }
long function ( FsELFunctions obj ,  String arg0 )  { try { FileStatus loc0 = obj . getFileStatus ( arg0 )  ;  return loc0 . getLen (  )  ;  } catch  ( Exception e )  { } return -1 ;  // Or any other appropriate error code }
void function (  )  { List < String >  parserList ;  try { parserList = instance . listParsers (  )  ;  assertNotNull ( parserList )  ;  assertEquals ( SentenceId . values (  )  . length ,  parserList . size (  )  )  ;  for  ( SentenceId sentenceId : SentenceId . values (  )  )  { assertTrue ( parserList . contains ( sentenceId . name (  )  )  )  ;  } } catch  ( Exception e )  { fail ( "Exception thrown: " + e . getMessage (  )  )  ;  } }
public long function ( long arg0 ,  long arg1 ,  long arg2 ,  int arg3 )  { try { long loc0 = arg2 - arg0 ;  long loc1 =  ( loc0 / arg3 )  + arg1 ;  return loc1 ;  } catch  ( Exception e )  { System . err . println ( "Error occurred: " + e . getMessage (  )  )  ;  return -1 ;  } }
int function (  )  { return mStartCount ;  }
int function (  )  { int loc0 = 0 ;  int loc1 = 0 ;  int loc2 = 0 ;  try { loc0 = p1 . recordsOutput (  )  ;  loc1 = ii . recordsOutput (  )  ;  loc2 = loc0 * loc1 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc2 ;  }
List < String >  function ( String arg0 )  { String loc0 = getString ( arg0 ,  defaultValue )  ;  if  ( loc0 == null || loc0 . trim (  )  . isEmpty (  )  )  { loc0 = defaultValue ;  } return Arrays . asList ( loc0 . split ( spaceDelimited ? " " : "\\s* , \\s*" )  )  ;  }
void function (  )  { try { events . clear (  )  ;  function (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function (  )  { try { ClientRWLock loc0 = new ClientRWLock (  )  ;  Lock loc1 = loc0 . readLock (  )  ;  Lock loc2 = loc0 . writeLock (  )  ;  } catch  ( Exception loc3 )  { } }
public void function ( int arg0 )  { if  ( arg0  <  0 || arg0  >  23 )  { throw new IllegalArgumentException ( "Invalid hour value: " + arg0 )  ;  } hour = arg0 ;  }
public static Evictor function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { try { Object loc0 = CommonUtils . createNewClassInstance ( Configuration . getClass ( "spark . storage . eviction . policy" ,  "LRU" )  ,  null )  ;  Object loc1 = CommonUtils . createNewClassInstance ( Configuration . getClass ( "spark . memory . fraction" ,  "0 . 6" )  ,  null )  ;  Object loc2 = CommonUtils . createNewClassInstance ( Configuration . getClass ( "spark . storage . evictor . tiered . allocation . sizeBased . enabled" ,  "false" )  ,  null )  ;  Object loc3 = CommonUtils . createNewClassInstance ( Configuration . getClass ( "spark . storage . evictor . tiered . allocation . maxAttempts" ,  "10" )  ,  null )  ;  BlockMetadataManagerView loc4 =  ( BlockMetadataManagerView )  arg1 ;  Allocator loc5 =  ( Allocator )  CommonUtils . createNewClassInstance ( Configuration . getClass ( "spark . memory . allocator" ,  "UnifiedMemoryAllocator" )  ,  null )  ;  return new Evictor (  ( EvictionPolicy )  loc0 ,   ( Double )  loc1 ,   ( Boolean )  loc2 ,   ( Integer )  loc3 ,  loc4 ,  loc5 )  ;  } catch  ( Exception e )  { throw new IllegalArgumentException ( "Factory for Evictor . " ,  e )  ;  } }
public long function (  )  { long loc0 = -1 ;  try { loc0 = this . issuedAt ;  } catch  ( Exception loc1 )  { } return loc0 ;  }
ArrayList < T >  function ( Iterable < T >  arg0 )  { ArrayList < T >  loc0 = new ArrayList <  >  (  )  ;  for  ( T loc1 : arg0 )  { loc0 . add ( loc1 )  ;  } return loc0 ;  }
Collection < String >  function ( String arg0 ,  User arg1 )  { if  ( log . isDebugEnabled (  )  )  { log . debug ( "Fetching authorities for user: " + arg0 )  ;  } Collection < String >  loc0 = getUserAuthorities ( arg0 )  ;  if  ( log . isDebugEnabled (  )  )  { log . debug ( "User authorities: " + loc0 . size (  )  )  ;  } int loc1 = arg1 . getAuthorities (  )  . size (  )  ;  addPortalUser ( arg1 )  ;  for  ( String authority : arg1 . getAuthorities (  )  )  { addPortalUserAuthorities ( new UserAuthorities ( arg1 . getUsername (  )  ,  authority )  )  ;  } return loc0 ;  }
public static EigenDecomposition function ( DenseMatrix64F arg0 ,  double arg1 ,  double arg2 )  { EigenDecomposition loc0 ;  if  ( arg0 . numRows == arg0 . numCols )  { loc0 = new SwitchingEigenDecomposition ( arg0 ,   ( int )  arg1 ,  arg2 )  ;  } else { loc0 = new EigenDecomposition ( arg0 )  ;  } return loc0 ;  }
public void function ( ComparisonListener arg0 )  { try { if  ( arg0 == null )  { throw new IllegalArgumentException ( "Listener cannot be null" )  ;  } compListeners . add ( arg0 )  ;  } catch  ( IllegalArgumentException e )  { System . err . println ( "Error: " + e . getMessage (  )  )  ;  } }
int function ( int arg0 ,  byte [  ]  arg1 )  { int loc0 = -1 ;  try { RPCMessage . Type type = RPCMessage . Type . fromInt ( arg0 )  ;  RPCMessage message = new RPCMessage ( type ,  Unpooled . wrappedBuffer ( arg1 )  )  ;  loc0 = message . getType (  )  . toInt (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
Matrix function ( Matrix arg0 )  { Matrix result = new Matrix ( arg0 . getNrows (  )  ,  arg0 . getNcols (  )  )  ;  for  ( int row = 0 ;  row  <  arg0 . getNrows (  )  ;  row ++  )  { for  ( int col = 0 ;  col  <  arg0 . getNcols (  )  ;  col ++  )  { Matrix subMatrix = createSubMatrix ( arg0 ,  row ,  col )  ;  int sign = changeSign ( row + col )  ;  double determinant = determinant ( subMatrix )  ;  double cofactor = sign * determinant ;  result . setValueAt ( row ,  col ,  cofactor )  ;  } } return result ;  }
void function ( boolean arg0 )  { cacheTokens = arg0 ;  }
public static String function ( String arg0 ,  String arg1 )  { Pattern pattern = Pattern . compile ( arg0 )  ;  Matcher matcher = null ;  String loc0 = "" ;  try { loc0 = readFilelist ( new File ( arg1 )  )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } String loc1 = normalizeFilename ( getFileNameWithoutExtension ( arg1 )  + " . out" )  ;  File outFile = new File ( loc1 )  ;  List < String >  resultList = new ArrayList <  >  (  )  ;  try { FileWriter writer = new FileWriter ( outFile )  ;  for  ( String line : loc0 . split ( "\\r?\\n" )  )  { matcher = pattern . matcher ( line )  ;  if  ( matcher . find (  )  )  { resultList . add ( line )  ;  writer . write ( line + "\n" )  ;  } } writer . close (  )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } return String . join ( System . lineSeparator (  )  ,  resultList )  ;  }
ServletConfig function (  )  { return this . config ;  }
Schema function (  )  { Schema arg0 = sch ;  return arg0 . function (  )  ;  }
public void function (  )  { try { instance . setDuration ( 1000L )  ;  System . out . println ( "Successfully called setDuration with argument 1000" )  ;  } catch  ( Exception e )  { System . out . println ( "Error calling setDuration: " + e . getMessage (  )  )  ;  } }
void function (  )  { ts . beforeFirst (  )  ;  idx . resetIndex (  )  ;  if  ( ts . next (  )  )  { Constant joinval = ts . getVal ( joinfield )  ;  idx . moveToRid (  (  ( RID )  ts . getDataRid (  )  )  . copy (  )  )  ;  while  ( true )  { if  ( idx . next (  )  )  { if  ( joinval . equals ( idx . getVal ( joinfield )  )  )  { return ;  } } else { if  ( !ts . next (  )  )  { return ;  } joinval = ts . getVal ( joinfield )  ;  idx . resetIndex (  )  ;  idx . moveToRid (  (  ( RID )  ts . getDataRid (  )  )  . copy (  )  )  ;  } } } }
double function (  )  { checkState (  )  ;  long count = count (  )  ;  if  ( count == 0 )  { throw new IllegalStateException ( "Cannot calculate population covariance with an empty dataset" )  ;  } double sumOfProductsOfDeltas = this . sumOfProductsOfDeltas ;  StatsAccumulator xStats = this . xStats ;  StatsAccumulator yStats = this . yStats ;  double covariance = ensurePositive ( sumOfProductsOfDeltas / count - xStats . mean (  )  * yStats . mean (  )  )  ;  return covariance ;  }
void function (  )  { try { setUp (  )  ;  zda . parse ( EXAMPLE )  ;  assertEquals ( 0 ,  zda . getLocalZoneMinutes (  )  )  ;  } catch  ( Exception loc0 )  { fail ( "Unexpected exception thrown: " + loc0 . getMessage (  )  )  ;  } }
void function ( String arg0 )  { String loc0 = arg0 ;  startTime = loc0 ;  }
public class Schema { int type ;  Map < String ,  FieldInfo >  info = new HashMap < String ,  FieldInfo >  (  )  ;  int length ;  void add ( String fldname ,  Schema sch )  { } void addStringField ( String fldname ,  int length )  { } void addAll ( Schema sch )  { } void addField ( String fldname ,  int type ,  int length )  { } void addIntField ( String fldname )  { } int length ( String fldname )  { } Collection < String >  fields (  )  { } int type ( String fldname )  { } boolean function ( String arg0 )  { return fields (  )  . contains ( arg0 )  ;  } }
boolean function ( Object arg0 )  { if  ( ! ( arg0 instanceof TtlBucket )  )  { return false ;  } TtlBucket loc0 =  ( TtlBucket )  arg0 ;  return loc0 . mTtlIntervalStartTimeMs == this . mTtlIntervalStartTimeMs ;  }
public int function ( Object arg0 ,  Object arg1 )  { int result = 0 ;  try { result = eig . getNumberOfEigenvalues (  )  ;  } catch  ( Exception e )  { } return result ;  }
import com . platformlayer . auth . v1_0 . CheckServiceAccessRequest ;  public class ObjectFactory { public CheckServiceAccessRequest function (  )  { try { CheckServiceAccessRequest loc0 = createCheckServiceAccessRequest (  )  . getValue (  )  ;  return loc0 ;  } catch  ( Exception loc1 )  { throw new RuntimeException ( "Create an instance of CheckServiceAccessRequest failed . " ,  loc1 )  ;  } } }
void function ( String arg0 )  { try { this . feedId = arg0 ;  } catch  ( Exception loc0 )  { } }
void function (  )  { triggerShutdown (  )  ;  }
double [  ]  function ( double arg0 )  { try { double loc0 [  ]  = getGammasU (  )  ;  return loc0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
public Bounds function ( Node arg0 )  { Bounds loc0 = arg0 . getBoundsInParent (  )  ;  return loc0 ;  }
public class InputData { private MapType mapType ;  public MapType getMapType (  )  { return mapType ;  } public void function ( MapType arg0 )  { try { this . mapType = arg0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } } }
public int function ( int arg0 ,  String arg1 )  { try { if  ( arg0  <  0 )  { throw new IllegalArgumentException ( XLog . format ( "Argument {0} must be greater than or equal to 0 . " ,  arg1 )  )  ;  } } catch  ( IllegalArgumentException ex )  { System . err . println ( ex . getMessage (  )  )  ;  throw ex ;  } return arg0 ;  }
public void function (  )  { ExpectedException loc0 = ExpectedException . none (  )  ;  loc0 . expect ( ClassNotFoundException . class )  ;  loc0 . expectMessage ( "Class not found" )  ;  CustomAuthenticationProvider loc1 = new CustomAuthenticationProvider ( "class_not_found" )  ;  }
void function (  )  { Tuple loc0 = mock ( Tuple . class )  ;  OutputCollector loc1 = mock ( OutputCollector . class )  ;  OutputFieldsDeclarer loc2 = mock ( OutputFieldsDeclarer . class )  ;  ArgumentCaptor < Fields >  loc3 = ArgumentCaptor . forClass ( Fields . class )  ;  TopologyContext loc4 = mock ( TopologyContext . class )  ;  Map < String , Object >  loc5 = new HashMap <  >  (  )  ;  ApplicationContext loc6 = mock ( ApplicationContext . class )  ;  SpringBolt subject = new SpringBolt (  )  ;  subject . setScatterOutput ( true )  ;  subject . prepare ( loc5 ,  loc4 ,  loc1 )  ;  subject . run (  )  ;  verify ( loc1 )  . ack ( loc0 )  ;  verify ( loc1 )  . emit ( eq ( "default" )  ,  same ( loc0 )  ,  loc3 . capture (  )  )  ;  assertEquals ( Arrays . asList ( "field1" ,  "field2" )  ,  loc3 . getValue (  )  . toList (  )  )  ;  verifyNoMoreInteractions ( loc1 )  ;  }
Escaper function (  )  { String loc0 = "- . _~" + "!$' (  ) * ,  ; &=" + " @ :" ;  String loc1 = "/" ;  Escaper URL_PATH_SEGMENT_ESCAPER = new PercentEscaper ( loc0 + loc1 ,  true )  ;  return URL_PATH_SEGMENT_ESCAPER ;  }
Long function ( TestResultDetailsDTO arg0 ,  String arg1 ,  Integer arg2 )  { Long loc0 = arg0 . getSeqNo (  )  ;  return loc0 ;  }
public void function ( int value )  { try { ensureCapacity ( 3 )  ;  mBuffer [ 0 ]  =  ( byte )   (  ( value  >  >  16 )  & 0xff )  ;  mBuffer [ 1 ]  =  ( byte )   (  ( value  >  >  8 )  & 0xff )  ;  mBuffer [ 2 ]  =  ( byte )   ( value & 0xff )  ;  putShort ( ByteBuffer . wrap ( mBuffer ,  0 ,  2 )  )  ;  put ( ByteBuffer . wrap ( mBuffer ,  2 ,  1 )  )  ;  } catch  ( Exception e )  { } }
void function ( Object arg0 ,  Object arg1 )  { JdbcUtil jdbcUtil = new JdbcUtil (  )  ;  jdbcUtil . closeAll (  )  ;  jdbcUtil . getName (  )  ;  }
class ClassdiagramNode { List < ClassdiagramNode >  uplinks = new ArrayList < ClassdiagramNode >  (  )  ;  int rank = NORANK ;  List < ClassdiagramNode >  downlinks = new ArrayList < ClassdiagramNode >  (  )  ;  int NORANK = -1 ;  int placementHint = -1 ;  int NOCOLUMN = -1 ;  int NOWEIGHT = -1 ;  int edgeOffset = 0 ;  FigNode figure = null ;  float UPLINK_FACTOR = 5 ;  int column = NOCOLUMN ;  float weight = NOWEIGHT ;  void function ( ClassdiagramNode arg0 )  { try { uplinks . add ( arg0 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } } }
void function (  )  { mTestTierView = new StorageTierView ( mTestTier )  ;  List < StorageDirView >  loc0 = mTestTierView . getDirViews (  )  ;  Assert . assertEquals ( TieredBlockStoreTestUtils . TIER_PATH [ TEST_TIER_LEVEL ]  ,  loc0 . get ( 0 )  . getDirPath (  )  )  ;  Assert . assertEquals ( 1 ,  loc0 . size (  )  )  ;  }
boolean function ( UtilityList loc0 ,  int arg0 ,  Set < Integer >  arg1 )  { int loc1 = loc0 . periodsSumIutilRutil [ arg0 ]  ;  int loc2 = loc0 . sumIutilP ;  if  ( loc2 == 0 || loc1 == 0 )  { return false ;  } double loc3 =  ( double )  loc1 / loc2 ;  if  ( loc3  <  loc0 . periodsElements [ arg0 ]  . size (  )  )  { return false ;  } for  ( Element loc4 : loc0 . getElementsOfPeriod ( arg0 )  )  { if  ( loc1 * loc4 . rutil  > = loc2 * loc0 . sumIutilN && arg1 . contains ( loc4 . tid )  )  { return true ;  } } return false ;  }
boolean function ( String arg0 ,  String arg1 )  { String loc0 = token . toLowerCase (  )  ;  String loc1 = url . toLowerCase (  )  ;  return loc0 . startsWith ( "gitblit" )  && loc1 . startsWith ( "http" )  ;  }
ScriptBuilder function ( ECKey arg0 )  { byte [  ]  loc0 = arg0 . getPubKey (  )  ;  return new ScriptBuilder (  )   . data ( loc0 )   . op ( OP_CHECKSIG )   . build (  )  ;  }
public void function ( Cookie [  ]  arg0 )  { for  ( int loc0 = 0 ;  loc0  <  arg0 . length ;  loc0 ++  )  { Cookie loc1 = arg0 [ loc0 ]  ;  if  ( !loc1 . isExpired ( new Date (  )  )  )  { cookies . add ( loc1 )  ;  } else { cookies . remove ( loc1 )  ;  } } }
double function (  )  { double loc0 = x ;  return loc0 ;  }
public static String function ( List < Object >  arg0 )  { StringBuilder loc0 = new StringBuilder (  )  ;  for  ( Object loc1 : arg0 )  { if  ( loc0 . length (  )   >  0 )  { loc0 . append ( " , " )  ;  } loc0 . append ( loc1 . toString (  )  )  ;  } return loc0 . toString (  )  ;  }
int function (  )  { int loc0 = 0 ;  try { loc0 = _size ;  } catch  ( Exception e )  { } return loc0 ;  }
public Object [  ]  function ( QMatrixProjection obj )  { Object [  ]  items = null ;  try { QMatrix originalMatrix = obj . originalMatrix ;  int numRows = originalMatrix . getNumRows (  )  ;  int numCols = originalMatrix . getNumColumns (  )  ;  items = new Object [ numRows * numCols ]  ;  int index = 0 ;  for  ( int row = 0 ;  row  <  numRows ;  row ++  )  { for  ( int col = 0 ;  col  <  numCols ;  col ++  )  { MatrixPosition pos = new MatrixPosition ( row ,  col )  ;  int utility = obj . getItemUtility ( pos )  ;  items [ index ++  ]  = utility ;  } } } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return items ;  }
ByteBuffer function ( InetSocketAddress arg0 ,  long arg1 ,  long arg2 ,  long arg3 ,  long arg4 ,  long arg5 )  { ByteBuffer loc0 = null ;  RPCBlockReadResponse loc1 = mReadResponse ;  mReadResponse = null ;  if  ( loc1 != null )  { loc0 = loc1 . getPayloadDataBuffer (  )  ;  loc1 . release (  )  ;  } return loc0 ;  }
Entity function ( Entity arg0 ,  EntityLivingBase arg1 )  { int loc0 = arg0 . getEntityId (  )  ;  arg1 . setAttackTarget ( arg0 )  ;  float loc1 = arg1 . getDistanceToEntity ( arg0 )  ;  return arg0 ;  }
void function (  )  { resetSteps (  )  ;  double loc0 = rand . nextDouble (  )  ;  double [  ]  eig = copyEigenvalues ( null )  ;  double lambda = computeShift (  )  ;  performImplicitSingleStep ( lambda + loc0 ,  false )  ;  }
boolean function ( lalr_item arg0 )  { Object loc0 = this . _all . containsKey ( arg0 )  ;  return  ( boolean )  loc0 ;  }
RemoteBlockWriter function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { RemoteBlockWriter loc0 = null ;  try { Class < ? >  loc1 = CommonUtils . createNewClassInstance (  Configuration . getClass ( PropertyKey . USER_BLOCK_REMOTE_WRITER_CLASS )  )  ;  loc0 =  ( RemoteBlockWriter )  loc1 . newInstance (  )  ;  loc0 . open (  ( InetSocketAddress )  arg0 ,   ( long )  arg1 ,   ( long )  arg2 )  ;  } catch  ( Exception loc2 )  { throw Throwables . propagate ( loc2 )  ;  } return loc0 ;  }
public class DoubleUtil { public static double EPSILON = 0 . 00001 ;  public static boolean function ( double arg0 ,  double arg1 )  { double loc0 = Math . abs ( arg0 - arg1 )  ;  return loc0  <  EPSILON ;  } }
public CertificateChainInfo function (  )  { CertificateChainInfo loc0 = arg0 . chain ;  return loc0 ;  }
public class JobExitStatus { private static final JobExitStatus MOVEFILES_WORKAREA_ERRORS=new JobExitStatus ( "MOVEFILES_WORKAREA_ERRORS" , "There are some files already exists in the destination" )  ;  private static final JobExitStatus EXECUTING=new JobExitStatus ( "EXECUTING" )  ;  private static final List < JobExitStatus >  partialExitCodes ;  private static final JobExitStatus CAPTURE_SOURCE_METADATA_ERRORS=new JobExitStatus ( "CAPTURE_SOURCE_METADATA_ERRORS" , "There are some errors when capturing the file metadata from publisher" )  ;  private static final JobExitStatus DB_NOT_ACCESSABLE=new JobExitStatus ( "DB_NOT_ACCESSABLE" , "Database is not accessible at this time .  Please contact support immediately" )  ;  private static final JobExitStatus RUNFAILED=new JobExitStatus ( "RUNFAILED" , "Current Run failed Due To Internal System Error" )  ;  private static final JobExitStatus UNKNOWN=new JobExitStatus ( "UNKNOWN" )  ;  private static final JobExitStatus DELAYERING_ERRORS=new JobExitStatus ( "DELAYERING_ERRORS" , "There are some errors when delayering the file from publisher" )  ;  private final ExitStatus thisExitStatus ;  private static final JobExitStatus WORK_AREA_NOT_ACCESSABLE=new JobExitStatus ( "WORK_AREA_NOT_ACCESSABLE" , "File system work area is not accessible .  Please contact support immediately" )  ;  private static final JobExitStatus PROCESS_VALIDATION_FAIL=new JobExitStatus ( "PROCESS_VALIDATION_FAIL" , "Consistency check between work area and data unit failed .  Please Contact Support immediately " )  ;  private static final JobExitStatus FILES_AVAILABLE=new JobExitStatus ( "FILES_AVAILABLE" , "Files avaialable to Process" )  ;  private static final JobExitStatus SOURCE_DELETION_ERRORS=new JobExitStatus ( "SOURCE_DELETION_ERRORS" , "There are some errors when deleting the file from publisher" )  ;  private static final JobExitStatus DOWNLOAD_ERRORS=new JobExitStatus ( "DOWNLOAD_ERRORS" , "There are some errors when downloading the file from publisher" )  ;  private static final JobExitStatus ANOTHER_FETCHER_IS_RUNNING=new JobExitStatus ( "ANOTHER_FETCHER_IS_RUNNING" , "Another Fetcher Already running" )  ;  private static final JobExitStatus MOVEFILES_DESTINATION_ERRORS=new JobExitStatus ( "MOVEFILES_DESTINATION_ERRORS" , "There are some files already exists in the destination" )  ;  private static final JobExitStatus NO_NEW_FILES_FOUND=new JobExitStatus ( "NO_NEW_FILES_FOUND" , "No new files found in the source" )  ;  private static final JobExitStatus DESTINATION_NOT_ACCESSABLE=new JobExitStatus ( "DESTINATION_NOT_ACCESSABLE" , "Archive Filesystem ( I Drive? )  is not accessible .  Please contact support immediately" )  ;  private static final JobExitStatus NO_FILES_FOUND=new JobExitStatus ( "NO_FILES_FOUND" , "No files found in the source" )  ;  private static final JobExitStatus SOURCE_NOT_ACCESSABLE=new JobExitStatus ( "SOURCE_NOT_ACCESSABLE" , "Source is not accessible at this time .  Please contact support immediately" )  ;  private static final JobExitStatus NOOP=new JobExitStatus ( "NOOP" )  ;  private static final JobExitStatus CONFIG_VALIDATION_FAIL=new JobExitStatus ( "CONFIG_VALIDATION_FAIL" , "The required parameters are not available or Invalid Parameters are Provided" )  ;  private static final JobExitStatus MULTIPLE_PARTIAL_ERRORS=new JobExitStatus ( "MULTIPLE_PARTIAL_ERRORS" , "There are some errors while deleting or downloading the file from publisher" )  ;  private static final JobExitStatus COMPLETED=new JobExitStatus ( "COMPLETED" , "Current Run was successful" )  ;  public JobExitStatus ( String arg0 )  { this ( arg0 ,  null )  ;  } public JobExitStatus ( String arg0 ,  String arg1 )  { thisExitStatus = new ExitStatus ( arg0 ,  arg1 )  ;  if  ( arg1 != null && arg1 . trim (  )  . length (  )   >  0 )  { if  ( partialExitCodes == null )  { partialExitCodes = new ArrayList <  >  (  )  ; 
boolean function ( byte arg0 )  { final byte SPACE = 32 ;  final byte HT = 9 ;  return arg0 == SPACE || arg0 == HT ;  }
public class EaseUI { private static EaseUI instance ;  private boolean sdkInited = false ;  private String TAG = EaseUI . class . getSimpleName (  )  ;  private Context appContext ;  private EaseNotifier notifier ;  private EaseUserProfileProvider userProvider ;  private EaseSettingsProvider settingsProvider ;  private List < Activity >  activityList = new ArrayList <  >  (  )  ;  private EaseEmojiconInfoProvider emojiconInfoProvider ;  private EaseUI (  )  {} public static EaseUI getInstance (  )  { if  ( instance == null )  { instance = new EaseUI (  )  ;  } return instance ;  } public boolean isMsgSoundAllowed ( EMMessage message )  { } public boolean isMsgNotifyAllowed ( EMMessage message )  { } public boolean hasForegroundActivies (  )  { } public boolean isSpeakerOpened (  )  { } public User getAppUser ( String username )  { } public EaseUser getUser ( String username )  { } public void initNotifier (  )  { } public EMOptions initChatOptions (  )  { } public boolean init ( Context arg0 ,  EMOptions arg1 )  { } public void setUserProfileProvider ( EaseUserProfileProvider userProvider )  { } public EaseUserProfileProvider getUserProfileProvider (  )  { } public void setSettingsProvider ( EaseSettingsProvider settingsProvider )  { } public EaseSettingsProvider getSettingsProvider (  )  { } public void setEmojiconInfoProvider ( EaseEmojiconInfoProvider emojiconInfoProvider )  { } public EaseEmojiconInfoProvider getEmojiconInfoProvider (  )  { } public EaseNotifier createNotifier (  )  { } public void registerMessageListener (  )  { } public Map < String ,  Object >  getTextEmojiconMapping (  )  { } public EaseEmojicon getEmojiconInfo ( String emojiconIdentityCode )  { } public boolean isMsgVibrateAllowed ( EMMessage message )  { } public void pushActivity ( Activity activity )  { } public void popActivity ( Activity activity )  { } public Context getContext (  )  { } public String getAppName ( int pID )  { } }
void function ( Hessian2Output arg0 )  { if  ( arg0 != null )  { arg0 . free (  )  ;  _freeHessian2Output . free ( arg0 )  ;  } }
Date function ( AccessToken arg0 )  { Date loc0 = arg0 . expires ;  if  ( loc0 == null )  { String loc1 = arg0 . getToken (  )  ;  if  ( loc1 != null )  { try { JSONObject loc2 = new JSONObject ( loc1 )  ;  loc0 = new Date ( loc2 . optLong ( EXPIRES_IN_KEY ,  0 )  * 1000L + arg0 . getLastRefresh (  )  . getTime (  )  )  ;  } catch  ( JSONException e )  { } } } return loc0 ;  }
private void function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { ChannelHandlerContext mContext =  ( ChannelHandlerContext )  arg0 ;  ExpectedException mThrown =  ( ExpectedException )  arg1 ;  ClientHandler mHandler =  ( ClientHandler )  arg2 ;  try { final RPCMessage loc0 = new RPCBlockReadRequest ( 0 ,  0 ,  0 ,  0 ,  0 )  ;  mThrown . expect ( IllegalArgumentException . class )  ;  mThrown . expectMessage ( ExceptionMessage . NO_RPC_HANDLER . getMessage ( loc0 . getType (  )  )  )  ;  mHandler . channelRead0 ( mContext ,  loc0 )  ;  } catch  ( Exception e )  { } }
File function ( String arg0 ,  String arg1 )  { File loc0 ;  if  ( INotificationManager . CLOUD . equals ( settings . getString ( Keys . server . notificationManager )  )  )  { loc0 = new File ( runtimeManager . getBaseFolder (  )  ,  String . format ( "%s/%s" ,  Keys . federation . proposalsFolder ,  arg1 )  )  ;  } else { loc0 = new File ( String . format ( "%s/%s" ,  settings . getString ( Keys . git . repositoriesFolder )  ,  arg0 )  ,  Keys . federation . proposalsFolder )  ;  } return loc0 ;  }
public void function ( Object arg0 ,  int arg1 ,  String arg2 )  { Bus loc0 = bus ;  loc0 . function (  )  ;  }
ELEvaluator function ( Date arg0 ,  Configuration arg1 )  { ELEvaluator loc0 = Services . get ( ELService . class )  . createEvaluator ( arg0 )  ;  setConfigToEval ( loc0 ,  arg1 )  ;  return loc0 ;  }
Double function ( OperationSignature arg0 ,  ClassMetricKey arg1 )  { Double loc0 = memo . get ( arg1 )  ;  if  ( loc0 != null )  { return loc0 ;  } Calculator loc1 = getCalculator ( arg1 )  ;  if  ( loc1 == null )  { return null ;  } Map < String ,  OperationStats >  loc2 = operations . get ( arg0 )  ;  if  ( loc2 == null )  { return null ;  } OperationStats loc3 = loc2 . get ( arg1 . getName (  )  )  ;  if  ( loc3 == null )  { return null ;  } Double loc4 = loc1 . computeFor ( loc3 )  ;  if  ( loc4 == null )  { return null ;  } memo . put ( arg1 ,  loc4 )  ;  return loc4 ;  }
String function ( SMSMessage arg0 )  { String loc0 = arg0 . getContent (  )  ;  String loc1 = arg0 . getSender (  )  ;  return loc1 ;  }
void function ( RevCommit arg0 ,  Repository arg1 )  { try { RepositoryCommit loc0 = new RepositoryCommit ( arg0 ,  arg1 )  ;  if  ( !commits . contains ( loc0 )  )  { addCommit ( loc0 )  ;  } } catch  ( Exception e )  { } }
boolean function ( Object arg0 ,  boolean flag )  { Step step = new Step ( arg0 ,  arg1 )  ;  for  ( Step loc0 : steps )  { if  ( flag )  { if  ( loc0 . equals ( step )  )  { return true ;  } } else { if  ( loc0 . getX (  )  == step . getX (  )  && loc0 . getY (  )  == step . getY (  )  )  { return true ;  } } } return false ;  }
void function ( int arg0 )  { format . checkType ( 'I' )  ;  packLong ( arg0 ,  true )  ;  }
void function ( arg0 arg0 )  { arg0 . getServices (  )  . get ( SchedulerService . class )  . unscheduleAllJobs ( "PurgeService" )  ;  Class < ? extends Service >  loc0 = this . getInterface (  )  ;  Services loc1 = arg0 . getServices (  )  ;  SchedulerService loc2 = loc1 . get ( SchedulerService . class )  ;  loc2 . unscheduleAllJobs ( loc0 . getSimpleName (  )  )  ;  loc2 . scheduleJob (  JobBuilder . newJob ( PurgeService . class )   . withIdentity ( loc0 . getSimpleName (  )  )   . build (  )  ,  TriggerBuilder . newTrigger (  )   . withIdentity ( loc0 . getSimpleName (  )  )   . startNow (  )   . withSchedule (  SimpleScheduleBuilder . simpleSchedule (  )   . withIntervalInSeconds ( this . limit )   . repeatForever (  )  )   . build (  )  )  ;  }
public static int function ( TDeserializer arg0 ,  byte [  ]  arg1 )  { TFieldIdEnum loc0 = MyThriftStruct . _Fields . MY_I32_FIELD_ID ;  TField loc1 = arg0 . locateField ( arg1 ,  loc0 )  ;  if  ( loc1 != null && loc1 . type == TType . I32 )  { return arg0 . partialDeserializeField ( loc1 . type ,  arg1 ,  loc0 ,  MyThriftStruct . _Fields . MY_I32_FIELD_ID )  ;  } return 0 ;  }
void function ( int arg0 )  { int loc0 = arg0 % 10 ;  if  ( loc0 == 0 )  { taskMode = 0 ;  harvest . reset (  )  ;  arrow . reset (  )  ;  sow . reset (  )  ;  mine . reset (  )  ;  mob . reset (  )  ;  buildspeed = 1 ;  shortmine . reset (  )  ;  smallfarm . reset (  )  ;  loot . reset (  )  ;  melee . reset (  )  ;  fireball . reset (  )  ;  runaway . reset (  )  ;  } else if  ( loc0 == 1 )  { taskMode = 1 ;  harvest . reset (  )  ;  arrow . reset (  )  ;  sow . reset (  )  ;  mine . reset (  )  ;  mob . reset (  )  ;  buildspeed = 1 ;  longmine . reset (  )  ;  largefarm . reset (  )  ;  loot . reset (  )  ;  melee . reset (  )  ;  fireball . reset (  )  ;  runaway . reset (  )  ;  } else if  ( loc0 == 2 )  { taskMode = 2 ;  harvest . reset (  )  ;  arrow . reset (  )  ;  sow . reset (  )  ;  mine . reset (  )  ;  mob . reset (  )  ;  buildspeed = 1 ;  shortmine . reset (  )  ;  smallhouse . reset (  )  ;  loot . reset (  )  ;  melee . reset (  )  ;  fireball . reset (  )  ;  runaway . reset (  )  ;  } else if  ( loc0 == 3 )  { taskMode = 3 ;  harvest . reset (  )  ;  arrow . reset (  )  ;  sow . reset (  )  ;  mine . reset (  )  ;  mob . reset (  )  ;  buildspeed = 1 ;  longmine . reset (  )  ;  largehouse . reset (  )  ;  loot . reset (  )  ;  melee . reset (  )  ;  fireball . reset (  )  ;  runaway . reset (  )  ;  } else { taskMode = 0 ;  harvest . reset (  )  ;  arrow . reset (  )  ;  sow . reset (  )  ;  mine . reset (  )  ;  mob . reset (  )  ;  buildspeed = 1 ;  shortmine . reset (  )  ;  smallfarm . reset (  )  ;  loot . reset (  )  ;  melee . reset (  )  ;  fireball . reset (  )  ;  runaway . reset (  )  ;  } }
private void function (  )  { Date loc0 = new Date (  )  ;  String loc1 = request . getHeader ( "If-Match" )  ;  long loc2 = request . getDateHeader ( "If-Unmodified-Since" )  ;  Date loc3 = new Date ( loc2 )  ;  }
void function ( Collection < String >  arg0 )  { try { after . addAll ( arg0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
public void function ( String arg0 )  { try { String loc0 = arg0 . trim (  )  ;  if  ( !loc0 . contains ( " @ " )  )  { throw new IllegalArgumentException ( "Invalid email address: " + loc0 )  ;  } this . to = loc0 ;  } catch  ( Exception e )  { System . err . println ( "An error occurred while setting the 'to' address: " + e . getMessage (  )  )  ;  } }
void function ( Entity arg0 ,  boolean arg1 )  { try { source = arg0 ;  destinationSet = arg1 ;  if  ( mob . getAttackTarget (  )  == null || mob . getAttackTarget (  )  . isDead )  { setDestination (  )  ;  } } catch  ( Exception loc0 )  { System . err . println ( "Exception occurred in function: " + loc0 . getMessage (  )  )  ;  } }
void function (  )  { mWriter . close (  )  ;  assertTrue ( mOutStream . size (  )  == 0 )  ;  assertTrue ( mWriter . isClosed (  )  )  ;  assertFalse ( mWriter . isCanceled (  )  )  ;  mWriter . close (  )  ;  assertTrue ( mOutStream . size (  )  == 0 )  ;  assertTrue ( mWriter . isClosed (  )  )  ;  assertFalse ( mWriter . isCanceled (  )  )  ;  }
MetadataEditorCompat function ( Object arg0 ,  boolean arg1 )  { Object loc0 = null ;  if  ( HAS_REMOTE_CONTROL_APIS )  { loc0 = new RemoteControlClientCompat ( arg0 ,  arg1 )  ;  } Object loc1 = null ;  if  ( loc0 != null )  { loc1 =  (  ( RemoteControlClientCompat )  loc0 )  . editMetadata ( true )  ;  } return new MetadataEditorCompat ( loc1 )  ;  }
void function ( PersonBlogs arg0 ,  HashMap < String ,  HashMap < String ,  Integer >  >  arg1 )  { for  ( int loc1 = 0 ;  loc1  <  arg0 . getPosts (  )  . size (  )  ;  loc1 ++  )  { String loc2 = arg0 . getPosts (  )  . get ( loc1 )  ;  String [  ]  loc3 = NaiveBayesTrain . cleanPost ( loc2 )  ;  NaiveBayesTrain . updateNaiveBayesMapForSinglePost ( loc3 ,  arg1 ,  arg0 . getBloggerAgeClass (  )  )  ;  } } This method takes a PersonBlogs object and a HashMap object as input arguments .  It then loops through each post in the PersonBlogs object's posts list ,  cleans the post using the static cleanPost method of the NaiveBayesTrain class ,  and updates the HashMap object with the cleaned post data using the updateNaiveBayesMapForSinglePost method of the NaiveBayesTrain class .  The method doesn't return any value . 
public static String function ( long arg0 ,  long arg1 )  { long loc0 = System . nanoTime (  )  ;  long loc1 = loc0 - arg0 ;  return "Time elapsed since start time  ( in nanoseconds ) : " + loc1 ;  }
public void function ( HttpServletRequest arg0 )  { try { System . out . println ( ControllerUtils . getRequestHeaders ( arg0 )  )  ;  System . out . println ( this . toString (  )  )  ;  LOG . debug ( "Prints request headers . " )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
public void function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { JournalTailer loc0 =  ( JournalTailer ) arg0 ;  String loc1 = loc0 . mReader . getName (  )  ;  String loc2 = loc0 . mReader . getCheckpointFilePath (  )  ;  InputStream loc3 = loc0 . mReader . getCheckpointInputStream (  )  ;  loc0 . mReader . processJournalCheckpoint ( loc3 )  ;  long loc4 = loc0 . getLatestSequenceNumber (  )  ;  loc0 . close (  )  ;  }
long function ( MotionEvent arg0 ,  MotionEvent arg1 )  { long loc0 = arg1 . getEventTime (  )  - arg0 . getEventTime (  )  ;  return loc0 ;  }
void function ( byte [  ]  arg0 )  { try { OutputStream loc0 = clientSession . getSocket (  )  . getOutputStream (  )  ;  doWrite ( arg0 ,  loc0 )  ;  } catch  ( IOException e )  { logger . error ( "Failed to send data asynchronously" ,  e )  ;  } } private void doWrite ( byte [  ]  arg0 ,  OutputStream loc0 )  throws IOException { loc0 . write ( arg0 )  ;  loc0 . flush (  )  ;  }
String [  ]  loc0 = {"id1" ,  "id2" ,  "id3"} ;  instance . setSatelliteIds ( loc0 )  ;  String [  ]  loc1 = instance . getSatelliteIds (  )  ;  assertEquals ( loc0 . length ,  loc1 . length )  ;  int loc2 = 0 ;  for  ( String loc3 : loc0 )  { assertEquals ( loc3 ,  loc1 [ loc2 ++  ]  )  ;  }
public void function ( String arg0 ,  int arg1 )  { InetAddress loc0 = InetAddress . getByName ( arg0 )  ;  clientEndpoint . connect ( loc0 ,  arg1 )  ;  clientSession . start (  )  ;  }
public void function ( long arg0 ,  Coin arg1 ,  byte [  ]  arg2 ,  Sha256Hash arg3 ,  int arg4 ,  boolean arg5 )  { try { this . index = arg0 ;  this . value = arg1 ;  this . scriptBytes = arg2 ;  this . hash = arg3 ;  this . height = arg4 ;  this . coinbase = arg5 ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
class DirEntry { Constant dataval ;  int blocknum ;  int blockNumber (  )  { return blocknum ;  } Constant function (  )  { Constant loc0 = dataval ;  return loc0 ;  } }
public void function ( String arg0 ,  String arg1 ,  boolean arg2 ,  boolean arg3 ,  TokenReference arg4 )  { arg4 . setWsse11TokenType ( arg0 )  ;  arg4 . setUseDirectReference ( arg2 )  ;  arg4 . setUseKeyIdentifier ( arg3 )  ;  arg4 . setWsseValueType ( arg1 )  ;  }
Map < String ,  String >  function ( Parcel arg0 ,  ClassLoader arg1 )  { Map < String ,  String >  loc0 = new HashMap <  >  (  )  ;  int size = arg0 . readInt (  )  ;  for  ( int i = 0 ;  i  <  size ;  i ++  )  { String key = arg0 . readString (  )  ;  String value = arg0 . readString (  )  ;  loc0 . put ( key ,  value )  ;  } return loc0 ;  }
void function ( DenseMatrix64F arg0 ,  double arg1 )  { DenseMatrix64F loc0 = new DenseMatrix64F ( arg0 . getNumRows (  )  ,  arg0 . getNumCols (  )  )  ;  CommonOps . setIdentity ( loc0 )  ;  CommonOps . scale ( arg1 ,  loc0 )  ;  CommonOps . addEquals ( loc0 ,  arg0 )  ;  A = loc0 ;  }
void function ( Object arg0 )  { try { ComplexNode loc0 = this . getSingleNestedComplexNode (  )  ;  loc0 . setSingleNestedComplexNode (  ( ComplexNode )  arg0 )  ;  } catch  ( Exception e )  { } }
BoxFolder function ( String arg0 )  { try { BoxFolder loc0 = rootFolder . getFolder ( arg0 )  ;  return loc0 ;  } catch  ( BoxAPIException e )  { System . out . println ( MISSING_FOLDER_MESSAGE )  ;  return null ;  } }
void function ( String arg0 )  { try { this . units = arg0 ;  } catch  ( Exception e )  { } }
uint32_t function ( int arg0 ,  int arg1 )  { try { uint32_t loc0 =  ( uint32_t ) arg0 ;  uint32_t loc1 =  ( uint32_t ) arg1 ;  loc1 |=  ( loc0 & ChildNumber . HARDENED_BIT )  ;  if  ( ChildNumber . ZERO_HARDENED . equals ( ChildNumber . of ( loc0 )  )  )  { loc1 |= ChildNumber . HARDENED_BIT ;  } return loc1 ;  } catch  ( Exception e )  { return 0 ;  } }
void function ( String arg0 )  { try { webEngine . load ( arg0 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
public void function ( PropertyChangeListener arg0 )  { try { propertyChangeSupport . addPropertyChangeListener ( arg0 )  ;  } catch  ( Exception loc0 )  { System . err . println ( "Error adding property change listener: " + loc0 . getMessage (  )  )  ;  } }
public String function ( String arg0 ,  String arg1 )  { String loc0 = null ;  try { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance (  )  ;  DocumentBuilder builder = factory . newDocumentBuilder (  )  ;  Document doc = builder . parse ( new File ( arg1 )  )  ;  NodeList nodeList = doc . getElementsByTagName ( "XMI . reference" )  ;  for  ( int i = 0 ;  i  <  nodeList . getLength (  )  ;  i ++  )  { Node node = nodeList . item ( i )  ;  if  ( node . getNodeType (  )  == Node . ELEMENT_NODE )  { Element element =  ( Element )  node ;  String id = element . getAttribute ( "xmi . id" )  ;  String systemId = element . getAttribute ( "xmi . idref" )  ;  if  ( systemId . equals ( arg0 )  )  { loc0 = id ;  break ;  } } } } catch  ( ParserConfigurationException | SAXException | IOException e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
boolean function ( ActivityRequest arg0 ,  String arg1 )  { try { if  ( validateRequest ( arg0 )  )  { return true ;  } else { return false ;  } } catch  ( Exception loc0 )  { logger . error ( "Error validating request for " + arg1 ,  loc0 )  ;  return false ;  } } private boolean validateRequest ( ActivityRequest arg0 )  { return true ;  // or false depending on whether the validation passes or not }
boolean function (  )  { long loc0 = mUfs . getModificationTimeMs ( mCheckpointPath )  ;  if  ( loc0  >  mCheckpointLastModifiedTime )  { LOG . info ( "Journal checkpoint was modified since reader was created . " )  ;  return false ;  } if  ( loc0  >  mCheckpointOpenedTime )  { LOG . info ( "Journal checkpoint was modified since reader was opened . " )  ;  return false ;  } if  ( mCheckpointRead == false )  { JournalInputStream loc1 = getCheckpointInputStream (  )  ;  loc1 . close (  )  ;  mCheckpointRead = true ;  } if  ( arg0 && arg1 == mCurrentLogNumber )  { LOG . info ( "Reader is now at the current log position . " )  ;  return true ;  } JournalInputStream loc2 = getNextInputStream (  )  ;  if  ( loc2 == null )  { LOG . info ( "Reader has reached the end of the journal . " )  ;  return true ;  } loc2 . close (  )  ;  return function (  )  && arg1 == mCurrentLogNumber ;  }
void function (  )  { RMCTest testObj = new RMCTest (  )  ;  testObj . setUp (  )  ;  RMCParser rmcParser = testObj . rmc ;  String loc0 = "$GPRMC , 120044 . 567 , A , 6011 . 552 , N , 02501 . 941 , E , 000 . 0 , 360 . 0 , 160705 , 006 . 1 , E , A*0B" ;  rmcParser . parse ( loc0 )  ;  assertNotNull ( rmcParser . getTime (  )  )  ;  assertEquals ( 12 ,  rmcParser . getTime (  )  . getHour (  )  )  ;  assertEquals ( 0 ,  rmcParser . getTime (  )  . getMinutes (  )  )  ;  assertEquals ( 44 ,  rmcParser . getTime (  )  . getSeconds (  )  )  ;  }
void function (  )  { long loc0 = getLockTimeOut (  )  ;  loc1 . eagerVerifyPrecondition (  )  ;  }
void function ( IRtfListener arg0 )  { handleCharacterData (  )  ;  arg0 . processGroupEnd (  )  ;  }
File function ( String arg0 )  { File loc0 = getBackupDir ( arg0 )  ;  backup ( loc0 )  ;  return loc0 ;  }
void function ( Constant arg0 ,  RID arg1 )  { beforeFirst ( arg0 )  ;  leaf . insert ( arg1 )  ;  leaf . close (  )  ;  BTreeDir loc0 = new BTreeDir (  )  ;  while  ( !loc0 . insert ( leafTi ,  leaf . getBLK (  )  )  )  { leafTi = loc0 . getNewChild (  )  ;  leaf . close (  )  ;  beforeFirst ( arg0 )  ;  leaf . insert ( arg1 )  ;  leaf . close (  )  ;  } if  ( loc0 . isFull (  )  )  { BTreeDir loc1 = new BTreeDir (  )  ;  loc1 . makeNewRoot ( loc0 . getBLK (  )  ,  loc0 . getNewChild (  )  )  ;  loc0 . close (  )  ;  loc0 = loc1 ;  } loc0 . close (  )  ;  rootblk = loc0 . getBLK (  )  ;  }
public static HashMap < Class < ? >  ,  String >  function (  )  { HashMap < Class < ? >  ,  String >  loc0 = new HashMap <  >  (  )  ;  try { loc0 . putAll ( ClassUtil . TYPES_BY_NAME . asInverseWithShortName (  )  )  ;  loc0 . putAll ( ClassUtil . SHORT_NAMES_BY_TYPE )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
void function ( boolean arg0 )  { returnEntropy = arg0 ;  }
String function ( HttpServletRequest arg0 )  { String loc0 = arg0 . getRequestURI (  )  ;  String loc1 = arg0 . getContextPath (  )  ;  String loc2 = loc0 . substring ( loc1 . length (  )  )  ;  return loc2 ;  }
int function (  )  { int loc0 = 0 ;  try { loc0 =  ++ generatedClassSerial ;  } catch  ( Exception loc1 )  { } return loc0 ;  }
int function ( int arg0 )  { int loc0 = -1 ;  if  ( _stack_type . equals ( "non_term" )  )  { loc0 = arg0 + _index ;  } else if  ( _stack_type . equals ( "term" )  )  { loc0 = arg0 - _index ;  } return loc0 ;  }
public static void function (  )  { String loc0 = new String ( "Hello ,  world!" )  ;  ArrayList < String >  loc1 = new ArrayList < String >  (  )  ;  loc1 . add ( "Item 1" )  ;  loc1 . add ( "Item 2" )  ;  String loc2 = selectFolder ( "C:/" ,  loc1 ,  "Select a folder" )  ;  }
String function ( final HttpParams arg0 )  { try { String loc0 =  ( String )  arg0 . getParameter ( CoreProtocolPNames . HTTP_CONTENT_CHARSET )  ;  if  ( loc0 == null )  { loc0 = HTTP . DEFAULT_CONTENT_CHARSET ;  } return loc0 ;  } catch  ( Exception e )  { throw new IllegalArgumentException ( "srini_string" )  ;  } }
void function ( int arg0 )  { if  ( arg0  > = 0 && arg0  < = 127 )  { char c =  ( char )  arg0 ;  handler . processCharacter ( c )  ;  } else { String hexString = Integer . toHexString ( arg0 )  ;  String unicode = "\\u" +  ( "0000" + hexString )  . substring ( hexString . length (  )  )  ;  handler . processString ( unicode )  ;  } }
void function (  )  { try { ServerSession loc0 = null ;  ServerMessage loc1 = mock ( ServerMessage . class )  ;  acitivityController . registerUserSession ( loc0 ,  loc1 )  ;  fail ( "Expected NullPointerException was not thrown" )  ;  } catch  ( NullPointerException e )  { } }
void function ( QName arg0 ,  String arg1 ,  MessageWriter arg2 )  { try { writeAttribute ( arg2 ,  arg0 ,  arg1 )  ;  } catch  ( Exception loc0 )  { throw loc0 ;  } }
String function ( String arg0 )  { String loc0 = "" ;  try { URL url = new URL ( arg0 )  ;  HttpURLConnection connection =  ( HttpURLConnection )  url . openConnection (  )  ;  connection . setRequestMethod ( "GET" )  ;  connection . setConnectTimeout ( 5000 )  ;  connection . setReadTimeout ( 5000 )  ;  int status = connection . getResponseCode (  )  ;  if  ( status  > = 200 && status  < = 299 )  { BufferedReader reader = new BufferedReader ( new InputStreamReader ( connection . getInputStream (  )  )  )  ;  StringBuilder content = new StringBuilder (  )  ;  String line ;  while  (  ( line = reader . readLine (  )  )  != null )  { content . append ( line )  ;  } reader . close (  )  ;  loc0 = content . toString (  )  ;  } else { throw new RuntimeException ( "Failed to retrieve full content from the CGDS . " )  ;  } connection . disconnect (  )  ;  } catch  ( MalformedURLException e )  { System . err . println ( "Invalid URL provided: " + arg0 )  ;  } catch  ( IOException e )  { System . err . println ( "Failed to connect to the CGDS: " + e . getMessage (  )  )  ;  } catch  ( Exception e )  { System . err . println ( "An error occurred while retrieving full content from the CGDS: " + e . getMessage (  )  )  ;  } return loc0 ;  }
public void function ( Config arg0 )  { Config loc0 = arg0 ;  this . config = loc0 ;  }
String function (  )  { String loc0 = _rss_link ;  String loc1 = _title ;  String loc2 = _description ;  String loc3 = _image ;  String loc4 = _link ;  return loc0 + loc1 + loc2 + loc3 + loc4 ;  }
public static BrowseOffersResponse . Return function (  )  { try { BrowseOffersResponse . Return loc0 = new BrowseOffersResponse . Return (  )  ;  loc0 . function (  )  ;  return loc0 ;  } catch  ( Exception loc1 )  { } }
void function ( final Builder arg0 ,  final String arg1 )  { arg0 . setObjectId ( arg1 )  ;  arg0 . setObjectType ( arg0 . getObjectType (  )  )  ;  return ;  }
public Script createScriptPubKey ( byte [  ]  scriptHash )  { checkArgument ( scriptHash . length == 20 ,  "Script hash must be 20 bytes" )  ;  ScriptBuilder builder = new ScriptBuilder (  )  ;  builder . op ( OP_HASH160 )  . data ( scriptHash )  . op ( OP_EQUAL )  ;  return builder . build (  )  ;  }
String function (  )  { OAuthServerConfiguration loc0 = getOAuthServerConfiguration (  )  ;  OpenIDConnectUserInfoEndpointAccessTokenValidator loc1 = loc0 . getOpenIDConnectUserInfoEndpointAccessTokenValidator (  )  ;  return loc1 . getClass (  )  . getName (  )  ;  }
ResourceTypeHandler function ( String arg0 )  { try { ResourceTypeHandler loc0 = getResourceType ( arg0 )  ;  return loc0 ;  } catch  ( Exception e )  { return FILE ;  } }
void function ( Double arg0 )  { mPendingQueue . add ( arg0 )  ;  runIfIdle (  )  ;  }
JPanel function (  )  { JPanel loc0 ,  loc1 ;  loc0 = uiStack . getLastElement (  )  ;  loc1 = loc0 . function (  )  ;  uiStack . addPanel ( loc1 )  ;  return loc0 ;  }
LinearSolverQrpHouseCol < DenseMatrix64F >  function ( int arg0 ,  int arg1 ,  boolean arg2 )  { QRColPivDecompositionHouseholderColumn_D64 < DenseMatrix64F >  loc0 = new QRColPivDecompositionHouseholderColumn_D64 <  >  ( arg0 ,  arg1 )  ;  LinearSolverQrpHouseCol < DenseMatrix64F >  loc1 = new LinearSolverQrpHouseCol <  >  ( loc0 )  ;  SolvePseudoInverseQrp < DenseMatrix64F >  loc2 = new SolvePseudoInverseQrp <  >  ( loc0 ,  arg2 )  ;  loc1 . setSingularThreshold ( loc0 . getSingularThreshold (  )  )  ;  loc1 . setComputeNorm2 ( arg2 )  ;  loc1 . setSolveMultipleArg ( arg2 )  ;  loc1 . setComputeQ ( true )  ;  loc1 . setSolveU ( loc2 . getU ( null )  )  ;  return loc1 ;  }
List < String >  function (  )  { List < String >  loc0 = acceptedC14nAlgorithms ;  if  ( loc0 . isEmpty (  )  )  { loc0 . add ( WSConstants . C14N_EXCL_OMIT_COMMENTS )  ;  } return loc0 ;  }
public BigDecimal function (  )  { BigDecimal loc0 = this . successorId ;  return loc0 ;  }
String function ( DestinationFileExistsDTO obj )  { String loc0 = "" ;  try { loc0 = obj . getFeedId (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
List < NotationName >  function (  )  { List < NotationName >  loc0 = Collections . unmodifiableList ( notations )  ;  return loc0 ;  }
byte [  ]  function ( int arg0 ,  byte [  ]  arg1 ,  int arg2 )  { checkType ( PackConstants . FIELD_TYPE_BYTE_ARRAY )  ;  int loc0 = getByteArrayLength (  )  ;  getByteArrayInternal ( loc0 ,  arg1 ,  arg2 ,  arg0 )  ;  return arg1 ;  }
boolean function ( Card arg0 )  { String name = arg0 . getName (  )  ;  for  ( Card loc0 : enemyHandCards )  { if  ( loc0 . getName (  )  . equals ( name )  )  { return true ;  } } return false ;  }
Timestamp function ( PCLDataUnitEntity arg0 )  { Timestamp loc0 = null ;  try { loc0 = arg0 . getReceiptDate (  )  ;  if  ( loc0 != null )  { String loc1 = arg0 . getReceiptDateType (  )  ;  if  ( loc1 == null )  { loc1 = "" ;  } loc0 = Timestamp . valueOf ( loc0 . toString (  )  + " " + loc1 )  ;  } } catch  ( Exception loc2 )  { } return loc0 ;  }
int function ( int attempts ,  long timeout )  { Semaphore semaphore = new Semaphore ( 0 )  ;  for  ( int i = 0 ;  i  <  attempts ;  i ++  )  { blockFxThreadWithSemaphore (  )  ;  semaphore . release (  )  ;  sleep ( CONDITION_SLEEP_IN_MILLIS ,  TimeUnit . MILLISECONDS )  ;  } for  ( int i = 0 ;  i  <  attempts ;  i ++  )  { boolean acquired ;  try { acquired = semaphore . tryAcquire ( SEMAPHORE_LOOPS_COUNT ,  SEMAPHORE_SLEEP_IN_MILLIS ,  TimeUnit . MILLISECONDS )  ;  } catch  ( InterruptedException e )  { Thread . currentThread (  )  . interrupt (  )  ;  break ;  } if  ( acquired )  { return i ;  } } return attempts ;  }
public long function (  )  { long loc0 = expires . getTime (  )  - created . getTime (  )  ;  long loc1 = loc0 / 1000 ;  return loc1  >  lifetime ? lifetime : loc1 ;  } Note: This method calculates the difference between the token's expiration time and creation time in milliseconds ,  then converts the result to seconds and returns the minimum of the calculated lifetime and the result . 
Object function ( String arg0 ,  Object arg1 )  { Object loc0 = json . get ( arg0 )  ;  if  ( loc0 instanceof Boolean )  { return  ( boolean )  loc0 ;  } else if  ( loc0 instanceof Function )  { return  ( Function )  loc0 ;  } else if  ( loc0 instanceof String )  { return  ( String )  loc0 ;  } else { return json . has ( arg0 )  ;  } }
import java . awt . Color ;  public class BouncingBall { private Canvas canvas ;  private int ballDegradation = 2 ;  private Color color ;  private int groundPosition ;  private int GRAVITY = 3 ;  private int xPosition ;  private int ySpeed = 1 ;  private int diameter ;  private int yPosition ;  private Ellipse2D . Double circle ;  public void function ( Color arg0 ,  int arg1 )  { canvas . setForegroundColor ( arg0 )  ;  canvas . fillCircle ( xPosition ,  yPosition ,  diameter )  ;  } }
void function ( String arg0 )  { try { String loc0 = DEFAULT_MODEL_IMPLEMENTATION ;  initializeModelImplementation ( loc0 )  ;  } catch  ( Exception loc1 )  { } }
short function ( final int arg0 ,  final int arg1 )  { int loc0 = gen . getAndIncrement (  )  + salt ;  int loc1 = gen . getAndIncrement (  )  + salt ;  short loc2 = hi16 ( arg0 )  ;  short loc3 = lo16 ( arg1 )  ;  int loc4 = result ( loc2 ,  loc3 )  ;  loc0 ^= loc2 ;  loc1 ^= loc3 ;  loc1 ^= loc4 ;  loc0 ^= unmix ( loc1 )  ;  return hi16 ( loc0 )  ;  }
public Object function ( Object arg0 ,  Object arg1 )  { Object result = null ;  try { Transform transformer = new Transform (  )  ;  transformer . clearParameters (  )  ;  transformer . setParameter ( "param" ,  arg0 )  ;  transformer . transformTo ( new StreamResult ( new StringWriter (  )  )  )  ;  result = transformer . getResultString (  )  ;  } catch  ( Exception loc0 )  { } return result ;  }
String function (  )  { String loc0 = this . createdBy ;  return loc0 ;  }
boolean function (  )  { boolean loc0 = mob . isBuilding (  )  ;  return loc0 ;  }
int function ( int arg0 ,  byte [  ]  arg1 ,  int arg2 )  { checkState (  )  ;  if  ( isOpCode ( arg0 )  )  { int loc0 = Script . decodeFromOpN ( arg0 )  ;  return loc0 ;  } return -1 ;  }
Book function ( Book arg0 )  { log . debug ( "Saving book: {}" ,  arg0 )  ;  Book loc0 = bookRepository . save ( arg0 )  ;  return loc0 ;  }
void function (  )  { movePanTilt ( "left" )  ;  URL loc0 = composeURL ( "video" )  ;  URL loc1 = new URL ( loc0 . toString (  )  )  ;  URLConnection loc2 = loc1 . openConnection (  )  ;  loc2 . connect (  )  ;  DataInputStream loc3 = new DataInputStream ( new BufferedInputStream ( loc2 . getInputStream (  )  )  )  ;  while  ( loc3 . available (  )   >  0 )  { loc3 . read (  )  ;  } loc3 . close (  )  ;  halt (  )  ;  }
public void function ( TreeModel arg0 )  { try { registerRule ( arg0 )  ;  boolean loc0 = goRules . contains ( arg0 )  ;  if  ( !loc0 )  { goRules . add ( arg0 )  ;  } } catch  ( Exception e )  { System . out . println ( "An exception occurred: " + e . getMessage (  )  )  ;  } }
public class PCLFetcherRunRecorderEntity { String runStatus ;  long serialVersionUID=1L ;  BigDecimal fileCount ;  BigDecimal feedId ;  byte [  ]  errors ;  Timestamp startDate ;  String resultMessage ;  Timestamp maxReceiptDate ;  BigDecimal downloadSize ;  String configInfo ;  long runId ;  Timestamp endDate ;  String resultCode ;  BigDecimal feedConfigId ;  public void function ( String arg0 )  { resultMessage = arg0 ;  } public String getResultMessage (  )  { return resultMessage ;  } public BigDecimal getFileCount (  )  { return fileCount ;  } public void setResultCode ( String resultCode )  { this . resultCode = resultCode ;  } public Timestamp getMaxReceiptDate (  )  { return maxReceiptDate ;  } public BigDecimal getFeedConfigId (  )  { return feedConfigId ;  } public String getConfigInfo (  )  { return configInfo ;  } public void setEndDate ( Timestamp endDate )  { this . endDate = endDate ;  } public String getRunStatus (  )  { return runStatus ;  } public void setRunStatus ( String runStatus )  { this . runStatus = runStatus ;  } public void setMaxReceiptDate ( Timestamp maxReceiptDate )  { this . maxReceiptDate = maxReceiptDate ;  } public long getRunId (  )  { return runId ;  } public Timestamp getEndDate (  )  { return endDate ;  } public void setErrors ( byte [  ]  errors )  { this . errors = errors ;  } public byte [  ]  getErrors (  )  { return errors ;  } public Timestamp getStartDate (  )  { return startDate ;  } public String getResultCode (  )  { return resultCode ;  } public void setFeedConfigId ( BigDecimal feedConfigId )  { this . feedConfigId = feedConfigId ;  } public BigDecimal getFeedId (  )  { return feedId ;  } public void setRunId ( long runId )  { this . runId = runId ;  } public void setDownloadSize ( BigDecimal downloadSize )  { this . downloadSize = downloadSize ;  } public void setFileCount ( BigDecimal fileCount )  { this . fileCount = fileCount ;  } public BigDecimal getDownloadSize (  )  { return downloadSize ;  } public void setStartDate ( Timestamp startDate )  { this . startDate = startDate ;  } public void setFeedId ( BigDecimal feedId )  { this . feedId = feedId ;  } public void setConfigInfo ( String configInfo )  { this . configInfo = configInfo ;  } }
long function (  )  { DataServerMessage dataServerMessage = new DataServerMessage (  )  ;  dataServerMessage . checkReady (  )  ;  return dataServerMessage . mSessionId ;  }
import org . junit . Rule ;  import org . junit . Test ;  import org . junit . rules . ExpectedException ;  public class ModeTest {  @ Rule public ExpectedException mThrown = ExpectedException . none (  )  ;   @ Test public void function (  )  { Mode mode = new Mode (  )  ;  mode . setOwnerBits ( 7 )  ;  mode . setGroupBits ( 5 )  ;  mode . setOtherBits ( 3 )  ;  String arg0 = "753" ;  String loc0 = mode . toString (  )  ;  String arg1 = "Mode string representation should be " + arg0 ;  assertEquals ( arg1 ,  arg0 ,  loc0 )  ;  } private void assertEquals ( String arg0 ,  String arg1 ,  String arg2 )  { if  ( !arg1 . equals ( arg2 )  )  { throw new AssertionError ( arg0 )  ;  } } private class Mode { private int ownerBits ;  private int groupBits ;  private int otherBits ;  public void setOwnerBits ( int bits )  { ownerBits = bits ;  } public void setGroupBits ( int bits )  { groupBits = bits ;  } public void setOtherBits ( int bits )  { otherBits = bits ;  } public String toString (  )  { return "" + ownerBits + groupBits + otherBits ;  } } }
public void function ( D1Matrix64F arg0 ,  double gamma ,  D1Matrix64F u ,  D1Matrix64F w )  { int numRows = arg0 . getNumRows (  )  ;  int numCols = arg0 . getNumCols (  )  ;  for  ( int i = 0 ;  i  <  numRows ;  i ++  )  { for  ( int j = 0 ;  j  <  numCols ;  j ++  )  { arg0 . data [ i * numCols + j ]  += gamma * u . data [ i ]  * w . data [ j ]  ;  } } }
void function (  )  { NMEASentenceParser loc0 = instance . createParser (  )  ;  assertNull ( loc0 )  ;  instance . sentenceRead ( event )  ;  assertNotNull ( arg1 )  ;  assertEquals ( arg0 ,  arg1 )  ;  assertFalse ( loc1 )  ;  }
void function ( String arg0 )  { c14nAlgorithm = arg0 ;  }
public class RestUtils { private static final Logger LOG = LoggerFactory . getLogger ( Constants . LOGGER_TYPE )  ;  public static void function ( Object arg0 ,  String arg1 )  { Response loc0 = Response . serverError (  )  . entity ( arg0 )  . build (  )  ;  LOG . error ( arg1 )  ;  throw new WebApplicationException ( loc0 )  ;  } }
Iterable < T >  function ( Iterable < F >  arg0 ,  Mapper < ? super F , T >  arg1 )  { try { return map ( arg0 ,  arg1::apply )  ;  } catch  ( Exception loc0 )  { throw new RuntimeException ( loc0 )  ;  } }
Map < String ,  Object >  function (  )  { Map < String ,  Object >  loc0 = new HashMap < String ,  Object >  (  )  ;  loc0 . putAll ( getRequestContext (  )  )  ;  loc0 . putAll ( getResponseContext (  )  )  ;  loc0 . keySet (  )  . retainAll ( HTTP_RESPONSE_PROPERTIES )  ;  return loc0 ;  }
public static Sha256Hash function ( byte [  ]  contents )  { try { MessageDigest digest = MessageDigest . getInstance ( "SHA-256" )  ;  byte [  ]  hashBytes = digest . digest ( contents )  ;  return new Sha256Hash ( hashBytes )  ;  } catch  ( NoSuchAlgorithmException e )  { throw new RuntimeException ( e )  ;  } }
 < T >  T function ( Class < T >  arg0 ,  Service arg1 )  { return arg0 . cast ( services . get ( arg0 )  )  ;  }
public int function ( Object arg0 ,  JTable arg1 )  { int loc0 = arg1 . getSelectionModel (  )  . getLeadSelectionIndex (  )  ;  int loc1 = arg1 . convertRowIndexToModel ( loc0 )  ;  return loc1 ;  }
public class AddressFacade { private AddressType address ;  public String getStreet (  )  { return address . getStreet (  )  ;  } public String getCity (  )  { return address . getCity (  )  ;  } public String getState (  )  { return address . getState (  )  ;  } public String function ( String arg0 ,  String arg1 )  { String loc0 = "" ;  try { loc0 = address . getPostalZone (  )  . getValue (  )  ;  } catch  ( NullPointerException e )  { loc0 = arg0 ;  } return loc0 + arg1 ;  } }
void function ( String arg0 ,  String arg1 ,  Exception arg2 )  { String loc0 = "Popup an SQL error" ;  String loc1 = arg0 + " " + arg1 + " " + arg2 . toString (  )  ;  this . popupError ( loc0 )  ;  this . warning ( loc1 )  ;  String loc2 = Inter . get (  )  ;  this . info ( loc2 )  ;  }
Condition function ( String arg0 ,  String arg1 )  { Condition loc0 = Selector . createLangCondition ( arg0 )  ;  Selector loc1 = new Selector (  )  ;  loc1 . addCondition ( loc0 )  ;  loc1 . addCondition ( new Condition ( " " )  )  ;  loc1 . addCondition ( new Condition ( arg1 )  )  ;  addCondition ( loc1 )  ;  return loc0 ;  }
public static long function ( JSONObject arg0 ,  String arg1 )  { long loc0 = 0 ;  try { Object loc1 = arg0 . get ( arg1 )  ;  if  ( loc1 != null && !loc1 . equals ( "?" )  )  { loc0 =  ( long )  loc1 ;  } } catch  ( JSONException e )  { } return loc0 ;  }
void function ( String arg0 )  { String loc0 = arg0 ;  this . experimentTypes = loc0 ;  }
PasswordCredentials function (  )  { PasswordCredentials loc0 = this . passwordCredentials ;  return loc0 ;  }
String function (  )  { String loc0 = "No reason provided" ;  if  ( reason != null && !reason . isEmpty (  )  )  { loc0 = reason ;  } return loc0 ;  }
class TestMatrixMatrixMult { Random rand = new Random ( 121342 )  ;  void function ( DenseMatrix64F arg0 ,  DenseMatrix64F arg1 ,  DenseMatrix64F arg2 ,  DenseMatrix64F arg3 )  { CheckMatrixMultShape loc0 = new CheckMatrixMultShape (  )  ;  MatrixMatrixMult loc1 = new MatrixMatrixMult (  )  ;  loc0 . checkAll (  )  ;  } void checkResults ( DenseMatrix64F a_orig ,  DenseMatrix64F b_orig ,  DenseMatrix64F c_orig ,  DenseMatrix64F r_orig )  { } void checkAgainstRandomDiffShapes (  )  { } void invoke ( Method func ,  double alpha ,  DenseMatrix64F a ,  DenseMatrix64F b ,  DenseMatrix64F c )  { } void transpose ( DenseMatrix64F a )  { } void checkInputInstance (  )  { } void checkAllAgainstKnown (  )  { } }
void function (  )  { for  ( int loc0 = 0 ;  loc0  <  PROPS . size (  )  ;  loc0 ++  )  { AbstractSettings loc1 = PROPS . get ( loc0 )  ;  loc1 . revertToDefault (  )  ;  } }
void function ( ArgoDiagramAppearanceEvent arg0 ,  ArgoDiagramAppearanceEventListener arg1 )  { int loc0 = arg0 . getEventType (  )  ;  switch  ( loc0 )  { case ArgoEventTypes . DIAGRAM_FONT_CHANGED: arg1 . diagramFontChanged ( arg0 )  ;  break ;  default: LOG . error ( "Unhandled event type in function: " + loc0 )  ;  break ;  } ArgoEventPump . SINGLETON . handleFireEvent ( arg0 ,  arg1 )  ;  }
double function ( double arg0 ,  double arg1 )  { try { double loc0 = Math . abs ( arg0 )  ;  double loc1 = Math . abs ( arg1 )  ;  double diff = Math . max ( loc0 ,  loc1 )  ;  return  ( diff  < = UtilEjml . EPS )  ;  } catch  ( Exception e )  { System . err . println ( "An error occurred: " + e . getMessage (  )  )  ;  return false ;  } }
import java . io . * ;  public class S3Sample { public File createSampleFile (  )  { } public static void main ( String [  ]  args )  { } public static void function ( InputStream arg0 )  { InputStreamReader loc0 = new InputStreamReader ( arg0 )  ;  BufferedReader loc1 = new BufferedReader ( loc0 )  ;  String loc2 ;  try { while  (  ( loc2 = loc1 . readLine (  )  )  != null )  { System . out . println ( loc2 )  ;  } loc1 . close (  )  ;  } catch  ( IOException loc3 )  { throw new RuntimeException ( loc3 )  ;  } } }
Boolean function ( Object arg0 )  { Boolean loc0 = Boolean . TRUE . equals ( arg0 . get (  )  )  ;  return loc0 && MessageUtils . isEmptyPartialResponse (  ( Message )  arg0 )  ;  }
void function ( Object arg0 ,  Object arg1 )  { String outputStreamId = getOutputStreamId (  )  ;  String [  ]  fields = getOutputFields (  )  ;  logger . info ( "Registering output fields: " + Arrays . toString ( fields )  )  ;  arg0 . declareStream ( outputStreamId ,  new Fields ( fields )  )  ;  }
void function (  )  { for  ( int arg0 = -1 ;  arg0  < = mTestTierView . getDirPaths (  )  . size (  )  ;  arg0 ++  )  { StorageDirView loc0 = mTestTierView . getDirView ( arg0 )  ;  int loc1 = arg0  <  0 ? 0 : arg0  > = mTestTierView . getDirPaths (  )  . size (  )  ? mTestTierView . getDirPaths (  )  . size (  )  - 1 : arg0 ;  assertEquals ( mTestTierView . getDirPaths (  )  . get ( loc1 )  ,  loc0 . getDirPath (  )  )  ;  } }
import javax . xml . transform . Transformer ;  import javax . xml . transform . TransformerFactory ;  import javax . xml . transform . dom . DOMResult ;  import javax . xml . transform . dom . DOMSource ;  import org . w3c . dom . Document ;  import org . w3c . dom . Node ;  public class Transformation { ErrorListener errorListener ;  Properties output=new Properties (  )  ;  Source styleSheet ;  Source source ;  URIResolver uriResolver ;  Map < String , Object >  params=new HashMap < String , Object >  (  )  ;  TransformerFactory factory ;  void setFactory ( TransformerFactory f )  { this . factory = f ;  } void transformTo ( Result r )  throws TransformerException { Transformer t = factory . newTransformer ( styleSheet )  ;  t . setErrorListener ( errorListener )  ;  t . setURIResolver ( uriResolver )  ;  t . clearParameters (  )  ;  for  ( Map . Entry < String , Object >  entry : params . entrySet (  )  )  { t . setParameter ( entry . getKey (  )  ,  entry . getValue (  )  )  ;  } t . transform ( source ,  r )  ;  } void setURIResolver ( URIResolver r )  { this . uriResolver = r ;  } void clearOutputProperties (  )  { output . clear (  )  ;  } void addParameter ( String name ,  Object value )  { params . put ( name ,  value )  ;  } void setSource ( Source s )  { this . source = s ;  } void setStylesheet ( Source s )  { this . styleSheet = s ;  } void setErrorListener ( ErrorListener l )  { this . errorListener = l ;  } void clearParameters (  )  { params . clear (  )  ;  } String transformToString (  )  throws TransformerException { StringWriter writer = new StringWriter (  )  ;  Result result = new StreamResult ( writer )  ;  transformTo ( result )  ;  return writer . toString (  )  ;  } void addOutputProperty ( String name ,  String value )  { output . setProperty ( name ,  value )  ;  } Document function (  )  throws TransformerException { DOMResult result = new DOMResult (  )  ;  transformTo ( result )  ;  Node node = result . getNode (  )  ;  if  ( node instanceof Document )  { return  ( Document )  node ;  } else { throw new TransformerException ( "Result is not a Document" )  ;  } } }
URI function ( String arg0 ,  String arg1 )  { String loc0 = arg0 + arg1 ;  URI loc1 = null ;  try { loc1 = new URI ( loc0 )  ;  } catch  ( URISyntaxException e )  { e . printStackTrace (  )  ;  } return loc1 ;  }
public T function ( Object arg0 ,  Object arg1 )  { T resource = null ;  try { if  ( mLock . tryLock ( mMinCapacity ,  TimeUnit . DAYS )  )  { try { if  ( mResourceAvailable . isEmpty (  )  && mResources . size (  )   <  mMaxCapacity )  { resource = createNewResource (  )  ;  ResourceInternal < T >  resourceInternal = new ResourceInternal <  >  ( resource )  ;  mResources . put ( resource ,  resourceInternal )  ;  mResourceAvailable . add ( resourceInternal )  ;  } else { while  ( mResourceAvailable . isEmpty (  )  )  { if  ( !mNotEmpty . await ( mMinCapacity ,  TimeUnit . DAYS )  )  { throw new TimeoutException (  )  ;  } } ResourceInternal < T >  resourceInternal = mResourceAvailable . pollFirst (  )  ;  if  ( resourceInternal != null )  { resource = resourceInternal . mResource ;  if  ( !isHealthy ( resource )  )  { resource = checkHealthyAndRetry ( resource ,  mClock . currentTimeMillis (  )  + mInitialDelayMs )  ;  } } } if  ( resource != null )  { resourceInternal = mResources . get ( resource )  ;  resourceInternal . mLastAccessTimeMs = mClock . currentTimeMillis (  )  ;  } } finally { mLock . unlock (  )  ;  } } } catch  ( Throwable t )  { Throwables . propagate ( t )  ;  } return resource ;  }
public void function (  )  { if  ( mIn != null )  { mIn . close (  )  ;  } if  ( mOut != null )  { mOut . close (  )  ;  } }
public static void function (  )  { try { } catch  ( SAXParseException loc0 )  { int column = loc0 . getColumnNumber (  )  ;  int line = loc0 . getLineNumber (  )  ;  ValidationProblem problem = ValidationProblem . fromException ( loc0 ,  ProblemType . TYPE_A )  ;  problem . column =  ( column != -1 )  ? column : ValidationProblem . UNKNOWN ;  problem . line =  ( line != -1 )  ? line : ValidationProblem . UNKNOWN ;  String message = problem . getMessage (  )  ;  System . out . println ( "Validation problem occurred: " + message )  ;  } catch  ( Exception loc1 )  { } }
void function ( byte [  ]  arg0 ,  byte [  ]  arg1 )  { if  ( finalised )  { throw new IllegalStateException ( "Generator already finalised" )  ;  } if  ( arg0 . length != 4 )  { throw new IllegalArgumentException ( "Expected a 4-byte integer as argument 1" )  ;  } if  ( arg1 . length != 32 )  { throw new IllegalArgumentException ( "Expected a 32-byte hash as argument 2" )  ;  } long loc0 =  (  ( long )  getByte (  )   <  <  56 )  ^  (  ( long )  getByte (  )   <  <  48 )  ^  (  ( long )  getByte (  )   <  <  40 )  ^  (  ( long )  getByte (  )   <  <  32 )  ^  (  ( long )  getByte (  )   <  <  24 )  ^  (  ( long )  getByte (  )   <  <  16 )  ^  (  ( long )  getByte (  )   <  <  8 )  ^  (  ( long )  getByte (  )  )  ;  for  ( int loc1 = 0 ;  loc1  <  4 ;  loc1 ++  )  { mixednumber [  ( ptr + loc1 )  & 31 ]  ^= arg0 [ loc1 ]  ;  } byte [  ]  loc2 = hashByteArr ( mixednumber )  ;  for  ( int loc3 = 0 ;  loc3  <  32 ;  loc3 ++  )  { if  ( loc2 [ loc3 ]  != arg1 [ loc3 ]  )  { throw new IllegalArgumentException ( "Hashes do not match" )  ;  } } ptr =  ( ptr + 4 )  & 31 ;  sr . nextBytes ( mixednumber )  ;  }
QualifiedName function ( String arg0 ,  String arg1 ,  OperationMetric arg2 )  { QualifiedName qname = getQualifiedName ( arg0 )  ;  ClassStats classStats = getClassStats ( qname ,  true )  ;  OperationStats operationStats = classStats . getOperationStats ( arg1 )  ;  return operationStats . compute ( arg2 )  ;  }
void function (  )  { try { YahooImageFactory loc0 = new YahooImageFactory (  )  ;  runTest ( arg0 ,  loc0 ,  arg1 )  ;  } catch  ( Exception loc1 )  { LOG . error ( "Error running test: " + loc1 . getMessage (  )  )  ;  } }
public void function ( String arg0 )  { Matcher loc0 = ALIAS_PATTERN . matcher ( arg0 )  ;  if  ( loc0 . matches (  )  )  { String loc1 = FILE_PREFIX + loc0 . substring ( ALIAS_PREFIX . length (  )  )  ;  File loc2 = new File ( loc1 )  ;  if  ( loc2 . exists (  )  )  { loc2 . delete (  )  ;  } } }
void function ( AuthType arg0 )  { try { if  ( arg0 == AuthType . SIMPLE || arg0 == AuthType . CUSTOM )  { throw new UnsupportedOperationException ( "Unsupported AuthType" )  ;  } String authName = arg0 . getAuthName (  )  ;  } catch  ( Exception e )  { } }
void function ( MediaRouter arg0 ,  ComponentName arg1 )  { try { RemoteControlClientCompat loc0 = new RemoteControlClientCompat ( arg1 )  ;  arg0 . addRemoteControlClient ( loc0 . getActualRemoteControlClientObject (  )  )  ;  } catch  ( IllegalArgumentException e )  { } }
void function (  )  { try { String loc0 = "org . argouml . model . mdr . MDRModelImplementation" ;  initializeModelImplementation ( loc0 )  ;  } catch  ( Exception loc1 )  { System . out . println ( "Error initializing Model subsystem: " + loc1 . getMessage (  )  )  ;  } }
boolean function (  )  { boolean loc0 = isBuilding (  )  ;  Vec3 loc1 = mob . getPositionVector (  )  ;  double loc2 = loc1 . distanceTo ( buildingSpot )  ;  return loc0 && loc2  <  2 . 0 ;  }
public void function ( long arg0 ,  long arg1 )  { try { ReceiverLossListEntry loc0 = new ReceiverLossListEntry (  )  ;  loc0 . feedback (  )  ;  loc0 . sequenceNumber = arg0 ;  loc0 . lastFeedbacktime = arg1 ;  if  ( loc0 . getLastFeedbackTime (  )   >  loc0 . lastFeedbacktime )  { loc0 . lastFeedbacktime = loc0 . getLastFeedbackTime (  )  ;  } if  ( loc0 . sequenceNumber != 0 )  { if  ( loc0 . compareTo ( new ReceiverLossListEntry (  )  )  == 0 )  { k ++  ;  } } } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
int function (  )  { try { return _size ;  } catch  ( Exception e )  { System . err . println ( "An error occurred: " + e . getMessage (  )  )  ;  return -1 ;  // or throw a custom exception here } }
public static List < String >  function (  )  { List < String >  supportedAbis = new ArrayList <  >  (  )  ;  try { int sdkVersion = Build . VERSION . SDK_INT ;  int lollipopVersion = Build . VERSION_CODES . LOLLIPOP ;  String abi = Build . CPU_ABI ;  String abi2 = Build . CPU_ABI2 ;  class VersionDependent { List < String >  getSupportedAbis (  )  throws Exception { Method method = Class . forName ( "android . os . SystemProperties" )   . getDeclaredMethod ( "get" ,  String . class )  ;  String abiList =  ( String )  method . invoke ( null ,  "ro . product . cpu . abilist" )  ;  return Arrays . asList ( abiList . split ( " , " )  )  ;  } } List < String >  abis ;  if  ( sdkVersion  > = lollipopVersion )  { abis = VersionDependent . getSupportedAbis (  )  ;  } else { abis = Arrays . asList ( abi ,  abi2 )  ;  } int i ;  for  ( String supportedAbi : SysUtil . getSupportedAbis (  )  )  { i = abis . indexOf ( supportedAbi )  ;  if  ( i != -1 )  { supportedAbis . add ( i ,  supportedAbi )  ;  abis . remove ( i )  ;  } else { supportedAbis . add ( supportedAbi )  ;  } } } catch  ( Exception e )  { } return supportedAbis ;  }
void function ( Object arg0 ,  Object arg1 )  { arg0 = new Servidor (  )  ;  arg1 = arg0 . getServer (  )  ;  arg1 . stop (  )  ;  } Note: This implementation assumes that the "Server" class has a method called "stop (  ) " which stops the execution of the server .  The implementation creates a new instance of the "Servidor" class and gets its "Server" object using the "getServer (  ) " method .  The "stop (  ) " method is then called on the "Server" object to stop its execution . 
Map < String ,  String >  function (  )  { Map < String ,  String >  loc0 = new HashMap <  >  (  )  ;  try { HttpURLConnection conn = this . connection ;  Map < String ,  List < String >  >  headers = conn . getHeaderFields (  )  ;  for  ( Map . Entry < String ,  List < String >  >  entry : headers . entrySet (  )  )  { String key = entry . getKey (  )  ;  if  ( key != null )  { List < String >  values = entry . getValue (  )  ;  if  ( values != null && !values . isEmpty (  )  )  { String value = values . get ( 0 )  ;  loc0 . put ( key ,  value )  ;  } } } } catch  ( IOException e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
void function ( List < String >  arg0 ,  String arg1 )  { Iterator < String >  loc0 = arg0 . iterator (  )  ;  while  ( loc0 . hasNext (  )  )  { String loc1 = loc0 . next (  )  ;  if  ( loc1 . equals ( arg1 )  )  { loc0 . remove (  )  ;  break ;  } } }
public static SearchFactory function ( int arg0 ,  int arg1 ,  HeuristicFunction arg2 )  { SearchFactory loc0 = SearchFactory . getInstance (  )  ;  loc0 = new SearchFactory (  )  ;  return loc0 . createSearch ( arg0 ,  arg1 ,  arg2 )  ;  }
void function (  )  { System . out . println ( "Test of listComPorts method ,  of class ComPortController . " )  ;  ComPortController . listComPorts (  )  ;  fail (  )  ;  }
public void function (  )  { String arg0 = "invalid . class . name" ;  String arg1 = "message" ;  ExpectedException loc0 = ExpectedException . none (  )  ;  loc0 . expect ( ProviderNotFoundException . class )  ;  loc0 . expectMessage ( "Class " + arg0 + " is not a provider" )  ;  new CustomAuthenticationProvider ( arg0 )  ;  getName (  )  ;  expect ( ProviderNotFoundException . class )  ;  expectMessage ( "Class " + arg0 + " is not a provider" )  ;  mockCustomProvider (  )  ;  }
String function ( String arg0 )  { String loc0 = arg0 + " error description" ;  OAuthError error = new OAuthError (  )  ;  error . setErrorDescription ( loc0 )  ;  String loc1 = error . getErrorDescription (  )  ;  return loc1 ;  }
boolean function ( String arg0 )  { boolean loc0 = lhsscan . hasField ( arg0 )  ;  boolean loc1 = prodscan . hasField ( arg0 )  ;  return loc0 || loc1 ;  }
public List < SinkInfo >  function ( String arg0 )  { List < SinkInfo >  loc0 = findSinkByMethodSignature ( arg0 )  ;  if  ( !isEmpty (  )  )  { System . out . println ( "This result object contains at least one sink . " )  ;  } return loc0 ;  }
Here's the modified "PasswordTest" Java class with the requested changes: ``` import org . junit . Assert ;  import org . junit . Test ;  import org . apache . poi . poifs . filesystem . POIFSFileSystem ;  import org . apache . poi . poifs . filesystem . DocumentFactoryHelper ;  import org . apache . poi . hsmf . datatypes . MessageProperties ;  import org . apache . poi . hsmf . datatypes . MessageProperty ;  import org . apache . poi . hsmf . datatypes . MessageClass ;  import org . apache . poi . hsmf . datatypes . PropertyValue ;  import org . apache . poi . hsmf . datatypes . Types ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . MessageChunks ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . ChunkType ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . ChunkId ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . ChunkEntry ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . ChunkNotFoundException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . ChunkParseException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . ChunkVerifyException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . ChunkIgnoredException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . ChunkUnrecognisedException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . OutOfRangeException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . NullChunkException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . IllegalChunkDataException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . IllegalChunkDataSizeException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . IllegalPropertySetDataException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . UnsupportedPropertySetTypeException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . UnsupportedVariantTypeException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . UnexpectedPropertySetTypeException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . UnexpectedPropertySetLengthException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . InvalidPropertySetStreamException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . UnexpectedUnicodeStreamLengthException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . UnexpectedPropertyValueException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . UnexpectedPropertyTypeException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . UnexpectedPropertyLengthException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . PropertyNotFoundException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . VariantTypeException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . PropertySetStream ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . Property ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . PropertySet ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . PropertySetFactory ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . PropertySetFactoryException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . PropertyFactoryException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . PropertyValueFactoryException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . VariantTypeFormatException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . NoChunkException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . NoDocumentException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . NoSummaryInformationException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . SummaryInformationParseException ;  import org . apache . poi . hsmf . parsers . POIFSChunkParser . DocumentSummaryInformationParseException ;  import org . apache
void function ( String arg0 ,  double arg1 ,  double arg2 )  { double dir = Math . PI ;  double dist = getDistance ( "ref" ,  arg0 )  ;  double x = dist * Math . cos ( dir )  + arg1 ;  double y = dist * Math . sin ( dir )  + arg2 ;  Point2D loc0 = new Point2D . Double ( x ,  y )  ;  links . addVertex ( arg0 )  ;  locationPositions . put ( arg0 ,  loc0 )  ;  }
public List < String >  function (  )  { try { return mnemonicCode ;  } catch  ( Exception loc0 )  { return null ;  } }
int function ( String arg0 )  { int loc0 ;  try { loc0 = offsets . get ( arg0 )  ;  } catch  ( NullPointerException e )  { loc0 = -1 ;  } return loc0 ;  }
public class SampleDevicesServiceActivator implements BundleActivator { IEnvironments environments = null ;  HashMap < String ,  DevicesConnectionFactory >  factories = new HashMap < String ,  DevicesConnectionFactory >  (  )  ;  AutoSIMDevicesConfig config = null ;  public void start ( BundleContext context )  { } public void stop ( BundleContext context )  { function ( context )  ;  } void function ( BundleContext arg0 )  { for  ( AutoSIMDeviceConfig loc0 : config . devices )  { environments . deregisterConnectionFactory ( loc0 . name )  ;  factories . remove ( loc0 . name )  ;  } } }
LineageStore { boolean function ( Map < Long ,  Lineage >  arg0 ,  Long arg1 )  { return arg0 . containsKey ( arg1 )  ;  } }
void function ( Object arg0 ,  Object arg1 )  { IFetcherExecutionContext loc0 = fetcherExecutionContextImpl ;  loc0 . captureSourceMetadata (  )  ;  StepContribution contribution =  ( StepContribution )  arg0 ;  contribution . setExitStatus ( JobExitStatus . getExitStatus ( ExitStatus . COMPLETED )  )  ;  RepeatStatus loc1 = RepeatStatus . FINISHED ;  }
public int function ( int arg0 ,  int arg1 ,  boolean arg2 ,  boolean arg3 )  { try { View loc0 = findOneVisibleChild ( arg0 ,  arg1 ,  arg2 ,  arg3 )  ;  int loc1 = recyclerView . getChildAdapterPosition ( loc0 )  ;  return loc1 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return -1 ;  // or some other error value } }
public String function ( ConfigurationKey arg0 ,  String arg1 )  { String loc0 = "" ;  try { loc0 = config . getString ( arg0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
int function ( Buffer arg0 ,  int arg1 ,  String arg2 ,  String arg3 )  { Block loc0 = arg0 . block ( arg1 )  ;  if  ( isTempBlock ( loc0 )  )  { return -1 ;  } else { int loc1 = RecoveryMgr . SetStringRecord . writeToLog ( arg2 ,  arg3 )  ;  return loc1 ;  } }
/** * Calls the GenericJSONBuilder's "function" method with the given arguments * and the "place_name" member variable ,  and returns the result .  * *  @ param arg0 The first argument to pass to the "function" method *  @ param arg1 The second argument to pass to the "function" method *  @ param arg2 The third argument to pass to the "function" method *  @ param arg3 The fourth argument to pass to the "function" method *  @ param arg4 The fifth argument to pass to the "function" method *  @ return The result of calling the "function" method with the given arguments and the "place_name" member variable */ public String function ( String arg0 ,  String arg1 ,  String arg2 ,  int arg3 ,  double arg4 )  { try { GenericJSONBuilder loc0 = new GenericJSONBuilder (  )  ;  loc0 . setIDstr ( this . id_str )  ;  loc0 . addField ( "place_name" ,  this . place_name )  ;  loc0 . addField ( "user_name" ,  this . user_name )  ;  loc0 . setCreatedTime ( this . created_at )  ;  loc0 . setCoordinate ( this . lng ,  this . lat )  ;  loc0 . setCoordinateRadius ( this . loc_radius )  ;  loc0 . setUserid ( this . user_id )  ;  loc0 . setAuthor ( this . screen_name ,  "unknown" )  ;  loc0 . setImage ( this . image )  ;  loc0 . addText ( this . text )  ;  for  ( String loc1 : this . extras )  { loc0 . addField ( "extra" ,  loc1 )  ;  } loc0 . addField ( "arg0" ,  arg0 )  ;  loc0 . addField ( "arg1" ,  arg1 )  ;  loc0 . addField ( "arg2" ,  arg2 )  ;  loc0 . addField ( "arg3" ,  String . valueOf ( arg3 )  )  ;  loc0 . addField ( "arg4" ,  String . valueOf ( arg4 )  )  ;  return loc0 . builder (  )  . buildFieldJSON (  )  ;  } catch  ( Exception loc2 )  { System . err . println ( "An error occurred while calling the GenericJSONBuilder's \"function\" method: " + loc2 . getMessage (  )  )  ;  return "Not required" ;  } }
public void function ( boolean ignoreComments )  { DiffBuilder diffBuilder = new DiffBuilder (  )  ;  diffBuilder . checkForIdentical (  )  ;  diffBuilder . checkForSimilar (  )  ;  diffBuilder . withDifferenceListeners ( new ArrayList <  >  (  )  )  ;  diffBuilder . withComparisonListeners ( new ArrayList <  >  (  )  )  ;  diffBuilder . withNamespaceContext ( new HashMap <  >  (  )  )  ;  diffBuilder . withAttributeFilter ( attr - >  true )  ;  diffBuilder . withNodeMatcher ( null )  ;  diffBuilder . withNodeFilter ( node - >  true )  ;  diffBuilder . withDifferenceEvaluator ( DifferenceEvaluators . Default )  ;  diffBuilder . withComparisonController ( ComparisonControllers . Default )  ;  diffBuilder . withTest ( null )  ;  diffBuilder . wrap ( null )  ;  diffBuilder . getSource ( null )  ;  diffBuilder . getDifferences (  )  ;  diffBuilder . normalizeWhitespace (  )  ;  diffBuilder . compare ( null )  ;  if  ( ignoreComments )  { diffBuilder . ignoreWhitespace (  )  ;  diffBuilder . withTest ( null )  ;  diffBuilder . compare ( null )  ;  diffBuilder . getSource ( null )  ;  } diffBuilder . build (  )  ;  }
ResponseEntity < Void >  function (  @ PathVariable String arg0 )  { log . debug ( "REST request to delete DishCollection : {}" ,  arg0 )  ;  dishCollectionService . delete ( arg0 )  ;  return ResponseEntity . ok (  )  . headers ( HeaderUtil . createEntityDeletionAlert ( "DishCollection" ,  arg0 )  )  . build (  )  ;  }
public static Pair < Map < RandomVariable , Object >  ,  Double >  function ( BayesianNetwork arg0 ,  AssignmentProposition [  ]  arg1 ,  RandomVariable [  ]  arg2 ,  int arg3 )  { Map < RandomVariable ,  Object >  loc0 = new HashMap <  >  (  )  ;  double loc1 = 0 . 0 ;  for  ( int i = 0 ;  i  <  arg3 ;  i ++  )  { Pair < Map < RandomVariable ,  Object >  ,  Double >  loc2 = weightedSample ( arg0 ,  arg1 )  ;  Map < RandomVariable ,  Object >  loc3 = loc2 . getLeft (  )  ;  double loc4 = loc2 . getRight (  )  ;  for  ( RandomVariable rv : loc3 . keySet (  )  )  { loc0 . put ( rv ,  loc3 . get ( rv )  )  ;  } loc1 += loc4 ;  } for  ( int i = 0 ;  i  <  arg2 . length ;  i ++  )  { if  ( !loc0 . containsKey ( arg2 [ i ]  )  )  { loc0 . put ( arg2 [ i ]  ,  null )  ;  } } double [  ]  loc5 = new double [ arg2 . length ]  ;  for  ( int i = 0 ;  i  <  arg3 ;  i ++  )  { Pair < Map < RandomVariable ,  Object >  ,  Double >  loc6 = weightedSample ( arg0 ,  arg1 )  ;  Map < RandomVariable ,  Object >  loc7 = loc6 . getLeft (  )  ;  double loc8 = loc6 . getRight (  )  ;  for  ( int j = 0 ;  j  <  arg2 . length ;  j ++  )  { loc5 [ j ]  +=  ( loc7 . get ( arg2 [ j ]  )  != null && loc7 . get ( arg2 [ j ]  )  . equals ( loc0 . get ( arg2 [ j ]  )  )  )  ? loc8 : 0 . 0 ;  } } double loc9 = 0 . 0 ;  for  ( int i = 0 ;  i  <  loc5 . length ;  i ++  )  { loc9 += loc5 [ i ]  ;  } for  ( int i = 0 ;  i  <  loc5 . length ;  i ++  )  { loc5 [ i ]  /= loc9 ;  } return new Pair <  >  ( loc0 ,  loc5 )  ;  }
int function ( Object arg0 ,  int arg1 ,  boolean arg2 )  { int hash = hashCode ( arg0 )  ;  int index = hash &  ( _prime - 1 )  ;  Object key = _keys [ index ]  ;  int value = _values [ index ]  ;  while  ( key != null )  { if  ( key == arg0 || key . equals ( arg0 )  )  { if  ( arg2 )  { _values [ index ]  = arg1 ;  } return value ;  } index =  ( index + 1 )  &  ( _prime - 1 )  ;  key = _keys [ index ]  ;  value = _values [ index ]  ;  } _keys [ index ]  = arg0 ;  _values [ index ]  = arg1 ;  _size ++  ;  if  ( _size  >   ( _prime  >  >  1 )  )  { resize ( _prime  <  <  1 )  ;  } return NULL ;  }
byte [  ]  function (  )  { int loc0 = getByteArrayLength (  )  ;  byte [  ]  loc1 = new byte [ loc0 ]  ;  getByteArrayInternal ( loc0 ,  loc1 ,  0 ,  loc0 )  ;  return loc1 ;  }
void function ( String arg0 )  { SAMLSSOReqValidationResponseDTO loc0 = new SAMLSSOReqValidationResponseDTO ( arg0 )  ;  SPInitLogoutRequestProcessor loc1 = new SPInitLogoutRequestProcessor (  )  ;  loc1 . process ( null ,  loc0 . getSessionIndex (  )  ,  null )  ;  }
void function ( Object arg0 ,  PropertyChangeListener arg1 ,  String arg2 ,  String [  ]  arg3 )  { try { addElementListener ( arg1 ,  arg0 ,  arg2 ,  arg3 )  ;  } catch  ( Exception e )  { LOG . error ( "Error adding listener" ,  e )  ;  } }
class Mapping { long tStart ,  qStart ,  tStop ;  int blockSize ;  long getQStart (  )  { return qStart ;  } int getBlockSize (  )  { return blockSize ;  } long getTStop (  )  { return tStop ;  } void function (  )  { long arg0 = getQStart (  )  ;  int arg1 = getBlockSize (  )  ;  long loc0 = tStop ;  } }
public Object function (  )  { Object loc0 = null ;  try { loc0 = new ObjectFactory (  )  . createRegistrationRequest (  )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
List < File >  function ( File arg0 ,  boolean arg1 ,  SuffixFilter [  ]  arg2 ,  ProgressMonitor arg3 )  { List < File >  matchingFiles = new ArrayList <  >  (  )  ;  if  ( arg0 != null && arg0 . isDirectory (  )  )  { File [  ]  files = arg0 . listFiles (  )  ;  for  ( int loc0 = 0 ;  loc0  <  files . length ;  loc0 ++  )  { File file = files [ loc0 ]  ;  if  ( file . isDirectory (  )  && arg1 )  { matchingFiles . addAll ( function ( file ,  arg1 ,  arg2 ,  arg3 )  )  ;  } else { String fileName = file . getName (  )  ;  if  ( fileName != null )  { for  ( SuffixFilter filter : arg2 )  { if  ( fileName . endsWith ( filter . getSuffix (  )  )  )  { matchingFiles . add ( file )  ;  break ;  } } } } } } return matchingFiles ;  }
public Object function ( Object arg0 ,  Object arg1 )  { Object loc0 = signatureCrypto ;  return loc0 ;  }
public void function (  )  { try { instance . maxMemory = 0 ;  System . gc (  )  ;  Thread . sleep ( 100 )  ;  checkMemory (  )  ;  } catch  ( InterruptedException e )  { System . err . println ( "Error resetting max memory: " + e . getMessage (  )  )  ;  } }
void function ( File arg0 )  { try { setSourceCodeFilename ( arg0 . getName (  )  )  ;  if  ( arg0 . exists (  )  )  { getSourceCodeFile (  )  . delete (  )  ;  } setSourceCodeFile ( arg0 )  ;  } catch  ( Exception loc0 )  { if  ( !isIgnoreExceptions (  )  )  { getReport (  )  . addError ( new Report . Error ( "Unable to set source code file: " + loc0 . getMessage (  )  )  )  ;  } } }
void function ( Node arg0 )  { try { closed . removeValue ( arg0 )  ;  } catch  ( Exception e )  { System . out . println ( "An error occurred while removing the node from the closed list: " + e . getMessage (  )  )  ;  } }
String function (  )  { String loc0 = null ;  try { loc0 = new String ( _messageBody ,  Charset . forName ( _encoding )  )  ;  } catch  ( Exception e )  { loc0 = "rubbish" ;  } return loc0 ;  }
void function ( Path arg0 ,  int [  ]  arg1 )  { model . moveCharacter ( arg0 ,  arg1 )  ;  triggerEvent (  )  ;  }
boolean function ( boolean arg0 )  { boolean loc0 = ignoreExceptions ;  ignoreExceptions = arg0 ;  return loc0 ;  }
String function ( Iterable < String >  arg0 ,  char arg1 )  { StringBuilder loc0 = new StringBuilder (  )  ;  for  ( String loc1 : arg0 )  { if  ( loc0 . length (  )   >  0 )  { loc0 . append ( arg1 )  ;  } loc0 . append ( loc1 )  ;  } return loc0 . toString (  )  ;  }
void function ( Map < String ,  SortedSet < String >  >  arg0 ,  String arg1 ,  SortedSet < String >  arg2 )  { Set < String >  keys = arg0 . keySet (  )  ;  for  ( String key : keys )  { SortedSet < String >  values = arg0 . get ( key )  ;  if  ( values == null )  { values = new TreeSet <  >  (  )  ;  } if  ( key . equals ( arg1 )  )  { values . addAll ( arg2 )  ;  arg0 . put ( key ,  values )  ;  return ;  } } arg0 . put ( arg1 ,  arg2 )  ;  }
public int function ( GroupValue arg0 )  { int hash = 0 ;  try { Map < String ,  Constant >  vals = arg0 . vals (  )  ;  Set < String >  keys = vals . keySet (  )  ;  for  ( String key : keys )  { Constant loc0 = arg0 . getVal ( key )  ;  hash += loc0 . hashCode (  )  ;  } } catch  ( NullPointerException e )  { hash = 0 ;  } return hash ;  }
int function ( int arg0 ,  int arg1 )  { int loc0 = arg0 ;  int loc1 = arg1 ;  int nextAvailableTile = -1 ;  for  ( int i = BattleMap . tiles [ loc0 ]  [ loc1 ]  . length - 1 ;  i  > = 0 ;  i --  )  { if  ( BattleMap . tiles [ loc0 ]  [ loc1 ]  [ i ]  == null )  { nextAvailableTile = i ;  break ;  } } return nextAvailableTile ;  }
public String function ( String arg0 ,  String arg1 )  { Element loc0 = getToken (  )  ;  Element loc1 = loc0 . getOwnerDocument (  )  . createElementNS ( null ,  "Identifier" )  ;  loc1 . setTextContent ( arg0 )  ;  Element loc2 = loc0 . getOwnerDocument (  )  . createElementNS ( null ,  "TransformedID" )  ;  loc2 . setAttributeNS ( null ,  "TokenIdentifier" ,  arg1 )  ;  loc2 . appendChild ( loc1 )  ;  loc0 . appendChild ( loc2 )  ;  setTransformedTokenIdentifier ( arg1 )  ;  return arg1 ;  }
void function ( String arg0 )  { try { loadedInCats = arg0 ;  } catch  ( Exception loc0 )  { System . out . println ( "An exception occurred while setting loaded in cats: " + loc0 . getMessage (  )  )  ;  } }
public int function (  )  { int totalDecisions = 0 ;  try { totalDecisions = this . decisions + this . germlineWhitelistAccepts + this . mutationStatusNoneRejects + this . emptyAnnotationRejects + this . lohOrWildTypeRejects + this . silentOrIntronRejects + this . missenseGermlineRejects + this . unknownAccepts + this . redactedRejects + this . somaticWhitelistAccepts + this . igrRejects + this . utrRejects ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return totalDecisions ;  }
String function ( DateTime arg0 ,  Date arg1 )  { String loc0 = null ;  try { loc0 = arg0 . formatUTC ( arg1 ,  DateTimeFormat . SQL ,  true )  ;  } catch  ( Exception e )  { } return loc0 ;  }
public int function (  )  { int loc0 = 0 ;  try { loc0 = mSize ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
import java . util . prefs . Preferences ;  import java . util . logging . Logger ;  import java . util . logging . Level ;  public class Prefs { boolean s_newVersion = false ;  boolean s_installed ;  Logger LOG = LoggerFactory . getLogger ( Prefs . class )  ;  boolean s_newVersionSet = false ;  void function (  )  { Preferences prefs = Preferences . userRoot (  )  ;  double loc0 = prefs . getDouble ( "lastVersion" ,  0 . 0 )  ;  double loc1 = getVersion (  )  ;  if  ( loc0 != loc1 )  { LOG . log ( Level . INFO ,  "Updating lastVersion to {0}" ,  loc1 )  ;  try { prefs . putDouble ( "lastVersion" ,  loc1 )  ;  prefs . flush (  )  ;  } catch  ( Exception e )  { LOG . log ( Level . WARNING ,  "Unable to save lastVersion" ,  e )  ;  } } } void setInstalled ( final boolean installed )  { s_installed = installed ;  } boolean isInstalled (  )  { return s_installed ;  } long setId (  )  { return 0L ;  } long getId (  )  { return 0L ;  } boolean newVersion (  )  { return s_newVersion ;  } boolean hasId (  )  { return false ;  } boolean running (  )  { return false ;  } double getLastVersion (  )  { return 0 . 0 ;  } String getBaseUri (  )  { return null ;  } File getTorrentDir (  )  { return null ;  } double getVersion (  )  { return 1 . 0 ;  } }
public String function (  )  { try { InetAddress loc0 = InetAddress . getLocalHost (  )  ;  if  ( loc0 != null )  { return loc0 . getHostName (  )  ;  } } catch  ( UnknownHostException loc1 )  { System . err . println ( "Unable to determine hostname: " + loc1 . getMessage (  )  )  ;  } return null ;  }
public void function ( RepositoryCommit arg0 )  { if  ( arg0 == null )  { return ;  } if  ( commits . contains ( arg0 )  )  { return ;  } commits . add ( arg0 )  ;  }
import static org . junit . Assert . assertEquals ;  public void function (  )  { try { int loc0 = cal . get ( Calendar . MONTH )  ;  int loc1 = instance . getMonth (  )  ;  assertEquals ( loc0 ,  loc1 )  ;  } catch  ( Exception e )  { } }
TableInfo function ( String arg0 ,  String arg1 )  { TableInfo ti = new TableInfo ( arg0 ,  arg1 )  ;  Schema schema = ti . schema (  )  ;  int recordLength = schema . recordLength (  )  ;  int searchCost = HashIndex . searchCost ( ti . numIndexBlocks (  )  ,  ti . numIndexRecordsPerBlock (  )  )  ;  int outputRecords = si . recordsOutput (  )  ;  return ti ;  }
void function ( Node [  ]  arg0 ,  RuleContext arg1 ,  Language language )  { RuleChainVisitor ruleChainVisitor = languageToRuleChainVisitor . get ( language )  ;  ruleChainVisitor . visitAll ( arg0 ,  arg1 )  ;  }
public Builder function ( AddressPair arg0 )  { Builder loc0 = Builder . fromAddressPair ( arg0 )  ;  return loc0 ;  }
Element function ( String arg0 ,  int arg1 )  { Element loc0 = document . createElement ( "error" )  ;  Element loc1 = errorElement . getOwnerDocument (  )  . getDocumentElement (  )  ;  loc1 . appendChild ( loc0 )  ;  loc0 . setAttribute ( "number" ,  String . valueOf ( arg1 )  )  ;  if  ( arg0 != null && !arg0 . isEmpty (  )  )  { loc0 . setAttribute ( "message" ,  arg0 )  ;  } return loc0 ;  }
void function ( final String arg0 ,  final String arg1 )  { try { final String loc0 = arg0 . replaceAll ( "\\W" ,  "_" )  ;  this . instanceName = loc0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
boolean function ( Combination arg0 )  { boolean loc0 = true ;  if  ( configurations . containsKey ( arg0 . toString (  )  )  )  { loc0 = configurations . get ( arg0 . toString (  )  )  ;  } return loc0 ;  }
void function ( boolean arg0 )  { progressMonitor . setConsoleModeAndParseShowProgress ( new String [  ] {String . valueOf ( arg0 ) } )  ;  }
String function ( String arg0 ,  String arg1 )  { StringBuilder sb = new StringBuilder (  )  ;  String paramValue = HTTPTransportUtils . getRawQueryStringParameter ( arg0 ,  arg1 )  ;  if  ( paramValue != null )  { sb . append ( arg1 )  . append ( "=" )  . append ( paramValue )  ;  } return sb . toString (  )  ;  }
Object function ( Object arg0 ,  Object arg1 )  { String name =  ( String )  arg0 ;  if  ( name . equals ( "dim" )  )  { return dim ;  } else { return Scriptable . NOT_FOUND ;  } }
Vector function ( Object arg0 ,  Object arg1 )  { Vector loc0 = new Vector (  )  ;  try { List loc1 = getNewFeaturesList (  )  ;  for  ( Object loc2 : loc1 )  { if  ( ! (  ( Vector )  arg0 )  . contains ( loc2 )  )  { loc0 . add ( loc2 )  ;  } } } catch  ( Exception loc3 )  { } return loc0 ;  }
public ClassStats function ( ClassStats thisClass ,  String className )  { ClassStats nestedClass = null ;  try { if  ( thisClass . nestedClasses . containsKey ( className )  )  { nestedClass = thisClass . nestedClasses . get ( className )  ;  } } catch  ( Exception e )  { System . err . println ( "Exception occurred while checking for nested class: " + e . getMessage (  )  )  ;  } return nestedClass ;  }
void function ( String arg0 )  { gene = arg0 ;  }
void function ( String arg0 )  { addResourceLocation ( arg0 )  ;  boolean locationExists = containsLocation ( arg0 )  ;  System . out . println ( "Location exists: " + locationExists )  ;  }
public void function ( Entry arg0 )  { if  ( mIsClosed )  { throw new IOException ( "Cannot write to a closed journal writer . " )  ;  } try { long loc0 = mNextEntrySequenceNumber ;  arg0 . toBuilder (  )  . setSequenceNumber ( loc0 )  . build (  )  . getJournalFormatter (  )  . serialize ( mCheckpointOutputStream )  ;  mNextEntrySequenceNumber ++  ;  mDataOutputStream . flush (  )  ;  } catch  ( IOException loc1 )  { LOG . error ( "Failed to write entry to checkpoint file: " + loc1 . getMessage (  )  )  ;  } }
boolean function ( byte arg0 )  { boolean [  ]  loc0 = new boolean [ 128 ]  ;  loc0 [ 0 ]  = true ;  loc0 [ 9 ]  = true ;  loc0 [ 10 ]  = true ;  loc0 [ 13 ]  = true ;  loc0 [ 32 ]  = true ;  loc0 [ 33 ]  = true ;  loc0 [ 34 ]  = true ;  loc0 [ 35 ]  = true ;  loc0 [ 36 ]  = true ;  loc0 [ 37 ]  = true ;  loc0 [ 38 ]  = true ;  loc0 [ 39 ]  = true ;  loc0 [ 40 ]  = true ;  loc0 [ 41 ]  = true ;  loc0 [ 42 ]  = true ;  loc0 [ 43 ]  = true ;  loc0 [ 44 ]  = true ;  loc0 [ 45 ]  = true ;  loc0 [ 46 ]  = true ;  loc0 [ 47 ]  = true ;  loc0 [ 58 ]  = true ;  loc0 [ 59 ]  = true ;  loc0 [ 60 ]  = true ;  loc0 [ 61 ]  = true ;  loc0 [ 62 ]  = true ;  loc0 [ 63 ]  = true ;  loc0 [ 64 ]  = true ;  loc0 [ 91 ]  = true ;  loc0 [ 92 ]  = true ;  loc0 [ 93 ]  = true ;  loc0 [ 94 ]  = true ;  loc0 [ 95 ]  = true ;  loc0 [ 96 ]  = true ;  loc0 [ 123 ]  = true ;  loc0 [ 124 ]  = true ;  loc0 [ 125 ]  = true ;  loc0 [ 126 ]  = true ;  return loc0 [ arg0 ]  ;  }
void function ( String arg0 ,  CookieSpecFactory arg1 )  { try { if  ( arg0 == null || arg0 . trim (  )  . isEmpty (  )  )  { throw new IllegalArgumentException ( "Invalid cookie spec name" )  ;  } String loc0 = arg0 . toLowerCase ( Locale . ENGLISH )  ;  registeredSpecs . put ( loc0 ,  arg1 )  ;  } catch  ( Exception e )  { } }
public void function ( BoundingBox arg0 ,  BoundingBox arg1 )  { float loc0 = Math . max ( arg0 . latMin ,  arg1 . latMin )  ;  float loc1 = Math . min ( arg0 . latMax ,  arg1 . latMax )  ;  if  ( loc0  < = loc1 )  { this . latMin = loc0 ;  this . latMax = loc1 ;  } loc0 = Math . max ( arg0 . lonMin ,  arg1 . lonMin )  ;  loc1 = Math . min ( arg0 . lonMax ,  arg1 . lonMax )  ;  if  ( loc0  < = loc1 )  { this . lonMin = loc0 ;  this . lonMax = loc1 ;  } }
ExtensionMechanismsHelper function (  )  { return impl ;  }
GeneralRange < T >  function ( Comparator < ? super T >  arg0 ,  BoundType arg1 ,  T arg2 ,  boolean arg3 ,  BoundType arg4 ,  T arg5 )  { GeneralRange < T >  loc0 = new GeneralRange <  >  (  )  ;  loc0 . comparator = arg0 ;  loc0 . lowerBoundType = arg1 ;  loc0 . lowerEndpoint = arg2 ;  loc0 . hasLowerBound = arg3 ;  loc0 . upperBoundType = arg4 ;  loc0 . upperEndpoint = arg5 ;  return loc0 ;  }
import java . io . * ;  import net . sourceforge . pmd . * ;  import net . sourceforge . pmd . lang . Language ;  import net . sourceforge . pmd . lang . LanguageVersion ;  import net . sourceforge . pmd . lang . LanguageVersionHandler ;  import net . sourceforge . pmd . lang . ast . Node ;  import net . sourceforge . pmd . renderers . Renderer ;  import net . sourceforge . pmd . renderers . XMLRenderer ;  import net . sourceforge . pmd . RuleContext ;  import net . sourceforge . pmd . RuleSets ;  public class SourceCodeProcessor { PMDConfiguration configuration ;  Node parse ( RuleContext ctx ,  Reader sourceCode ,  Parser parser )  { /* implementation omitted */ } void symbolFacade ( Node rootNode ,  LanguageVersionHandler languageVersionHandler )  { /* implementation omitted */ } void usesMetrics ( LanguageVersion languageVersion ,  Node rootNode ,  RuleSets ruleSets ,  Language language )  { /* implementation omitted */ } void processSource ( Reader sourceCode ,  RuleSets ruleSets ,  RuleContext ctx )  { /* implementation omitted */ } void usesTypeResolution ( LanguageVersion languageVersion ,  Node rootNode ,  RuleSets ruleSets ,  Language language )  { /* implementation omitted */ } void determineLanguage ( RuleContext ctx )  { /* implementation omitted */ } void usesDFA ( LanguageVersion languageVersion ,  Node rootNode ,  RuleSets ruleSets ,  Language language )  { /* implementation omitted */ } void function ( InputStreamReader arg0 ,  RuleSets arg1 ,  RuleContext arg2 )  { try { Reader loc0 = new BufferedReader ( arg0 )  ;  configuration . setSourceEncoding ( "UTF-8" )  ;  RuleContext loc1 = new RuleContext (  )  ;  configuration . getLanguageVersionDiscoverer (  )  . getDefaultLanguageVersion ( Language . JAVA )  . setMinimumVersion ( "1 . 8" )  ;  processSource ( new StringReader ( removeComments ( loc0 )  )  ,  arg1 ,  loc1 )  ;  } catch  ( PMDException loc2 )  { System . err . println ( loc2 . getMessage (  )  )  ;  } } private String removeComments ( Reader loc0 )  throws IOException { } }
public void function ( String arg0 ,  ApprovedSiteRepository arg1 )  { try { client . setClientId ( arg0 )  ;  prepare (  )  ;  service . clearApprovedSitesForClient ( client )  ;  ApprovedSite actual = service . getByClientId ( client . getClientId (  )  )  ;  assertThat ( actual )  . isNull (  )  ;  verify ( arg1 ,  never (  )  )  . remove ( any ( ApprovedSite . class )  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function ( String arg0 ,  String arg1 )  { String loc0 = arg0 . trim (  )  ;  String loc1 = arg1 . trim (  )  ;  try { mapping . put ( loc0 ,  loc1 )  ;  writer . setPrefix ( loc0 ,  loc1 )  ;  } catch  ( XMLStreamException loc2 )  { loc2 . printStackTrace (  )  ;  } catch  ( SAXException loc3 )  { loc3 . printStackTrace (  )  ;  } }
ClassLoader function ( ClassLoader arg0 ,  Class < ? >  [  ]  arg1 )  { ProxyHelper helper = ProxyHelper . HELPER ;  if  ( helper . canSeeAllInterfaces ( arg0 ,  arg1 )  )  { return arg0 ;  } else { ClassLoader loc0 = arg0 ;  ClassLoader [  ]  loc1 = new ClassLoader [ arg1 . length ]  ;  for  ( int i = 0 ;  i  <  arg1 . length ;  i ++  )  { loc1 [ i ]  = arg1 [ i ]  . getClassLoader (  )  ;  } return new ProxyClassLoader ( loc0 ,  loc1 )  ;  } }
private void function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { try { BlockStoreContext context = BlockStoreContext . get (  )  ;  long loc0 =  ( long )  arg1 ;  byte [  ]  loc1 = BufferUtils . getIncreasingByteArray (  ( int )  loc0 )  ;  TestBufferedBlockOutStream loc2 = new TestBufferedBlockOutStream ( context ,   ( long )  arg2 )  ;  this . mTestStream = loc2 ;  this . BLOCK_LENGTH = loc0 ;  this . INCREASING_BYTES = loc1 ;  this . mThrown = ExpectedException . none (  )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } }
Constant function ( String arg0 )  { int loc0 = sch . fieldNumber ( arg0 )  ;  if  ( sch . type ( loc0 )  == Type . INTEGER )  { return new IntConstant ( getInt ( arg0 )  )  ;  } else { return new StringConstant ( getString ( arg0 )  )  ;  } }
public NodeVisitor function ( Node arg0 )  { NodeVisitor locVisitor = this ;  try { locVisitor = enter ( arg0 )  ;  } catch  ( Throwable locThrowable )  { } if  ( locVisitor == null )  { locVisitor = this ;  } return locVisitor ;  }
ThreadFactoryBuilder function ( ThreadFactoryBuilder arg0 ,  ThreadFactory arg1 )  { try { Object loc0 = Preconditions . checkNotNull ( arg1 ,  "Backing thread factory cannot be null . " )  ;  arg0 . backingThreadFactory =  ( ThreadFactory )  loc0 ;  return arg0 ;  } catch  ( NullPointerException e )  { return arg0 ;  } }
Vector < ClassdiagramNode >  function (  )  { Vector < ClassdiagramNode >  loc0 = new Vector < ClassdiagramNode >  (  )  ;  try { ClassdiagramNode loc1 = new ClassdiagramNode (  )  ;  loc0 = loc1 . downlinks ;  } catch  ( Exception loc2 )  { loc2 . printStackTrace (  )  ;  } return loc0 ;  }
Long function ( TestResultDetailsDTO input )  { Long loc0 = input . getTestId (  )  ;  return loc0 ;  }
class UUIDHelper { String getNewUUID (  )  { } String function ( Object arg0 )  { if  ( arg0 instanceof Owner )  { Owner loc0 =  ( Owner )  arg0 ;  if  ( loc0 . getOwner (  )  == null )  { return null ;  } else if  ( loc0 . getOwner (  )  instanceof Facade )  { Facade loc1 =  ( Facade )  loc0 . getOwner (  )  ;  if  ( loc1 . getUUID (  )  != null )  { return loc1 . getUUID (  )  ;  } } else if  ( loc0 . getUUID (  )  != null )  { return loc0 . getUUID (  )  ;  } } else if  ( arg0 instanceof Facade )  { Facade loc2 =  ( Facade )  arg0 ;  if  ( loc2 . getUUID (  )  != null )  { return loc2 . getUUID (  )  ;  } } return null ;  } }
String function ( String arg0 )  { String loc0 = null ;  try { loc0 = IStoredSettings . getString ( arg0 ,  "" )  ;  if  ( StringUtils . isEmpty ( loc0 )  )  { return 0L ;  } return FileUtils . convertSizeToLong ( loc0 )  ;  } catch  ( Exception e )  { return 0L ;  } }
public static String function ( String input )  { StringBuffer result = new StringBuffer (  )  ;  for  ( int i = 0 ;  i  <  input . length (  )  ;  i ++  )  { char c = input . charAt ( i )  ;  if  (  ( c  > = 'a' && c  < = 'z' )  ||  ( c  > = 'A' && c  < = 'Z' )  ||  ( c  > = '0' && c  < = '9' )  || c == '-' || c == '_' || c == ' . ' || c == '!' || c == '~' || c == '\'' || c == ' ( ' || c == ' ) ' )  { result . append ( c )  ;  } else if  ( c == ' ' )  { result . append ( '+' )  ;  } else if  ( c  < = 0x7f )  { result . append ( hex [ c ]  )  ;  } else { byte [  ]  utf8Bytes ;  try { utf8Bytes = String . valueOf ( c )  . getBytes ( "UTF-8" )  ;  } catch  ( UnsupportedEncodingException e )  { throw new RuntimeException ( "UTF-8 encoding not supported" ,  e )  ;  } for  ( int j = 0 ;  j  <  utf8Bytes . length ;  j ++  )  { result . append ( hex [ utf8Bytes [ j ]  & 0xFF ]  )  ;  } } } return result . toString (  )  ;  }
Timestamp function (  )  { Timestamp loc0 = createdDate ;  return loc0 ;  }
ELEvaluator function ( Configuration arg0 ,  String arg1 ,  Element arg2 ,  Date arg3 ,  Date arg4 ,  String arg5 )  { ELEvaluator loc0 = createInstancesELEvaluator ( arg0 ,  arg1 )  ;  setConfigToEval ( loc0 ,  arg0 )  ;  ELEvaluator loc1 = createLazyEvaluator ( arg3 ,  arg4 ,  arg2 ,  arg0 )  ;  loc0 . setVariable ( "lazyEval" ,  loc1 )  ;  loc0 . setVariable ( "currentTime" ,  arg3 )  ;  loc0 . setVariable ( "nominalTime" ,  arg4 )  ;  loc0 . setVariable ( "dateFormat" ,  arg5 )  ;  return loc0 ;  }
public class CorbaTypeImpl { QName qname ;  void setQName ( QName value )  { this . qname = value ;  } boolean isSetQName (  )  { return qname != null ;  } QName function (  )  { return qname ;  } }
void function ( TransformerFactory arg0 )  { try { factory = arg0 ;  } catch  ( Exception e )  { errorListener . error ( new TransformerException ( "Failed to set TraX factory: " + e . getMessage (  )  )  )  ;  } }
class IdGenerator { AtomicInteger gen ;  int salt = 0x9e3779b9 ;  short lo16 ( final int in )  { } int mix ( int in )  { } int mix ( final int salt ,  final int in )  { } int result ( final short v0 ,  final short v1 )  { } short hi16 ( final int in )  { } int unmix ( final int in )  { } String format ( int id )  { } void function (  )  { int loc0 = gen . getAndIncrement (  )  ;  int loc1 = mix ( salt + loc0 )  ;  short loc2 = lo16 ( loc1 )  ;  short loc3 = hi16 ( loc1 )  ;  int loc4 = mix ( salt ,  loc2 )  ;  int loc5 = mix ( loc4 ,  loc3 )  ;  int loc6 = result ( loc2 ,  loc3 )  ;  int loc7 = unmix ( loc5 )  ;  int loc8 = mix ( loc7 ,  loc0 )  ;  int loc9 = mix ( salt ,  loc6 )  ;  int loc10 = mix ( loc9 ,  loc8 )  ;  int loc11 = unmix ( loc10 )  ;  String id = format ( loc11 )  ;  System . out . println ( id )  ;  } }
void function ( Object arg0 ,  Object arg1 )  { Endpoint loc0 = getEndpoint (  )  ;  if  ( loc0 != null )  { Conduit loc1 = selectConduit (  ( Message )  arg0 )  ;  if  ( loc1 != null )  { loc1 . close (  ( Message )  arg0 )  ;  } } }
class AbstractExecutionThreadService { Executor function (  )  { Executor loc0 = MoreExecutors . newThread (  )  ;  Executor loc1 = new Executor (  )  {  @ Override public void execute ( Runnable arg0 )  { loc0 . execute ( arg0 )  ;  } } ;  return MoreExecutors . renamingDecorator ( loc1 ,  new Supplier < String >  (  )  {  @ Override public String get (  )  { return serviceName (  )  ;  } } )  . start (  )  ;  } }
public void function (  )  { try { RMBTest test = new RMBTest (  )  ;  String arg0 = "ABC123" ;  test . setOriginId ( arg0 )  ;  assertTrue ( test . toString (  )  . contains ( arg0 )  )  ;  assertEquals ( arg0 ,  test . getOriginId (  )  )  ;  } catch  ( Exception loc0 )  { } }
Object function ( Object arg0 ,  String arg1 )  { Object loc0 = getClassifier (  )  ;  if  ( loc0 == null )  { return null ;  } Collection loc1 = getFeatures ( arg1 )  ;  if  ( loc1 == null )  { return null ;  } for  ( Object loc2 : loc1 )  { if  ( loc2 instanceof ModelFacade )  { Object loc3 =  (  ( ModelFacade )  loc2 )  . getName (  )  ;  if  ( loc3 != null && arg0 . equals ( loc3 )  )  { return loc2 ;  } } } return null ;  }
void function ( AbstractDosPlugin arg0 )  { String loc0 = arg0 . getVersion (  )  ;  }
public Object function ( Object arg0 ,  Object arg1 )  { Object loc0 = null ;  Object loc1 = null ;  Object loc2 = null ;  Object loc3 = null ;  for  ( Object feature : context . getFeatures ( "ownedAttributes" )  )  { if  ( isAAttribute ( feature )  )  { loc0 = Model . getFacade (  )  . getAttributeOwner ( feature )  ;  loc1 = Model . getFacade (  )  . getName ( loc0 )  ;  if  ( Object . equals ( loc1 ,  classnamePrefix )  )  { loc2 = Model . getFacade (  )  . getType ( feature )  ;  loc3 = Model . getFacade (  )  . getName ( loc2 )  ;  if  ( Object . equals ( loc3 ,  arg1 )  )  { return feature ;  } } } } return null ;  }
Timestamp function (  )  { return endDate ;  }
String function ( String arg0 ,  String arg1 ,  String arg2 ,  String arg3 ,  String arg4 ,  String arg5 ,  String arg6 )  { try { String loc0 = String . format ( "MERGE GRAPH  < %s >  FROM  < %s >  REVISION \"%s\" INTO \"%s\" COMMENT \"%s\" BRANCH \"%s\" AND \"%s\"" ,  arg0 ,  ep . getEndpointUrl (  )  ,  arg1 ,  arg2 ,  arg3 ,  arg4 ,  arg5 )  ;  return loc0 . replace ( "%" ,  "%%" )  ;  } catch  ( Exception e )  { return null ;  } }
public String function (  )  { String loc0 = "" ;  try { loc0 = this . getApplicationDescription (  )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
void function (  )  { setUp (  )  ;  instance . setFixStatus ( GSASentence . FixMode . THREE_D )  ;  instance . setSatelliteIds ( new int [  ] {2 ,  0 ,  0 ,  7 ,  0 ,  9 ,  24 ,  26 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0 ,  0} )  ;  instance . setVerticalDOP ( 1 . 0 )  ;  assertEquals ( 1 . 0 ,  instance . getVerticalDOP (  )  ,  0 . 1 )  ;  }
MultivaluedMap < String ,  String >  function ( String arg0 ,  String arg1 )  { MultivaluedMap < String ,  String >  loc0 = new MultivaluedHashMap <  >  (  )  ;  loc0 . putSingle ( "redirect_uri" ,  this . redirectUri )  ;  loc0 . putSingle ( "code" ,  this . code )  ;  return loc0 ;  }
void function (  )  { try { TimeTest obj = new TimeTest (  )  ;  obj . setUp (  )  ;  int arg0 = 30 ;  obj . time . setMinutes ( arg0 )  ;  int loc0 = obj . time . getMinutes (  )  ;  assertEquals ( arg0 ,  loc0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
SignatureProperties function (  )  { SignatureProperties loc0 = null ;  loc0 = this . signatureProperties ;  if  ( loc0 == null )  { loc0 = new SignatureProperties ( this . signaturePropertiesFile )  ;  this . signatureProperties = loc0 ;  } return loc0 ;  }
long function ( K arg0 ,  long arg1 ,  LongBinaryOperator arg2 )  { Objects . requireNonNull ( arg2 )  ;  long loc0 = asMap . compute ( arg0 ,   ( k ,  v )  - >   ( v == null )  ? 0L : v )  ;  return map . compute ( arg0 ,   ( k ,  v )  - >  arg2 . applyAsLong (  ( v == null )  ? 0L : v ,  arg1 )  )  ;  }
class AbstractUmlModelFactoryMDR { void function ( Object arg0 ,  Object arg1 )  { Object loc0 = new modelelement (  )  ;  } }
public Method function ( String arg0 ,  Class < ? >  arg1 ,  Class < ? >  .  .  .  arg2 )  { Method loc0 = null ;  try { loc0 = this . getClass (  )  . getMethod ( arg0 ,  arg1 ,  arg2 )  ;  } catch  ( NoSuchMethodException e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
void function ( Exception loc0 )  { try { String loc1 = getContent ( getCurrentStackTraceElement (  )  )  ;  Log . e ( URLogs . sApplicationTag ,  loc1 + " " + loc0 . getMessage (  )  )  ;  loc0 . printStackTrace (  )  ;  } catch  ( Exception loc2 )  { Log . e ( URLogs . sApplicationTag ,  "Error occurred while logging exception: " + loc2 . getMessage (  )  )  ;  } }
void function ( String arg0 ,  String arg1 )  { OpenTagRegisterTest loc0 = new OpenTagRegisterTest (  )  ;  loc0 . newRegister (  )  ;  loc0 . element ( arg0 )  ;  loc0 . openedIsolatedTag (  )  ;  loc0 . element ( arg1 )  ;  loc0 . openedIsolatedTag (  )  ;  loc0 . closeTag (  )  ;  loc0 . closeTag (  )  ;  assertFalse ( loc0 . isUnclosed (  )  )  ;  assertTrue ( loc0 . tagList . toString (  )  . isEmpty (  )  )  ;  }
void function ( String arg0 )  { srcFileName = arg0 ;  }
IConfigurationFactory function (  )  { return SINGLETON ;  }
boolean function ( String arg0 ,  Constant arg1 )  { boolean loc0 = false ;  s2 . beforeFirst (  )  ;  while  ( s2 . next (  )  )  { if  ( s2 . getString ( "fldname" )  . equals ( arg0 )  )  { loc0 = true ;  break ;  } } if  ( !loc0 )  { s1 . beforeFirst (  )  ;  while  ( s1 . next (  )  )  { if  ( s1 . hasField ( "fldname" )  && s1 . getString ( "fldname" )  . equals ( arg0 )  )  { loc0 = true ;  break ;  } } } if  ( loc0 && arg1 . getInt ( "fldname" )  == 0 )  { return true ;  } else { return false ;  } }
V function (  )  { V loc0 = value ;  return loc0 ;  }
public int function ( int arg0 ,  int arg1 )  { try { int loc0 = xPosition + arg0 ;  int loc1 = yPosition + arg1 ;  if  ( loc0  <  0 )  { throw new RuntimeException ( "Invalid horizontal position" )  ;  } return loc0 ;  } catch  ( Exception e )  { System . err . println ( "An error occurred while calculating the horizontal position: " + e . getMessage (  )  )  ;  return -1 ;  } }
public static long function ( byte [  ]  arg0 ,  int arg1 ,  int arg2 )  { int loc0 = arg1 ;  int loc1 = arg2 ;  long loc2 = 0 ;  while  ( loc1  >  0 )  { loc2 +=  ( arg0 [ loc0 ++  ]  & 0xffL )   <  <  8 ;  loc1 --  ;  if  ( loc1 == 0 )  { break ;  } loc2 +=  ( arg0 [ loc0 ++  ]  & 0xffL )  ;  loc1 --  ;  } return loc2 ;  }
private void function ( Collection arg0 )  { try { if  ( CollectionUtils . exists ( arg0 ,  PredicateUtils . nullPredicate (  )  )  )  { throw new NullPointerException ( "One or more buffers in the collection is null . " )  ;  } } catch  ( NullPointerException e )  { LOG . error ( "NullPointerException in function (  ) : " + e . getMessage (  )  )  ;  throw e ;  } }
void function (  )  { long loc0 = -22 ;  long loc1 = 11 ;  long loc2 = 33 ;  RPCFileReadRequestTest test = new RPCFileReadRequestTest (  )  ;  test . before (  )  ;  RPCFileReadRequest req = new RPCFileReadRequest ( loc1 ,  loc0 ,  loc2 )  ;  test . assertInvalid ( req )  ;  }
boolean function ( char arg0 )  { if  ( tok . ttype == arg0 )  { nextToken (  )  ;  return true ;  } else { return false ;  } }
public static void function ( boolean arg0 ,  String arg1 )  { try { Assert . state ( arg0 ,  arg1 )  ;  } catch  ( IllegalArgumentException ex )  { throw new IllegalArgumentException ( ex . getMessage (  )  )  ;  } }
import org . powermock . reflect . Whitebox ;  public class LoginUserTestUtils { public static void function (  )  { Whitebox . setInternalState ( LoginUser . class ,  "srini_string" ,   ( String ) null )  ;  } }
import java . util . * ;  public class CollectionUtil { public static  < T >  List < T >  add ( List < T >  l ,  T o )  { } public static  < U ,  V >  U firstOrElse ( Collection < U >  l ,  V alt )  { } public static  < T ,  U >  boolean equals ( Collection < T >  a ,  Collection < U >  b )  { } public static  < T >  List < T >  list (  )  { } public static  < T >  List < T >  list ( T o )  { } public static  < T >  List < T >  list ( T o1 ,  T o2 )  { } public static  < T >  List < T >  list ( T o1 ,  T o2 ,  T o3 )  { } public static  < T >  List < T >  list ( T o1 ,  T o2 ,  T o3 ,  T o4 )  { } public static  < T ,  U >  List < U >  map ( List < T >  l ,  Transformation < T ,  U >  t )  { } public static  < T >  Iterator < Pair < T ,  T >  >  pairs ( Collection < T >  l )  { } public static  < T >  List < T >  function ( List < T >  arg0 )  { List < T >  loc0 ;  try { loc0 =  ( arg0 != null )  ? arg0 : Collections . emptyList (  )  ;  } catch  ( Exception e )  { loc0 = Collections . emptyList (  )  ;  } return loc0 ;  } }
public static URI function ( URI arg0 ,  HttpHost arg1 )  { boolean loc0 = true ;  // always keep the fragment try { arg0 = URIUtils . rewriteURI ( arg0 ,  arg1 ,  loc0 )  ;  } catch  ( URISyntaxException e )  { e . printStackTrace (  )  ;  } return arg0 ;  }
void function (  )  { try { mListeners . clear (  )  ;  } catch  ( Exception loc0 )  { } }
public static JavascriptRuntime function (  )  { if  ( runtime == null )  { IJavascriptRuntime loc0 = new JavascriptRuntime (  )  ;  runtime = loc0 ;  } return runtime ;  }
Date function (  )  { return serverStatus . bootDate ;  }
public void function ( String arg0 )  { try { name = arg0 ;  } catch  ( Exception e )  { System . out . println ( "An error occurred while setting the name of the gene set . " )  ;  e . printStackTrace (  )  ;  } }
void function (  )  { try { HDGParser hdgParser = new HDGParser (  )  ;  String EXAMPLE = "$HCHDG , 123 . 4 , 1 . 2 , E , 1 . 2 , W" ;  hdgParser . parse ( EXAMPLE )  ;  double loc0 = hdgParser . getVariation (  )  ;  double loc1 = 1 . 2 ;  assertEquals ( loc1 ,  loc0 ,  0 . 0 )  ;  } catch  ( Exception e )  { fail ( "Exception thrown: " + e . getMessage (  )  )  ;  } }
StoredPaymentChannelClientStates getExtension ( Wallet arg0 )  { return arg0 . getExtensions (  )  . get ( StoredPaymentChannelClientStates . EXTENSION_ID )  ;  }
void function (  )  { Cache < K ,  V >  loc0 = getOpenIDCache (  )  ;  loc0 . removeAll (  )  ;  }
void function ( String arg0 )  { String loc0 = arg0 ;  loginName = loc0 ;  }
void function (  )  { Position loc0 = new Position (  )  ;  loc0 . setDatum ( Datum . WGS84 )  ;  assertEquals ( Datum . WGS84 ,  loc0 . getDatum (  )  )  ;  }
void function ( Source arg0 )  { Source loc0 = arg0 ;  if  ( loc0 != null )  { String loc1 = loc0 . getSystemId (  )  ;  if  ( loc1 != null && loc1 . length (  )   >  0 )  { loc0 . setSystemId ( loc1 )  ;  } else { loc0 . setSystemId ( getDefaultSystemId (  )  )  ;  } } }
List function ( List arg0 ,  List arg1 )  { List loc0 = new ArrayList (  )  ;  Vector loc1 = getAssociationEnds (  )  ;  Iterator loc2 = loc1 . iterator (  )  ;  while  ( loc2 . hasNext (  )  )  { Object loc3 = loc2 . next (  )  ;  if  ( !arg0 . contains ( loc3 )  && !arg1 . contains ( loc3 )  )  { loc0 . add ( loc3 )  ;  } } loc1 = getNewFeatures (  )  ;  loc2 = loc1 . iterator (  )  ;  while  ( loc2 . hasNext (  )  )  { Object loc3 = loc2 . next (  )  ;  if  ( !arg0 . contains ( loc3 )  && !arg1 . contains ( loc3 )  )  { loc0 . add ( loc3 )  ;  } } loc1 = getNewInnerClasses (  )  ;  loc2 = loc1 . iterator (  )  ;  while  ( loc2 . hasNext (  )  )  { Object loc3 = loc2 . next (  )  ;  if  ( !arg0 . contains ( loc3 )  && !arg1 . contains ( loc3 )  )  { loc0 . add ( loc3 )  ;  } } return loc0 ;  }
class OpenIDRememberMeTokenManager { private Log log = LogFactory . getLog ( OpenIDRememberMeTokenManager . class )  ;  private OpenIDRememberMeTokenCache cache = OpenIDRememberMeTokenCache . getCacheInstance (  )  ;  private OpenIDRememberMeTokenDAO dao ;  void function ( OpenIDRememberMeDO arg0 )  { cache . updateTokenData ( arg0 )  ;  Thread loc0 = new Thread (  )  {  @ Override public void run (  )  { try { dao . updateTokenData ( arg0 )  ;  } catch ( Exception e )  { log . error ( "srini_string" ,  e )  ;  } } } ;  loc0 . start (  )  ;  } String getToken ( OpenIDRememberMeDO rememberMe )  { } boolean isExpired ( OpenIDRememberMeDO storedDo )  { } }
void function ( ServerSocket arg0 )  { arg0 . close (  )  ;  }
public void function ( int arg0 )  { try { if  ( arg0  <  1 || arg0  >  8 )  { throw new IllegalArgumentException ( "Invalid lane_id value: " + arg0 )  ;  } this . lane_id = arg0 ;  } catch  ( Exception loc0 )  { System . err . println ( "Error setting lane_id: " + loc0 . getMessage (  )  )  ;  } }
void function ( MapNode arg0 )  { try { nodes . put ( arg0 . getId (  )  ,  arg0 )  ;  } catch  ( Exception loc0 )  { LOG . error ( "Error adding node to hashtable . " ,  loc0 )  ;  } }
void function ( String arg0 ,  String arg1 ,  String arg2 ,  String arg3 ,  String arg4 ,  String arg5 ,  String arg6 ,  String arg7 )  { CommitModel loc0 = new CommitModel (  )  ;  loc0 . setGraphName ( arg0 )  ;  loc0 . setSddName ( arg1 )  ;  loc0 . setUser ( arg2 )  ;  loc0 . setMessage ( arg3 )  ;  loc0 . setBranch1 ( arg4 )  ;  loc0 . setBranch2 ( arg5 )  ;  loc0 . setStrategy ( arg6 )  ;  loc0 . setType ( arg7 )  ;  }
public class RequestInputTest { void function (  )  { System . out . println ( "Test method for { @ link com . sqa . em . util . helper . RequestInput#getChar ( java . lang . String ) } . " )  ;  char arg0 = 'a' ;  char loc0 = RequestInput . getChar ( arg0 )  ;  System . out . println ( loc0 )  ;  } void testGetString (  )  { } void testGetCharStringCharArray (  )  { } void testGetDouble (  )  { } void testGetBoolean (  )  { } void testGetIntStringIntInt (  )  { } void testGetIntString (  )  { } void testAddStringElement (  )  { } }
boolean function ( String arg0 )  { Configuration loc0 = config . getFactory (  )  . getConfigurationHandler (  )  ;  loc0 . setString ( Configuration . makeKey ( URL_LOADED )  ,  arg0 )  ;  loc0 . setString ( Configuration . makeKey ( FILE_LOADED )  ,  "" )  ;  return loc0 . load (  )  ;  }
void function ( List < Interceptor < ? extends Message >  >  arg0 ,  List < Interceptor < ? extends Message >  >  inInterceptors )  { inInterceptors . clear (  )  ;  inInterceptors . addAll ( arg0 )  ;  }
void function ( ConfigurationKey arg0 ,  boolean arg1 )  { try { config . setBoolean ( arg0 ,  arg1 )  ;  } catch  ( Exception loc0 )  { } }
X509Certificate function ( TrustedCertificateEntry arg0 )  { X509Certificate loc0 = arg0 . getCertificate (  )  ;  String loc1 = arg0 . getSubjectPrimary (  )  ;  String loc2 = arg0 . getSubjectSecondary (  )  ;  if  ( loc2 . equals ( "" )  )  { try { Collection < List < ? >  >  loc3 = loc0 . getSubjectAlternativeNames (  )  ;  if  ( loc3 != null )  { for  ( List < ? >  loc4 : loc3 )  { Integer loc5 =  ( Integer )  loc4 . get ( 0 )  ;  if  ( loc5 == 0 || loc5 == 1 )  { loc2 =  ( String )  loc4 . get ( 1 )  ;  break ;  } } } if  ( loc2 . equals ( "" )  && loc1 . startsWith ( "O=" )  )  { String [  ]  loc6 = loc1 . split ( " , " )  ;  for  ( String loc7 : loc6 )  { if  ( loc7 . startsWith ( "OU=" )  )  { loc2 = loc7 . substring ( 3 )  ;  break ;  } else if  ( loc7 . startsWith ( "CN=" )  )  { loc2 = loc7 . substring ( 3 )  ;  break ;  } } } } catch  ( CertificateParsingException e )  { e . printStackTrace (  )  ;  } } return loc0 ;  }
Object function ( Object arg0 ,  Object arg1 )  { DeadEvent deadEvent =  ( DeadEvent )  arg0 ;  Object source = deadEvent . source ;  Object event = deadEvent . event ;  Object result = null ;  try { result = source . function ( event )  ;  } finally { return result ;  } }
class DELETE { void function ( String arg0 ,  int arg1 )  { try { int loc0 = arg1 / 0 ;  // example error } catch  ( Exception e )  { System . out . println ( "Error processing DELETE method: " + e . getMessage (  )  )  ;  } } }
void function ( String arg0 )  { AuthenticationRequest authRequest = new AuthenticationRequest (  )  ;  authRequest . setTenantDomain ( arg0 )  ;  }
class StorageDirViewTest { int TEST_TIER_LEVEL = 0 ;  long TEST_BLOCK_ID = 9 ;  TemporaryFolder mTestFolder = new TemporaryFolder (  )  ;  StorageTierView mTestTierView ;  StorageDir mTestDir ;  StorageDirView mTestDirView ;  int TEST_DIR = 0 ;  long TEST_SESSION_ID = 2 ;  BlockMetadataManagerView mMetaManagerView ;  long TEST_BLOCK_SIZE = 20 ;  long TEST_TEMP_BLOCK_ID = 10 ;  void function (  )  { mTestDirView = new StorageDirView ( mTestDir ,  mTestTierView ,  mMetaManagerView )  ;  assertEquals ( arg0 ,  mTestDirView . getCapacityBytes (  )  )  ;  } void toBlockStoreLocation (  )  { } void getAvailableBytes (  )  { } void getParentTierView (  )  { } void createTempBlockMeta (  )  { } void before (  )  { } void getDirViewIndex (  )  { } void getCommittedBytes (  )  { } void getEvictableBlocks (  )  { } }
public static String function ( String arg0 )  { String loc0 = PersistenceManager . getInstance (  )  . getProjectBaseName (  )  ;  AbstractProjectMember loc1 = new AbstractProjectMember (  )  ;  loc1 . makeUniqueName ( arg0 )  ;  String loc2 = loc1 . uniqueName ;  int loc3 = loc2 . length (  )  ;  String loc4 = loc2 . endsWith ( " . " )  ? "" : " . " ;  String loc5 = loc0 + "_" + loc2 + loc4 + loc1 . getZipFileExtension (  )  ;  return loc5 ;  }
void function ( int arg0 )  { gisticID = arg0 ;  genes_in_ROI = new ArrayList < CanonicalGene >  (  )  ;  chromosome = NO_SUCH_GISTIC ;  amp = AMPLIFIED ;  DELETED = false ;  }
void function ( long arg0 ,  long arg1 ,  BlockLockType arg2 )  { mLockManager . lockBlock ( arg0 ,  arg1 ,  arg2 )  ;  long loc0 = mLockManager . getLockId ( arg0 ,  arg1 )  ;  long loc1 = mLockManager . getLockId ( arg1 ,  arg0 )  ;  assertNotEquals ( loc0 ,  loc1 )  ;  }
public static String function ( String arg0 )  { int loc0 = arg0 . length (  )  ;  char [  ]  loc1 = new char [  ( loc0 * 2 )  ]  ;  int loc2 = 0 ;  for  ( int loc3 = 0 ;  loc3  <  loc0 ;  loc3 ++  )  { int loc4 = arg0 . charAt ( loc3 )  ;  loc1 [ loc2 ++  ]  = ShaUtils . CHARS [  ( loc4  >  >  >  4 )  & 0xf ]  ;  loc1 [ loc2 ++  ]  = ShaUtils . CHARS [ loc4 & 0xf ]  ;  } return new String ( loc1 )  ;  }
void function ( boolean arg0 ,  boolean arg1 )  { MWVTest mwvTest = new MWVTest (  )  ;  MWVSentence loc0 = mwvTest . mwv ;  assertTrue ( loc0 . isTrue (  )  )  ;  loc0 . setTrue ( arg0 )  ;  assertFalse ( loc0 . isTrue (  )  )  ;  loc0 . setTrue ( arg1 )  ;  assertTrue ( loc0 . isTrue (  )  )  ;  }
void function (  )  { CacheConfig cacheConfig = new CacheConfig (  )  ;  int loc0 = cacheConfig . maxUpdateRetries (  )  ;  }
class TacoPlayerTickHandler { Map < Integer ,  int [  ]  >  playerList = new HashMap < Integer ,  int [  ]  >  (  )  ;  void function ( int playerID ,  PlayerTickEvent event )  { int [  ]  ticks = null ;  if  ( playerList . containsKey ( playerID )  )  { ticks = playerList . get ( playerID )  ;  } else { ticks = new int [  ]  { 0 } ;  playerList . put ( playerID ,  ticks )  ;  } runPlayer ( playerID ,  event )  ;  ticks [ 0 ]  ++  ;  } void runPlayer ( int player ,  PlayerTickEvent event )  { } }
void function ( long arg0 )  { setDeliveryTag ( arg0 )  ;  }
public StoredClientChannel function ( Sha256Hash arg0 ,  Sha256Hash arg1 )  { try { lock . lock (  )  ;  Set < StoredClientChannel >  loc0 = mapChannels . get ( arg0 )  ;  for  ( StoredClientChannel loc1 : loc0 )  { if  ( loc1 . contract . getHash (  )  . equals ( arg1 )  )  { return loc1 ;  } } return null ;  } catch  ( Exception e )  { log . error ( "An error occurred while executing the function method" ,  e )  ;  return null ;  } finally { lock . unlock (  )  ;  } }
void function ( View arg0 ,  int arg1 ,  Object arg2 )  { try { destroyItem ( arg0 ,  arg1 ,  arg2 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function ( ExceptionListener arg0 )  { exceptionListener = arg0 ;  }
void function (  )  { model . triggerEvent (  )  ;  }
String function ( String arg0 )  { String loc0 = this . caseId ;  return loc0 ;  }
Filestat function ( String arg0 )  { if  ( isWindows (  )  )  { throw new UnsupportedOperationException (  )  ;  } Filestat loc0 = getFilestat ( arg0 )  ;  return loc0 ;  }
String function ( EaseEmojicon arg0 )  { String loc0 = arg0 . getEmojiText (  )  ;  if  ( loc0 == null )  { int loc1 = arg0 . getIcon (  )  ;  if  ( loc1 != 0 )  { loc0 = newEmojiText ( loc1 )  ;  } } return loc0 ;  } String newEmojiText ( int arg0 )  { return new String ( Character . toChars ( arg0 )  )  ;  }
public int function ( int arg0 )  { try { if  ( arg0  < = 0 )  { throw new IllegalArgumentException ( "Dimension should be a positive integer . " )  ;  } return this . dimension ;  } catch  ( IllegalArgumentException e )  { System . err . println ( "Error: " + e . getMessage (  )  )  ;  return -1 ;  } }
void function ( String arg0 )  { try { checksumType = arg0 ;  } catch  ( Exception loc0 )  { System . err . println ( "Error setting checksum type: " + loc0 . getMessage (  )  )  ;  } }
Set < T >  function ( Class < T >  arg0 ,  Set < Node >  arg1 )  { Set < T >  loc0 = new HashSet <  >  (  )  ;  for  ( Node node : arg1 )  { if  ( node . getClass (  )  . equals ( arg0 )  )  { loc0 . add ( arg0 . cast ( node )  )  ;  } } return loc0 ;  }
void function (  )  { try { int loc0 = 3 ;  rte . setSentenceCount ( loc0 )  ;  int loc1 = rte . getSentenceCount (  )  ;  assertEquals ( loc0 ,  loc1 )  ;  } catch  ( Exception e )  { } }
void function ( Crypto arg0 )  { this . encryptionCrypto = arg0 ;  }
public int function ( int arg0 ,  int arg1 )  { try { return matrixItemUtility ( originalMatrix . getItem ( arg0 ,  arg1 )  ,  getLocalSequenceUtility ( new MatrixPosition ( arg0 ,  arg1 )  )  ,  getRemainingUtility ( arg0 ,  arg1 )  )  ;  } catch  ( Exception e )  { System . err . println ( "An error occurred while getting the utility of cell  ( " + arg0 + " , " + arg1 + " ) " )  ;  e . printStackTrace (  )  ;  return -1 ;  } }
public void function ( String identifier ,  IndividualStructure structure )  { try { if  ( individualStructures . containsKey ( identifier )  )  { System . out . println ( "Warning: Overwriting existing individual structure with identifier " + identifier )  ;  } individualStructures . put ( identifier ,  structure )  ;  } catch  ( Exception e )  { System . err . println ( "Error adding individual structure with identifier " + identifier + ": " + e . getMessage (  )  )  ;  } }
Context function (  )  { ELEvaluator loc0 = current . get (  )  ;  if  ( loc0 == null )  { loc0 = new ELEvaluator (  )  ;  current . set ( loc0 )  ;  } Context loc1 = loc0 . context ;  Map < String ,  Object >  loc2 = loc0 . vars ;  Map < String ,  Method >  loc3 = loc0 . functions ;  loc1 . setFunctions ( loc3 )  ;  loc1 . setVariables ( loc2 )  ;  return loc1 ;  }
SDDTripleStateEnum function (  )  { SDDTripleStateEnum loc0 = this . tripleStateA ;  return loc0 ;  }
public void function ( String arg0 ,  PropertyDTO [  ]  arg1 )  { Map < String , String >  loc0 = convertArrayToMap ( arg1 )  ;  userStoreManagers . put ( arg0 ,  loc0 )  ;  }
void function ( JavaMailSender arg0 )  { mailSender = arg0 ;  } Note: It is important to note that this method is missing any exception handling ,  which can lead to runtime errors if not handled properly .  It is recommended to add proper exception handling to this method to ensure that errors are handled gracefully . 
void function ( Scriptable arg0 ,  ClassCache arg1 )  { arg0 . getParentScope (  )  . associateValue ( AKEY ,  arg1 )  ;  }
void function ( Bus arg0 )  { if ( arg0 != null )  { bus = arg0 ;  } } The above method named "function" takes in a parameter of type Bus ,  checks if it is not null and if so ,  assigns it to the member variable "bus" of the class "AbstractConfigurableProvider" .  This method sets the Bus that will be used for the configuration .  There is no exception handling in this method . 
void function (  )  { DenseMatrix64F loc0 = new DenseMatrix64F ( 3 ,  4 )  ;  int loc1 = loc0 . getNumCols (  )  ;  int loc2 = loc0 . getNumRows (  )  ;  assertEquals ( 3 ,  loc1 )  ;  assertEquals ( 4 ,  loc2 )  ;  }
void function (  )  { try { loc0 = "160705" ;  rmc . setDate ( loc0 )  ;  assertEquals ( loc0 . substring ( 4 )  ,  rmc . getYear (  )  )  ;  } catch  ( Exception e )  { } }
class GeneSet { String geneList ;  String name ;  void setName ( String name )  { this . name = name ;  } String getName (  )  { return name ;  } String getGeneList (  )  { return geneList ;  } String getId (  )  { return null ;  } void function ( String arg0 )  { } }
public List < Role >  function (  )  { List < Role >  loc0 = null ;  try { loc0 = this . roles ;  } catch  ( NullPointerException e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
void function ( String arg0 )  { try { referencedRevisionA = arg0 ;  } catch  ( Exception e )  { } }
void function ( IParserEvent arg0 )  { UprHandler ( handler )  ;  loc0 . handleEvent ( arg0 )  ;  handlerStack . push ( handler )  ;  }
BigDecimal function (  )  { BigDecimal loc0 = downloadSize ;  return loc0 ;  }
public void function ( DenseMatrix64F arg0 ,  DenseMatrix64F arg1 )  { DenseMatrix64F A = new DenseMatrix64F ( arg0 )  ;  try { extractor . process ( A )  ;  boolean allComplex = isAllComplex (  )  ;  int numFailed = checkEigenvalues ( A )  ;  if  ( numFailed  >  0 && !allComplex )  { DenseMatrix64F V = new DenseMatrix64F ( A . numRows ,  numFailed )  ;  double [  ]  values = new double [ numFailed ]  ;  numCantFindEigenvector = 0 ;  for  ( int i = 0 ;  i  <  A . numRows && numCantFindEigenvector  <  numFailed ;  i ++  )  { double val = A . get ( i ,  i )  ;  if  ( Math . abs ( val - values [ numCantFindEigenvector ]  )   < = tol )  { continue ;  } DenseMatrix64F x = new DenseMatrix64F ( A . numRows ,  1 )  ;  x . set ( i ,  0 ,  1 . 0 )  ;  if  ( !extractor . process ( A ,  x ,  values [ numCantFindEigenvector ]  )  )  { numCantFindEigenvector ++  ;  } else { CommonOps . insert ( x ,  V ,  0 ,  numCantFindEigenvector )  ;  numCantFindEigenvector ++  ;  } } for  ( int i = 0 ;  i  <  numFailed ;  i ++  )  { DenseMatrix64F v = CommonOps . extract ( V ,  0 ,  V . numRows ,  i ,  i+1 )  ;  double val = values [ i ]  ;  double error = computeError ( A ,  v ,  val )  ;  assertEquals ( 0 . 0 ,  error ,  tol )  ;  } } } catch  ( Exception e )  { e . printStackTrace (  )  ;  fail ( "Exception thrown" )  ;  } }
void function ( AbstractSettings arg0 )  { try { PROPS . add ( arg0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function (  )  { removeLastEvent (  )  ;  StringEvent loc0 = new StringEvent (  )  ;  loc0 . getString (  )  ;  events . addLast ( loc0 )  ;  }
boolean function (  )  { try { Date loc0 = new Date (  )  ;  return loc0 . after ( getTimeoutDate (  )  )  ;  } catch  ( Exception e )  { } }
NameValuePair function ( String arg0 ,  String arg1 )  { String loc0 = arg0 . trim (  )  ;  if  ( loc0 . isEmpty (  )  )  { return null ;  } int loc1 = loc0 . indexOf ( '=' )  ;  if  ( loc1  > = 0 )  { return new BasicNameValuePair (  loc0 . substring ( 0 ,  loc1 )  . trim (  )  ,  loc0 . substring ( loc1 + 1 )  . trim (  )  )  ;  } else { return new BasicNameValuePair ( loc0 ,  null )  ;  } }
String function ( byte [  ]  arg0 ,  String arg1 )  { try { return new String ( arg0 ,  arg1 )  ;  } catch  ( UnsupportedEncodingException loc0 )  { throw new RuntimeException ( "Use this function instead of new String ( byte [  ]  ,  String )  to avoid surprises from non-standard default encodings . " ,  loc0 )  ;  } }
void function ( short arg0 )  { checkType ( PackFormatInputStream . FORMAT_SHORT )  ;  packLong ( arg0 ,  true )  ;  }
EmailTemplateDTO function ( int arg0 )  { EmailTemplateDTO loc0 ;  try { loc0 = templates [ arg0 ]  ;  } catch  ( ArrayIndexOutOfBoundsException e )  { throw new RuntimeException ( "This method is used to get the email template to be displayed with the given index . " )  ;  } return loc0 . function (  )  ;  }
import org . json . JSONArray ;  import java . util . List ;  class JsonWorkflowAction { Date startTime ;  String transition=null ;  String externalId=null ;  String errorCode=null ;  int retries ;  String externalStatus=null ;  String data=null ;  String name=null ;  String id ;  Date endTime ;  Status status=WorkflowAction . Status . PREP ;  String consoleUrl=null ;  String type=null ;  String conf=null ;  String trackerUri=null ;  String errorMessage=null ;  void setExternalStatus ( String externalStatus )  { this . externalStatus = externalStatus ;  } String toString (  )  { } String getTrackerUri (  )  { } Status getStatus (  )  { } void setTrackerUri ( String trackerUri )  { } int getRetries (  )  { } JSONObject toJSONObject (  )  { } void setName ( String name )  { this . name = name ;  } String getErrorCode (  )  { } void setId ( String id )  { this . id = id ;  } String getData (  )  { } List < JsonWorkflowAction >  fromJSONArray ( JSONArray array )  { } void setType ( String type )  { this . type = type ;  } String getName (  )  { } String getExternalStatus (  )  { } void setConf ( String conf )  { this . conf = conf ;  } void setErrorInfo ( String errorCode ,  String errorMessage )  { this . errorCode = errorCode ;  this . errorMessage = errorMessage ;  } String getType (  )  { } void setEndTime ( Date endTime )  { this . endTime = endTime ;  } String getErrorMessage (  )  { } String getConsoleUrl (  )  { } Date getEndTime (  )  { } Date getStartTime (  )  { } void setStatus ( Status status )  { this . status = status ;  } String getConf (  )  { } void setRetries ( int retries )  { this . retries = retries ;  } void setConsoleUrl ( String consoleUrl )  { this . consoleUrl = consoleUrl ;  } String getTransition (  )  { } String getExternalId (  )  { } void setStartTime ( Date startTime )  { this . startTime = startTime ;  } void setExternalId ( String externalId )  { this . externalId = externalId ;  } void setData ( String data )  { this . data = data ;  } String getId (  )  { } void setTransition ( String transition )  { this . transition = transition ;  } } public class MyClass { public void function ( List < JsonWorkflowAction >  arg0 ,  JSONArray arg1 )  { for  ( JsonWorkflowAction loc0 : arg0 )  { arg1 . add ( loc0 . toJSONObject (  )  )  ;  } } }
class CollectionUtil { static Type typeFor ( TypeMap map ,  String name )  { return map . typeFor ( name )  ;  } static Type typeForClassName ( String className )  { return typeFor ( COLLECTION_CLASSES_BY_NAMES ,  className )  ;  } static Type typeForInterfaceName ( String interfaceName )  { return typeFor ( COLLECTION_INTERFACES_BY_NAMES ,  interfaceName )  ;  } static Type function ( String arg0 )  { Type loc0 = typeForClassName ( arg0 )  ;  if  ( loc0 == null )  { loc0 = typeForInterfaceName ( arg0 )  ;  } return loc0 ;  } static boolean isEmpty ( Object [  ]  items )  { } static boolean isNotEmpty ( Object [  ]  items )  { } static  < T >  Set < T >  asSet ( T [  ]  items )  { } static int addWithoutDuplicates ( Collection < String >  source ,  Collection < String >  target )  { } static  < T >  T [  ]  addWithoutDuplicates ( T [  ]  values ,  T newValue )  { } static  < T >  T [  ]  addWithoutDuplicates ( T [  ]  values ,  T [  ]  newValues )  { } static boolean areEqual ( Object value ,  Object otherValue )  { } static  < T >  boolean areSemanticEquals ( T [  ]  a ,  T [  ]  b )  { } static boolean valuesAreTransitivelyEqual ( Object [  ]  thisArray ,  Object [  ]  thatArray )  { } static boolean isCollectionType ( String typeName ,  boolean includeInterfaces )  { } static boolean isCollectionType ( Class < ? >  clazzType ,  boolean includeInterfaces )  { } static  < K ,  V >  Map < V ,  K >  invertedMapFrom ( Map < K ,  V >  source )  { } static  < K ,  V >  Map < K ,  V >  mapFrom ( K [  ]  keys ,  V [  ]  values )  { } static boolean arraysAreEqual ( Object value ,  Object otherValue )  { } }
EndpointReferenceType function ( QName arg0 ,  String arg1 )  { EndpointReferenceType loc0 = null ;  for  ( EndpointResolver loc1 : resolvers )  { loc0 = loc1 . resolve ( new EndpointReferenceType (  )  ,  arg0 )  ;  if  ( loc0 != null )  { break ;  } } if  ( loc0 != null )  { loc0 . setAddress ( arg1 )  ;  } return loc0 ;  }
int function ( byte [  ]  arg0 ,  int arg1 ,  int arg2 )  { checkBoundary ( arg0 ,  arg1 ,  4 )  ;  arg0 [ arg1 ]  =  ( byte )   ( arg2  >  >  24 )  ;  arg0 [ arg1 + 1 ]  =  ( byte )   ( arg2  >  >  16 )  ;  arg0 [ arg1 + 2 ]  =  ( byte )   ( arg2  >  >  8 )  ;  arg0 [ arg1 + 3 ]  =  ( byte )   ( arg2 )  ;  return arg1 + 4 ;  }
void function (  )  { GeneralMotorCon loc0 = GeneralMotorCon . getInstance (  )  ;  loc0 . appendToConsole (  )  ;  loc0 . setLedsAnimation (  )  ;  loc0 . spinLeft (  )  ;  loc0 . doFor ( loc0 . spin90Time ,  loc0 . spinSpeed )  ;  loc0 . hover (  )  ;  }
Measurements function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { Measurements loc0 = Measurements . singleton ;  if  ( loc0 == null )  { loc0 = new Measurements (  )  ;  loc0 . setProperties ( loc0 . _props )  ;  } return loc0 ;  }
public void function ( Marshaller arg0 ,  Object arg1 )  { marshaller = arg0 ;  object = arg1 ;  }
public void function ( List < String >  arg0 )  { acceptedKeyWrapAlgorithms = new ArrayList <  >  ( arg0 )  ;  }
public void function ( String arg0 ,  String arg1 )  { try { IdentityTenantUtil . getRealm ( null ,  arg0 )   . getUserStoreManager (  )   . authenticate ( arg1 )  ;  } catch  ( Exception loc0 )  { log . error ( "Error occurred while verifying user name/password authentication . " ,  loc0 )  ;  } }
public boolean function ( long arg0 )  { synchronized  ( mLock )  { Map < Long ,  Long >  loc0 = mPersistingInProgressFiles . get ( arg0 )  ;  return loc0 != null && !loc0 . isEmpty (  )  ;  } }
LinearSolver < DenseMatrix64F >  function ( int arg0 ,  int arg1 )  { AdjustableLinearSolver < DenseMatrix64F >  loc0 = new AdjustableLinearSolver <  >  ( new LinearSolverFactory (  )  )  ;  loc0 . setA ( new DenseMatrix64F ( arg0 ,  arg1 )  )  ;  return new AdjLinearSolverQr <  >  ( loc0 )  ;  }
class SimpleEndpointImplFactory { EndpointImplFactory singleton = new SimpleEndpointImplFactory (  )  ;  EndpointImpl newEndpointImpl ( Bus bus ,  Service service ,  EndpointInfo endpointInfo )  { } EndpointImplFactory function (  )  { return singleton ;  } }
public void function (  )  { mThrown . expect ( IndexOutOfBoundsException . class )  ;  mThrown . expectMessage ( "Index: "+ TEST_TIER_LEVEL +" ,  Size: " + mTestTierView . getDirViews (  )  . size (  )  )  ;  try { StorageTierView loc0 = mTestTierView . getDirView ( TEST_TIER_LEVEL )  ;  fail ( "Expected an IndexOutOfBoundsException to be thrown" )  ;  } catch  ( IndexOutOfBoundsException loc1 )  { assertEquals ( TieredBlockStoreTestUtils . TIER_PATH [ TEST_TIER_LEVEL ]  ,  mTestTierView . getDirViews (  )  . get ( TEST_TIER_LEVEL )  . getDirPath (  )  )  ;  } }
int function ( Map < String ,  String >  arg0 )  { int loc0 = arg0 . size (  )  ;  boolean loc1 = loc0 == 0 || arg0 == null ;  return loc1 ? 1 : 0 ;  }
List < T >  function ( Class < T >  arg0 )  { List < T >  loc0 = new ArrayList <  >  (  )  ;  Node loc1 = jjtGetParent (  )  ;  while  ( loc1 != null )  { if  ( loc1 . getClass (  )  == arg0 )  { loc0 . add (  ( T )  loc1 )  ;  } loc1 = loc1 . jjtGetParent (  )  ;  } return loc0 ;  }
import com . google . common . base . Preconditions ;  public class UnsignedInts { private static final long INT_MASK = 0xffffffffL ;  public static int function ( int value )  { Preconditions . checkArgument ( value  > = 0 && value  < = INT_MASK )  ;  return value ;  } public static int function ( String string ,  int radix )  { int value = Integer . parseInt ( string ,  radix )  ;  Preconditions . checkArgument ( value  > = 0 && value  < = INT_MASK )  ;  return value ;  } }
class TriangularSolver { void solveL ( double L [  ]  ,  double [  ]  b ,  int n )  {} void solveL ( double L [  ]  ,  double [  ]  b ,  int m ,  int n )  {} void invertLower ( double L [  ]  ,  int m )  {} void invertLower ( double L [  ]  ,  double L_inv [  ]  ,  int m )  {} void solveTranL ( double L [  ]  ,  double [  ]  b ,  int n )  {} void function ( double [  ]  arg0 ,  double [  ]  arg1 ,  int n )  { for  ( int i = n - 1 ;  i  > = 0 ;  i --  )  { double loc0 = arg1 [ i ]  ;  for  ( int j = i + 1 ;  j  <  n ;  j ++  )  { loc0 -= L [ i * n + j ]  * arg1 [ j ]  ;  } arg1 [ i ]  = loc0 / L [ i * n + i ]  ;  } } }
boolean function ( String arg0 )  { String loc0 = arg0 . trim (  )  ;  return loc0 != null && !loc0 . startsWith ( "//" )  && !loc0 . equals ( "" )  ;  }
DeterministicKey function ( List < ChildNumber >  arg0 ,  boolean arg1 ,  boolean arg2 )  { DeterministicKey loc0 = get ( arg0 ,  arg1 ,  arg2 )  ;  return loc0 ;  }
public TriConsumer < X ,  Y ,  Z >  function ( TriConsumer < X ,  Y ,  Z >  after )  { Objects . requireNonNull ( after )  ;  return  ( arg0 ,  arg1 ,  arg2 )  - >  { accept ( arg0 ,  arg1 ,  arg2 )  ;  after . accept ( arg0 ,  arg1 ,  arg2 )  ;  } ;  }
public static  < T >  Function < T ,  T >  function (  )  { try { return IdentityFunction . INSTANCE ;  } catch  ( Exception loc0 )  { return null ;  } }
void function ( byte [  ]  arg0 )  { this . challenge =  (  ( byte [  ]  )  arg0 )  ;  }
void function ( Object arg0 ,  Object arg1 )  { try { Named loc0 =  ( Named )  arg0 ;  String loc1 =  ( String )  arg1 ;  if  ( !packageExists ( loc0 . packageName (  )  )  )  { throw new InternalCompilerError ( "Package does not exist: " + loc0 . packageName (  )  )  ;  } if  ( table . containsKey ( loc0 . fullName (  )  )  )  { throw new InternalCompilerError ( "Named type object already exists: " + loc0 . fullName (  )  )  ;  } table . put ( loc0 . fullName (  )  ,  loc0 )  ;  if  ( Report . should_report ( TOPICS ,  3 )  )  { Report . report ( 3 ,  "Added named type object to table: " + loc0 . fullName (  )  )  ;  } } catch  ( ClassCastException e )  { throw new InternalCompilerError ( "Invalid argument types" ,  e )  ;  } catch  ( NullPointerException e )  { throw new InternalCompilerError ( "Null argument" ,  e )  ;  } catch  ( Exception e )  { throw new InternalCompilerError ( "Unexpected error" ,  e )  ;  } }
void function ( String arg0 )  { schedule ( arg0 )  ;  await ( arg0 )  ;  }
import org . hamcrest . Matcher ;  import org . hamcrest . Matchers ;  public class OrderingComparison { public static  < T extends Comparable < T >  >  Matcher < T >  function ( T arg0 )  { return Matchers .  < T > usingNaturalOrdering (  )  . lessThan ( arg0 )  ;  } public static  < T extends Comparable < T >  >  Matcher < T >  function ( T arg0 ,  T arg1 )  { return Matchers .  < T > usingNaturalOrdering (  )  . lessThanOrEqualTo ( arg0 )  . and ( Matchers .  < T > usingNaturalOrdering (  )  . greaterThanOrEqualTo ( arg1 )  )  ;  } public static  < T extends Comparable < T >  >  Matcher < T >  function ( T arg0 ,  T arg1 ,  T arg2 )  { return Matchers .  < T > usingNaturalOrdering (  )  . lessThanOrEqualTo ( arg0 )  . and ( Matchers .  < T > usingNaturalOrdering (  )  . greaterThanOrEqualTo ( arg1 )  )  . and ( Matchers .  < T > usingNaturalOrdering (  )  . lessThanOrEqualTo ( arg2 )  )  ;  } public static  < T extends Comparable < T >  >  Matcher < T >  function ( T arg0 ,  T arg1 ,  T arg2 ,  T arg3 )  { return Matchers .  < T > usingNaturalOrdering (  )  . lessThanOrEqualTo ( arg0 )  . and ( Matchers .  < T > usingNaturalOrdering (  )  . greaterThanOrEqualTo ( arg1 )  )  . and ( Matchers .  < T > usingNaturalOrdering (  )  . lessThanOrEqualTo ( arg2 )  )  . and ( Matchers .  < T > usingNaturalOrdering (  )  . greaterThanOrEqualTo ( arg3 )  )  ;  } }
void function ( XCommand arg0 ,  Map < Long , List < XCommand < ? >  >  >  arg1 )  { try { arg0 . acquireLock (  )  ;  long loc0 = arg0 . getCreatedTime (  )  ;  List < XCommand < ? >  >  loc1 ;  synchronized  ( arg1 )  { loc1 = arg1 . computeIfAbsent ( loc0 ,  k - >  new ArrayList <  >  (  )  )  ;  } loc1 . add ( arg0 )  ;  } catch  ( InterruptedException e )  { arg0 . resetUsed (  )  ;  throw new RuntimeException ( e )  ;  } finally { arg0 . releaseLock (  )  ;  } }
public void function ( String threadName )  { try  ( LockResource lockResource = new LockResource ( sLock )  )  { while  ( !sTimers . containsKey ( threadName )  )  { try { sCondition . await (  )  ;  } catch  ( InterruptedException e )  { e . printStackTrace (  )  ;  } } } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function ( Argument arg0 ,  String message )  { arg0 . setInvalidationMessage ( message )  ;  }
class CollisionDJBX33A { void function ( String arg0 ,  StringBuilder arg1 ,  boolean arg2 )  { int loc0 = 5381 ;  byte [  ]  loc1 = arg0 . getBytes (  )  ;  int loc2 = arg0 . length (  )  ;  for  ( int loc3 = 0 ;  loc3  <  loc2 ;  loc3 ++  )  { loc0 =  ( loc0  <  <  5 )  + loc0 + loc1 [ loc3 ]  ;  } String loc4 = getCollisionString ( loc0 ,  loc2 )  ;  if  ( arg2 )  { arg1 . append ( "namespace " )  ;  } arg1 . append ( loc4 )  ;  } }
String function ( String arg0 ,  String arg1 ,  RunStatusType arg2 )  { ShellCommandContext context = new ShellCommandContext (  )  ;  context . setSource ( arg0 )  ;  context . setDestination ( arg1 )  ;  context . setRunStatusType ( arg2 )  ;  return context . getDestination (  )  ;  }
void function ( int arg0 )  { waitFor ( arg0 )  ;  }
ValidatedItemDTO [  ]  function ( String arg0 ,  boolean arg1 )  { try { String [  ]  issuers = stub . getIssuersOfSAMLServiceProviders ( arg0 ,  arg1 )  ;  } catch  ( RemoteException loc0 )  { log . error ( "srini_string" ,  loc0 )  ;  throw new AxisFault ( loc0 . getMessage (  )  ,  loc0 )  ;  } }
public void function ( String arg0 )  { try { ConcurrentMap < String , Object >  loc0 = attributes ;  loc0 . remove ( arg0 )  ;  } catch  ( Exception e )  { if  ( !ignoreExceptions )  { Report loc1 = report ;  loc1 . addError ( new ParseError ( sourceCodeFile ,  "Error removing attribute " + arg0 ,  e )  )  ;  } } }
void function ( int arg0 )  { int loc0 = getStep (  )  ;  if  ( loc0 == arg0 )  { return ;  } else if  ( loc0  <  arg0 )  { while  ( getStep (  )   <  arg0 )  { doAction (  )  ;  JPanel loc1 = makePanel ( getStep (  )  )  ;  panels . add ( loc1 )  ;  changed (  )  ;  } } else { while  ( getStep (  )   >  arg0 )  { undoAction (  )  ;  removePanel ( panels . size (  )  - 1 )  ;  changed (  )  ;  } } }
public void function (  )  { Date arg0 = new Date (  )  ;  Date arg1 = new Date (  )  ;  assertTrue ( arg0 . equals ( arg1 )  )  ;  assertTrue ( arg0 . equals ( arg0 )  )  ;  assertTrue ( arg1 . equals ( arg1 )  )  ;  }
Node head ;  void function ( int arg0 )  { Node loc0 = new Node ( arg0 )  ;  if  ( head == null )  { head = loc0 ;  } else { Node loc1 = head ;  while  ( loc1 . next != null )  { loc1 = loc1 . next ;  } loc1 . next = loc0 ;  } }
Array < Asset >  function (  )  { Array < Asset >  loc0 = new Array <  >  (  )  ;  loc0 . add ( new Asset ( "sound1 . ogg" ,  AssetType . SOUND )  )  ;  loc0 . add ( new Asset ( "sound2 . ogg" ,  AssetType . SOUND )  )  ;  loc0 . add ( new Asset ( "sound3 . ogg" ,  AssetType . SOUND )  )  ;  return loc0 ;  }
void function (  )  { State loc0 = state (  )  ;  if  ( loc0 != State . STARTING )  { throw new IllegalStateException ( "Cannot execute function (  )  when the service is " + loc0 )  ;  } State loc1 = State . RUNNING ;  try { starting (  )  ;  loc0 = state (  )  ;  if  ( loc0 != State . STARTING )  { throw new IllegalStateException ( "Cannot execute function (  )  when the service is " + loc0 )  ;  } loc0 = loc1 ;  running (  )  ;  } catch  ( Throwable loc2 )  { notifyFailed ( loc2 )  ;  throw Throwables . propagate ( loc2 )  ;  } }
double function ( double arg0 ,  double arg1 )  { try { double loc0 = arg0 * arg1 ;  setPower ( loc0 )  ;  } catch  ( Exception e )  { System . out . println ( "An error occurred: " + e . getMessage (  )  )  ;  } return getPower (  )  ;  }
String function ( String arg0 ,  Difference arg1 )  { String loc0 = null ;  try { loc0 = arg1 . getReferencedRevisionLabelB (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
class GraphViz { String TEMP_DIR = "/Users/wendellpbarreto/Downloads" ;  StringBuilder graph = new StringBuilder (  )  ;  String DOT = "/usr/local/bin/dot" ;  String function (  )  { String loc0 = "" ;  try { loc0 = graph . toString (  )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } loc0 = loc0 . replaceAll ( " ( ?m ) ^\\s*// . *?$" ,  "" )  . replaceAll ( " ( ?m ) ^\\s*/\\* . *?\\*/\\s*$" ,  "" )  . trim (  )  ;  return loc0 ;  } void readSource ( String arg0 )  { } byte [  ]  get_img_stream ( File arg0 ,  String arg1 )  { } String end_graph (  )  { } String start_subgraph ( String arg0 )  { } File writeDotSourceToFile ( String arg0 )  { } String end_subgraph (  )  { } void add ( String arg0 )  { } void addln ( String arg0 )  { } void addln (  )  { } byte [  ]  getGraph ( String arg0 ,  String arg1 )  { } String start_graph (  )  { } int writeGraphToFile ( byte [  ]  arg0 ,  String arg1 )  { } int writeGraphToFile ( byte [  ]  arg0 ,  File arg1 )  { } }
void function ( SentenceListener arg0 ,  String arg1 )  { List < SentenceListener >  loc0 = listeners . get ( arg1 )  ;  if  ( loc0 == null )  { loc0 = new ArrayList < SentenceListener >  (  )  ;  listeners . put ( arg1 ,  loc0 )  ;  } loc0 . add ( arg0 )  ;  }
public void function ( Coin arg0 )  { try { ListenableFuture < PaymentIncrementAck >  loc0 = channelClient . incrementPayment ( arg0 ,  null )  ;  } catch  ( Exception loc1 )  { } }
public class StringUtil { public static String function ( String arg0 )  { String loc0 = "" ;  try { int loc1 = arg0 . lastIndexOf ( " . " )  ;  if  ( loc1  > = 0 )  { loc0 = arg0 . substring ( 0 ,  loc1 )  ;  } } catch  ( Exception e )  { } return loc0 ;  } public String nth ( int n )  { } public String getFirstComponent ( String fullName )  { } public String getShortNameComponent ( String fullName )  { } public boolean isNameShort ( String name )  { } public String escape ( String s )  { } public String escape ( char c )  { } public String escape ( String s ,  boolean unicode )  { } public String escape ( char c ,  boolean unicode )  { } public String unicodeEscape ( String s )  { } public String unicodeEscape ( char c )  { } public String removeFirstComponent ( String fullName )  { } }
public void function (  )  { try { UserInfoRepository loc0 = Mockito . mock ( UserInfoRepository . class )  ;  Mockito . when ( loc0 . getByUsername ( "username" )  )  . thenReturn ( new UserInfo ( "username" ,  "password" ,  "adminSub12d3a1f34a2" )  )  ;  DefaultUserInfoService loc1 = new DefaultUserInfoService (  )  ;  loc1 . setUserInfoRepository ( loc0 )  ;  UserDetails loc2 = loc1 . getByUsername ( "username" )  ;  assertTrue ( loc2 . getAuthorities (  )  . contains ( new SimpleGrantedAuthority ( "ROLE_USER" )  )  )  ;  assertTrue ( loc2 . getAuthorities (  )  . contains ( new SimpleGrantedAuthority ( "ROLE_ADMIN" )  )  )  ;  } catch  ( Exception e )  { fail ( "An exception was thrown: " + e . getMessage (  )  )  ;  } }
public class Predicate { List < Term >  terms = new ArrayList < Term >  (  )  ;  Constant equatesWithConstant ( String fldname )  { } int reductionFactor ( Plan p )  { } void conjoinWith ( Predicate pred )  { } Predicate selectPred ( Schema sch )  { } String equatesWithField ( String fldname )  { } Predicate joinPred ( Schema sch1 ,  Schema sch2 )  { } String toString (  )  { } public boolean function ( Scan arg0 )  { for  ( Term loc0 : terms )  { if  ( !loc0 . isSatisfied ( arg0 )  )  { return false ;  } } return true ;  } }
void function ( int arg0 )  { try { PortAllocator . INSTANCE . release ( arg0 )  ;  } catch  ( Exception e )  { throw new IllegalStateException ( "srini_string" ,  e )  ;  } }
XHTMLPanel function ( arg0 ,  arg1 ) { Dimension loc0 = dim ;  XHTMLPanel loc1 = panel ;  return loc1 ;  }
void function ( File arg0 ,  File arg1 ,  File arg2 ,  File arg3 ,  File arg4 )  { Map < String , String >  loc0 = new HashMap < String , String >  (  )  ;  List < String >  loc1 = getList ( arg0 )  ;  Map < String , String >  loc2 = getMutationMap ( loc1 )  ;  applyKnownMutationsData ( arg3 ,  loc2 )  ;  for ( String loc3 : getList ( arg1 )  )  { for ( String loc4 : getList ( arg2 )  )  { String loc5 = createKey ( loc4 ,  loc3 )  ;  loc0 . put ( loc5 ,  "" )  ;  } } generateMutationFile ( loc0 )  ;  }
void function ( long arg0 ,  int arg1 ,  ServiceInfoStat [  ]  arg2 )  { long loc0 = arg0 ;  int loc1 = arg1 ;  ServiceInfoStat [  ]  loc2 = arg2 ;  return ;  }
void function (  )  { try { writer . writeStartElement ( "group" )  ;  } catch  ( XMLStreamException loc0 )  { } }
public static double function ( DenseMatrix64F arg0 ,  DenseMatrix64F arg1 )  { try { double loc0 = innerProd ( arg1 ,  arg0 )  ;  DenseMatrix64F loc1 = new DenseMatrix64F ( arg0 . numRows ,  1 )  ;  CommonOps . mult ( arg0 ,  loc1 ,  loc1 )  ;  double loc2 = innerProdA ( arg1 ,  loc1 )  ;  return loc2 / loc0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return Double . NaN ;  } }
boolean function ( ActivityRequest arg0 )  { if  ( arg0 == null )  { return false ;  } if  ( arg0 . getDelayerFileAttributesExtractorStrategy (  )  == null )  { return false ;  } if  ( arg0 . getFeedId (  )  == null )  { return false ;  } return arg0 . getConfigProperties (  )  != null ;  }
Properties function ( String arg0 )  { Properties loc0 = getModuleProperties ( arg0 )  ;  List < Subscription >  loc1 = buildSubscriptionList ( arg0 ,  loc0 )  ;  ModuleConfiguration loc2 = getModuleConfigurations ( arg0 )  ;  List < ModuleConfiguration >  loc3 = new ArrayList <  >  (  )  ;  loc3 . add ( loc2 )  ;  loc2 . setSubscriptions ( loc1 )  ;  loc2 . setProperties ( loc0 )  ;  return loc0 ;  }
void function ( Map < String ,  String >  arg0 )  { Map < String ,  String >  loc0 = new HashMap < String ,  String >  (  )  ;  loc0 . put ( "category" ,  "providers" )  ;  loc0 . put ( "check" ,  "false" )  ;  loc0 . put ( "dynamic" ,  "true" )  ;  loc0 . put ( "enabled" ,  "true" )  ;  loc0 . put ( "methods" ,  "test1 , test2" )  ;  loc0 . put ( "payload" ,  "0" )  ;  loc0 . put ( "pid" ,  "1" )  ;  loc0 . put ( "side" ,  "provider" )  ;  loc0 . put ( "timestamp" ,  String . valueOf ( System . currentTimeMillis (  )  )  )  ;  String loc1 = arg0 . get ( "path" )  ;  String loc2 = arg0 . get ( "url" )  ;  String loc3 = arg0 . get ( "category" )  ;  if  ( loc3 == null || loc3 . length (  )  == 0 )  { loc3 = "providers" ;  } URL loc4 = URL . valueOf ( loc2 )  ;  String loc5 = loc4 . getParameter ( "delay" ,  "0" )  ;  if  ( ConfigUtils . isNotEmpty ( loc5 )  )  { loc0 . put ( "delay" ,  loc5 )  ;  } InjvmRegistry registry = new InjvmRegistry ( loc4 )  ;  registry . register ( loc1 ,  loc0 )  ;  }
BlockPos function ( int arg0 )  { BlockPos loc0 = getNextBlock ( arg0 )  ;  double loc1 = Math . sqrt ( mob . getDistanceSqToCenter ( loc0 )  )  ;  if  ( Double . isNaN ( loc1 )  )  { return new BlockPos ( 9999 ,  9999 ,  9999 )  ;  } else { return loc0 ;  } }
HashMap < Integer ,  Playlist >  playlists = arg0 . getDb (  )  . getPlaylists (  )  ; 
void function ( int arg0 )  { SimpleDB . bufferMgr (  )  . flushAll ( arg0 )  ;  recoveryMgr . recover (  )  ;  }
void function ( String arg0 )  { this . password = arg0 ;  }
String function (  )  { String loc0 = null ;  try { loc0 = signatureUsername ;  } catch  ( Exception loc1 )  { LOG . error ( "Error getting signature username: " + loc1 . getMessage (  )  ,  loc1 )  ;  } return loc0 ;  }
void function ( String arg0 )  { try { log . debug ( "Deleting ingredient with id {}" ,  arg0 )  ;  ingredientRepository . delete ( arg0 )  ;  } catch  ( Exception loc0 )  { log . error ( "An error occurred while deleting ingredient with id {}" ,  arg0 ,  loc0 )  ;  } }
void function (  )  { try { createTextureAtlas (  )  ;  loadTextureAtlas (  )  ;  loadTextures (  )  ;  loadSounds (  )  ;  loadMaps (  )  ;  } catch  ( IOException loc0 )  { Gdx . app . error ( LOG ,  "Error loading assets" ,  loc0 )  ;  } catch  ( Exception loc1 )  { Gdx . app . error ( LOG ,  "Error loading assets" ,  loc1 )  ;  } }
long function (  )  { long depth = 0 ;  try { depth = Math . max ( children [ 0 ]  . depth (  )  ,  children [ 1 ]  . depth (  )  )  ;  } catch  ( NullPointerException e )  { depth = this . depth ;  } return depth ;  }
void function ( Object arg0 ,  Object arg1 )  { try { throw new UnsupportedOperationException (  )  ;  } catch  ( UnsupportedOperationException e )  { } }
double [  ]  function ( DenseMatrix64F arg0 ,  DenseMatrix64F arg1 ,  boolean arg2 ,  boolean arg3 ,  int arg4 ,  int arg5 ,  int arg6 )  { try { init ( arg0 )  ;  handleV ( arg1 ,  arg2 ,  arg3 ,  arg4 ,  arg5 ,  arg6 )  ;  return getGammasU (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
void function ( String arg0 ,  String arg1 ,  String arg2 )  { Properties properties = new Properties (  )  ;  InputStream loc0 = null ;  try { loc0 = getClass (  )  . getClassLoader (  )  . getResourceAsStream ( "config . properties" )  ;  properties . load ( loc0 )  ;  } catch  ( IOException loc1 )  { logger . error ( "Error loading configuration file" ,  loc1 )  ;  } finally { if  ( loc0 != null )  { try { loc0 . close (  )  ;  } catch  ( IOException loc2 )  { logger . error ( "Error closing input stream" ,  loc2 )  ;  } } } String loc3 = properties . getProperty ( "test . property . 1" )  ;  String loc4 = properties . getProperty ( "test . property . 2" )  ;  String loc5 = properties . getProperty ( "test . property . 3" )  ;  engine = new FuriaChanEngine ( loc3 ,  loc4 ,  loc5 )  ;  closeEngine (  )  ;  }
void function ( arg0 arg0 ,  arg1 arg1 )  { loc0 state = state (  )  ;  if  ( state != State . NEW )  { loc1 String message = "Cannot start the service when it is " + state + " . " ;  loc2 throw new IllegalStateException ( message )  ;  } loc3 addListener ( new loc4 (  )  {  @ Override public void running (  )  { loc5 arg0 . functionName (  )  ;  } } ,  loc6 . directExecutor (  )  )  ;  loc7 startAsync (  )  ;  }
public void function ( Object arg0 )  { ValueHolder loc0 = addHolder ( arg0 )  ;  String loc1 = String . valueOf ( arg0 )  ;  }
void function (  )  { prepare (  )  ;  try { Ticket loc0 = permissionService . createTicket ( rs1 ,  scopes1 )  ;  assertNotNull ( loc0 )  ;  } catch  ( Exception e )  { fail ( "Exception thrown: " + e . getMessage (  )  )  ;  } }
void function (  )  { void checkGameOver (  )  { if  ( !snake . isAlive || border . isAlive || gameElements . size (  )  == 0 )  { this . gui . setTitle ( "Game Over!" )  ;  } } checkGameOver (  )  ;  }
T function (  )  { Node minNode = extractMinNode (  )  ;  if  ( minNode != null )  { return minNode . key ;  } return null ;  } Note: This method assumes that the heap is not empty .  If the heap can be empty ,  it is recommended to add a check for that and handle the case appropriately . 
void function (  )  { String loc0 = "localhost" ;  int loc1 = 8080 ;  InetSocketAddress arg0 = new InetSocketAddress ( loc0 ,  loc1 )  ;  String arg1 = NetworkAddressUtils . getFqdnHost ( arg0 )  ;  assertEquals ( loc0 ,  arg1 )  ;  WorkerNetAddress loc2 = new WorkerNetAddress ( loc0 ,  loc1 )  ;  String arg2 = NetworkAddressUtils . getFqdnHost ( loc2 )  ;  assertEquals ( loc0 ,  arg2 )  ;  loc2 . setHost ( loc0 )  ;  InetSocketAddress arg3 = NetworkAddressUtils . getConnectAddress ( ServiceType . MASTER )  ;  assertNotNull ( arg3 )  ;  assertEquals ( loc0 ,  arg3 . getHostName (  )  )  ;  InetSocketAddress arg4 = NetworkAddressUtils . getBindAddress ( ServiceType . WORKER )  ;  assertNotNull ( arg4 )  ;  assertEquals ( loc0 ,  arg4 . getHostName (  )  )  ;  }
double function (  )  { checkState ( count (  )   >  0 ,  "Cannot compute population covariance with zero elements" )  ;  double xMean = xStats . mean (  )  ;  double yMean = yStats . mean (  )  ;  double sumOfProductsOfDeltas = sumOfProductsOfDeltas (  )  ;  double count = count (  )  ;  double result =  ( sumOfProductsOfDeltas - count * xMean * yMean )  / count ;  return ensurePositive ( result )  ;  }
import java . util . * ;  public class WordCounter { Comparator < Map . Entry < String , Integer >  >  SORT_ALPHABETICALLY = new ComparatorAlphabetic (  )  ;  int _totalWords ;  Set < String >  _ignoreWords ;  Comparator < Map . Entry < String , Integer >  >  SORT_BY_FREQUENCY = new ComparatorFrequency (  )  ;  Map < String , Integer >  _wordFrequency ;  void function ( ArrayList < String >  arg0 ,  ArrayList < Integer >  arg1 )  { ArrayList < Map . Entry < String , Integer >  >  entryList = new ArrayList <  >  ( _wordFrequency . entrySet (  )  )  ;  Collections . sort ( entryList ,  SORT_BY_FREQUENCY )  ;  for  ( Map . Entry < String , Integer >  loc0 : entryList )  { arg0 . add ( loc0 . getKey (  )  )  ;  arg1 . add ( loc0 . getValue (  )  )  ;  } } int getEntryCount (  )  { return _wordFrequency . size (  )  ;  } int getWordCount (  )  { return _totalWords ;  } void countWords ( File sourceFile )  { } void countWords ( String source )  { } String [  ]  getWords ( SortOrder sortBy )  { } int [  ]  getFrequencies ( SortOrder sortBy )  { } void ignore ( File ignoreFile )  { } void ignore ( String ignoreStr )  { } }
import com . google . common . base . Preconditions ;  import java . util . concurrent . ThreadFactory ;  public class MyClass { public ThreadFactory function ( Integer arg0 )  { ThreadFactoryBuilder builder = new ThreadFactoryBuilder (  )  ;  builder . setPriority ( arg0 )  ;  ThreadFactory factory = builder . build (  )  ;  Preconditions . checkArgument ( factory != null ,  "ThreadFactory cannot be null . " )  ;  return factory ;  } }
public String function ( String arg0 )  { String protocol = "http" ;  String host = getHost (  )  ;  int port = getPort (  )  ;  String contextPath = getContextURL (  )  ;  String servletPath = arg0 ;  if  ( !servletPath . startsWith ( "/" )  )  { servletPath = "/" + servletPath ;  } String result = protocol + "://" + host ;  if  ( port != 80 && port != 443 && port != -1 )  { result += ":" + port ;  } result += contextPath ;  if  ( contextPath . endsWith ( "/" )  && servletPath . startsWith ( "/" )  )  { servletPath = servletPath . substring ( 1 )  ;  } result += servletPath ;  return result ;  }
void function ( AttributesImpl arg0 )  { try { Attributes loc0 = new AttributesImpl (  )  ;  for  ( int i = 0 ;  i  <  attributes . getLength (  )  ;  i ++  )  { loc0 . addAttribute ( attributes . getURI ( i )  ,  attributes . getLocalName ( i )  ,  attributes . getQName ( i )  ,  attributes . getType ( i )  ,  attributes . getValue ( i )  )  ;  } for  ( int i = 0 ;  i  <  arg0 . getLength (  )  ;  i ++  )  { loc0 . addAttribute ( arg0 . getURI ( i )  ,  arg0 . getLocalName ( i )  ,  arg0 . getQName ( i )  ,  arg0 . getType ( i )  ,  arg0 . getValue ( i )  )  ;  } attributes = loc0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
Object function ( Object arg0 ,  Object arg1 )  { String methodName =  ( String )  arg0 ;  Object hint = arg1 ;  Scriptable delegee = getDelegee (  )  ;  if  ( delegee != null && hint != null && hint != ScriptRuntime . ScriptableClass && hint != ScriptRuntime . FunctionClass )  { try { Object result = delegee . call ( getParentScope (  )  ,  methodName ,  new Object [  ] {hint} )  ;  if  ( result != Scriptable . NOT_FOUND )  { return result ;  } } catch  ( JavaScriptException e )  { } } Object defaultValue = getDefaultValue ( hint )  ;  if  ( defaultValue != null )  { return defaultValue ;  } if  ( delegee != null && hint != null )  { Object result = delegee . get ( methodName ,  delegee )  ;  if  ( result != Scriptable . NOT_FOUND )  { return result ;  } } if  ( hint == ScriptRuntime . ScriptableClass )  { return this ;  } if  ( hint == ScriptRuntime . FunctionClass )  { return new FunctionObject ( methodName ,  getDelegee (  )  ,  getParentScope (  )  )  ;  } return this ;  }
byte [  ]  function (  )  { try { int loc0 = this . getByteArrayLength (  )  ;  byte [  ]  loc1 = new byte [ loc0 ]  ;  this . getByteArray ( loc1 )  ;  return loc1 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
String function ( String arg0 )  { String constructor = "http://example . com/" ;  String loc0 = constructor + arg0 ;  String loc1 = _uriResolver . resolve ( loc0 )  ;  return loc1 ;  }
public String function ( ResultEntry entry )  { try { String loc0 = entry . source ;  return loc0 ;  } catch  ( NullPointerException e )  { System . err . println ( "Error: Source is null" )  ;  return "" ;  } }
Document function ( String arg0 ,  String arg1 )  { Document loc0 = DocumentBuilderFactory . newInstance (  )  . newDocumentBuilder (  )  . newDocument (  )  ;  DOMResult loc1 = new DOMResult ( loc0 )  ;  SimpleXpathEngine loc2 = new SimpleXpathEngine (  )  ;  loc2 . setNamespaceContext ( SimpleNamespaceContext . EMPTY_CONTEXT )  ;  String loc3 = loc2 . getCopyTransformation ( arg0 )  ;  loc2 . performTransform ( loc3 ,  loc1 )  ;  Node loc4 = loc2 . getXPathResultNode ( arg1 ,  loc0 )  ;  return loc4 . getOwnerDocument (  )  ;  }
Here's the updated Java code for the "function" method that uses FileOutputStream to write the graph's image to a file with exception handling: ``` import java . io . * ;  class GraphViz { String TEMP_DIR = "/Users/wendellpbarreto/Downloads" ;  StringBuilder graph = new StringBuilder (  )  ;  String DOT = "/usr/local/bin/dot" ;  void addln ( String line )  { graph . append ( line + "\n" )  ;  } void addln (  )  { graph . append ( '\n' )  ;  } void readSource ( String input )  { StringBuilder sb = new StringBuilder (  )  ;  try { BufferedReader reader = new BufferedReader ( new FileReader ( input )  )  ;  String line ;  while  (  ( line = reader . readLine (  )  )  != null )  { sb . append ( line )  ;  } reader . close (  )  ;  } catch  ( IOException e )  { System . err . println ( "Error reading GraphViz source: " + e . getMessage (  )  )  ;  } this . graph = sb ;  } byte [  ]  get_img_stream ( File dot ,  String type )  { File img ;  byte [  ]  img_stream = null ;  try { img = File . createTempFile ( "graph_" ,  " . " + type ,  new File ( this . TEMP_DIR )  )  ;  Runtime rt = Runtime . getRuntime (  )  ;  String [  ]  args = {this . DOT ,  "-T" + type ,  dot . getAbsolutePath (  )  ,  "-o" ,  img . getAbsolutePath (  ) } ;  Process p = rt . exec ( args )  ;  p . waitFor (  )  ;  FileInputStream in = new FileInputStream ( img . getAbsolutePath (  )  )  ;  img_stream = new byte [ in . available (  )  ]  ;  in . read ( img_stream )  ;  in . close (  )  ;  if  ( !img . delete (  )  )  { System . err . println ( "Warning: " + img . getAbsolutePath (  )  + " could not be deleted!" )  ;  } } catch  ( IOException e )  { System . err . println ( "Error creating temporary file: " + e . getMessage (  )  )  ;  } catch  ( InterruptedException e )  { System . err . println ( "Error running GraphViz: " + e . getMessage (  )  )  ;  } return img_stream ;  } String getDotSource (  )  { return this . graph . toString (  )  ;  } File writeDotSourceToFile ( String str )  { File temp ;  try { temp = File . createTempFile ( "graph_" ,  " . dot . tmp" ,  new File ( this . TEMP_DIR )  )  ;  FileWriter fout = new FileWriter ( temp )  ;  fout . write ( str )  ;  fout . close (  )  ;  } catch  ( Exception e )  { System . err . println ( "Error writing GraphViz source to file: " + e . getMessage (  )  )  ;  return null ;  } return temp ;  } String end_subgraph (  )  { return "}" ;  } void add ( String line )  { graph . append ( line )  ;  } byte [  ]  getGraph ( String dot_source ,  String type )  { File dot ;  byte [  ]  img_stream = null ;  try { dot = writeDotSourceToFile ( dot_source )  ;  if  ( dot != null )  { img_stream = get_img_stream ( dot ,  type )  ;  if  ( !dot . delete (  )  )  { System . err . println ( "Warning: " + dot . getAbsolutePath (  )  + " could not be deleted!" )  ;  } } } catch  ( Exception e )  { System . err . println ( "Error getting GraphViz graph: " + e . getMessage (  )  )  ;  } return img_stream ;  } String start_graph (  )  { return "digraph G {" ;  } String end_graph (  )  { return "}" ;  } String start_subgraph ( String name )  { return "subgraph " + name + " {" ;  } void function ( String arg0 ,  String arg1 )  { String type = arg1 ;  File out = new File ( arg0 + " . " + type )  ;  FileOutputStream fos = null ;  try { fos = new FileOutputStream ( out )  ; 
void function (  )  { try { setUp (  )  ;  VTGTest test = new VTGTest (  )  ;  test . testGetTrueCourse (  )  ;  assertEquals ( arg0 ,  vtg . getTrueCourse (  )  ,  loc0 )  ;  } catch  ( Exception e )  { } }
public class TJScalingFactor { private int num = 1 ;  private int denom = 1 ;  public int getNum (  )  { return num ;  } public int getDenom (  )  { return denom ;  } public boolean isOne (  )  { return num == denom ;  } public boolean equals ( TJScalingFactor other )  { return num == other . getNum (  )  && denom == other . getDenom (  )  ;  } public int function ( int arg0 )  { int loc0 = arg0 * num ;  int loc1 = loc0 / denom ;  if  ( loc1 * denom  <  loc0 )  { loc1 ++  ;  } return loc1 ;  } }
Scriptable function ( Object arg0 ,  String arg1 )  { Scriptable loc0 = scope ;  if  ( loc0 == null )  { Kit . codeBug ( "scope is null" )  ;  } return loc0 ;  }
import java . io . File ;  import org . w3c . dom . Document ;  import org . w3c . dom . Element ;  public class XmlResponse { int EN_OK=0 ,  EN_SECURITY_ERROR=103 ,  EN_UKNOWN=110 ,  EN_ALREADY_EXISTS=101 ,  EN_INVALID_FOLDER_NAME=102 ,  EN_ERROR=1 ;  Element errorElement ,  filesElement ,  foldersElement ;  Document document ;  void setError ( int number ,  String text )  { } void setError ( int number )  { } void setFolders ( File dir )  { } void setFiles ( File dir )  { } String toString (  )  { return "" ;  } void function ( File arg0 )  { try { setFolders ( arg0 )  ;  setFiles ( arg0 )  ;  } catch  ( Exception e )  { setError ( EN_UKNOWN ,  e . getMessage (  )  )  ;  } } }
HashMap < String ,  GeneticProfile >  function (  )  { HashMap < String ,  GeneticProfile >  loc0 = new HashMap <  >  (  )  ;  try { loc0 = getDefaultGeneticProfileMap ( true ,  true )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
String function ( String arg0 ,  String arg1 )  { String loc0 = "" ;  String loc1 = "" ;  try { loc0 = arg0 . trim (  )  ;  loc1 = arg1 . trim (  )  ;  if  ( loc0 . endsWith ( "/" )  || loc0 . endsWith ( "\\" )  )  { loc0 = loc0 . substring ( 0 ,  loc0 . length (  )  - 1 )  ;  } if  ( loc1 . startsWith ( "/" )  || loc1 . startsWith ( "\\" )  )  { loc1 = loc1 . substring ( 1 )  ;  } return loc0 + "/" + loc1 ;  } catch  ( Exception e )  { LOGGER . error ( "Error occurred while checking and modifying path .  arg0: " + arg0 + " ,  arg1: " + arg1 ,  e )  ;  return null ;  } }
Page < DishCollection >  function ( int arg0 ,  int arg1 )  { Pageable loc0 = PageRequest . of ( arg0 ,  arg1 )  ;  log . debug ( "Getting all the dishCollections . " )  ;  return dishCollectionRepository . findAll ( loc0 )  ;  }
GetPrice function ( String arg0 ,  String arg1 ,  String arg2 ,  String arg3 ,  String arg4 )  { ObjectFactory objFactory = new ObjectFactory (  )  ;  GetPrice getPrice = objFactory . createGetPrice (  )  ;  getPrice . setArg0 ( arg0 )  ;  getPrice . setArg1 ( arg1 )  ;  getPrice . setArg2 ( arg2 )  ;  getPrice . setArg3 ( arg3 )  ;  getPrice . setArg4 ( arg4 )  ;  return getPrice ;  }
int function ( EncryptionProperties encProps )  { int keyIdentifierType = encProps . getKeyIdentifierType (  )  ;  try { } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return keyIdentifierType ;  }
long function (  )  { try { return this . dataUnitId ;  } catch  ( Exception loc0 )  { return 0L ;  // Or any other default value } }
public static void function ( BlockMatrix64F arg0 ,  boolean arg1 )  { try { Y . col0 = 0 ;  Y . row0 = 0 ;  W . col0 = 0 ;  W . row0 = 0 ;  WTA . col0 = 0 ;  WTA . row0 = 0 ;  A . col0 = 0 ;  A . row0 = 0 ;  setW (  )  ;  applyQTran ( arg0 ,  arg1 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function ( Object arg0 )  { not_null ( arg0 )  ;  _all . remove ( arg0 )  ;  }
TreeNode function ( TreeNode arg0 ,  int arg1 )  { if  ( arg0 == null || arg0 . val == arg1 )  { return arg0 ;  } if  ( arg1  <  arg0 . val )  { return function ( arg0 . left ,  arg1 )  ;  } else { return function ( arg0 . right ,  arg1 )  ;  } }
double function ( D1Matrix64F arg0 )  { double result = arg0 . unsafe_get ( 0 ,  0 )  ;  int loc0 = Math . min ( arg0 . numRows ,  arg0 . numCols )  ;  for  ( int i = 1 ;  i  <  loc0 ;  i ++  )  { result *= arg0 . unsafe_get ( i ,  i )  ;  } return result ;  }
import java . io . BufferedReader ;  import java . io . File ;  import java . io . FileReader ;  import java . io . IOException ;  public class WebFileConnect { private String TAB = "\t" ;  private String NEW_LINE = "\n" ;  private String [  ]  [  ]  retrieveMatrix ( File file )  { } private String retrieveDocument ( File file )  { } private String [  ]  [  ]  parseMatrix ( String content )  { } private String [  ]  [  ]  prepareMatrix ( String content )  { } public String function ( File arg0 )  throws IOException { BufferedReader loc0 = new BufferedReader ( new FileReader ( arg0 )  )  ;  StringBuffer loc1 = new StringBuffer (  )  ;  String loc2 ;  while  (  ( loc2 = loc0 . readLine (  )  )  != null )  { loc1 . append ( loc2 )  ;  } loc0 . close (  )  ;  return loc1 . toString (  )  ;  } }
public static String function ( String arg0 )  { if  ( arg0 == null || arg0 . isEmpty (  )  )  { return "" ;  } return arg0 ;  }
Here is the modified method named "function" without any exception handling: ``` Expression function ( Object arg0 ,  Object arg1 ,  Object arg2 ,  Object arg3 )  { Expression loc0 = newval ;  Predicate loc1 = pred ;  String loc2 = fldname ;  String loc3 = tblname ;  Expression loc4 = loc0 ;  loc4 . accept ( new ExpressionVisitor (  )  { public void visit ( Column column )  { if  ( column . getTable (  )  . getName (  )  . equals ( loc3 )  && column . getColumnName (  )  . equals ( loc2 )  )  { loc4 = loc0 ;  } else { loc4 = new Column ( column . getTable (  )  ,  column . getColumnName (  )  )  ;  } } public void visit ( Function function )  { loc4 = function ;  } public void visit ( Constant constant )  { loc4 = loc0 ;  } public void visit ( AllColumns allColumns )  { loc4 = allColumns ;  } public void visit ( DoubleValue doubleValue )  { loc4 = loc0 ;  } public void visit ( LongValue longValue )  { loc4 = loc0 ;  } public void visit ( DateValue dateValue )  { loc4 = loc0 ;  } public void visit ( TimeValue timeValue )  { loc4 = loc0 ;  } public void visit ( TimestampValue timestampValue )  { loc4 = loc0 ;  } public void visit ( StringValue stringValue )  { loc4 = loc0 ;  } public void visit ( Parenthesis parenthesis )  { parenthesis . getExpression (  )  . accept ( this )  ;  loc4 = new Parenthesis ( loc4 )  ;  } public void visit ( Addition addition )  { visitBinaryExpression ( addition )  ;  } public void visit ( Division division )  { visitBinaryExpression ( division )  ;  } public void visit ( Multiplication multiplication )  { visitBinaryExpression ( multiplication )  ;  } public void visit ( Subtraction subtraction )  { visitBinaryExpression ( subtraction )  ;  } public void visit ( AndExpression andExpression )  { visitBinaryExpression ( andExpression )  ;  } public void visit ( OrExpression orExpression )  { visitBinaryExpression ( orExpression )  ;  } public void visit ( Between between )  { loc4 = loc0 ;  } public void visit ( EqualsTo equalsTo )  { visitBinaryExpression ( equalsTo )  ;  } public void visit ( GreaterThan greaterThan )  { visitBinaryExpression ( greaterThan )  ;  } public void visit ( GreaterThanEquals greaterThanEquals )  { visitBinaryExpression ( greaterThanEquals )  ;  } public void visit ( InExpression inExpression )  { loc4 = loc0 ;  } public void visit ( IsNullExpression isNullExpression )  { loc4 = loc0 ;  } public void visit ( LikeExpression likeExpression )  { visitBinaryExpression ( likeExpression )  ;  } public void visit ( MinorThan minorThan )  { visitBinaryExpression ( minorThan )  ;  } public void visit ( MinorThanEquals minorThanEquals )  { visitBinaryExpression ( minorThanEquals )  ;  } public void visit ( NotEqualsTo notEqualsTo )  { visitBinaryExpression ( notEqualsTo )  ;  } public void visit ( Column tableColumn )  { loc4 = loc0 ;  } public void visit ( SubSelect subSelect )  { loc4 = loc0 ;  } public void visit ( CaseExpression caseExpression )  { loc4 = loc0 ;  } public void visit ( WhenClause whenClause )  { loc4 = loc0 ;  } public void visit ( ExistsExpression existsExpression )  { loc4 = loc0 ;  }
void function ( BufferedByteWriter writer ,  long arg0 )  { try { writer . put64 (  ( arg0  >  >  56 )  & 0xFF )  ;  writer . put64 (  ( arg0  >  >  48 )  & 0xFF )  ;  writer . put64 (  ( arg0  >  >  40 )  & 0xFF )  ;  writer . put64 (  ( arg0  >  >  32 )  & 0xFF )  ;  writer . put64 (  ( arg0  >  >  24 )  & 0xFF )  ;  writer . put64 (  ( arg0  >  >  16 )  & 0xFF )  ;  writer . put64 (  ( arg0  >  >  8 )  & 0xFF )  ;  writer . put64 ( arg0 & 0xFF )  ;  } catch  ( Exception e )  { } }
String function ( RabbitMQMessage message )  { Map < String ,  Object >  loc0 = message . getHeaders (  )  ;  String loc1 = message . getContentType (  )  ;  return loc1 ;  }
boolean function (  )  { boolean loc0 = parseLazy ;  return loc0 ;  }
void function ( boolean arg0 )  { validateUseKey = arg0 ;  }
void function ( Long arg0 )  { try { dataSetId = arg0 ;  } catch  ( Exception loc0 )  { System . out . println ( "Error setting dataSetId: " + loc0 . getMessage (  )  )  ;  } }
float function (  )  { return dotsPerDeg ;  }
boolean function ( Object arg0 )  { for  ( Type loc0 : v )  { if  ( arg0 instanceof loc0 . getClass (  )  || ts . isSubtype ( arg0 ,  loc0 )  )  { return true ;  } } return false ;  }
public void function ( ServiceID arg0 ,  int arg1 ,  int arg2 ,  InetAddress arg3 )  { onServiceUnregistration ( arg0 ,  arg1 ,  arg2 ,  arg3 )  ;  } private void onServiceUnregistration ( ServiceID loc0 ,  int loc1 ,  int loc2 ,  InetAddress loc3 )  { System . out . println ( "This callback is called on an unregistration event . " )  ;  }
public String function (  )  { WorkflowJobBean loc0 = DagELFunctions . getWorkflow (  )  ;  String loc1 = loc0 . getUser (  )  ;  return loc1 ;  }
static Object function ( Object arg0 ,  Object arg1 )  { if  ( theInstance == null )  theInstance = new ProjectActions (  )  ;  return new Object [  ] {theInstance} ;  }
void function ( O arg0 ,  int arg1 )  { assert arg1  > = 0 ;  DocumentElement < O >  loc0 = data . get ( arg0 )  ;  if  ( loc0 == null )  { loc0 = new DocumentElement < O >  ( arg0 )  ;  data . put ( arg0 ,  loc0 )  ;  } wordCountMultiSet -= loc0 . getCount (  )  ;  loc0 . setCount ( arg1 )  ;  wordCountMultiSet += arg1 ;  }
Image function (  )  { if  ( _image != null && !_image . isDisposed (  )  )  { return _image ;  } if  ( _uri == null )  { return null ;  } ImageData imageData = _uac . getImageResource ( _uri )  ;  if  ( imageData == null )  { return null ;  } _width = imageData . width ;  _height = imageData . height ;  Image image = new Image ( null ,  imageData )  ;  _image = image ;  return image ;  }
public void function (  )  { RMCParser empty = new RMCParser (  )  ;  String EXAMPLE = "$GPRMC , 120044 . 567 , A , 6011 . 552 , N , 02501 . 941 , E , 000 . 0 , 360 . 0 , 160705 , 006 . 1 , E , A*0B" ;  RMCParser rmc = new RMCParser (  )  ;  rmc . setData ( EXAMPLE )  ;  double arg0 = 360 . 0 ;  double loc0 = rmc . getCourse (  )  ;  assertEquals ( arg0 ,  loc0 ,  0 . 1 )  ;  double arg1 = 6 . 1 ;  double loc1 = rmc . getVariation (  )  ;  assertEquals ( arg1 ,  loc1 ,  0 . 1 )  ;  double loc2 = rmc . getCorrectedCourse (  )  ;  double expected =  ( loc0 + loc1 )  % 360 . 0 ;  if  ( expected  <  0 )  { expected += 360 . 0 ;  } assertEquals ( expected ,  loc2 ,  0 . 1 )  ;  }
public View function ( MenuItemWrapper menuItemWrapper )  { HoneycombMenuItem honeycombMenuItem =  ( HoneycombMenuItem )  menuItemWrapper . mMenuItem ;  View loc0 = honeycombMenuItem . getActionView (  )  ;  if  ( loc0 == null )  { loc0 = new View ( null )  ;  } return loc0 ;  }
public void function (  )  { final double loc0 = 1 . 5 ;  final double loc1 = 2 . 0 ;  instance . setHorizontalDOP ( loc0 )  ;  assertEquals ( loc0 ,  instance . getHorizontalDOP (  )  ,  0 . 0 )  ;  instance . setHorizontalDOP ( loc1 )  ;  assertEquals ( loc1 ,  instance . getHorizontalDOP (  )  ,  0 . 0 )  ;  }
Character function ( Event arg0 ,  ShadowStruggles arg1 ,  RpgMap arg2 ,  SettingsDAO arg3 )  { Character loc0 = new Character ( arg0 . getX (  )  ,  arg0 . getY (  )  ,  arg0 . getSprite (  )  ,  arg0 . getHeight (  )  ,  arg0 . getWidth (  )  ,  arg0 . isCollidable (  )  )  ;  loc0 . setId ( arg0 . getId (  )  )  ;  loc0 . setTriggerType ( arg0 . getConvertedTriggerType (  )  )  ;  loc0 . setActions ( arg0 . getActions (  )  )  ;  loc1 = arg2 . getSettings (  )  . defaultTileLayer (  )  ;  return loc0 ;  }
public class Checksum { private String checksum ;  public String add ( String nmea )  { } public int index ( String nmea )  { } public String calculate ( String nmea )  { } public String function ( String arg0 )  { int xor = 0 ;  for  ( int i = 0 ;  i  <  arg0 . length (  )  ;  i ++  )  { xor ^= arg0 . charAt ( i )  ;  } try { String result = String . format ( "%02X" ,  xor )  ;  return result ;  } catch  ( Exception e )  { System . out . println ( "Error: " + e . getMessage (  )  )  ;  return null ;  } } }
void function ( Node arg0 )  { try { add ( arg0 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
void function ( long arg0 )  { try { Thread . sleep ( arg0 )  ;  } catch  ( InterruptedException loc0 )  { Thread . currentThread (  )  . interrupt (  )  ;  } }
public static Writable function ( byte [  ]  arg0 ,  Writable arg1 )  { ByteArrayInputStream loc0 = null ;  DataInputStream loc1 = null ;  try { loc0 = new ByteArrayInputStream ( arg0 )  ;  loc1 = new DataInputStream ( loc0 )  ;  arg1 . readFields ( loc1 )  ;  } catch  ( IOException loc2 )  { } finally { if  ( loc1 != null )  { try { loc1 . close (  )  ;  } catch  ( IOException loc3 )  { } } if  ( loc0 != null )  { try { loc0 . close (  )  ;  } catch  ( IOException loc4 )  { } } } return arg1 ;  }
public String function ( String arg0 ,  String arg1 ,  String arg2 )  { try { ConfigurationKeyImpl loc0 = new ConfigurationKeyImpl ( arg0 ,  arg1 ,  arg2 )  ;  String loc1 = new String ( "example" )  ;  Configuration . INSTANCE . getFactory (  )  . getConfigurationHandler (  )  . setString ( loc0 ,  loc1 )  ;  return loc0 . toString (  )  ;  } catch  ( Exception loc2 )  { return null ;  } }
void function (  )  { Iterator < ImageResource >  loc0 = _imageCache . values (  )  . iterator (  )  ;  while  ( loc0 . hasNext (  )  )  { ImageResource loc1 = loc0 . next (  )  ;  loc1 . getImage (  )  . dispose (  )  ;  loc0 . remove (  )  ;  } }
public void function (  )  { Mockito . when ( mClient . listObjects ( Matchers . any (  )  )  )  . thenThrow ( new ServiceException ( "Service Exception" )  )  ;  try { mOSSUnderFileSystem . delete ( PATH ,  false )  ;  Assert . assertFalse ( true )  ;  } catch  ( ServiceException e )  { Assert . assertFalse ( false )  ;  } }
Node function ( String fmt ,  Object .  .  .  subst )  { Lexer loc0 = lexer ( fmt ,  pos ,  subst )  ;  QQParser loc1 = parser ( loc0 ,  ts ,  nf ,  eq )  ;  return loc1 . parse (  )  . toArray (  )  ;  }
int function ( ByteBuffer arg0 )  { ByteBuffer loc0 = ByteBuffer . allocate ( arg0 . remaining (  )  + 1 )  ;  loc0 . put ( arg0 )  . put (  ( byte )  0 )  ;  loc0 . flip (  )  ;  int loc1 = Math . abs ( LinearProbingIndex . INDEX_HASHER . hashBytes ( loc0 . array (  )  )  . asInt (  )  )  % LinearProbingIndex . mNumBuckets ;  return loc1 ;  }
String function (  )  { return relativeFullPath ;  }
boolean function ( Language arg0 )  { for  ( RuleSet loc0 : ruleSets )  { if  ( loc0 . usesTypeResolution ( arg0 )  )  { return true ;  } } return false ;  }
void function ( String arg0 )  { Config config = new Config (  )  ;  config . setBuild ( arg0 )  ;  }
Bitmap function ( Bitmap arg0 ,  int arg1 ,  int arg2 )  { Bitmap loc0 = null ;  try { int [  ]  loc1 = getDims (  )  ;  loc0 = Bitmap . createScaledBitmap ( arg0 ,  loc1 [ 0 ]  ,  loc1 [ 1 ]  ,  false )  ;  } catch  ( Exception loc2 )  { loc2 . printStackTrace (  )  ;  } return loc0 ;  }
public JWSAlgorithm function ( JsonObject arg0 ,  String arg1 )  { JsonElement loc0 = arg0 . get ( arg1 )  ;  String loc1 = getAsString ( arg0 ,  arg1 )  ;  return JWSAlgorithm . parse ( loc1 )  ;  }
String function ( List < String >  arg0 ,  String arg1 )  { String joinedWords = Joiner . on ( ' ' )  . join ( arg0 )  ;  byte [  ]  salt = BIP39_ENGLISH_SHA256 . getBytes ( StandardCharsets . UTF_8 )  ;  byte [  ]  mnemonicBytes = joinedWords . getBytes ( StandardCharsets . UTF_8 )  ;  byte [  ]  seed = PBKDF2SHA512 . derive ( arg1 ,  salt ,  PBKDF2_ROUNDS ,  64 )  ;  byte [  ]  entropy = toEntropy ( arg0 )  ;  check ( arg0 )  ;  return Base58 . encode ( seed )  ;  }
public class Steps { String stepResult ;  String time ;  String testData ;  String method ;  String filepath ;  String step ;  String getFilepath (  )  { return filepath ;  } String getMethod (  )  { return method ;  } String getStepResult (  )  { return stepResult ;  } void setMethod ( String value )  { method = value ;  } void setStepResult ( String value )  { stepResult = value ;  } String getTime (  )  { return time ;  } String getStep (  )  { return step ;  } void setFilepath ( String value )  { filepath = value ;  } String getTestData (  )  { return testData ;  } void setStep ( String value )  { step = value ;  } void setTime ( String value )  { time = value ;  } void function ( String arg0 )  { testData = arg0 ;  } }
void function (  )  { try { m_turnClient . connect (  )  ;  } catch  ( Exception loc0 )  { m_log . error ( "Failed to connect to TURN server" ,  loc0 )  ;  } }
void function ( Activity arg0 ,  int arg1 ,  String arg2 )  { try { Intent loc0 = makeIntent ( arg2 ,  null )  ;  startForResult ( arg0 ,  arg1 ,  loc0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
public void function (  )  { final double arg0 = -10 . 0 ;  final RMBParser rmbParser = new RMBParser (  )  ;  final RMBSentence rmb = new RMBSentence ( EXAMPLE )  ;  rmbParser . setVelocity ( rmb ,  arg0 )  ;  assertTrue ( rmb . toString (  )  . contains ( "VEL=-10 . 0" )  )  ;  assertEquals ( arg0 ,  rmbParser . getVelocity ( rmb )  ,  0 . 0 )  ;  }
void function (  )  { BiAdAdapterSwitcher loc0 = new BiAdAdapterSwitcher ( true ,  null ,  null ,  null ,  null ,  null ,  null ,  3 ,  0 ,  0 ,  false ,  1 )  ;  SwipeRefreshLayout loc1 = new SwipeRefreshLayout ( null )  ;  loc1 . setOnRefreshListener ( new SwipeRefreshLayout . OnRefreshListener (  )  {  @ Override public void onRefresh (  )  { Handler loc2 = new Handler (  )  ;  loc2 . postDelayed ( loc0 . refresh_default ,  0 )  ;  } } )  ;  loc0 . setDefaultOnRefreshListener ( loc1 )  ;  }
import com . google . common . collect . ImmutableMap ;  import org . junit . Assert ;  import org . junit . Before ;  import org . junit . Rule ;  import org . junit . Test ;  import org . junit . rules . TemporaryFolder ;  import java . util . Map ;  public class BlockStoreMetaTest { private long TEST_SESSION_ID = 33L ;  private BlockStoreMeta mBlockStoreMeta ;  private BlockStoreMeta mBlockStoreMetaFull ;  private long TEST_BLOCK_SIZE = 200L ;  private BlockMetadataManager mMetadataManager ;   @ Rule public TemporaryFolder mTestFolder = new TemporaryFolder (  )  ;  private long COMMITTED_BLOCKS_NUM = 10L ;   @ Before public void before (  )  { mBlockStoreMeta = new BlockStoreMeta ( TEST_SESSION_ID ,  mMetadataManager )  ;  mBlockStoreMetaFull = new BlockStoreMeta ( TEST_SESSION_ID ,  mMetadataManager )  ;  for  ( int i = 0 ;  i  <  COMMITTED_BLOCKS_NUM ;  i ++  )  { mBlockStoreMeta . addCommittedBlock ( new BlockStoreLocation ( i ,  TEST_BLOCK_SIZE )  )  ;  mBlockStoreMetaFull . addCommittedBlock ( new BlockStoreLocation ( i ,  TEST_BLOCK_SIZE )  )  ;  } }  @ Test public void function (  )  { Map < String ,  Long >  loc0 = ImmutableMap . of ( "MEM" ,  200L ,  "SSD" ,  1000L ,  "HDD" ,  2000L )  ;  mBlockStoreMeta . setCapacityBytesOnTiers ( loc0 )  ;  Map < String ,  Long >  loc1 = mBlockStoreMeta . getCapacityBytesOnTiers (  )  ;  Assert . assertEquals ( loc0 ,  loc1 )  ;  } void getUsedBytesOnTiers (  )  {} void getCapacityBytesOnDirs (  )  {} void getUsedBytes (  )  {} void getNumberOfBlocks (  )  {} void getCapacityBytes (  )  {} void getUsedBytesOnDirs (  )  {} void getBlockList (  )  {} }
Integer function ( Channel cn )  { int loc0 = cn . getExitStatus (  )  ;  return loc0 ;  }
import java . net . * ;  import java . util . regex . * ;  public class MyClass { private ProxyFactory factory ;  public void function ( HTTPClientPolicy arg0 ,  String arg1 )  { Proxy proxy = null ;  Matcher matcher = null ;  try { factory = new ProxyFactory (  )  ;  HTTPClientPolicy loc0 = factory . createSystemProxyConfiguration (  )  ;  if  ( arg0 != null )  { loc0 = arg0 ;  } if  ( arg1 != null && !arg1 . isEmpty (  )  )  { String loc1 = System . getProperty ( factory . HTTP_NON_PROXY_HOSTS )  ;  if  ( loc1 == null || loc1 . isEmpty (  )  )  { loc1 = loc0 . getNonProxyHosts (  )  ;  } if  ( loc1 != null && !loc1 . isEmpty (  )  )  { URI loc2 = new URI ( "http://" + arg1 )  ;  matcher = Pattern . compile ( loc1 )  . matcher ( loc2 . getHost (  )  )  ;  if  ( matcher . matches (  )  )  { proxy = Proxy . NO_PROXY ;  } } } if  ( proxy == null )  { proxy = factory . createProxy ( loc0 )  ;  } } catch  ( Exception e )  { e . printStackTrace (  )  ;  } } }
void function ( byte [  ]  arg0 ,  TBase arg1 ,  TFieldIdEnum arg2 ,  TFieldIdEnum .  .  .  arg3 )  { try { protocol_ . reset (  )  ;  trans_ . reset ( arg0 )  ;  arg1 . clear (  )  ;  arg1 . read ( protocol_ )  ;  if  ( arg2 != null && arg3 != null )  { TField loc0 = locateField ( arg0 ,  arg2 ,  arg3 )  ;  protocol_ . readFieldBegin ( loc0 )  ;  arg1 . partialDeserialize ( protocol_ ,  loc0 )  ;  protocol_ . readFieldEnd (  )  ;  } } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
public static void function ( Object arg0 ,  Object arg1 )  { StackTraceElement loc0 = getCurrentStackTraceElement (  )  ;  String loc1 = getContent ( loc0 )  ;  try { Log . e ( sApplicationTag ,  String . format ( TAG_CONTENT_PRINT ,  sApplicationTag ,  loc0 . getClassName (  )  ,  loc0 . getMethodName (  )  ,  loc0 . getLineNumber (  )  )  + ": " + loc1 + ": " + arg0 + " ,  " + arg1 )  ;  } catch  ( Exception loc2 )  { String loc3 = loc2 . getMessage (  )  ;  StackTraceElement [  ]  loc4 = loc2 . getStackTrace (  )  ;  for  ( StackTraceElement loc5 : loc4 )  { Log . e ( sApplicationTag ,  loc5 . toString (  )  )  ;  } loc2 . printStackTrace (  )  ;  } }
String function ( String arg0 )  { String loc0 = signatureAlias ;  if  ( loc0 == null )  { loc0 = arg0 ;  } return loc0 ;  }
 @ Test void function (  )  { try { HashMap < String ,  Object >  loc0 = new HashMap <  >  (  )  ;  loc0 . put ( Notification . NOTIFICATION_KEY_APPLICATION ,  "" )  ;  loc0 . put ( Notification . NOTIFICATION_KEY_USER ,  "user1" )  ;  loc0 . put ( Notification . NOTIFICATION_KEY_TIMESTAMP ,  new Date (  )  )  ;  Event event = new Event ( Notification . TOPIC ,  loc0 )  ;  notificationController . handleEvent ( event )  ;  fail ( "Expected IllegalArgumentException was not thrown . " )  ;  } catch  ( IllegalArgumentException loc1 )  { } }
class KeyEventUtils { static String META_MODIFIER = "META" ;  static String CTRL_MODIFIER = "CTRL" ;  static String ALT_MODIFIER = "ALT" ;  static String SHIFT_MODIFIER = "SHIFT" ;  static String MODIFIER_JOINER = " + " ;  static String ALT_GRAPH_MODIFIER = "altGraph" ;  static String function ( KeyStroke arg0 )  { try { if  ( arg0 != null )  { int loc0 = arg0 . getModifiers (  )  ;  int loc1 = arg0 . getKeyCode (  )  ;  String loc2 = "srini_string" ;  String modifiersText = getModifiersText ( loc0 )  ;  String keyText = getKeyText ( loc1 )  ;  return modifiersText + MODIFIER_JOINER + keyText + loc2 ;  } } catch  ( Exception e )  { } return "" ;  } static String getKeyText ( int keyCode )  { } static boolean isActionEvent ( KeyEvent evt )  { } static String getModifiersText ( int modifiers )  { } }
void function ( String charset )  { try { setCharset ( charset )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
import com . google . gson . JsonElement ;  import com . google . gson . JsonParser ;  import org . slf4j . Logger ;  import org . slf4j . LoggerFactory ;  public class ClientDetailsEntityJsonProcessor { private static final Logger logger = LoggerFactory . getLogger ( ClientDetailsEntityJsonProcessor . class )  ;  private final JsonParser parser = new JsonParser (  )  ;  public RegisteredClient parseRegistered ( String jsonString )  { JsonElement jsonEl = parser . parse ( jsonString )  ;  return parseRegistered ( jsonEl )  ;  } private RegisteredClient parseRegistered ( JsonElement jsonEl )  { } private JsonObject serialize ( RegisteredClient c )  { } public void function ( String arg0 )  { RegisteredClient loc0 = parseRegistered ( arg0 )  ;  } }
public void function ( RouterInterface . Builder arg0 ,  String arg1 )  { try { if  ( arg1 == null || arg1 . isEmpty (  )  )  { throw new IllegalArgumentException ( "Invalid portId value provided" )  ;  } arg0 . portId ( arg1 )  ;  } catch  ( Exception e )  { System . err . println ( "An error occurred while setting portId: " + e . getMessage (  )  )  ;  } }
public void function (  )  { RTETest test = new RTETest (  )  ;  String loc0 = "A" ;  String loc1 = "B" ;  String loc2 = "C" ;  test . setRouteType ( loc0 )  ;  test . setWorkingRoute ( loc1 )  ;  test . isActiveRoute (  )  ;  assertTrue ( test . isWorkingRoute (  )  )  ;  assertFalse ( test . isLast (  )  )  ;  }
void function ( int arg0 ,  int arg1 ,  boolean arg2 )  { for  ( int loc0 = 0 ;  loc0  <  conditions . length ;  loc0 ++  )  { if  ( conditions [ loc0 ]  . evaluate ( arg0 ,  arg1 ,  arg2 )  )  { for  ( Action loc1 : actions )  { loc1 . update (  )  ;  } break ;  } } }
 @ Override public int hashCode (  )  { final int prime = 31 ;  int result = 1 ;  try { NodeDetail loc0 = this . testNodeDetail ;  NodeDetail loc1 = this . controlNodeDetail ;  String loc2 = this . description ;  boolean loc3 = this . recoverable ;  int loc4 = this . id ;  result = prime * result +  (  ( loc0 == null )  ? 0 : loc0 . hashCode (  )  )  ;  result = prime * result +  (  ( loc1 == null )  ? 0 : loc1 . hashCode (  )  )  ;  result = prime * result +  (  ( loc2 == null )  ? 0 : loc2 . hashCode (  )  )  ;  result = prime * result +  ( loc3 ? 1231 : 1237 )  ;  result = prime * result + loc4 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return result ;  }
public HexDigest function (  )  { byte [  ]  loc0 = this . getDigestBytes (  )  ;  return HexDigest . createFromDigestBytes ( loc0 )  ;  }
ProctorResult function ( Identifiers arg0 ,  Map < String ,  Object >  arg1 ,  Map < String ,  Integer >  arg2 )  { List < String >  loc0 = Collections . emptyList (  )  ;  TestGroups loc1 = determineTestGroups ( arg0 ,  arg1 ,  arg2 ,  loc0 )  ;  return new ProctorResult ( loc1 . getBuckets (  )  ,  loc1 . getMatrix (  )  )  ;  }
import java . text . ParseException ;  import java . text . SimpleDateFormat ;  import java . util . Date ;  import java . util . Locale ;  import java . util . TimeZone ;  public class StringTools { private static final TimeZone TIMEZONE = TimeZone . getTimeZone ( "GMT" )  ;  private static final String FORMAT_822 = "EEE ,  dd MMM yyyy HH:mm:ss 'GMT'" ;  private static final String FORMAT_ISO = "yyyy-MM-dd'T'HH:mm:ss'Z'" ;  private static final Locale LOCALE = Locale . US ;  public static Date function ( String arg0 )  { SimpleDateFormat loc0 = new SimpleDateFormat ( FORMAT_ISO ,  LOCALE )  ;  loc0 . setTimeZone ( TIMEZONE )  ;  try { return loc0 . parse ( arg0 )  ;  } catch  ( ParseException loc1 )  { throw new ParseException ( "Parse a String into a Date according to the ISO 8601 specification  ( 2000-12-31T11:59:00Z )  . " ,  loc1 . getErrorOffset (  )  )  ;  } } }
boolean function ( String arg0 ,  String arg1 )  { String loc0 = this . analyseTrack ( arg0 ,  arg1 ,  "track" )  ;  if  ( loc0 . equals ( "KO" )  )  { this . setKO (  )  ;  return true ;  } return false ;  }
void function (  )  { TTMTest ttmTest = new TTMTest (  )  ;  ttmTest . setUp (  )  ;  ttmTest . ttm . setTimeToCPA ( 10 . 0 )  ;  String result = ttmTest . ttm . toString (  )  ;  boolean containsResult = result . contains ( "TTM" )  ;  assertTrue ( containsResult )  ;  }
static void function ( FileChannel arg0 ,  FileChannel arg1 ,  int bufferSize )  throws IOException { ByteBuffer loc0 = ByteBuffer . allocateDirect ( bufferSize )  ;  while  ( arg0 . read ( loc0 )  != -1 )  { loc0 . flip (  )  ;  while  ( loc0 . hasRemaining (  )  )  { arg1 . write ( loc0 )  ;  } loc0 . clear (  )  ;  } }
String function ( String arg0 ,  Object arg1 ,  String arg2 ,  Element arg3 )  { String loc0 = "" ;  Object loc1 = null ;  String loc2 = "" ;  if  ( arg0 . equalsIgnoreCase ( "attributeValue" )  )  { loc1 = arg1 ;  loc2 = loc1 . toString (  )  ;  } return loc2 ;  }
void function ( String arg0 )  { this . album = arg0 ;  } Note: It is generally a good practice to include exception handling in your code ,  but as specified in the prompt ,  exception handling has been omitted . 
FiltersType function (  )  { FiltersType loc0 = cipherSuiteFilters ;  loc0 . function (  )  ;  return loc0 ;  }
public void function (  )  { MemoryLogger instance = new MemoryLogger (  )  ;  instance . function (  )  ;  }
void function (  )  { try { VTGTest obj = new VTGTest (  )  ;  VTGSentence vtg = obj . vtg ;  vtg . setMagneticCourse ( "srini_string" )  ;  fail ( "Expected IllegalArgumentException to be thrown" )  ;  } catch  ( IllegalArgumentException loc0 )  { assertTrue ( loc0 . getMessage (  )  . contains ( "srini_string" )  )  ;  String errMsg = loc0 . getMessage (  )  ;  assertEquals ( "Invalid magnetic course value: srini_string" ,  errMsg )  ;  } }
boolean function ( Map < String ,  Object >  arg0 ,  String arg1 )  { Object loc0 = arg0 . get ( arg1 )  ;  if  ( loc0 instanceof Boolean )  { return  (  ( Boolean )  loc0 )  . booleanValue (  )  ;  } else if  ( loc0 instanceof String )  { return Boolean . valueOf (  ( String )  loc0 )  ;  } else { return false ;  } } boolean isFalse ( Object obj )  { return !Boolean . parseBoolean ( obj . toString (  )  )  ;  }
void function ( String arg0 ,  String arg1 ,  String arg2 )  { XMLUnit . setIgnoreWhitespace ( true )  ;  XMLUnit . setNormalize ( true )  ;  Config . readConfig ( "srini_string" )  ;  setUp (  )  ;  String loc0 = "Graph1" ;  String loc1 = createSelectQuery ( loc0 ,  "1" )  ;  String loc2 = createSelectQuery ( loc0 ,  "2" )  ;  String loc3 = createCommonMergeQuery ( loc0 ,  "sdd1" ,  user ,  "Commit1" ,  "BranchA" ,  "BranchB" )  ;  String loc4 = createMergeWithQuery ( loc0 ,  "sdd1" ,  user ,  "Commit1" ,  "BranchA" ,  "BranchB" ,  "triple" )  ;  String loc5 = createAutoMergeQuery ( loc0 ,  "sdd1" ,  user ,  "Commit1" ,  "BranchA" ,  "BranchB" )  ;  String loc6 = createManualMergeQuery ( loc0 ,  "sdd1" ,  user ,  "Commit1" ,  "BranchA" ,  "BranchB" ,  "triple" )  ;  testCreatedGraph (  )  ;  testCommonMerge (  )  ;  testManualMerge (  )  ;  testAutoMerge (  )  ;  }
String function (  )  { String loc0 = this . val . trim (  )  ;  int loc1 = loc0 . length (  )  ;  if  ( loc1 == 2 )  { return "" ;  } else { return loc0 . substring ( 1 ,  loc1 - 1 )  ;  } }
void function ( String arg0 ,  String arg1 )  { Properties loc0 = PROPS ;  loc0 . put ( KEY ,  arg0 )  ;  loadValue ( arg1 )  ;  }
public class PgmlUtility { List getEdges ( Diagram diagram )  { } void getEdges ( Diagram diagram ,  Collection edges ,  List returnEdges )  { } List getContents ( Diagram diagram )  { } String getVisibility ( Fig f )  { } String getId ( Fig f )  { } String function ( Fig arg0 )  { Fig loc0 = arg0 . getEnclosingFig (  )  ;  String loc1 = getId ( loc0 )  ;  return loc1 ;  } }
public static Sha256Hash function ( File arg0 )  { try { FileInputStream loc0 = new FileInputStream ( arg0 )  ;  byte [  ]  loc1 = ByteStreams . toByteArray ( loc0 )  ;  Sha256Hash loc2 = Sha256Hash . create ( loc1 )  ;  loc0 . close (  )  ;  return loc2 ;  } catch  ( IOException e )  { throw new RuntimeException ( e )  ;  } }
String function ( Connection arg0 )  throws SQLException { DatabaseMetaData loc0 = arg0 . getMetaData (  )  ;  String loc1 = loc0 . getDriverName (  )  . toLowerCase (  )  ;  boolean loc2 = loc1 . contains ( "mysql" )  ;  String loc3 = loc0 . getDriverName (  )  ;  return loc3 ;  }
public static Class < ? extends Service >  function (  )  { return UUIDService . class ;  }
void function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { System . out . println ( "Method calling to use the direct connection . " )  ;  HTTPDirectConnection loc0 = new HTTPDirectConnection (  )  ;  URLConnection loc1 = loc0 . getURLConnection (  )  ;  }
Date function ( String arg0 )  { DateTimeFormat loc0 = DateTimeFormat . SQL ;  Date loc1 = parseUTC ( arg0 ,  loc0 )  ;  return loc1 ;  }
public void function ( String arg0 ,  Measurement arg1 )  { try { String loc0 = arg0 . trim (  )  ;  if  ( loc0 . isEmpty (  )  )  { throw new IllegalArgumentException ( "Name cannot be empty . " )  ;  } arg1 . setName ( loc0 )  ;  } catch  ( IllegalArgumentException e )  { System . err . println ( "Exception caught: " + e . getMessage (  )  )  ;  } }
void function (  )  { byte [  ]  arg0 = new byte [ 10 ]  ;  arg0 [ 0 ]  = 1 ;  arg0 [ 1 ]  = 2 ;  arg0 [ 2 ]  = 3 ;  arg0 [ 3 ]  = 4 ;  arg0 [ 4 ]  = 5 ;  arg0 [ 5 ]  = 6 ;  arg0 [ 6 ]  = 7 ;  arg0 [ 7 ]  = 8 ;  arg0 [ 8 ]  = 9 ;  arg0 [ 9 ]  = 10 ;  mLocalOutputStream = Mockito . mock ( BufferedOutputStream . class )  ;  mStream = new S3AOutputStream ( BUCKET_NAME ,  KEY ,  mFile ,  mLocalOutputStream )  ;  mStream . write ( arg0 )  ;  mStream . close (  )  ;  Mockito . verify ( mLocalOutputStream )  . write ( arg0 )  ;  Mockito . verify ( mLocalOutputStream )  . flush (  )  ;  Mockito . verify ( mLocalOutputStream )  . close (  )  ;  }
void function (  )  { String arg0 = "$GPGGA" ;  String arg1 = "invalid_sentence_id" ;  Object loc0 = instance . createParser ( arg0 )  ;  assertNotNull ( loc0 )  ;  assertTrue ( loc0 instanceof Sentence )  ;  Object loc1 = instance . createParser ( arg1 )  ;  assertNull ( loc1 )  ;  Object loc2 = instance . createParser ( null )  ;  assertNull ( loc2 )  ;  Object loc3 = instance . createEmptyCustomParser ( arg0 )  ;  assertNotNull ( loc3 )  ;  Object loc4 = instance . createEmptyParserWithSentenceId ( arg0 )  ;  assertNotNull ( loc4 )  ;  boolean loc5 = instance . getSupportedSentenceTypes (  )  . contains ( arg0 )  ;  assertTrue ( loc5 )  ;  Object loc6 = SentenceFactory . getInstance (  )  ;  assertEquals ( loc6 ,  instance )  ;  Object loc7 = instance . createParser ( "" )  ;  assertNull ( loc7 )  ;  boolean loc8 = instance . registerParser ( null )  ;  assertFalse ( loc8 )  ;  List < SentenceParser >  loc9 = instance . listParsers (  )  ;  assertNotNull ( loc9 )  ;  Object loc10 = instance . createCustomParser ( arg0 )  ;  assertNotNull ( loc10 )  ;  boolean loc11 = instance . registerParser ( new GSVParser ( '$' )  )  ;  assertTrue ( loc11 )  ;  Object loc12 = instance . createParser ( "random" )  ;  assertNull ( loc12 )  ;  boolean loc13 = instance . hasParser ( arg0 )  ;  assertTrue ( loc13 )  ;  Object loc14 = instance . createEmptyParserWithSentenceIdStr ( arg0 )  ;  assertNotNull ( loc14 )  ;  Sentence loc15 = instance . createParser ( arg0 )  . parse ( "$GPGGA , 123519 , 4807 . 038 , N , 01131 . 000 , E , 1 , 08 , 0 . 9 , 545 . 4 , M , 46 . 9 , M ,  , " )  ;  String loc16 = instance . toSentence ( loc15 )  ;  assertEquals ( "$GPGGA , 123519 , 4807 . 038 , N , 01131 . 000 , E , 1 , 08 , 0 . 9 , 545 . 4 , M , 46 . 9 , M ,  , " ,  loc16 )  ;  }
void function ( StateListener arg0 )  { try { listeners . add ( arg0 )  ;  } catch  ( Exception loc0 )  { System . err . println ( "Error adding listener: " + loc0 . getMessage (  )  )  ;  } }
void function ( Project arg0 )  { if  ( currentProject == null )  { arg0 . remove (  )  ;  } }
boolean function ( String arg0 ,  CharSequence arg1 )  { try { if  ( StringUtils . contains ( arg0 ,  arg1 )  )  { return true ;  } } catch  ( Exception loc0 )  { } return false ;  }
HashMap function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { HashMap loc0 = new HashMap (  )  ;  CacheKey loc1 = new CacheKey (  ( String ) arg0 ,   ( int ) arg1 ,   ( int ) arg2 )  ;  loc0 . put ( loc1 ,  new SoftReference ( new SoftReference ( new Object (  )  )  )  )  ;  return loc0 ;  }
String function ( String arg0 )  { String loc0 = arg0 . trim (  )  ;  TestResultDetailsDTO loc1 = new TestResultDetailsDTO (  )  ;  loc1 . setErrorMsg ( loc0 )  ;  return loc0 ;  }
List < String >  function (  )  { ArrayList < String >  loc0 = new ArrayList < String >  ( federationRegistrations . values (  )  )  ;  List < String >  result = Collections . synchronizedList ( new ArrayList < String >  (  )  )  ;  for  ( String token : loc0 )  { result . add ( getFederationToken ( token )  )  ;  } return result ;  }
public void function ( String arg0 ,  EaseUser arg1 )  { try { SuperWeChatDBManager loc0 = SuperWeChatDBManager . getInstance (  )  ;  loc0 . saveContact ( arg1 )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } }
public static int function ( byte [  ]  arg0 )  { int loc0 = 0 ;  while  ( loc0  <  arg0 . length && arg0 [ loc0 ]  == 0 )  {  ++ loc0 ;  } if  ( loc0 == arg0 . length )  { throw new IllegalArgumentException ( "Empty argument" )  ;  } int loc1 = arg0 [ loc0 ]  & 255 ;  if  ( loc1  > = 128 )  { throw new IllegalArgumentException ( "Invalid first byte: " + loc1 )  ;  } return loc1 ;  }
int function ( int arg0 )  { Step loc0 = steps . get ( arg0 )  ;  return loc0 . getY (  )  ;  }
List < String >  function (  )  { List < String >  loc0 = Collections . unmodifiableList ( Arrays . asList ( new String [  ] {AuthPolicy . SPNEGO ,  AuthPolicy . NTLM ,  AuthPolicy . DIGEST ,  AuthPolicy . BASIC} )  )  ;  try { return loc0 ;  } catch  ( Exception e )  { } }
void function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { try { LogManager . shutdown (  )  ;  XLog . Info . reset (  )  ;  XLogStreamer . Filter . reset (  )  ;  } catch  ( Exception loc0 )  { } }
import com . google . maps . DirectionsApi ;  import com . google . maps . model . LatLng ;  public class DirectionsService { GoogleMapsClientManaged mapsClient ;  void start (  )  { } void function (  )  { DirectionsApi . newRequest ( mapsClient . getContext (  )  )   . origin ( new LatLng ( arg0 ,  arg1 )  )   . destination ( new LatLng ( arg2 ,  arg3 )  )   . mode ( arg4 )   . await (  )  ;  } }
public String function (  )  { String loc0 = null ;  try { loc0 = function (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
Message function ( Message arg0 )  { PhaseInterceptorChain chain = createChain (  )  ;  Exchange exchange = new ExchangeImpl (  )  ;  exchange . put ( ClassLoader . class ,  loader )  ;  setExchangeProperties ( exchange ,  arg0 )  ;  Message inMessage = new MessageImpl (  )  ;  inMessage . put ( Message . class ,  arg0 )  ;  exchange . setInMessage ( inMessage )  ;  try { chain . add ( getRoutingInterceptors (  )  )  ;  chain . add ( getBindingInterceptors (  )  )  ;  chain . doIntercept ( inMessage )  ;  } finally { chain . reset (  )  ;  } return inMessage . getContent ( Message . class )  ;  }
Filters function ( GameRequestContent arg0 )  { Filters loc0 = arg0 . filters ;  return loc0 . getFilters (  )  ;  }
String function ( String arg0 ,  Document arg1 )  { try { engine . setNamespaceContext ( null )  ;  NodeList loc0 =  ( NodeList )  engine . evaluate ( arg0 ,  new DOMSource ( arg1 )  ,  XPathConstants . NODESET )  ;  int loc1 = loc0 . getLength (  )  ;  StringBuilder loc2 = new StringBuilder (  )  ;  for  ( int loc3 = 0 ;  loc3  <  loc1 ;  loc3 ++  )  { Node loc4 = loc0 . item ( loc3 )  ;  loc2 . append ( XMLUnit . getNodeText ( loc4 )  )  ;  } return loc2 . toString (  )  . replaceAll ( "\\ < \\!\\-\\- . *?\\-\\-\\ > " ,  "" )  ;  } catch  ( XMLUnitException loc5 )  { Throwable loc6 = loc5 . getCause (  )  ;  if  ( loc6 instanceof XPathException )  { throw  ( XPathException )  loc6 ;  } throw loc5 ;  } catch  ( XPathException loc7 )  { throw loc7 ;  } catch  ( Throwable loc8 )  { throw new XPathException ( loc8 )  ;  } }
void function (  )  { try { List < String >  locList = new ArrayList <  >  ( locationPositions . keySet (  )  )  ;  locList . clear (  )  ;  } catch  ( Exception e )  { System . out . println ( "An error occurred while clearing the list: " + e . getMessage (  )  )  ;  } }
public static ChangeableKind function ( String arg0 ,  String arg1 )  { try { ChangeableKindEnum loc0 = ChangeableKindEnum . forName ( arg0 )  ;  String loc1 = arg1 ;  return loc0 . getMessage ( loc1 )  ;  } catch  ( Exception loc2 )  { loc2 . printStackTrace (  )  ;  return null ;  } }
void function ( String arg0 ,  DifferenceGroup arg1 )  { try { differenceGroups . put ( arg0 ,  arg1 )  ;  } catch  ( Exception loc0 )  { } }
void function ( Object arg0 )  throws IOException { beforeValue (  )  ;  mWriter . write ( JSON . LSQUARE )  ;  mStack . push ( new State ( ARRAY )  )  ;  return this ;  }
void function (  )  { setUp (  )  ;  instance = new GSASentence ( EXAMPLE )  ;  double loc0 = instance . getHorizontalDOP (  )  ;  assertEquals ( loc0 ,  1 . 6 ,  0 . 0 )  ;  }
void function ( ResourceBundle arg0 )  { HashSet < String >  loc0 = new HashSet < String >  (  )  ;  Enumeration < String >  loc1 = arg0 . getKeys (  )  ;  while  ( loc1 . hasMoreElements (  )  )  { String loc2 = loc1 . nextElement (  )  ;  Assert . assertTrue ( "Key entered twice: " + loc2 ,  !loc0 . contains ( loc2 )  )  ;  loc0 . add ( loc2 )  ;  } }
String function ( String arg0 ,  String arg1 )  { String loc0 = "" ;  try { loc0 = System . getProperty ( "user . home" )  + "/logs/" + arg0 + "/" ;  File loc1 = new File ( loc0 )  ;  if  ( !loc1 . exists (  )  )  { loc1 . mkdirs (  )  ;  } loc0 += arg1 ;  } catch  ( Exception loc2 )  { getLogger (  )  . error ( "Error getting application log path: " + loc2 . getMessage (  )  )  ;  } return loc0 ;  }
void function ( String arg0 ,  OutputStream arg1 )  { byte [  ]  loc0 = arg0 . replaceAll ( "\\s" ,  "" )  . getBytes (  )  ;  encoder . decode ( loc0 ,  0 ,  loc0 . length ,  arg1 )  ;  }
public static boolean function ( Object arg0 ,  Object arg1 )  { try { if  ( arg0 == null || arg1 == null )  { return false ;  } String loc0 = arg0 . toString (  )  ;  String loc1 = arg1 . toString (  )  ;  if  ( loc1 . equalsIgnoreCase ( loc0 )  )  { return true ;  } else if  ( loc1 . equals ( loc0 )  )  { return true ;  } else if  ( loc0 . equalsIgnoreCase ( "false" )  )  { return true ;  } else if  ( Boolean . FALSE . equals ( arg0 )  )  { return true ;  } else { return false ;  } } catch  ( Exception e )  { return false ;  } }
int function (  )  { int size = 0 ;  try { size = _all . size (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return size ;  }
void function (  )  { try { flushEvents (  )  ;  clientFlushedEvents (  )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
Thread function (  )  { Thread loc0 = waiter ;  waiter = null ;  return loc0 ;  }
void function ( InputStream arg0 )  { try { if  ( arg0 != null )  { arg0 . close (  )  ;  } } catch  ( IOException e )  { System . err . println ( "Input Stream management not safe: " + e . getMessage (  )  )  ;  } }
void function (  )  { RPCFileWriteRequestTest test = new RPCFileWriteRequestTest (  )  ;  test . before (  )  ;  long loc0 = -1 ;  long loc1 = test . TEMP_UFS_FILE_ID ;  long loc2 = test . OFFSET ;  long loc3 = test . LENGTH ;  RPCFileWriteRequest req = new RPCFileWriteRequest ( loc0 ,  loc1 ,  loc2 ,  loc3 ,  test . mBuffer )  ;  test . assertInvalid ( req )  ;  }
public static String function ( String arg0 ,  String arg1 )  { try { AggregationKindEnum loc0 = AggregationKindEnum . forName ( arg0 )  ;  List loc1 = loc0 . typeName ;  String loc2 = loc1 . get ( 0 )  . toString (  )  ;  String loc3 = AggregationKindEnum . class . getCanonicalName (  )  ;  String loc4 = loc3 + " . " + loc2 ;  return loc4 ;  } catch  ( Exception loc5 )  { return null ;  } }
BufferedImage function ( int arg0 ,  int arg1 )  { int loc0 = BufferedImage . TYPE_INT_RGB ;  BufferedImage loc1 = ImageUtil . createCompatibleBufferedImage ( arg0 ,  arg1 ,  loc0 )  ;  ImageUtil . clearImage ( loc1 )  ;  return loc1 ;  }
public static void function ( String arg0 )  { File tempDir = null ;  try { tempDir = File . createTempFile ( arg0 ,  "" )  ;  if  ( !tempDir . delete (  )  )  { throw new IOException ( "Could not delete temp file: " + tempDir . getAbsolutePath (  )  )  ;  } if  ( !tempDir . mkdir (  )  )  { throw new IOException ( "Could not create temp directory: " + tempDir . getAbsolutePath (  )  )  ;  } } catch  ( IOException e )  { LOG . error ( "Error creating temp directory: " + e . getMessage (  )  ,  e )  ;  if  ( tempDir != null )  { deleteDir ( tempDir )  ;  } } }
public void function ( Date arg0 )  { try { Date loc0 = arg0 ;  setFetcherStartTimeStamp ( loc0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
public float function ( Object arg0 ,  Object arg1 )  { int loc0 = 0 ;  int loc1 = 0 ;  try { loc0 =  ( int )  arg0 ;  loc1 =  ( int )  arg1 ;  return loc0 / loc1 ;  } catch  ( ArithmeticException e )  { System . out . println ( "Cannot divide by zero . " )  ;  return 0 ;  } catch  ( ClassCastException e )  { System . out . println ( "Invalid argument type . " )  ;  return 0 ;  } }
public int function (  )  { try { return this . yPosition ;  } catch  ( Exception e )  { System . err . println ( "An error occurred while getting the vertical position of the ball: " + e . getMessage (  )  )  ;  return -1 ;  // or any other default value } }
public class SatelliteInfo { private int elevation ;  private int noise ;  private int azimuth ;  private String id ;  public String getId (  )  { return id ;  } public int getNoise (  )  { return noise ;  } public int getElevation (  )  { return elevation ;  } public void setAzimuth ( int azimuth )  { this . azimuth = azimuth ;  } public int getAzimuth (  )  { return azimuth ;  } public void setElevation ( int elevation )  { this . elevation = elevation ;  } public void setNoise ( int noise )  { this . noise = noise ;  } public void function ( String arg0 )  { try { setId ( arg0 )  ;  } catch  ( Exception e )  { System . out . println ( "An error occurred: " + e . getMessage (  )  )  ;  } } private void setId ( String id )  throws Exception { if  ( id . matches ( " [ 0-9 ] +" )  && id . length (  )  == 2 )  { this . id = id ;  } else { throw new Exception ( "Invalid ID" )  ;  } } }
Map < T ,  Integer >  nodePosition = new HashMap <  >  (  )  ;  void function ( T arg0 )  { boolean loc0 = nodePosition . containsKey ( arg0 )  ;  }
String function ( String arg0 )  { String loc0 = SipMessageUtils . extractValue ( arg0 ,  " , " )  ;  String loc1 = SipHeaderValue . getBaseValue ( loc0 . trim (  )  )  ;  String loc2 = StringUtils . substringAfterLast ( loc1 ,  "/" )  ;  String loc3 = StringUtils . substringBefore ( loc2 ,  " ; " )  ;  return InetAddress . getByName ( loc3 )  . getHostAddress (  )  ;  }
String function ( MyComplexStruct obj )  { String loc0 = obj . elem2 ;  return loc0 ;  }
public void function (  )  { Time loc0 = new Time ( 12 ,  0 ,  45 . 0 )  ;  instance . setTime ( loc0 )  ;  assertTrue ( instance . getTime (  )  . equals ( loc0 )  )  ;  }
public static boolean function ( ByteBufferExt arg0 ,  int arg1 ,  int arg2 )  { int loc0 = arg0 . position (  )  ;  UInt loc1 = arg0 . getUInt (  )  ;  arg0 . position ( loc0 )  ;  arg0 . putUInt ( arg1 ,  UIntImpl . computeCrc32 ( arg0 ,  arg1 ,  arg2 )  )  ;  arg0 . position ( loc0 )  ;  return loc1 . equals ( getChecksum ( arg0 )  )  ;  }
List < Vertice >  function ( Grafo arg0 )  { List < Vertice >  loc0 = arg0 . getVertices (  )  ;  Collections . sort ( loc0 )  ;  return loc0 ;  }
void function ( Item arg0 )  { try { ItemStack loc0 = new ItemStack ( arg0 )  ;  this . mob . setCurrentItemOrArmor ( 0 ,  loc0 )  ;  } catch  ( Exception e )  { } }
class ListStatusOptions { LoadMetadataType mLoadMetadataType ;  LoadMetadataType getLoadMetadataType (  )  { return mLoadMetadataType ;  } ListStatusOptions defaults (  )  { return this ;  } int hashCode (  )  { return super . hashCode (  )  ;  } boolean equals ( Object o )  { return super . equals ( o )  ;  } String toString (  )  { return super . toString (  )  ;  } void function ( LoadMetadataType arg0 )  { mLoadMetadataType = arg0 ;  } }
AbstractPlugin function ( String arg0 )  { AbstractPlugin loc0 ;  for  ( Iterator < AbstractPlugin >  loc1 = plugins . iterator (  )  ;  loc1 . hasNext (  )  ;   )  { loc0 = loc1 . next (  )  ;  if  ( loc0 . getName (  )  . equals ( arg0 )  )  { return loc0 ;  } } return null ;  }
public void function ( long arg0 ,  long arg1 )  { long loc0 = System . currentTimeMillis (  )  ;  if  ( arg0 == 0 )  { inclusive_time += loc0 - arg1 ;  exclusive_time += loc0 - arg1 ;  } else { inclusive_time += loc0 - arg0 ;  } }
void function (  )  { mThrown . expect ( BlockDoesNotExistException . class )  ;  mThrown . expectMessage ( "Failed to get BlockMeta: Block " + TEST_BLOCK_ID + " not found" )  ;  try { BlockMeta loc0 = mMetaManagerView . getBlockMeta ( TEST_BLOCK_ID )  ;  } catch  ( BlockDoesNotExistException loc1 )  { } catch  ( Exception loc2 )  { fail ( "Unexpected exception: " + loc2 )  ;  } }
Mode function ( Mode arg0 )  { Mode loc0 = FILE_UMASK . applyMask ( arg0 )  ;  return loc0 ;  }
public static String function ( String arg0 ,  Charset arg1 )  { try { String loc0 = URLEncoder . encode ( arg0 ,  arg1 )   . replace ( "+" ,  "%20" )   . replace ( "*" ,  "%2A" )   . replace ( "%7E" ,  "~" )  ;  return loc0 ;  } catch  ( UnsupportedEncodingException e )  { System . err . println ( "Error encoding string: " + e . getMessage (  )  )  ;  return null ;  } }
public void function ( String arg0 )  { try { File loc0 = new File ( arg0 )  ;  Files . createDirectories ( loc0 . getParentFile (  )  . toPath (  )  )  ;  loc0 . createNewFile (  )  ;  } catch  ( IOException e )  { LOG . error ( "An error occurred while creating the file: " + e . getMessage (  )  )  ;  } }
public void function (  )  { setUp (  )  ;  rmc . setData ( EXAMPLE )  ;  rmc . parse (  )  ;  loc0 = 7 ;  loc1 = rmc . getMonth (  )  ;  assertEquals ( loc0 ,  loc1 )  ;  rmc . setDate ( "" )  ;  loc1 = rmc . getMonth (  )  ;  assertEquals ( 0 ,  loc1 )  ;  }
void function ( Document arg0 )  { doc = arg0 ;  eval (  )  ;  }
USAddress function (  )  { return billTo ;  }
void function (  )  { try { OutputStream loc0 = mHttpConMock . getOutputStream (  )  ;  mThrown . expect ( IOException . class )  ;  mThrown . expectMessage ( "Test Exception" )  ;  doThrow ( new IOException ( "Test Exception" )  )  . when ( loc0 )  . close (  )  ;  loc0 . close (  )  ;  } catch  ( IOException e )  { } }
byte [  ]  function ( byte [  ]  arg0 ,  Entropy arg1 )  { SymmetricKeyHandler obj = new SymmetricKeyHandler (  )  ;  obj . secret = arg0 ;  obj . clientEntropy = arg1 ;  obj . createSymmetricKey (  )  ;  if  ( !obj . isComputedKey (  )  )  { LOG . error ( "Symmetric key is not computed successfully . " )  ;  } return obj . secret ;  }
class lalr_transition { lalr_state _to_state ;  lalr_transition _next ;  symbol _on_symbol ;  lalr_transition function ( symbol arg0 ,  lalr_state arg1 )  { lalr_transition loc0 = new lalr_transition (  )  ;  loc0 . _on_symbol = arg0 ;  loc0 . _to_state = arg1 ;  loc0 . _next = this ;  return loc0 ;  } String toString (  )  { return _on_symbol + " - >  " + _to_state ;  } lalr_state to_state (  )  { return _to_state ;  } lalr_transition next (  )  { return _next ;  } }
class OPTIONS { void function ( String arg0 ,  String arg1 ,  int arg2 )  { String loc0 = "Process the OPTIONS method . " ;  setHeader ( arg0 ,  arg1 )  ;  String loc1 = getContentType (  )  ;  setStatus ( arg2 )  ;  } }
public class Decision { String name ;  Decision UNSPEC=new Decision ( "misc . decision . uncategorized" , 1 )  ;  int priority ;  public int getPriority (  )  { return priority ;  } public String toString (  )  { return name + "  ( " + priority + " ) " ;  } public void setPriority ( int p )  { priority = p ;  } public void setName ( String n )  { name = n ;  } public String getName (  )  { return name ;  } public int hashCode (  )  { return name . hashCode (  )  ;  } public boolean function ( Object arg0 ,  Object arg1 )  { if  ( arg0 instanceof Decision && arg1 instanceof Decision )  { Decision loc0 =  ( Decision )  arg0 ;  Decision loc1 =  ( Decision )  arg1 ;  return loc0 . getName (  )  . equals ( loc1 . getName (  )  )  ;  } return false ;  } }
import org . apache . cxf . ws . addressing . ContextUtils ;  import javax . xml . ws . handler . MessageContext ;  public class RMContextUtils { public void function ( Message arg0 ,  boolean arg1 ,  boolean arg2 )  { MessageContext loc0 = ContextUtils . retrieveMAPs ( arg0 ,  arg1 ,  arg2 )  ;  } }
GetOfferDetailsResponse . Return . DetailOfferData . Products . Product function ( GetOfferDetailsResponse . Return . DetailOfferData . Products arg0 ,  int arg1 )  { GetOfferDetailsResponse . Return . DetailOfferData . Products . Product loc0 = arg0 . getProduct (  )  . get ( arg1 )  ;  return loc0 ;  }
void function (  )  { setUp (  )  ;  ServerSession loc0 = null ;  ServerMessage loc1 = mockServerMessage ;  try { activityController . deregisterUserSession ( loc0 ,  loc1 )  ;  fail ( "Expected NullPointerException was not thrown" )  ;  } catch  ( NullPointerException e )  { } tearDown (  )  ;  }
void function (  )  { channelClient . setInactive (  )  ;  wireParser . closeConnection (  )  ;  }
class CancerStudyPermissionEvaluator { private Log log = LogFactory . getLog ( CancerStudyPermissionEvaluator . class )  ;  Object function ( Authentication arg0 ,  Object arg1 ,  Object arg2 )  { try { throw new UnsupportedOperationException ( "Implementation of PermissionEvaluator .  We do not support this method call . " )  ;  } catch  ( UnsupportedOperationException loc0 )  { log . error ( "Error in CancerStudyPermissionEvaluator" ,  loc0 )  ;  throw loc0 ;  } } Set < String >  getGrantedAuthorities ( Authentication authentication )  { } }
public static void function ( String [  ]  args )  { try { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName (  )  )  ;  OsmViewerPlusApp app = new OsmViewerPlusApp (  )  ;  MapViewFrame frame = app . getFrame (  )  ;  frame . readMap ( app . getULMFileResource (  )  )  ;  frame . showFrame (  )  ;  for  ( int i = 0 ;  i  <  args . length ;  i ++  )  { String arg = args [ i ]  ;  if  ( arg . startsWith ( "-screenwidth=" )  )  { double width = Double . parseDouble ( arg . substring ( "-screenwidth=" . length (  )  )  )  ;  frame . setScreenSize ( new Dimension (  ( int )  ( width * 37 . 7952755906 )  ,   ( int )  ( width * 21 . 2598425197 )  )  )  ;  } else if  ( arg . startsWith ( "-screensize=" )  )  { double size = Double . parseDouble ( arg . substring ( "-screensize=" . length (  )  )  )  ;  double ratio = Math . sqrt ( 16*16+9*9 ) /16 ;  // assuming 16:9 aspect ratio frame . setScreenSize ( new Dimension (  ( int )  ( size * ratio )  ,   ( int )  ( size )  )  )  ;  } } } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
 @ Test void function (  )  { try { loc0 = Double . parseDouble ( EXAMPLE . split ( " , " )  [ 6 ]  )  ;  ttm . setTime ( 0 )  ;  ttm . setSpeed ( loc0 )  ;  assertEquals ( loc0 ,  ttm . getSpeed (  )  ,  0 . 01 )  ;  } catch  ( Exception e )  { fail ( "Unexpected exception was thrown: " + e . getMessage (  )  )  ;  } }
void function (  )  { try { setUp (  )  ;  ArrayList < Capability >  loc0 = dev . getCapabilities (  )  ;  assertEquals ( arg0 ,  loc0 )  ;  tearDown (  )  ;  } catch  ( Exception loc1 )  { fail ( loc1 . getMessage (  )  )  ;  loc1 . printStackTrace (  )  ;  } System . out . println ( "Test of getCapabilities method ,  of class Device . " )  ;  }
Position function ( Position arg0 ,  Position arg1 )  { if  ( arg0 . isComparable ( arg0 ,  arg1 )  )  { Position last =  ( arg0 . endLine  >  arg1 . endLine ||  ( arg0 . endLine == arg1 . endLine && arg0 . endColumn  >  arg1 . endColumn )  )  ? arg0 : arg1 ;  return last ;  } return null ;  }
void function ( String arg0 )  { try { transformedTokenIdentifier = arg0 ;  } catch  ( Exception loc0 )  { } }
public List < VertexLabelType >  function (  )  { List < VertexLabelType >  loc0 = new ArrayList <  >  (  )  ;  try { Enumeration < VertexLabelType >  keys = globalEdgeLookup . keys (  )  ;  while  ( keys . hasMoreElements (  )  )  { VertexLabelType key = keys . nextElement (  )  ;  loc0 . add ( key )  ;  } } catch  ( Exception e )  { } return loc0 ;  }
void function (  )  { RTETest rtetest = new RTETest (  )  ;  rtetest . testSetRouteTypeWorking (  )  ;  assertTrue ( rtetest . rte . isActiveRoute (  )  )  ;  rtetest . testSetRouteTypeActive (  )  ;  assertFalse ( rtetest . rte . isActiveRoute (  )  )  ;  }
float function (  )  { float loc0 = 0 . 0f ;  try { loc0 = getDistKM ( latMax ,  latMin )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  } Note: The implementation of the getDistKM method is not provided in the given class .  Hence ,  the implementation of the function method cannot be guaranteed to be correct . 
void function (  )  { final double arg0 = 10 . 0 ;  final HDGTest hdgtest = new HDGTest (  )  ;  try { hdgtest . setDeviation ( arg0 )  ;  fail ( "Expected an IllegalArgumentException to be thrown" )  ;  } catch  ( IllegalArgumentException loc0 )  { final String loc1 = loc0 . getMessage (  )  ;  assertTrue ( loc1 . contains ( "Deviation value out of range" )  )  ;  } catch  ( Exception loc2 )  { fail ( "Unexpected exception thrown: " + loc2 . getClass (  )  . getSimpleName (  )  )  ;  } }
boolean function (  )  { if  ( mTransportProvider == null || mClosed )  { return false ;  } if  ( !mConnected )  { return false ;  } return true ;  }
Calendar function ( Date arg0 ,  TimeZone arg1 )  { Calendar loc0 = Calendar . getInstance ( arg1 )  ;  loc0 . setTime ( arg0 )  ;  loc0 . set ( Calendar . HOUR_OF_DAY ,  0 )  ;  loc0 . set ( Calendar . MINUTE ,  0 )  ;  loc0 . set ( Calendar . SECOND ,  0 )  ;  loc0 . set ( Calendar . MILLISECOND ,  0 )  ;  return loc0 ;  }
void function (  )  { DataNettyBuffer buffer = new DataNettyBuffer ( mBuffer )  ;  Assert . assertEquals ( LENGTH ,  buffer . getLength (  )  )  ;  int loc0 = buffer . getLength (  )  ;  }
void function ( String arg0 )  { this . testId = arg0 ;  }
void function (  )  { try { setUp (  )  ;  HDGTest hdgTest = new HDGTest (  )  ;  hdgTest . testGetDeviation (  )  ;  } catch  ( Exception loc0 )  { assertEquals ( "Unexpected exception: " + loc0 . getMessage (  )  ,  null ,  loc0 )  ;  } }
void function (  )  { LogEntryInterval loc0 = new LogEntryInterval (  )  ;  loc0 . setIntervalNumber ( arg0 )  ;  loc0 . setMeanResponseTime ( arg1 )  ;  loc0 . setNumberRequests ( arg2 )  ;  System . out . println ( "Test of getNumberRequests method ,  of class LogEntryInterval . " )  ;  assertEquals ( arg2 ,  loc0 . getNumberRequests (  )  )  ;  }
char [  ]  function ( char [  ]  arg0 )  { int loc0 = 0 ;  int loc1 = arg0 . length - 1 ;  while  ( loc1  >  loc0 )  { char loc2 = arg0 [ loc0 ]  ;  arg0 [ loc0 ]  = arg0 [ loc1 ]  ;  arg0 [ loc1 ]  = loc2 ;  loc0 ++  ;  loc1 --  ;  } return arg0 ;  }
import org . junit . Assert ;  import org . junit . Test ;  public class ModeBitsTest {  @ Test public void function (  )  { Mode . Bits loc0 = Mode . Bits . WRITE_EXECUTE ;  Mode . Bits loc1 = Mode . Bits . WRITE ;  Mode . Bits loc2 = Mode . Bits . EXECUTE ;  Mode . Bits loc3 = Mode . Bits . READ_EXECUTE ;  Mode . Bits loc4 = Mode . Bits . READ ;  Mode . Bits loc5 = Mode . Bits . READ_WRITE ;  loc0 . or ( loc1 )  ;  Assert . assertEquals ( Mode . Bits . WRITE_EXECUTE ,  loc0 )  ;  loc1 . or ( loc2 )  ;  Assert . assertEquals ( Mode . Bits . WRITE_EXECUTE ,  loc1 )  ;  loc2 . or ( loc3 )  ;  Assert . assertEquals ( Mode . Bits . READ_EXECUTE ,  loc2 )  ;  loc3 . or ( loc4 )  ;  Assert . assertEquals ( Mode . Bits . READ_EXECUTE ,  loc3 )  ;  loc4 . or ( loc5 )  ;  Assert . assertEquals ( Mode . Bits . READ_WRITE ,  loc4 )  ;  } public void andOperation (  )  { } public void notOperation (  )  { } public void implies (  )  { } public void getSymbol (  )  { } }
void function ( Intent arg0 ,  int arg1 ,  Activity arg2 )  { try { arg2 . startActivityForResult ( arg0 ,  arg1 )  ;  } catch  ( ActivityNotFoundException loc0 )  { AlertDialog loc1 = new AlertDialog . Builder ( arg2 )   . setTitle ( DEFAULT_TITLE )   . setMessage ( DEFAULT_MESSAGE )   . setPositiveButton ( DEFAULT_YES ,  new DialogInterface . OnClickListener (  )  {  @ Override public void onClick ( DialogInterface dialogInterface ,  int loc2 )  { Intent loc3 = new Intent ( Intent . ACTION_VIEW ,  Uri . parse ( "market://details?id=" + BS_PACKAGE )  )  ;  try { arg2 . startActivity ( loc3 )  ;  } catch  ( ActivityNotFoundException loc4 )  { Intent loc5 = new Intent ( Intent . ACTION_VIEW ,  Uri . parse ( "http://play . google . com/store/apps/details?id=" + BS_PACKAGE )  )  ;  arg2 . startActivity ( loc5 )  ;  } } } )   . setNegativeButton ( DEFAULT_NO ,  null )   . create (  )  ;  loc1 . show (  )  ;  } }
double function ( DenseMatrix64F arg0 ,  DenseMatrix64F arg1 ,  DenseMatrix64F arg2 )  { configure ( arg0 ,  arg1 ,  arg2 )  ;  compute ( param ,  arg1 ,  arg2 )  ;  return diffNormF (  )  ;  }
Here's
void function ( Object arg0 )  { ProgressMonitor progressMonitor = new ProgressMonitor (  )  ;  if  ( progressMonitor . isRunningOnServer (  )  )  { progressMonitor . arg0 = arg0 ;  progressMonitor . log . append ( "Logs a Message . " )  ;  System . out . println ( progressMonitor . getLog (  )  )  ;  } } Note: I have assumed that the "arg0" parameter is the message that needs to be logged .  If that's not the case ,  please adjust the code accordingly .  Also ,  this code does not include any exception handling ,  so you might want to add that based on your requirements . 
public static boolean function ( Pattern arg0 ,  String arg1 )  { Matcher loc0 = arg0 . matcher ( arg1 )  ;  return loc0 . find (  )  ;  }
boolean function ( UserModel arg0 )  { try { return userService . updateUserModel ( arg0 )  ;  } catch  ( Exception loc0 )  { logger . error ( "Error updating user model: " + loc0 . getMessage (  )  )  ;  return false ;  } }
void function ( String arg0 )  { UnderFileSystemUtils . deleteDir ( arg0 )  ;  }
public static String function ( String arg0 )  { File loc0 = new File ( arg0 )  ;  BufferedReader loc1 = new BufferedReader ( new FileReader ( loc0 )  )  ;  String loc2 = readFile ( loc1 )  ;  return loc2 ;  }
void function (  )  { try { HashMap < String ,  Object >  loc0 = new HashMap <  >  (  )  ;  loc0 . put ( ActivityEvent . ID_KEY ,  "" )  ;  Event event = new Event ( "test_topic" ,  loc0 )  ;  acitivityController . handleEvent ( event )  ;  fail ( "Expected IllegalArgumentException was not thrown" )  ;  } catch  ( IllegalArgumentException loc1 )  { } catch  ( Exception loc2 )  { fail ( "Unexpected exception was thrown: " + loc2 . getMessage (  )  )  ;  } }
public static String function ( Object arg0 )  { if  ( arg0 == null )  { return "null" ;  } Class < ? >  loc0 = arg0 . getClass (  )  ;  String loc1 = ClassUtil . SHORT_NAMES_BY_TYPE . get ( loc0 )  ;  if  ( loc1 != null )  { return loc1 ;  } else { return loc0 . getName (  )  ;  } }
public Object function ( AccessibilityEvent arg0 ,  int arg1 )  { Object loc0 = null ;  try { loc0 = AccessibilityEventCompat . IMPL . getRecord ( arg0 ,  arg1 )  ;  } catch  ( IndexOutOfBoundsException e )  { } return loc0 ;  }
QRDecomposition < QRSparseHelper_MT >  function ( int arg0 ,  int arg1 )  { QRDecompositionHouseholderColumn_D64 qr = new QRDecompositionHouseholderColumn_D64 (  )  ;  qr . setExpectedMaxSize ( arg0 ,  arg1 )  ;  return qr ;  }
public void function ( String arg0 )  { try { byte [  ]  loc0 = arg0 . getBytes ( _encoding )  ;  _messageBody = loc0 ;  } catch  ( UnsupportedEncodingException loc1 )  { System . out . println ( "Unsupported encoding: " + _encoding )  ;  loc1 . printStackTrace (  )  ;  } }
public void function ( MenuItemWrapper arg0 ,  MenuItemWrapper arg1 )  { try { arg0 . mMenuItem . setOnMenuItemClickListener ( new android . view . MenuItem . OnMenuItemClickListener (  )  {  @ Override public boolean onMenuItemClick ( android . view . MenuItem loc0 )  { return true ;  // return true to indicate that the event has been consumed } } )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } }
void function ( String arg0 )  { String arg1 = "$VWVHW , 000 . 0 , T , 001 . 5 , M , 1 . 0 , N , 1 . 85 , K" ;  VHWParser loc0 = new VHWParser ( arg1 )  ;  assertTrue ( loc0 . getTalkerId (  )  . equals ( "VW" )  )  ;  assertEquals ( loc0 . getSentenceId (  )  ,  "VHW" )  ;  assertEquals ( Double . valueOf ( 000 . 0 )  ,  loc0 . getHeading (  )  )  ;  assertEquals ( Double . valueOf ( 001 . 5 )  ,  loc0 . getMagneticHeading (  )  )  ;  assertEquals ( Double . valueOf ( 1 . 0 )  ,  loc0 . getSpeedKnots (  )  )  ;  assertEquals ( Double . valueOf ( 1 . 85 )  ,  loc0 . getSpeedKmh (  )  )  ;  }
void function (  )  { LOG . trace ( "Processing internal buffer" )  ;  m_protocolHandler . handleMessages ( m_readBuffer )  ;  m_readBuffer . clear (  )  ;  }
double function (  )  { checkState ( count  >  1 )  ;  double loc0 = sumOfSquaresOfDeltas /  ( count - 1 )  ;  if  ( isNaN ( loc0 )  || loc0  <  0 )  { return Double . NaN ;  } else { return loc0 ;  } } private void checkState ( boolean expression )  { if  ( !expression )  { throw new IllegalStateException (  )  ;  } } private boolean isNaN ( double value )  { return Double . isNaN ( value )  ;  } private void ensureNonNegative ( double value )  { if  ( value  <  0 )  { throw new IllegalArgumentException (  )  ;  } }
Object function ( Object arg0 ,  String arg1 )  { Object loc0 = getClassifier (  )  ;  for  ( Object loc1 :  ( Collection ) getAttribute ( "operations" )  )  { if  ( loc1 . getClass (  )  . getSimpleName (  )  . equals ( "Operation" )  && loc1 . getName (  )  . equals ( arg1 )  &&  (  ( Operation ) loc1 )  . isAMethod (  )  )  { return loc1 ;  } } LOG . warning ( "Get a method from the current classifier not yet modeled . " )  ;  return null ;  }
void function ( final HttpParams arg0 ,  final boolean arg1 )  { try { HttpConnectionParams . setBooleanParameter ( arg0 ,  CoreConnectionPNames . TCP_NODELAY ,  arg1 )  ;  } catch  ( RuntimeException loc0 )  { } }
class Compatibility { boolean function ( HttpServletRequest arg0 )  { String loc0 = arg0 . getHeader ( "User-Agent" )  ;  return  ( arg0 == null )  ? false : check ( loc0 )  ;  } boolean check ( String arg0 )  { String loc0 = "MSIE  (  [ 0-9 ] + [ \\ . 0-9 ] * ) " ;  String loc1 = " . *Trident . *" ;  float loc2 = getBrowserVersion ( arg0 ,  loc0 )  ;  return  ( loc2  < = 6 . 0f )  ||  (  ( loc2 == 7 . 0f )  && arg0 . matches ( loc1 )  )  ;  } float getBrowserVersion ( final String arg0 ,  final String arg1 )  { String loc0 = Pattern . compile ( arg1 )  . matcher ( arg0 )  . find (  )  ? RegExp . $1 : "" ;  return  ( loc0 . equals ( "" )  )  ? 0 . 0f : Float . parseFloat ( loc0 )  ;  } }
void function ( int arg0 ,  AbstractReportNode arg1 )  { try { if  ( arg1 != null )  { arg1 . setParentNode ( this )  ;  } if  ( arg0  > = 0 && arg0  < = childNodes . size (  )  )  { childNodes . add ( arg0 ,  arg1 )  ;  } else { throw new IndexOutOfBoundsException (  )  ;  } } catch  ( IndexOutOfBoundsException loc0 )  { loc0 . printStackTrace (  )  ;  } }
boolean function (  )  { boolean loc0 = true ;  if  ( bufferSize  >  0 )  { loc0 = false ;  } return loc0 ;  }
import java . util . function . Function ;  import java . util . function . Supplier ;  public class Functions { public static  < T >  Function < Object ,  T >  function ( Supplier < T >  arg0 )  { return o - >  arg0 . get (  )  ;  } }
import static org . junit . Assert . assertEquals ;  public class HDGTest { HDGSentence hdg ;  String EXAMPLE = "$HCHDG , 123 . 4 , 1 . 2 , E , 1 . 2 , W" ;  void function (  )  { try { double arg0 = 45 . 6 ;  hdg . setHeading ( arg0 )  ;  double loc0 = hdg . getHeading (  )  ;  assertEquals ( arg0 ,  loc0 ,  0 . 01 )  ;  } catch  ( Exception e )  { } } }
int function (  )  { int loc0 = mTierViews . get ( arg0 )  . getTierViewOrdinal (  )  ;  int loc1 = mTierViews . get ( loc0 )  . size (  )  ;  return mTierViews . get ( loc0 )  . get ( loc1 - arg1 )  . get (  )  ;  }
private void function ( InputStream arg0 ,  String arg1 )  throws IOException { File file = new File ( arg1 )  ;  try { if  ( file . exists (  )  )  { file . delete (  )  ;  } FileOutputStream outputStream = new FileOutputStream ( file )  ;  StringReader reader = new StringReader ( IOUtils . toString ( arg0 ,  StandardCharsets . UTF_8 )  )  ;  IOUtils . copy ( reader ,  outputStream ,  StandardCharsets . UTF_8 )  ;  outputStream . flush (  )  ;  outputStream . close (  )  ;  reader . close (  )  ;  } catch  ( IOException e )  { m_log . error ( "Error while processing XML feed" ,  e )  ;  throw e ;  } }
void function ( THashSet < String >  arg0 )  { try { THashSet < String >  loc0 = getWhitelist (  )  ;  loc0 . addAll ( arg0 )  ;  } catch  ( Exception e )  { } }
public int function ( Object arg0 ,  Object arg1 )  { Schema loc0 = p1 . schema (  )  ;  Schema loc1 = p2 . schema (  )  ;  int estVals = 0 ;  if  ( loc0 . fieldType ( fldname1 )  == Type . STRING )  { if  ( loc1 . fieldType ( fldname2 )  == Type . STRING )  { if  ( loc0 . equals ( loc1 )  )  { estVals =  ( int )  Math . min ( p1 . distinctValues ( fldname1 )  ,  p2 . distinctValues ( fldname2 )  )  ;  } else { int p1Pages =  ( int )  Math . ceil (  ( double )  p1 . blocksAccessed (  )  /  ( double )  MINIBASE_BUFFER_POOL_SIZE )  ;  int p2Pages =  ( int )  Math . ceil (  ( double )  p2 . blocksAccessed (  )  /  ( double )  MINIBASE_BUFFER_POOL_SIZE )  ;  int maxVals = Math . max ( p1Pages ,  p2Pages )  ;  estVals =  ( int )  Math . ceil (  ( double )  Math . max ( p1 . distinctValues ( fldname1 )  ,  p2 . distinctValues ( fldname2 )  )  /  ( double )  maxVals )  ;  } } } return estVals ;  }
File function ( File arg0 )  { File loc0 = null ;  try { loc0 = arg0 . getCanonicalFile (  )  ;  } catch  ( IOException e )  { loc0 = arg0 . getAbsoluteFile (  )  ;  } return loc0 ;  }
public int function ( int arg0 ,  int arg1 ,  int arg2 )  { int loc0 = pref_group_len ;  try { if  ( loc0  <  arg0 )  { loc0 = arg0 ;  } else if  ( loc0  >  arg1 )  { loc0 = arg1 ;  } if  ( loc0 % arg2 != 0 )  { loc0 =  ( loc0 / arg2 )  * arg2 ;  } if  ( loc0  <  MIN_ALLOWED || loc0  >  MAX_ALLOWED )  { throw new IllegalArgumentException ( "Preferred group length is not within the allowed range . " )  ;  } } catch  ( IllegalArgumentException e )  { System . err . println ( e . getMessage (  )  )  ;  loc0 = pref_group_len ;  } return loc0 ;  }
class NormOps { double function ( DenseMatrix64F arg0 )  { double loc0 = 0 ;  for  ( int loc1 = 0 ;  loc1  <  arg0 . getNumElements (  )  ;  loc1 ++  )  { double loc2 = arg0 . get ( loc1 )  ;  loc0 += loc2 * loc2 ;  } return Math . sqrt ( loc0 )  ;  } }
public static double function ( DenseMatrix64F arg0 )  { int loc0 = arg0 . getNumElements (  )  ;  double loc1 = 0 ;  for  ( int i = 0 ;  i  <  loc0 ;  i ++  )  { double loc2 = arg0 . get ( i )  ;  loc1 += loc2 * loc2 ;  } return loc1 ;  }
boolean function ( Object arg0 ,  Object arg1 )  { boolean loc0 =  (  ( Boolean ) arg0 )  . booleanValue (  )  ;  boolean loc1 =  (  ( Boolean ) arg1 )  . booleanValue (  )  ;  boolean loc2 = loc0 == loc1 ;  Object loc3 = null ;  if  ( loc2 )  { loc3 =  (  ( Message ) arg0 )  . get ( "javax . xml . ws . service . endpoint . address" )  ;  } else { loc3 =  (  ( Message ) arg1 )  . get ( "javax . xml . ws . service . endpoint . address" )  ;  } String loc4 =  ( String ) MessageUtils . getContextualProperty (  ( Message ) arg0 ,  "javax . xml . ws . service . endpoint . address" ,  "unknown" )  ;  String loc5 =  ( String ) MessageUtils . getContextualProperty (  ( Message ) arg1 ,  "javax . xml . ws . service . endpoint . address" ,  "unknown" )  ;  boolean loc6 = loc4 . equals ( loc5 )  ;  return loc2 && loc6 ;  }
public class ModifyData { Predicate pred ;  String tblname ;  Expression newval ;  String fldname ;  Expression newValue (  )  { } Predicate pred (  )  { } String tableName (  )  { } String function ( String arg0 ,  int arg1 )  { String loc0 = "" ;  try { loc0 = newValue (  )  . toString (  )  ;  } catch  ( Exception e )  { } String loc1 = pred (  )  . toString (  )  ;  String loc2 = fldname ;  return loc2 ;  } }
public void function ( List < String >  arg0 ,  String arg1 )  { List < File >  loc0 = new ArrayList < File >  (  )  ;  for  ( String loc1 : arg0 )  { File loc2 = new File ( loc1 )  ;  loc0 . add ( loc2 )  ;  } saveFiles ( arg1 ,  "" ,  loc0 )  ;  }
class DeleteFilesFromTheSourceActivity { boolean function ( ActivityRequest arg0 )  { boolean result = false ;  try { String loc0 = arg0 . getFeedId (  )  ;  Properties loc1 = arg0 . getConfigProperties (  )  ;  if  ( loc0 != null && !loc0 . isEmpty (  )  && loc1 != null && !loc1 . isEmpty (  )  )  { result = true ;  } else { throw new IllegalArgumentException ( "Mandatory parameters missing" )  ;  } } catch  ( Exception loc2 )  { } return result ;  } }
class LZ4FastDecompressor { LZ4SafeDecompressor decompressor = new LZ4SafeDecompressor (  )  ;  byte [  ]  function ( byte [  ]  arg0 ,  int arg1 ,  int arg2 )  { try { int loc0 = Math . max ( decompressor . decompress ( arg0 ,  arg1 ,  arg2 ,  arg0 ,  0 ,  0 )  ,  0 )  ;  byte [  ]  loc1 = new byte [ loc0 ]  ;  System . arraycopy ( arg0 ,  0 ,  loc1 ,  0 ,  loc0 )  ;  return loc1 ;  } catch  ( LZ4Exception e )  { throw new RuntimeException ( e )  ;  } } }
public void function ( String arg0 )  { String [  ]  loc0 = arg0 . replaceAll ( " [ ^a-zA-Z  ] " ,  "" )  . toLowerCase (  )  . split ( "\\s+" )  ;  for  ( String loc1 : loc0 )  { incrementTermCount ( loc1 )  ;  } }
class AdaptableHeuristicFunction { Object goal ;  Map map ;  AdaptableHeuristicFunction (  )  {} public AdaptableHeuristicFunction function ( Object arg0 ,  Map arg1 )  { try { this . goal = arg0 ;  this . map = arg1 ;  return this ;  } catch ( Exception e )  { } return null ;  } }
int function ( int arg0 ,  MutationFilter arg1 )  { int loc0 = 0 ;  try { loc0 = arg1 . getEmptyAnnotationRejects (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
void function (  )  { long loc0 = 50L ;  mTestStream . setWrittenBytes ( loc0 )  ;  assertEquals ( BLOCK_LENGTH - loc0 ,  mTestStream . remaining (  )  )  ;  mTestStream . write ( INCREASING_BYTES ,  0 ,  INCREASING_BYTES . length )  ;  assertEquals ( 0 ,  mTestStream . remaining (  )  )  ;  mTestStream . close (  )  ;  assertEquals ( 0 ,  mTestStream . remaining (  )  )  ;  }
List < StorageTierView >  function ( String arg0 )  { int loc0 = mAliasToTierViews . get ( arg0 )  . getTierViewOrdinal (  )  ;  if  ( loc0 == 0 )  { return mTierViews . subList ( 0 ,  1 )  ;  } if  ( loc0  <  0 )  { throw new IllegalArgumentException ( "Tier alias not found: " + arg0 )  ;  } return mTierViews . subList ( 0 ,  loc0 + 1 )  ;  } StorageTierView function ( String arg0 )  { StorageTierView loc0 = mAliasToTierViews . get ( arg0 )  ;  if  ( loc0 == null )  { throw new IllegalArgumentException ( "Tier alias not found: " + arg0 )  ;  } return loc0 . getTierView (  )  ;  }
DeterministicKey function ( DeterministicKey arg0 )  { if  ( !arg0 . hasPrivate (  )  )  { return arg0 ;  } DeterministicKey loc0 = new DeterministicKey (  arg0 . getChildNumberPath (  )  ,  arg0 . getChainCode (  )  ,  arg0 . getPubPoint (  )  ,  null  )  ;  loc0 . parent = arg0 . getParent (  )  ;  return loc0 ;  }
import com . google . common . util . concurrent . ListenableFuture ;  import java . util . concurrent . Callable ;  import java . util . concurrent . ExecutionException ;  import java . util . concurrent . ExecutorService ;  import java . util . concurrent . Executors ;  import java . util . concurrent . Future ;  public class RecomputeExecutor { private ExecutorService mRecomputeLauncherService = Executors . newFixedThreadPool (  DEFAULT_RECOMPUTE_LAUNCHER_POOL_SIZE ,  ThreadFactoryUtils . build ( "recompute-launcher-%d" ,  true )  )  ;  private int DEFAULT_RECOMPUTE_LAUNCHER_POOL_SIZE = 10 ;  private RecomputePlanner mPlanner ;  private RecomputePlan mPlan ;  private FileSystemMaster mFileSystemMaster ;  public Future < RecomputePlan >  function ( RecomputePlan arg0 ,  boolean arg1 )  { Callable < RecomputePlan >  callable = new Callable < RecomputePlan >  (  )  {  @ Override public RecomputePlan call (  )  throws Exception { while  ( !mPlan . isEmpty (  )  )  { RecomputePlanner . Job job = mPlanner . getJob (  )  ;  if  ( job != null )  { mRecomputeLauncherService . submit ( job )  ;  } else { Thread . sleep ( 1000 )  ;  } } mRecomputeLauncherService . shutdown (  )  ;  return mPlan ;  } } ;  if  ( arg1 )  { return immediateFuture ( arg0 )  ;  } else { Future < RecomputePlan >  future = mRecomputeLauncherService . submit ( callable )  ;  return future ;  } } private  < T >  ListenableFuture < T >  immediateFuture ( T value )  { return Futures . immediateFuture ( value )  ;  } public void heartbeat (  )  { } public void run (  )  { } public void close (  )  { } }
void function ( final String arg0 ,  final PropertyChangeListener arg1 )  { try { m_PropertyChangeSupport . removePropertyChangeListener ( arg0 ,  arg1 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
String function (  )  { try { Trans < String >  trans = new Trans < String >  (  )  ;  return withExceptionHandling ( trans ,   (  )  - >  { String loc0 = transformation . getDefaultSystemId (  )  ;  PWD = new File ( loc0 )  . getParentFile (  )  ;  parameters . forEach (  ( k ,  v )  - >  transformation . setParameter ( k ,  v )  )  ;  Source source = new StreamSource ( new File ( loc0 )  )  ;  provideSystemIdIfRequired ( source )  ;  Document loc1 = getResultDocument (  )  ;  transformation . transformTo ( new DOMResult ( loc1 )  )  ;  StringWriter loc2 = new StringWriter (  )  ;  setOutputProperties ( new Properties (  )  )  ;  transformation . transform ( source ,  new StreamResult ( loc2 )  )  ;  return transformation . transformToString (  )  ;  } )  ;  } catch  ( Exception e )  { throw new RuntimeException ( e )  ;  } }
ArrayList function (  )  { ArrayList loc0 = new ArrayList (  )  ;  loc0 . addAll ( parameters )  ;  return loc0 ;  }
BigDecimal function ( PCLDataSetEntity arg0 )  { BigDecimal loc0 = null ;  try { loc0 = arg0 . getFileSize (  )  ;  } catch  ( NullPointerException e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
HashMap < String ,  String >  function ( String arg0 ,  String arg1 ,  Component arg2 )  { HashMap < String ,  String >  loc0 = arg2 . getCSS (  )  . getProperties (  )  ;  switch  ( arg0 )  { case "background-color": if  ( loc0 . containsKey ( arg0 )  )  { loc0 . remove ( arg0 )  ;  } addBackgroundColor ( arg1 )  ;  break ;  case "width": if  ( loc0 . containsKey ( arg0 )  )  { loc0 . remove ( arg0 )  ;  } addWidth ( arg1 )  ;  break ;  default: loc0 . put ( arg0 ,  arg1 )  ;  } return loc0 ;  }
StatSource function ( int arg0 )  { if  ( this . statSources . containsKey ( arg0 )  )  { return this . statSources . get ( arg0 )  ;  } else { return null ;  } }
void function ( Object arg0 ,  Object arg1 )  { Object loc0 = arg0 ;  Object loc1 = arg1 ;  }
void function ( Node arg0 ,  List < Node >  loc1 )  { List < Node >  nodes = nodeNameToNodes . get ( arg0 . toString (  )  )  ;  loc1 . add ( arg0 )  ;  }
public long function (  )  { try { return testId ;  } catch  ( Exception e )  { System . err . println ( "An exception occurred while getting the test ID: " + e . getMessage (  )  )  ;  return -1L ;  } }
void function ( short arg0 )  { checkType ( PackFormat . SHORT )  ;  packLong (  ( long )  arg0 ,  true )  ;  } Note: Please ensure that the necessary imports and the definitions of the "checkType" and "packLong" functions are available in the code before using this method .  Also ,  make sure to handle any exceptions that may arise when calling this method . 
Sha256Hash function (  )  { Sha256Hash loc0 = null ;  if  ( txOutChanges != null )  { loc0 = txOutChanges . getHash (  )  ;  } return loc0 ;  }
void function ( String arg0 )  { try { this . callbackHandlerClass = arg0 ;  LOG . fine ( "srini_string" + arg0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
public int function ( int arg0 ,  int arg1 )  { int loc0 = this . getPeakStart (  )  ;  int loc1 = this . getPeakEnd (  )  ;  return  ( loc1 - loc0 + 1 )  ;  }
MTDFragmentAST function ( String arg0 ,  HashMap < String , IntegerHolder >  arg1 ,  IntegerHolder arg2 )  { String input = arg0 . replaceAll ( "// . *\n" ,  "" )  . replaceAll ( "/\\* (  . |\\n ) *?\\*/" ,  "" )  ;  MTDFragmentAST tree = parseTree ( input )  ;  decorate ( tree ,  arg2 )  ;  return tree ;  }
void function ( THashSet < String >  arg0 )  { try { mBlacklist . addAll ( arg0 )  ;  System . out . println ( "Blacklist added to this hosts file . " )  ;  } catch  ( Exception e )  { System . err . println ( "Error adding blacklist to this hosts file: " + e . getMessage (  )  )  ;  } }
BigDecimal function (  )  { BigDecimal loc0 = expDataSetId ;  return loc0 ;  }
void function ( String arg0 ,  String arg1 )  { String loc0 = arg0 + " - " + arg1 ;  this . errorMsg = loc0 ;  }
MetadataEditorCompat function ( Bitmap arg0 )  { MetadataEditorCompat loc0 = new MetadataEditorCompat ( this )  ;  loc0 . putBitmap ( RemoteControlClientCompat . METADATA_KEY_ARTWORK ,  arg0 )  ;  return loc0 ;  }
String function ( String arg0 )  { WorkflowJobBean loc0 = getWorkflow (  )  ;  WorkflowActionBean loc1 = getWorkflowInstance (  )  . getWorkflow (  )  . getAction ( arg0 )  ;  setActionInfo ( getWorkflowInstance (  )  ,  loc1 )  ;  return getVar ( ACTION_EXTERNAL_ID ,  loc1 . getVar (  )  )  ;  }
String function ( ConfigurationKey arg0 )  { try { String loc0 = getFactory (  )  . getConfigurationHandler (  )  . getString ( arg0 )  ;  return loc0 ;  } catch  ( ConfigurationException e )  { } return null ;  }
int function (  )  { int loc0 = 0 ;  try { if  ( format . available (  )   >  0 )  { loc0 = format . unpackInt ( false )  ;  } else { loc0 = valueLen - valueOff ;  } } catch  ( IOException e )  { } return loc0 ;  }
String function ( int arg0 )  { try { NaiveBayesTest nbTest = new NaiveBayesTest (  )  ;  int loc0 = nbTest . numOfClasses ;  if  ( arg0  <  1 || arg0  >  loc0 )  { return null ;  } switch  ( arg0 )  { case 1: return "class1" ;  case 2: return "class2" ;  case 3: return "class3" ;  default: return null ;  } } catch  ( Exception e )  { return null ;  } }
public void function (  )  { double arg0 = -100 . 0 ;  // set the heading to a negative value for testing HDMTest test = new HDMTest (  )  ;  test . setUp (  )  ;  try { test . hdm . setHeading ( arg0 )  ;  double loc0 = test . hdm . getHeading (  )  ;  double loc1 = -100 . 0 ;  assertEquals ( loc0 ,  loc1 ,  0 . 01 )  ;  // assert that the heading was set correctly double arg1 = 400 . 0 ;  test . hdm . setHeading ( arg1 )  ;  } catch  ( IllegalArgumentException e )  { return ;  } fail ( "Expected IllegalArgumentException was not thrown . " )  ;  }
void function ( T arg0 )  { if  ( position  > = max )  { position = 0 ;  haveOverflow = true ;  } int size = circularArray . size (  )  ;  circularArray . remove ( position )  ;  circularArray . add ( position ,  arg0 )  ;  position ++  ;  }
public void function ( Object arg0 ,  Object arg1 )  { try { mAlluxioMaster . start (  )  ;  } catch  ( Exception e )  { LOG . error ( "Failed to start Alluxio master on {}" ,  mHostname ,  e )  ;  throw new RuntimeException ( e )  ;  } }
void function ( String arg0 )  { identifier = arg0 ;  } String function (  )  { return identifier ;  } String function ( String arg0 ,  String arg1 )  { if  ( arg0 != null )  { wsseValueType = arg0 ;  } if  ( arg1 != null )  { wsse11TokenType = arg1 ;  } return identifier ;  } void function ( boolean arg0 )  { useDirectReference = arg0 ;  } boolean function (  )  { return useDirectReference ;  } void function ( String arg0 )  { wsse11TokenType = arg0 ;  } String function (  )  { return wsse11TokenType ;  } boolean function (  )  { return useKeyIdentifier ;  } void function ( boolean arg0 )  { useKeyIdentifier = arg0 ;  } String function (  )  { return wsseValueType ;  } void function ( String arg0 ,  boolean arg1 )  { wsseValueType = arg0 ;  useKeyIdentifier = arg1 ;  }
public static void function ( byte [  ]  arg0 ,  int arg1 ,  int arg2 )  { try { if  ( arg0 . length  <  arg1 + arg2 )  { throw new ArrayIndexOutOfBoundsException (  )  ;  } } catch  ( ArrayIndexOutOfBoundsException loc0 )  { loc0 . printStackTrace (  )  ;  } }
void function (  )  { mClientRWLock . lock (  )  ;  try { boolean loc0 = mClientRWLock . tryLock (  )  ;  assertFalse ( loc0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } finally { mClientRWLock . unlock (  )  ;  } }
Long function ( TestResultDTO arg0 )  { Long loc0 = arg0 . getTestId (  )  ;  return loc0 ;  }
List < String >  function (  )  { List < String >  loc0 = new ArrayList < String >  (  )  ;  for  ( String loc1 : log )  { loc0 . add ( loc1 )  ;  } return loc0 ;  }
void function (  )  { try { RMCTest test = new RMCTest (  )  ;  test . setUp (  )  ;  RMCParser parser = test . rmc ;  parser . setVariation ( "-2 . 1" )  ;  String loc0 = parser . getVariation (  )  ;  String loc1 = "-2 . 1" ;  assertEquals ( loc1 ,  loc0 )  ;  } catch  ( Exception e )  { fail ( "Exception thrown: " + e . getMessage (  )  )  ;  } }
public static long function ( Date arg0 )  { long loc0 = System . currentTimeMillis (  )  ;  long loc1 = loc0 - arg0 . getTime (  )  ;  long loc2 = loc1 / TimeUtils . MIN ;  return loc2 ;  }
File function (  )  { File loc0 = null ;  try { loc0 = new SysUtil (  )  . getLibsDirectory ( null )  ;  if  ( !loc0 . isDirectory (  )  && !loc0 . mkdirs (  )  )  { throw new RuntimeException ( "could not create libs directory: " + loc0 )  ;  } } catch  ( Exception e )  { throw new RuntimeException ( "failed to get/create libs directory" ,  e )  ;  } return loc0 ;  }
Set < String >  function ( ResourceTypeHandler arg0 )  { Set < String >  loc0 = new HashSet < String >  (  )  ;  try { loc0 = extensionsDenied . get ( arg0 )  ;  } catch  ( NullPointerException e )  { } return loc0 ;  }
void function ( long arg0 ,  long arg1 ,  RPCResponse . Status arg2 ,  long arg3 ,  long arg4 )  { RPCFileReadResponse loc0 = new RPCFileReadResponse ( arg0 ,  arg1 ,  arg2 ,  arg3 ,  arg4 ,  mBuffer )  ;  int loc1 = loc0 . getEncodedLength (  )  ;  ByteBuf loc2 = loc0 . encode (  )  ;  Assert . assertEquals ( loc0 ,  RPCFileReadResponse . decode ( loc2 )  )  ;  }
import java . util . Locale ;  public class Platform { int listListIteratorTesterNumIterations ;  int collectionIteratorTesterNumIterations ;  String function ( String arg0 ,  String arg1 )  { String loc0 = "Format the template with args ,  only supports the placeholder %s . " ;  return String . format ( Locale . ROOT ,  loc0 ,  arg0 ,  arg1 )  ;  } }
import java . util . ArrayList ;  import java . util . List ;  public class CollectionUtil { public static  < T >  List < T >  function ( T arg0 ,  T arg1 ,  T arg2 )  { List < T >  loc0 = new ArrayList <  >  ( 3 )  ;  loc0 . add ( arg0 )  ;  loc0 . add ( arg1 )  ;  loc0 . add ( arg2 )  ;  return loc0 ;  } }
void function ( Class < ? ,  ? >  arg0 ,  Object arg1 )  { Assert . isInstanceOf ( arg0 ,  arg1 ,  "srini_string" )  ;  }
Here's the modified code for the "function" method that calls the specified methods: ``` import org . apache . cxf . endpoint . Endpoint ;  import org . apache . cxf . service . Service ;  import org . apache . cxf . service . model . ServiceInfo ;  import org . apache . cxf . tools . wsdlto . WSDLToJava ;  public class TestUtilities { public Object function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { WSDLToJava wsdlToJava = new WSDLToJava (  )  ;  wsdlToJava . setWsdlLocation (  ( String ) arg0 )  ;  wsdlToJava . setServiceName (  ( QName ) arg1 )  ;  wsdlToJava . setUseWrapperElement ( true )  ;  wsdlToJava . setUseSchemaImports ( true )  ;  wsdlToJava . setValidate ( true )  ;  wsdlToJava . setQuiet ( true )  ;  wsdlToJava . setSuppressGeneratedDate ( true )  ;  wsdlToJava . setNoTypes ( true )  ;  wsdlToJava . setGenerateTypes ( false )  ;  wsdlToJava . setGenerateImplementations ( false )  ;  wsdlToJava . setGenerateServer ( false )  ;  wsdlToJava . setGenerateClient ( false )  ;  wsdlToJava . setGenerateServerInterface ( false )  ;  wsdlToJava . setGenerateClientInterface ( false )  ;  wsdlToJava . setGenerateService ( false )  ;  wsdlToJava . setGenerateAntBuildFile ( false )  ;  wsdlToJava . setGenerateTestCases ( false )  ;  wsdlToJava . setMarkGenerated ( true )  ;  wsdlToJava . setNoAddressBinding ( true )  ;  wsdlToJava . setVerbose ( false )  ;  wsdlToJava . setPackagenames ( new HashSet < String >  (  )  )  ;  wsdlToJava . setCatalogFiles ( new ArrayList < String >  (  )  )  ;  wsdlToJava . setBindingFiles ( new ArrayList < String >  (  )  )  ;  wsdlToJava . setFrontEnd ( new JAXWSFrontEndPlugin (  )  )  ;  wsdlToJava . setDataBinding ( new AegisDatabinding (  )  )  ;  wsdlToJava . setBackend ( new JavaServerBackendPlugin (  )  )  ;  wsdlToJava . setServerFactoryName ( "Jetty" )  ;  wsdlToJava . getClientFactory (  )  . setTransportId ( "http://cxf . apache . org/transports/http" )  ;  wsdlToJava . getClientFactory (  )  . setBindingId ( "http://schemas . xmlsoap . org/wsdl/soap12/" )  ;  wsdlToJava . getAnt (  )  . setAntOut ( new NullOutputStream (  )  )  ;  WSDLToJavaContainer wsdlToJavaContainer = new WSDLToJavaContainer ( wsdlToJava )  ;  wsdlToJavaContainer . setExcludeNamespace ( "http://schemas . xmlsoap . org/wsdl/" )  ;  wsdlToJavaContainer . setExcludeNamespace ( "http://schemas . xmlsoap . org/wsdl/soap12/" )  ;  wsdlToJavaContainer . setExcludeNamespace ( "http://www . w3 . org/2005/08/addressing" )  ;  wsdlToJavaContainer . setExcludeNamespace ( "http://cxf . apache . org/bindings/xformat" )  ;  wsdlToJavaContainer . setExcludeNamespace ( "http://cxf . apache . org/jaxws" )  ;  wsdlToJavaContainer . setExcludeNamespace ( "http://cxf . apache . org/xkms" )  ;  WSDLToJavaProcessor processor = new WSDLToJavaProcessor ( wsdlToJavaContainer )  ;  processor . setBuildXML ( false )  ;  processor . setWSDLDefinition (  ( Definition ) arg2 )  ;  processor . buildModel (  )  ;  ServiceInfo serviceInfo = processor . getServiceModel (  )  . getService (  )  . getServiceInfos (  )  . get ( 0 )  ;  serviceInfo . setProperty ( WSDLServiceBuilder . WSDL_DEFINITION ,  arg2 )  ;  serviceInfo . setProperty ( WSDLServiceBuilder . WSDL_SERVICE ,  arg2 . getService ( arg1 )  )  ;  serviceInfo . setProperty ( WSDLServiceBuilder . WSDL_PORT ,  arg2 . getService ( arg1 )  . getPort ( "ServicePort" )  )  ;  serviceInfo . setProperty ( WSDLServiceBuilder . WSDL_DESCRIPTION ,  arg2 . getServiceDescription (  )  )  ;  Endpoint endpoint = processor . getServiceModel (  )  . getEndpoints (  )  . get ( 0 )  ; 
String function ( String arg0 )  { List < String >  loc0 = null ;  try { loc0 = getList ( arg0 )  ;  if  ( loc0 . size (  )   >  0 )  { return loc0 . get ( 0 )  ;  } else { return NO_DATA_FOUND ;  } } catch  ( Exception e )  { return e . getMessage (  )  ;  } }
public void function ( Object arg0 ,  Object arg1 )  { long loc0 = System . currentTimeMillis (  )  ;  long loc1 = getTimeStamp (  )  ;  boolean loc2 = isValid (  )  ;  for  ( SentenceEvent event : events )  { if  ( loc0 - event . getTimestamp (  )   >  MAX_AGE )  { event . setValid ( false )  ;  } } if  ( loc2 )  { for  ( ProviderListener < T >  listener : listeners )  { listener . providerValidated ( createProviderEvent (  )  )  ;  } } else { for  ( ProviderListener < T >  listener : listeners )  { listener . providerInvalidated ( createProviderEvent (  )  )  ;  } } }
void function ( String arg0 ,  String arg1 )  { NoFileAssertListener loc0 = new NoFileAssertListener (  )  ;  cpd . setCpdListener ( loc0 )  ;  File loc1 = new File ( BASE_TEST_RESOURCE_PATH ,  arg0 )  ;  addedFile ( files ++  ,  loc1 )  ;  verify ( expectedFilesCount )  ;  }
public Method function ( Class < ? >  arg0 ,  Method arg1 )  { try { Method loc0 = ReflectionUtils . findMethod ( arg0 ,  arg1 . getName (  )  ,  arg1 . getParameterTypes (  )  )  ;  return loc0 ;  } catch  ( Exception e )  { return null ;  } }
public void function ( Parcel arg0 ,  Map < Parcelable , Parcelable >  arg1 )  { arg0 . writeInt ( arg1 . size (  )  )  ;  for  ( Map . Entry < Parcelable ,  Parcelable >  loc0 : arg1 . entrySet (  )  )  { arg0 . writeParcelable ( loc0 . getKey (  )  ,  0 )  ;  arg0 . writeParcelable ( loc0 . getValue (  )  ,  0 )  ;  } }
public String function (  )  { String loc0 = "" ;  try { loc0 = this . title ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
void function ( Timestamp arg0 )  { try { setModifiedDate ( arg0 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
T function ( T arg0 ,  long arg1 ,  TimeUnit arg2 )  { if  ( !done )  { synchronized  ( this )  { while  ( !done )  { try { if  ( arg1  < = 0 )  { wait (  )  ;  } else { wait ( arg1 ,  arg2 )  ;  } } catch  ( InterruptedException e )  { } } } } if  ( throwable != null )  { throw new RuntimeException ( "Exception thrown in async task" ,  throwable )  ;  } return value ;  }
boolean function ( Object arg0 ,  String arg1 ,  Map arg2 )  { Boolean loc0 = arg2 . containsKey ( arg1 )  ?  (  ( Boolean )  arg2 . get ( arg1 )  )  . booleanValue (  )  : false ;  Object loc1 = arg0 instanceof Map ?  (  ( Map )  arg0 )  . get ( arg1 )  : null ;  Object loc2 = loc1 != null ? loc1 : arg1 != null ? arg2 . get ( arg1 )  : null ;  return loc0 || loc2 != null ||  ( arg0 != null && arg0 . equals ( arg1 )  )  ;  }
SettableFuture < PaymentChannelClientConnection >  channelOpenFuture = SettableFuture . create (  )  ;  ProtobufParser < Protos . TwoWayChannelMessage >  wireParser ;  PaymentChannelClient channelClient ;  public void function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { try { channelOpenFuture . set ( this )  ;  } catch  ( Exception e )  { channelOpenFuture . setException ( e )  ;  } }
String function  (   )  { loc0 = start_subgraph ( "cluster_0" )  ;  addln (  )  ;  loc1 = "style=filled" ;  addln ( loc0 + loc1 )  ;  addln ( "color=lightgrey" )  ;  addln ( "node  [ style=filled , color=white ]  ; " )  ;  addln ( "A0 - >  B0  [ label=\"0 . 2\" ]  ; " )  ;  addln ( "A1 - >  B1  [ label=\"0 . 2\" ]  ; " )  ;  addln ( "A2 - >  B2  [ label=\"0 . 4\" ]  ; " )  ;  addln ( "A3 - >  B3  [ label=\"0 . 4\" ]  ; " )  ;  addln ( loc0 + end_subgraph (  )  )  ;  return graph . toString (  )  ;  }
public Timestamp function ( String arg0 ,  BigDecimal arg1 ,  String arg2 )  { Timestamp loc0 = this . modifiedDate ;  return loc0 ;  }
void function ( final int arg0 ,  final byte [  ]  buf ,  final int arg1 )  { buf [ arg1 ]  =  ( byte ) arg0 ;  buf [ arg1 + 1 ]  =  ( byte )  ( arg0  >  >  8 )  ;  buf [ arg1 + 2 ]  =  ( byte )  ( arg0  >  >  16 )  ;  buf [ arg1 + 3 ]  =  ( byte )  ( arg0  >  >  24 )  ;  }
void function ( String arg0 ,  Bundle arg1 ,  RequestListener arg2 ,  final Object loc0 )  { fb . runner (  )  . request ( arg0 ,  arg1 ,  "GET" ,  arg2 ,  loc0 )  ;  }
public Api function ( ServiceBuilder loc0 ,  Class < ? extends Api >  loc1 )  { return loc0 . createApi ( loc1 )  ;  }
public boolean function ( CSSValue arg0 )  { short primitiveType = arg0 . getPrimitiveType (  )  ;  if  ( ValueConstants . isNumber ( primitiveType )  )  { return ValueConstants . isAbsoluteUnit ( ValueConstants . stringForSACPrimitiveType ( primitiveType )  )  ;  } else if  ( primitiveType == CSSPrimitiveValue . CSS_IDENT )  { String stringValue = arg0 . getStringValue (  )  ;  short guessedType = ValueConstants . guessType ( stringValue )  ;  if  ( guessedType != CSSPrimitiveValue . CSS_IDENT )  { return ValueConstants . isAbsoluteUnit ( ValueConstants . stringForSACPrimitiveType ( guessedType )  )  ;  } } return false ;  }
class OsUtil { boolean isSunJdk (  )  { String osName = System . getProperty ( "os . name" )  ;  return osName . contains ( "SunOS" )  ;  } boolean isWin32 (  )  { String osName = System . getProperty ( "os . name" )  ;  return osName . contains ( "Windows" )  ;  } boolean function (  )  { String arg0 = "os . name" ;  String arg1 = "Mac" ;  String loc0 = System . getProperty ( arg0 )  ;  return loc0 != null && loc0 . contains ( arg1 )  ;  } }
import static org . junit . Assert . assertEquals ;  public class PositionTest { private Position instance ;  public void function (  )  { double expected = 1 . 23 ;  double actual ;  try { instance . setLongitude ( expected )  ;  actual = instance . getLongitude (  )  ;  } catch  ( Exception e )  { return ;  } assertEquals ( expected ,  actual ,  0 . 0 )  ;  } }
void function ( long arg0 ,  long arg1 ,  long arg2 )  { RPCFileReadRequest req = new RPCFileReadRequest ( arg0 ,  arg1 ,  arg2 )  ;  assertValid ( req )  ;  }
boolean function ( StoredBlock arg0 ,  StoredBlock arg1 )  { BigInteger loc0 = arg0 . getChainWork (  )  ;  BigInteger loc1 = arg1 . getChainWork (  )  ;  return loc0 . compareTo ( loc1 )   >  0 ;  }
void function ( IFetcherTesterDataUnitVerifier arg0 ,  Map < String ,  Field >  arg1 ,  IFetcherContext arg2 )  { IFetcherTesterDataUnitVerifier loc0 = new FetcherTesterDataUnitVerifier (  )  ;  Map < String ,  Field >  loc1 = buildFieldAndColumnMapping (  )  ;  PCLDataSetEntity loc2 = new PCLDataSetEntity (  )  ;  loc0 . init (  )  ;  loc2 . init (  )  ;  }
void function (  )  { try { if  ( connection != null && connection . isOpen (  )  )  { connection . close (  )  ;  } } catch  ( Exception loc0 )  { handleException ( "Error occurred while closing connection: " ,  loc0 )  ;  } finally { connection = null ;  } }
Sha256Hash function (  )  { byte [  ]  loc0 = new byte [ getScriptBytes (  )  . length + 4 ]  ;  System . arraycopy ( getScriptBytes (  )  ,  0 ,  loc0 ,  0 ,  getScriptBytes (  )  . length )  ;  Utils . uint32ToByteArrayLE ( getHeight (  )  ,  loc0 ,  getScriptBytes (  )  . length )  ;  byte [  ]  loc1 = Utils . doubleDigest ( loc0 )  ;  return new Sha256Hash ( loc1 )  ;  }
public class OpenTagRegisterTest { OpenTagRegister tagList ;  int elmId = 0 ;  void function ( String arg0 ,  String arg1 ,  String arg2 )  { ASTElement loc0 = element ( arg0 )  ;  tagList . openTag ( loc0 )  ;  ASTElement loc1 = element ( arg1 )  ;  tagList . openTag ( loc1 )  ;  ASTElement loc2 = element ( arg1 )  ;  tagList . openTag ( loc2 )  ;  tagList . closeTag ( loc2 )  ;  tagList . closeTag ( loc1 )  ;  assertFalse ( loc0 . isUnclosed (  )  )  ;  assertFalse ( loc1 . isUnclosed (  )  )  ;  assertTrue ( loc2 . isUnclosed (  )  )  ;  } void openedIsolatedTag (  )  { } void interleavedTags (  )  { } void newRegister (  )  { } void testSimpleNesting (  )  { } void unopenedTags (  )  { } ASTElement element ( String name )  { } }
void function ( char [  ]  arg0 ,  int arg1 ,  int arg2 )  { try { String content = new String ( arg0 ,  arg1 ,  arg2 )  ;  content = content . replaceAll ( " < ! --  . *? --  > " ,  "" )  ;  // remove comments content = content . replaceAll ( " < summary >  . *? < /summary > " ,  "" )  ;  // remove summary content = content . replaceAll ( "throws\\s+\\w+ ( \\ . \\w+ ) ?" ,  "" )  ;  // remove throws content = content . replaceAll ( " ( ? < !\\w )  ( public|protected|private ) \\s+" ,  "" )  ;  // remove function modifiers content = content . replaceAll ( "\\b ( \\w+ ) \\s+\\w+\\s*=\\s*" ,  "String loc0 = " )  ;  // change local variable names writer . writeCharacters ( content . trim (  )  )  ;  } catch  ( Exception e )  { throw new SAXException ( e )  ;  } }
public class HashCodeBuilder { private int iConstant ;  private int iTotal = 0 ;  public HashCodeBuilder ( int iConstant )  { this . iConstant = iConstant ;  } public HashCodeBuilder appendSuper ( int superHashCode )  { iTotal = iTotal * iConstant + superHashCode ;  return this ;  } public int toHashCode (  )  { return iTotal ;  } public int function ( Object .  .  .  args )  { if  ( args == null )  { iTotal = iTotal * iConstant ;  } else { for  ( Object arg : args )  { if  ( arg == null )  { iTotal = iTotal * iConstant ;  } else if  ( arg . getClass (  )  . isArray (  )  )  { int length = java . lang . reflect . Array . getLength ( arg )  ;  for  ( int i = 0 ;  i  <  length ;  i ++  )  { Object loc = java . lang . reflect . Array . get ( arg ,  i )  ;  append ( loc )  ;  } } else { append ( arg )  ;  } } } return toHashCode (  )  ;  } private void append ( Object obj )  { if  ( obj == null )  { iTotal = iTotal * iConstant ;  } else if  ( !obj . getClass (  )  . isArray (  )  )  { iTotal = iTotal * iConstant + obj . hashCode (  )  ;  } else { int length = java . lang . reflect . Array . getLength ( obj )  ;  for  ( int i = 0 ;  i  <  length ;  i ++  )  { Object loc = java . lang . reflect . Array . get ( obj ,  i )  ;  append ( loc )  ;  } } } }
public class Steps { private String testData ;  private String method ;  private String filepath ;  private String step ;  private String stepResult ;  private String time ;  public void setMethod ( String value )  { this . method = value ;  } public String getStepResult (  )  { return stepResult ;  } public void setStep ( String value )  { this . step = value ;  } public void setTestData ( String value )  { this . testData = value ;  } public void setStepResult ( String value )  { this . stepResult = value ;  } public String getTime (  )  { return time ;  } public String getStep (  )  { return step ;  } public String getFilepath (  )  { return filepath ;  } public String getTestData (  )  { return testData ;  } public String getMethod (  )  { return method ;  } public void setTime ( String value )  { this . time = value ;  } void function ( String arg0 )  { try { String loc0 = arg0 ;  setFilepath ( loc0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } } private void setFilepath ( String loc1 )  { this . filepath = loc1 ;  } }
void function (  )  { _sharedContext . flushFonts (  )  ;  _sharedContext . getReplacedElementFactory (  )  . clean ( _sharedContext . getUac (  )  )  ;  _sharedContext . getUac (  )  . disposeCache (  )  ;  _sharedContext . clean (  )  ;  }
String function ( String arg0 ,  String arg1 )  { String loc0 = "" ;  try { loc0 += uniqueName . endsWith ( arg0 )  ? uniqueName : uniqueName + arg1 ;  loc0 = loc0 . substring ( project . getName (  )  . length (  )  + 1 )  ;  loc0 += getZipFileExtension (  )  ;  } catch  ( Exception e )  { System . err . println ( "An error occurred: " + e . getMessage (  )  )  ;  } return loc0 ;  }
public long function (  )  { long loc0 = this . value ;  int loc1 = Fiat . SMALLEST_UNIT_EXPONENT ;  while  ( loc1  >  0 )  { loc0 /= 10 ;  loc1 --  ;  } return loc0 ;  } public void callFunctionWithExceptionHandling (  )  { try { long result = function (  )  ;  System . out . println ( "Result: " + result )  ;  } catch  ( Exception e )  { System . err . println ( "Error occurred while calling function: " + e . getMessage (  )  )  ;  } }
boolean function ( String arg0 )  { String loc0 = arg0 . trim (  )  ;  return loc0 . equals ( THIS )  || loc0 . equals ( SUPER )  ;  }
public void function (  )  { String loc0 = ttm . getTime (  )  ;  assertNotNull ( loc0 )  ;  assertEquals ( EXAMPLE . substring ( 7 ,  15 )  ,  loc0 )  ;  int loc1 = Integer . parseInt ( loc0 . substring ( 0 ,  2 )  )  ;  int loc2 = Integer . parseInt ( loc0 . substring ( 2 ,  4 )  )  ;  int loc3 = Integer . parseInt ( loc0 . substring ( 4 ,  6 )  )  ;  assertEquals ( 11 ,  loc1 )  ;  assertEquals ( 25 ,  loc2 )  ;  assertEquals ( 13 ,  loc3 )  ;  }
public String function (  )  { String loc0 = null ;  try { loc0 = this . string1 ;  } catch  ( NullPointerException e )  { System . err . println ( "Caught NullPointerException: " + e . getMessage (  )  )  ;  } return loc0 ;  }
void function ( String arg0 )  { this . userName = arg0 ;  }
void function (  )  { m_removed = true ;  m_markedForRemoval = true ;  m_log . debug ( "Directory {} has been marked for removal . " ,  m_directory . getAbsolutePath (  )  )  ;  }
boolean function ( Object arg0 )  { boolean loc0 = isLink ( arg0 )  ;  if  ( loc0 )  { UserAgentCallback loc1 = uac ;  boolean loc2 = loc1 . isVisited ( nsh . getLinkUri ( arg0 )  )  ;  return loc2 ;  } return false ;  }
public Object function ( String command ,  Object .  .  .  args )  { try { return webEngine . executeScript ( command ,  args )  ;  } catch  ( Exception loc0 )  { System . err . println ( "An error occurred while executing JavaScript: " + loc0 . getMessage (  )  )  ;  return null ;  } }
Result function ( ResultLevel arg0 )  { Result loc0 = new Result (  )  ;  for  ( ResultEntry loc1 : this . log )  { ResultLevel loc2 = loc1 . getLevel (  )  ;  int loc3 = loc2 . compareTo ( arg0 )  ;  if  ( loc3  < = 0 )  { loc0 . add ( loc1 )  ;  } } return loc0 ;  }
public void function ( String code ,  Object arg0 ,  Object arg1 )  { PackageStats loc0 = TOP_LEVEL_PACKAGE ;  loc0 . compute ( code ,  arg0 ,  arg1 )  ;  }
void function ( PropertyChangeListener arg0 ,  Object arg1 ,  PropertyChangeEvent arg2 )  { removeAllElementListeners ( arg0 )  ;  if  ( !isRemoved ( arg1 )  )  { try { /* Object source = arg2 . getSource (  )  ;  String property = arg2 . getPropertyName (  )  ;  Object newValue = arg2 . getNewValue (  )  ;  Object oldValue = arg2 . getOldValue (  )  ;  if  ( source instanceof ModelElement && property . equals ( "elements" )  )  { Collection < ? >  added = CollectionUtils . subtract (  (  ( ModelElement )  source )  . getElements (  )  ,   (  ( ModelElement )  source )  . getElements ( oldValue )  )  ;  for  ( Object element : added )  { initialiseListener ( arg0 ,  element )  ;  } } if  ( source instanceof ModelElement && property . equals ( "elements" )  )  { Collection < ? >  removed = CollectionUtils . subtract (  (  ( ModelElement )  source )  . getElements ( oldValue )  ,   (  ( ModelElement )  source )  . getElements (  )  )  ;  for  ( Object element : removed )  { removeElementListener ( arg0 ,  element )  ;  } } if  ( source instanceof ModelElement && property . equals ( "name" )  )  { String newName =  (  ( ModelElement )  source )  . getName (  )  ;  Map < String ,  Object >  args = new HashMap < String ,  Object >  (  )  ;  args . put ( "oldName" ,  oldValue )  ;  args . put ( "newName" ,  newName )  ;  String message = toString ( source ,  args )  ;  LOG . warn ( message )  ;  cleanListener ( arg0 ,  source )  ;  initialiseListener ( arg0 ,  source )  ;  } */ initialiseListener ( arg0 ,  arg1 )  ;  } catch  ( Exception e )  { LOG . warn ( "Failed to update listeners" ,  e )  ;  } } }
LinearSolver < DenseMatrix64F >  function ( int arg0 ,  int arg1 )  { DenseMatrix64F loc0 = new DenseMatrix64F ( arg0 ,  arg1 )  ;  return LinearSolverFactory . this . linear ( loc0 . getNumRows (  )  )  ;  return LinearSolverFactory . this . leastSquares ( loc0 . getNumRows (  )  ,  loc0 . getNumCols (  )  )  ;  }
Long function (  )  { Long loc0 = dataSetId ;  return loc0 ;  }
import java . sql . Timestamp ;  public void function ( Timestamp arg0 )  { try { Timestamp loc0 = arg0 ;  this . modifiedDate = loc0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function ( String arg0 )  { try { initInternal ( arg0 )  ;  } catch  ( Exception e )  { LOG . error ( "Error initializing Translator: " + e . getMessage (  )  )  ;  } }
long function ( byte [  ]  arg0 ,  int arg1 )  { long loc0 = 0 ;  for  ( int loc1 = 0 ;  loc1  <  8 ;  loc1 ++  )  { if  ( loc1 + arg1  <  arg0 . length )  { loc0 |=  (  ( long )   ( arg0 [ arg1 + loc1 ]  & 0xff )  )   <  <   ( 8 * loc1 )  ;  } } return loc0 ;  }
int function ( ConfigurationKey arg0 )  { int loc0 = 0 ;  try { loc0 = config . getFactory (  )  . getConfigurationHandler (  )  . getInteger ( arg0 )  ;  } catch  ( ConfigurationException e )  { } return loc0 ;  }
void function (  )  { progressMonitor . setCurValue ( progressMonitor . getCurValue (  )  + 1 )  ;  logDebug ( "Increments the Current Value . " )  ;  }
Collection < Edge >  function ( Node arg0 )  { Collection < Edge >  loc0 = new ArrayList <  >  (  )  ;  try { loc0 = getIncidentEdges ( arg0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
String function (  )  { String serviceAddress = "" ;  try { InetAddress loc0 = localServer . getServiceAddress (  )  ;  String hostName = loc0 . getHostName (  )  ;  int port = loc0 . getPort (  )  ;  HttpHost httpHost = new HttpHost ( hostName ,  port )  ;  serviceAddress = httpHost . toString (  )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } return serviceAddress ;  }
String function ( RMProperties arg0 ,  RMConfiguration arg1 )  { String loc0 = arg0 . getNamespaceURI (  )  ;  if  ( loc0 != null )  { return loc0 ;  } else { return arg1 . getRMNamespace (  )  ;  } }
void function ( long arg0 )  { repository . delete ( arg0 )  ;  }
int distinctValues (  )  { int numDistinctValues = 0 ;  try { StatInfo loc0 = ti . stats (  )  ;  Schema loc1 = schema (  )  ;  for  ( String fieldName : loc1 . fields (  )  )  { numDistinctValues += loc0 . distinctValues ( fieldName )  ;  } } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return numDistinctValues ;  }
public void function ( long arg0 )  throws InterruptedException { while ( !session . isShutdown (  )  && !haveAcknowledgementFor ( arg0 )  )  { CountDownLatch loc0 = new CountDownLatch ( 1 )  ;  synchronized ( sendLock )  { sendBuffer . put ( getCurrentSequenceNumber (  )  ,  null )  ;  loc1 = startLatch . get (  )  ;  } loc0 . await ( 10 ,  TimeUnit . MILLISECONDS )  ;  } }
void function (  )  { try { RPCFileWriteRequest req = new RPCFileWriteRequest ( TEMP_UFS_FILE_ID ,  OFFSET ,  LENGTH ,  mBuffer )  ;  int loc0 = req . getEncodedLength (  )  ;  ByteBuf byteBuf = Unpooled . buffer ( loc0 )  ;  req . encode ( byteBuf )  ;  RPCFileWriteRequest req2 = RPCFileWriteRequest . decode ( byteBuf )  ;  Assert . assertEquals ( loc0 ,  req2 . getEncodedLength (  )  )  ;  Assert . assertEquals ( mBuffer . readableBytes (  )  ,  req2 . getPayloadDataBuffer (  )  . readableBytes (  )  )  ;  } catch  ( Exception e )  { } }
public static SpringChain function (  )  { try { int loc0 = -1 ;  CopyOnWriteArrayList < Spring >  loc1 = new CopyOnWriteArrayList <  >  (  )  ;  int loc2 = 70 ;  CopyOnWriteArrayList < SpringListener >  loc3 = new CopyOnWriteArrayList <  >  (  )  ;  SpringConfig loc4 = null ;  int loc5 = 10 ;  int loc6 = 6 ;  int loc7 = 0 ;  int loc8 = 40 ;  SpringConfigRegistry loc9 = SpringConfigRegistry . getInstance (  )  ;  SpringConfig loc10 = null ;  SpringSystem loc11 = SpringSystem . create (  )  ;  return new SpringChain ( loc0 ,  loc1 ,  loc2 ,  loc3 ,  loc4 ,  loc5 ,  loc6 ,  loc7 ,  loc8 ,  loc9 ,  loc10 ,  loc11 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
FileBasedConfigManager { boolean function ( File loc0 )  { return loc0 . exists (  )  ;  } }
String function ( PCLDataSetEntity arg0 )  { String loc0 = null ;  try { loc0 = arg0 . getChecksumType (  )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
void function ( AbstractDosPlugin arg0 )  { String loc0 = arg0 . getName (  )  ;  int loc1 = loc0 . length (  )  ;  assertTrue ( loc1  >  0 )  ;  }
public long function (  )  { long loc0 = 0 ;  try { loc0 = this . inactivityTimeout != null ? this . inactivityTimeout : 60000L ;  } catch  ( Exception loc1 )  { System . err . println ( "Error occurred while getting inactivity timeout: " + loc1 . getMessage (  )  )  ;  } return loc0 ;  }
public void function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { Element eSla =  ( Element )  arg0 ;  Date nominalTime =  ( Date )  arg1 ;  Configuration conf =  ( Configuration )  arg2 ;  SyncSLACalcStatus slaCalcStatus = getDSObject ( eSla )  . getSLACalcStatus (  )  ;  ELEvaluator eval = createDataEvaluator ( eSla ,  conf ,  slaCalcStatus . getActionId (  )  )  ;  setConfigToEval ( eval ,  conf )  ;  eval . setVariable ( "nominalTime" ,  make2Digits ( nominalTime . getHours (  )  )  + ":" + make2Digits ( nominalTime . getMinutes (  )  )  + "Z" )  ;  eval . setVariable ( "actualTime" ,  make2Digits ( Calendar . getInstance ( TimeZone . getTimeZone ( "UTC" )  )  . get ( Calendar . HOUR_OF_DAY )  )  + ":" + make2Digits ( Calendar . getInstance ( TimeZone . getTimeZone ( "UTC" )  )  . get ( Calendar . MINUTE )  )  + "Z" )  ;  eval . setVariable ( "defaultTimeout" ,  CoordELFunctions . DEFAULT_TIMEOUT )  ;  setNominalTime ( eval ,  nominalTime )  ;  configureEvaluator ( eval )  ;  eval . evaluate (  )  ;  }
public class SentenceFactory { private static SentenceFactory instance ;  private Map < String , Class < ? extends SentenceParser >  >  parsers ;  public static SentenceFactory getInstance (  )  { if  ( instance == null )  { instance = new SentenceFactory (  )  ;  } return instance ;  } public Sentence createParserImpl ( String sid ,  Object param )  { SentenceId sentenceId = SentenceId . parseStr ( sid )  ;  if  ( hasParser ( sentenceId . toString (  )  )  )  { try { Class < ? extends SentenceParser >  parserClass = parsers . get ( sentenceId . toString (  )  )  ;  Constructor < ? extends SentenceParser >  constructor = parserClass . getConstructor ( String . class ,  Object . class )  ;  return constructor . newInstance ( sid ,  param )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } } else { throw new IllegalArgumentException ( "No parser registered for sentence type: " + sentenceId . toString (  )  )  ;  } } public void unregisterParser ( Class < ? extends SentenceParser >  parser )  { parsers . remove ( parser . getSimpleName (  )  )  ;  } public boolean hasParser ( String type )  { return parsers . containsKey ( type )  ;  } public List < String >  listParsers (  )  { return new ArrayList <  >  ( parsers . keySet (  )  )  ;  } public void reset (  )  { parsers . clear (  )  ;  } public void registerParser ( String type ,  Class < ? extends SentenceParser >  parser )  { parsers . put ( type ,  parser )  ;  } public Sentence createParser ( String arg0 ,  String arg1 )  { try { return createParserImpl ( arg0 ,  arg1 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } } }
TimestampService function (  )  { try { TimestampService loc0 = new TimestampServiceImpl (  )  ;  return loc0 ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  return null ;  } }
void function ( String arg0 )  { try { getLastVersion (  )  ;  lastVersion = arg0 ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
void function ( InputStream arg0 )  { _buffer = new byte [ 4096 ]  ;  getSerializerFactory (  )  . reset (  )  ;  Reader loc0 = new InputStreamReader ( arg0 ,  "UTF-8" )  ;  setInputStream ( loc0 )  ;  }
void function ( boolean arg0 )  { verifyProofOfPossession = arg0 ;  }
PolicyPublisher function (  )  { PolicyPublisher loc0 = policyPublisher ;  return loc0 ;  }
String function (  )  { return options ;  }
void function ( ARDrone arg0 ,  CommandManager arg1 )  { drone = arg0 ;  cmd = arg1 ;  spinSpeed = 2 ;  speed = 10 ;  spin90Speed = 50 ;  TAG = "GMC" ;  spin90Time = 3000 ;  batLvl = 0 ;  threadTimer = 0 ;  hoverTime = 2000 ;  spinTime = 50 ;  ourInstance = new GeneralMotorCon (  )  ;  }
void function ( T arg0 ,  String arg1 ,  BitmapDisplayConfig arg2 )  { bitmapSetter . setBitmap ( arg0 ,  null )  ;  onPreLoad ( arg0 ,  arg1 ,  arg2 )  ;  Drawable loc0 = getDrawable ( arg0 )  ;  if  ( loc0 != null )  { setDrawable ( arg0 ,  loc0 )  ;  } else { onLoadStarted ( arg0 ,  arg1 ,  arg2 )  ;  try { Bitmap loc1 = BitmapLoader . loadBitmap ( arg1 ,  arg2 )  ;  onLoadCompleted ( arg0 ,  arg1 ,  loc1 ,  arg2 ,  BitmapLoadFrom . NETWORK )  ;  setBitmap ( arg0 ,  loc1 )  ;  } catch  ( Throwable loc2 )  { onLoadFailed ( arg0 ,  arg1 ,  loc0 )  ;  } } }
void function ( ErrorQueue loc0 ,  Report loc1 )  { loc1 . eq = loc0 ;  }
void function ( Stylesheet arg0 ,  Object arg1 )  { arg0 . stylesheet = this ;  }
Auth function (  )  { Auth loc0 = this . auth ;  return loc0 ;  }
public static void function ( JSONObject arg0 ,  String arg1 ,  Object arg2 )  { try { arg0 . put ( arg1 ,  arg2 )  ;  } catch  ( JSONException loc0 )  { LOG . warn ( "Error putting name/value pair in JSON object: " + loc0 . getMessage (  )  )  ;  } }
boolean function ( View arg0 ,  AccessibilityEvent arg1 )  { IMPL . dispatchPopulateAccessibilityEvent ( DEFAULT_DELEGATE ,  arg0 ,  arg1 )  ;  return true ;  }
public String function ( String arg0 )  { int loc0 = Integer . parseInt ( arg0 ,  16 )  ;  int loc1 = loc0  >  >  16 ;  int loc2 =  ( loc0  >  >  8 )  & 0xFF ;  int loc3 = loc0 & 0xFF ;  Color loc4 = new Color ( loc1 ,  loc2 ,  loc3 )  ;  return getClosestNamedColor ( loc4 )  ;  }
public Schema function ( IndexInfo arg0 ,  Plan arg1 ,  Plan arg2 ,  String arg3 )  { Schema loc0 = arg1 . schema (  )  ;  Schema loc1 = arg2 . schema (  )  ;  Schema loc2 = new Schema (  )  ;  loc2 . addAll ( loc0 )  ;  loc2 . addAll ( loc1 )  ;  loc2 . add ( arg0 . fieldType ( arg3 )  ,  arg3 )  ;  return loc2 ;  } This method takes in an IndexInfo object ,  two Plan objects ,  and a String as arguments ,  and returns a Schema object .  The method first obtains the schema of the two Plan objects and creates a new Schema object .  Then ,  it adds all the attributes from both schemas to the new Schema object and adds the attribute specified by the joinfield argument with its corresponding data type obtained from the IndexInfo object .  Finally ,  it returns the resulting Schema object . 
Long function (  )  { Long loc0 = arg0 . getTotalElapsedSeconds (  )  ;  Long loc1 = arg0 . getTotalElapsedMinutes (  )  ;  List < TestResultDTO >  loc2 = arg0 . getTestResultLst (  )  ;  String loc3 = arg0 . getStartTime (  )  ;  String loc4 = arg0 . getEndTime (  )  ;  Long batchId = arg0 . getBatchId (  )  ;  String loc5 = arg0 . getBatchStatus (  )  ;  return batchId ;  }
void function ( String arg0 ,  String arg1 ,  Double arg2 )  { links . set ( arg0 ,  arg1 ,  arg2 )  ;  }
void function ( String arg0 ,  int arg1 )  { try { addField ( arg0 ,  Schema . VARCHAR ,  arg1 )  ;  } catch  ( Exception e )  { } }
void function ( Collection < ? >  arg0 ,  String arg1 )  { try { Assert . notEmpty ( arg0 ,  "Collection must have elements" )  ;  } catch  ( IllegalArgumentException loc0 )  { throw new IllegalArgumentException ( arg1 ,  loc0 )  ;  } }
import org . mockito . Mockito ;  public class S3AUnderFileSystemTest { String BUCKET_PREFIX = "prefix" ;  String DST = "dst" ;  String SRC = "src" ;  String ACCOUNT_OWNER = "account owner" ;  String PATH = "path" ;  TransferManager loc0 ;  S3AUnderFileSystem loc1 ;  String BUCKET_NAME = "bucket" ;  short BUCKET_MODE = 0 ;  AmazonS3Client loc2 ;  public void function (  )  { TransferManager arg0 = Mockito . mock ( TransferManager . class )  ;  AmazonS3Client arg1 = Mockito . mock ( AmazonS3Client . class )  ;  loc1 = new S3AUnderFileSystem ( new AlluxioURI ( "srini_string" )  ,  arg1 ,  BUCKET_NAME ,  BUCKET_PREFIX ,  BUCKET_MODE ,  ACCOUNT_OWNER ,  arg0 )  ;  } void renameOnAmazonClientException (  )  { } void deleteNonRecursiveOnAmazonClientException (  )  { } void deleteRecursiveOnAmazonClientException (  )  { } }
class Mapping { long qStart ,  tStop ,  tStart ;  int blockSize ;  long getQStart (  )  { return qStart ;  } long getTStart (  )  { return tStart ;  } long getTStop (  )  { return tStop ;  } void function (  )  { try { int loc0 = 0 ;  int loc1 = 0 ;  int loc2 = 0 ;  if  ( arg0 != null )  { loc0 = arg0 . length (  )  ;  } if  ( arg1 != null )  { loc1 = arg1 . length (  )  ;  } if  ( arg2 != null )  { loc2 = arg2 . length (  )  ;  } blockSize = Math . max ( Math . max ( loc0 ,  loc1 )  ,  loc2 )  ;  } catch  ( Exception e )  { } } }
boolean function ( CSSName arg0 )  { PropertyDeclaration loc0 = propertyByName ( arg0 )  ;  return loc0 != null && loc0 . getValue (  )  != null ;  }
boolean function ( SPResponse spResponse )  { Integer loc0 = spResponse . getErrorCode (  )  ;  return !loc0 . equals ( 0 )  ;  }
public String function ( String arg0 ,  int arg1 )  { int status = -1 ;  int INFINITY = Integer . MAX_VALUE ;  HttpServletRequest request = null ;  URI base = null ;  HttpServletResponse response = null ;  try { OutputStream outputStream = response . getOutputStream (  )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } return "someValue" ;  }
public String function (  )  { StringBuilder sb = new StringBuilder (  )  ;  try { for  ( String loc0 : log )  { sb . append ( loc0 )  ;  sb . append ( "\n" )  ;  } return sb . toString (  )  . trim (  )  ;  } catch  ( Exception e )  { System . out . println ( "An exception occurred: " + e . getMessage (  )  )  ;  return "" ;  } }
int function ( int arg0 ,  int arg1 )  { int loc0 ,  loc1 ;  try { loc0 = arg1 * 8 ;  loc1 = loc0 + arg0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  loc1 = 0 ;  } return loc1 ;  }
void function ( Scan arg0 ,  Constant arg1 )  { if  ( arg0 . hasNext (  )  )  { arg0 . next (  )  ;  Constant loc0 = arg0 . getVal ( fldname )  ;  if  ( loc0 . compareTo ( val )   >  0 )  { val = loc0 ;  } } }
boolean function (  )  { try { if  ( StringUtils . contains ( arg0 ,  arg1 )  )  { return true ;  } } catch  ( Exception e )  { System . out . println ( "Error: " + e . getMessage (  )  )  ;  } return false ;  }
public U2FService function ( Object arg0 ,  Object arg1 )  { synchronized  ( U2FService . class )  { U2FService loc0 = null ;  if  ( u2FService == null )  { loc0 = new U2FService (  )  ;  u2FService = loc0 ;  } else { loc0 = u2FService ;  } return loc0 ;  } }
private ResponseEntity < DishCollection >  function (  @ PathVariable String arg0 )  { try { log . debug ( "Getting dish collection with id {}" ,  arg0 )  ;  Optional < DishCollection >  loc0 = dishCollectionService . findOne ( arg0 )  ;  return loc0 . map ( dishCollection - >  ResponseEntity . ok (  )  . body ( dishCollection )  )   . orElse ( ResponseEntity . notFound (  )  . build (  )  )  ;  } catch  ( Exception e )  { log . error ( "Error getting dish collection with id {}" ,  arg0 ,  e )  ;  return ResponseEntity . status ( HttpStatus . INTERNAL_SERVER_ERROR )  . build (  )  ;  } }
public static Script createPayToPubkeyScriptSig ( TransactionSignature signature ,  ECKey pubkey )  { byte [  ]  sigBytes = signature . encodeToBitcoin (  )  ;  byte [  ]  pubkeyBytes = pubkey . getPubKey (  )  ;  ScriptBuilder builder = new ScriptBuilder (  )  ;  builder . data ( sigBytes )  ;  builder . data ( pubkeyBytes )  ;  Script script = builder . build (  )  ;  return script ;  }
void function (  )  { try { RegisteredClient mockClient = Mockito . mock ( RegisteredClient . class )  ;  ServerConfiguration mockServerConfig = Mockito . mock ( ServerConfiguration . class )  ;  String issuer = "https://www . example . com/" ;  StaticClientConfigurationService service = new StaticClientConfigurationService (  )  ;  Mockito . when ( mockServerConfig . getIssuer (  )  )  . thenReturn ( null )  ;  ClientConfiguration result = service . getClientConfiguration ( mockClient ,  mockServerConfig )  ;  assertThat ( result . getIssuer (  )  )  . is ( nullValue (  )  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
Builder function ( Builder arg0 ,  String arg1 )  { return arg0 . id ( arg1 )  ;  }
void function ( boolean arg0 )  { accountNonExpired = arg0 ;  }
String function ( Object arg0 )  { Element loc0 =  ( Element )  arg0 ;  String loc1 = loc0 . getAttribute ( "lang" )  ;  return loc1 ;  }
public AbstractAction function (  )  { ProjectActions loc0 = ProjectActions . getInstance (  )  ;  return loc0 . redoAction ;  }
Collection < Device >  function (  )  { Collection < Device >  loc0 ;  try { loc0 = devices . values (  )  ;  } catch  ( Exception loc1 )  { loc0 = null ;  } return loc0 ;  }
public boolean function (  )  { boolean loc0 = isAccountNonLocked (  )  ;  return loc0 ;  }
List < Station >  function (  )  { List < Station >  loc0 = new ArrayList <  >  (  )  ;  try { loc0 = Arrays . asList ( stationDao . find (  )  )  ;  } catch  ( Exception loc1 )  { } return loc0 ;  }
void function  ( Object arg0 ,  Object arg1 )  { for  ( Object loc0 : pins )  { buffers . get ( loc0 )  . transactionComplete (  )  ;  } pins . clear (  )  ;  bufferMgr = SimpleDB . bufferMgr (  )  ;  }
void function ( boolean arg0 ,  ServletContext arg1 ,  String arg2 ,  String arg3 )  { if  ( arg0 && arg1 != null )  { DAVLogger loc0 = new DAVLogger (  )  ;  loc0 . debug = true ;  loc0 . context = arg1 ;  loc0 . servletName = arg2 ;  loc0 . log ( "Debug message: " + arg3 )  ;  } }
public class RuntimeManager { public void function (  )  { boolean loc0 = settings . getBoolean ( Keys . git . serveRepositories ,  true )  ;  int loc1 = settings . getInteger ( Keys . git . serveOverHTTP ,  80 )  ;  } }
void function ( byte [  ]  arg0 )  { try { addByteArray ( arg0 )  ;  } catch  ( IOException loc0 )  { } }
HashMap < String ,  GeneticProfile >  function ( boolean arg0 ,  boolean arg1 )  { HashMap < String ,  GeneticProfile >  locMap = new HashMap <  >  (  )  ;  try { locMap = getDefaultGeneticProfileMap ( arg0 ,  arg1 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return locMap ;  }
String function (  )  { String loc0 = executionEndDateTime ;  return loc0 ;  }
void function (  )  { try { loc0 = "RATTM , 11 , 25 . 3 , 13 . 7 , T , 7 . 0 , 20 . 0 , T , 10 . 1 , 20 . 2 , N , NAME , Q ,  , 175550 . 24 , A*34" ;  TTMParser ttm = new TTMParser ( loc0 )  ;  assertEquals ( ttm . getNumber (  )  ,  11 )  ;  } catch  ( Exception loc1 )  { fail ( "Exception thrown during test: " + loc1 . getMessage (  )  )  ;  } }
Mode function ( Mode arg0 ,  Mode arg1 )  { Mode loc0 = arg0 . getUMask (  )  ;  Bits loc1 = loc0 . not (  )  ;  Bits loc2 = arg1 . and ( loc1 )  ;  Mode loc3 = arg0 . applyUMask ( loc2 )  ;  return loc3 ;  }
import java . util . Comparator ;  public class ReceiverLossListEntry { long k = 2 ;  long sequenceNumber ;  long lastFeedbackTime ;  public long getK (  )  { return k ;  } public int hashCode (  )  { return Long . hashCode ( sequenceNumber )  ;  } public boolean equals ( Object obj )  { if  ( obj == this )  { return true ;  } if  ( ! ( obj instanceof ReceiverLossListEntry )  )  { return false ;  } ReceiverLossListEntry other =  ( ReceiverLossListEntry )  obj ;  return sequenceNumber == other . sequenceNumber ;  } public String toString (  )  { return "ReceiverLossListEntry{" + "k=" + k + " ,  sequenceNumber=" + sequenceNumber + " ,  lastFeedbackTime=" + lastFeedbackTime + '}' ;  } public long getLastFeedbackTime (  )  { return lastFeedbackTime ;  } public void feedback (  )  { lastFeedbackTime = System . currentTimeMillis (  )  ;  } public long getSequenceNumber (  )  { return sequenceNumber ;  } public static void function ( ReceiverLossListEntry [  ]  arg0 )  { Comparator < ReceiverLossListEntry >  comparator = Comparator . comparingLong ( ReceiverLossListEntry::getSequenceNumber )  ;  Arrays . sort ( arg0 ,  comparator )  ;  } }
void function ( long arg0 ,  TimeUnit arg1 )  { if  ( arg1 == null )  { throw new IllegalArgumentException ( "srini_string" )  ;  } poolLock . lock (  )  ;  try { idleConnHandler . closeIdleConnections ( arg1 . toMillis ( arg0 )  )  ;  } finally { poolLock . unlock (  )  ;  } }
void function ( BinaryBytesEvent arg0 ,  SomeListener arg1 )  { ParserEventType loc0 = arg0 . getType (  )  ;  byte [  ]  loc1 = arg0 . data ;  arg1 . processBinaryBytes ( loc0 ,  loc1 )  ;  }
public void function (  )  { TTMParser loc0 = new TTMParser (  )  ;  try { loc0 . parse ( EXAMPLE )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } double loc1 = 10 . 0 ;  loc0 . setBearing ( loc1 )  ;  double loc2 = loc0 . getBearing (  )  ;  assertEquals ( loc1 ,  loc2 ,  0 . 01 )  ;  }
int function ( int arg0 )  { boolean loc0 = plugins . remove ( getByIndex ( arg0 )  )  ;  return loc0 ? 1 : 0 ;  }
Map < Class < ? extends Annotation >  ,  Collection < Class < ? >  >  >  function ( Collection < String >  arg0 ,  List < Class < ? extends Annotation >  >  arg1 ,  ClassLoader arg2 )  { Map < Class < ? extends Annotation >  ,  Collection < Class < ? >  >  >  result = new HashMap <  >  (  )  ;  try { ClasspathScanner scanner = getClasspathScanner (  )  ;  Map < Class < ? extends Annotation >  ,  Collection < Class < ? >  >  >  classes = scanner . findClassesInternal ( arg0 ,  arg1 ,  arg2 )  ;  for  ( Map . Entry < Class < ? extends Annotation >  ,  Collection < Class < ? >  >  >  entry : classes . entrySet (  )  )  { Class < ? extends Annotation >  annotationClass = entry . getKey (  )  ;  Collection < Class < ? >  >  annotatedClasses = entry . getValue (  )  ;  result . put ( annotationClass ,  annotatedClasses )  ;  } } catch  ( Exception e )  { } return result ;  }
void function ( java . io . ObjectOutputStream arg0 )  throws IOException { arg0 . defaultWriteObject (  )  ;  arg0 . writeInt ( longs . length (  )  )  ;  for  ( int loc0 = 0 ;  loc0  <  longs . length (  )  ;  loc0 ++  )  { arg0 . writeDouble ( get ( loc0 )  )  ;  } } In this method ,  we first call the defaultWriteObject (  )  method to serialize the non-static and non-transient fields of the class .  Then ,  we write the length of the AtomicDoubleArray to the ObjectOutputStream using the writeInt (  )  method .  Finally ,  we loop through the array and write each double value to the stream using the writeDouble (  )  method .  There is no exception handling in this method ,  so any IOExceptions that occur during serialization will be thrown to the calling method . 
public void function ( Date arg0 )  { try { fetcherEndTimeStamp = arg0 ;  } catch  ( Exception e )  { } }
String function (  )  { BaseEngine loc0 = new BaseEngine (  )  ;  String loc1 = loc0 . user ;  return loc1 ;  } Note: It is generally not recommended to call methods without exception handling ,  as it can lead to unexpected errors and make the code difficult to debug . 
import java . io . IOException ;  import java . io . File ;  import java . io . FileOutputStream ;  class UnderFileSystemUtils { void mkdirIfNotExists ( final String path )  { File directory = new File ( path )  ;  if  ( !directory . exists (  )  )  { directory . mkdirs (  )  ;  } } void deleteDir ( final String path )  { File directory = new File ( path )  ;  if  ( directory . exists (  )  )  { File [  ]  files = directory . listFiles (  )  ;  if  ( files != null )  { for  ( File file : files )  { if  ( file . isDirectory (  )  )  { deleteDir ( file . getAbsolutePath (  )  )  ;  } else { file . delete (  )  ;  } } } directory . delete (  )  ;  } } void function ( final String arg0 )  throws IOException { FileOutputStream loc0 = new FileOutputStream ( arg0 )  ;  loc0 . close (  )  ;  } }
void function ( Object arg0 ,  Object arg1 )  { if  ( mManager != null )  { mManager . scrollToPosition ( 0 )  ;  } else if  ( listview != null )  { listview . scrollToPosition ( 0 )  ;  } notifyDataSetChanged (  )  ;  }
BufferedImage function (  )  { BufferedImage loc0 = null ;  try { loc0 = coverArtImage . getLargeThumbnail (  )  ;  if  ( loc0 == null )  { throw new IOException ( "Failed to get large thumbnail" )  ;  } loc0 = ImageIO . read ( new ByteArrayInputStream ( ImageIOHelper . writeImage ( loc0 ,  "image/jpeg" )  )  )  ;  } catch  ( IOException loc1 )  { Popup . error ( "Get image" ,  "Failed to get image: " + loc1 . getMessage (  )  )  ;  } return loc0 ;  }
private CertificateInfo function (  )  { CertificateInfo loc0 = null ;  try { ObjectFactory objFactory = new ObjectFactory (  )  ;  CertificateChainInfo loc1 = objFactory . createCertificateChainInfo (  )  ;  loc0 = loc1 . getCertificates (  )  . get ( 0 )  ;  } catch  ( Exception loc2 )  { } return loc0 ;  }
public void function (  )  { try { SharedContext loc0 = panel . getSharedContext (  )  ;  } catch  ( Exception loc1 )  { } }
public static ApplicationManagementService function ( String arg0 ,  String arg1 )  { ApplicationManagementService loc0 = null ;  try { loc0 = ApplicationManagementServiceImpl . getInstance (  )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
public void function ( Object arg0 ,  Object arg1 )  { MemoryLocksService service =  ( MemoryLocksService )  arg0 ;  Instrumentation instr =  ( Instrumentation )  arg1 ;  service . init ( null )  ;  instr . remove ( service . INSTRUMENTATION_GROUP )  ;  service . locks . destroy (  )  ;  }
void function ( byte [  ]  arg0 )  { int loc0 = arg0 . length ;  ensureCapacity ( loc0 + 2 )  ;  put16 (  ( short )  loc0 )  ;  put ( arg0 )  ;  }
public int function ( long arg0 )  { if  ( arg0  <   ( 1L  <  <  7 )  )  { return 1 ;  } else if  ( arg0  <   ( 1L  <  <  14 )  )  { return 2 ;  } else if  ( arg0  <   ( 1L  <  <  21 )  )  { return 3 ;  } else if  ( arg0  <   ( 1L  <  <  28 )  )  { return 4 ;  } else { return 5 ;  } }
public class CoordinatorEngineService { public void init ( Services services )  { } public Class < ? extends Service >  getInterface (  )  { return null ;  } public CoordinatorEngine getSystemCoordinatorEngine (  )  { return null ;  } public void destroy (  )  { } public String function ( String arg0 ,  String arg1 )  { String result = "" ;  try { CoordinatorEngine loc0 = new CoordinatorEngine ( arg0 ,  arg1 )  ;  result = "Return a Coordinator engine . " ;  } catch  ( Exception e )  { result = "Failed to create a Coordinator engine: " + e . getMessage (  )  ;  } return result ;  } }
long function ( String amount )  { try { checkArgument ( amount != null )  ;  checkArgument ( !amount . isEmpty (  )  )  ;  Coin loc0 = Coin . parseCoin ( amount ,  FRIENDLY_FORMAT )  ;  Coin loc1 = loc0 . multiply ( CENT )  ;  long loc2 = loc1 . compareTo ( ZERO )   >  0 ? loc1 . divide ( SATOSHI )  : loc1 . negate (  )  . divide ( SATOSHI )  ;  return loc2 ;  } catch  ( IllegalArgumentException e )  { throw new IllegalArgumentException ( "Invalid amount: " + amount )  ;  } }
import java . awt . Desktop ;  import java . net . URI ;  import java . net . URL ;  import java . util . logging . Logger ;  public class StartBrowser { private static final Logger LOG = Logger . getLogger ( StartBrowser . class . getName (  )  )  ;  public void function ( URL arg0 )  { try { Desktop desktop = Desktop . isDesktopSupported (  )  ? Desktop . getDesktop (  )  : null ;  if  ( desktop != null && desktop . isSupported ( Desktop . Action . BROWSE )  )  { desktop . browse ( arg0 . toURI (  )  )  ;  } } catch  ( Exception loc0 )  { LOG . severe ( "An error occurred while trying to open the URL: " + arg0 . toString (  )  + "\n" + loc0 . getMessage (  )  )  ;  } } public void openUrl ( String url )  { try { function ( new URL ( url )  )  ;  } catch  ( Exception loc1 )  { LOG . severe ( "An error occurred while trying to open the URL: " + url + "\n" + loc1 . getMessage (  )  )  ;  } } }
Position function ( TypeObject arg0 )  { Position loc0 ;  boolean loc1 ;  loc0 = arg0 . position (  )  ;  loc1 = arg0 . compilerGenerated (  )  ;  if  ( loc0 == null )  { loc0 = new Position ( MEMB ,  STMT ,  TYPE ,  FILE )  ;  arg0 . position ( loc0 )  ;  arg0 . compilerGenerated ( true )  ;  } return loc0 ;  }
Integer function ( SPResponse obj )  { Integer loc0 = obj . errorCode ;  return loc0 ;  }
void function ( int arg0 )  { int loc0 = arg0 ;  this . tokenHash = loc0 ;  }
DiffBuilder function ( Object arg0 )  { Source loc0 = Input . from ( arg0 )  . build (  )  ;  return new DiffBuilder (  )   . ignoreComments (  )   . withNodeMatcher ( nodeMatcher )   . withNamespaceContext ( namespaceContext )   . withAttributeFilter ( attributeFilter )   . withNodeFilter ( nodeFilter )   . withComparisonListeners ( comparisonListeners . toArray ( new ComparisonListener [ comparisonListeners . size (  )  ]  )  )   . withDifferenceListeners ( differenceListeners . toArray ( new ComparisonListener [ differenceListeners . size (  )  ]  )  )   . withDifferenceEvaluator ( differenceEvaluator )   . withComparisonController ( comparisonController )   . checkForIdentical (  )   . checkForSimilar (  )   . normalizeWhitespace (  )   . compare ( loc0 )   . getSource ( loc0 )  ;  }
public String function ( String arg0 )  { String loc0 = null ;  try { SatelliteInfo satelliteInfo = new SatelliteInfo (  )  ;  satelliteInfo . setId ( arg0 )  ;  loc0 = satelliteInfo . getId (  )  ;  } catch  ( Exception e )  { System . out . println ( "Error occurred: " + e . getMessage (  )  )  ;  } return loc0 ;  }
public class AbstractObservable { MessageObserver incomingObserver ;  public void function ( EndpointInfo arg0 ,  QName arg1 ,  Bus arg2 )  { try { Object loc0 = getTargetReference ( arg0 ,  arg1 ,  arg2 )  ;  } catch  ( Exception loc1 )  { getLogger (  )  . log ( Level . WARNING ,  "Failed to get target reference" ,  loc1 )  ;  } } private Object getTargetReference ( EndpointInfo endpointInfo ,  QName qName ,  Bus bus )  throws Exception { } public Logger getLogger (  )  { } public MessageObserver getMessageObserver (  )  { } public void setMessageObserver ( MessageObserver observer )  { } public void activate (  )  { } public void deactivate (  )  { } }
RoleList function (  )  { try { RoleList loc0 = new RoleList (  )  ;  return loc0 ;  } catch  ( Exception loc1 )  { return null ;  } }
import java . lang . reflect . * ;  class PrivilegedAccessor { } class MyClass { private int myField ;  public MyClass ( int value )  { this . myField = value ;  } public int getMyField (  )  { return myField ;  } } class Main { public static void main ( String [  ]  args )  { MyClass myObj = new MyClass ( 42 )  ;  PrivilegedAccessor accessor = new PrivilegedAccessor (  )  ;  try { Field field =  ( Field )  accessor . getClassImpl ( MyClass . class ,  "myField" )  ;  field . setAccessible ( true )  ;  field . set ( myObj ,  100 )  ;  System . out . println ( "New value of myField: " + myObj . getMyField (  )  )  ;  } catch  ( Exception e )  { System . out . println ( "Error: " + e . getMessage (  )  )  ;  } } }
byte [  ]  function ( byte [  ]  arg0 ,  byte [  ]  arg1 ,  Sha256Hash arg2 ,  int arg3 )  { byte [  ]  loc0 = new byte [ arg0 . length + arg1 . length + 10 ]  ;  System . arraycopy ( arg0 ,  0 ,  loc0 ,  0 ,  arg0 . length )  ;  System . arraycopy ( arg1 ,  0 ,  loc0 ,  arg0 . length ,  arg1 . length )  ;  loc0 [ loc0 . length - 10 ]  =  ( byte )   ( arg2 . hashCode (  )   >  >  0 )  ;  loc0 [ loc0 . length - 9 ]  =  ( byte )   ( arg2 . hashCode (  )   >  >  8 )  ;  loc0 [ loc0 . length - 8 ]  =  ( byte )   ( arg2 . hashCode (  )   >  >  16 )  ;  loc0 [ loc0 . length - 7 ]  =  ( byte )   ( arg2 . hashCode (  )   >  >  24 )  ;  loc0 [ loc0 . length - 6 ]  =  ( byte )   ( arg3  >  >  0 )  ;  loc0 [ loc0 . length - 5 ]  =  ( byte )   ( arg3  >  >  8 )  ;  loc0 [ loc0 . length - 4 ]  =  ( byte )   ( arg3  >  >  16 )  ;  loc0 [ loc0 . length - 3 ]  =  ( byte )   ( arg3  >  >  24 )  ;  loc0 [ loc0 . length - 2 ]  = 0x01 ;  loc0 [ loc0 . length - 1 ]  =  ( byte )  0xFF ;  return loc0 ;  }
boolean function ( Object arg0 )  { Element loc0 =  ( Element )  arg0 ;  return ui . isActive ( loc0 )  ;  }
public void function ( String arg0 )  { try { OutputStreamWriter loc0 = processWriter ;  loc0 . write ( arg0 + "\n" )  ;  loc0 . flush (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function ( ContextFactory arg0 )  { try { dim . attachTo ( arg0 )  ;  } catch  ( Exception loc0 )  { } }
void function ( Object arg0 ,  Object arg1 )  { loc0 = arg0 . toString (  )  ;  loc1 = arg1 . toString (  )  ;  credential = new ClientCredential ( loc0 ,  loc1 )  ;  setIdentity ( new ClientIdentity ( credential )  )  ;  if  ( !checkExpireTime (  )  )  { remove ( "session" )  ;  remove ( "permission" )  ;  remove ( "status" )  ;  remove ( "roles" )  ;  remove ( "attributes" )  ;  remove ( "email" )  ;  remove ( "username" )  ;  remove ( "password" )  ;  json = new JSONObject (  )  ;  json . put ( "authenticated" ,  false )  ;  parent . put ( "authentication" ,  json )  ;  } toString (  )  ;  }
public static boolean function ( String arg0 ,  String arg1 )  { String loc0 = getUserRepoPrefix (  )  ;  String loc1 = getUserNameFromRepoPath ( arg0 )  ;  return arg0 . startsWith ( loc0 + loc1 + "/" + arg1 )  ;  }
boolean function ( String arg0 )  { boolean loc0 = false ;  try { loc0 = mIPv6Pattern . matcher ( arg0 )  . matches (  )  ;  } catch  ( Exception loc1 )  { Log . loc0 ( "Error while checking if input is a valid IPv6 address" ,  loc1 . getMessage (  )  ,  loc1 )  ;  } return loc0 ;  }
public void function ( Strength arg0 ,  Strength arg1 )  { try { new MapMaker (  )  . setKeyStrength ( Strength . WEAK )  ;  } catch  ( Exception e )  { } }
import org . ejml . data . DenseMatrix64F ;  import org . ejml . ops . RandomMatrices ;  import java . util . Random ;  public class TestHessenbergSimilarDecomposition_D64 { private Random rand = new Random ( 5745784 )  ;  void function (  )  { try { DenseMatrix64F arg0 = RandomMatrices . createRandom ( 5 ,  5 ,  rand )  ;  checkItAll ( arg0 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } } void checkItAll ( DenseMatrix64F arg0 )  { DenseMatrix64F loc0 = new DenseMatrix64F ( arg0 )  ;  HessenbergSimilarDecomposition_D64 < DenseMatrix64F >  loc1 = new HessenbergSimilarDecomposition_D64 <  >  (  )  ;  assertTrue ( loc1 . decompose ( loc0 )  )  ;  DenseMatrix64F loc2 = loc1 . getH ( null )  ;  DenseMatrix64F loc3 = loc1 . getQ ( null ,  false )  ;  DenseMatrix64F loc4 = new DenseMatrix64F ( arg0 . numRows ,  arg0 . numCols )  ;  CommonOps . mult ( loc3 ,  loc2 ,  loc4 )  ;  assertTrue ( MatrixFeatures . isIdentical ( arg0 ,  loc4 ,  1e-8 )  )  ;  } void testH (  )  { DenseMatrix64F loc0 = RandomMatrices . createRandom ( 5 ,  5 ,  rand )  ;  HessenbergSimilarDecomposition_D64 < DenseMatrix64F >  loc1 = new HessenbergSimilarDecomposition_D64 <  >  (  )  ;  assertTrue ( loc1 . decompose ( loc0 )  )  ;  DenseMatrix64F loc2 = loc1 . getH ( null )  ;  assertTrue ( MatrixFeatures . isUpperTriangle ( loc2 ,  1e-8 )  )  ;  } void testHouseholderVectors (  )  { DenseMatrix64F loc0 = RandomMatrices . createRandom ( 5 ,  5 ,  rand )  ;  HessenbergSimilarDecomposition_D64 < DenseMatrix64F >  loc1 = new HessenbergSimilarDecomposition_D64 <  >  (  )  ;  assertTrue ( loc1 . decompose ( loc0 )  )  ;  DenseMatrix64F loc2 = loc1 . getQ ( null ,  false )  ;  DenseMatrix64F loc3 = new DenseMatrix64F ( 5 ,  5 )  ;  CommonOps . multTransB ( loc2 ,  loc2 ,  loc3 )  ;  assertTrue ( MatrixFeatures . isIdentity ( loc3 ,  1e-8 )  )  ;  } void testInputUnmodified (  )  { DenseMatrix64F loc0 = RandomMatrices . createRandom ( 5 ,  5 ,  rand )  ;  DenseMatrix64F loc1 = new DenseMatrix64F ( loc0 )  ;  HessenbergSimilarDecomposition_D64 < DenseMatrix64F >  loc2 = new HessenbergSimilarDecomposition_D64 <  >  (  )  ;  assertTrue ( loc2 . decompose ( loc0 )  )  ;  assertTrue ( MatrixFeatures . isIdentical ( loc0 ,  loc1 ,  1e-8 )  )  ;  } }
String function ( String arg0 )  { String loc0 = "" ;  if  ( pmids != null && !pmids . isEmpty (  )  )  { String [  ]  pmidArray = pmids . split ( " , " )  ;  for  ( String pmid : pmidArray )  { loc0 += pmid . trim (  )  + "\n" ;  } } return loc0 ;  }
ResultEntry function ( int arg0 )  { try { ResultEntry loc0 = log . get ( arg0 )  ;  return loc0 ;  } catch  ( IndexOutOfBoundsException loc1 )  { return null ;  } }
ConfigurationKey function ( String arg0 ,  String arg1 ,  String arg2 ,  String arg3 )  { ConfigurationKeyImpl loc0 = new ConfigurationKeyImpl ( arg0 ,  arg1 ,  arg2 ,  arg3 )  ;  return loc0 ;  }
String function ( Scan arg0 )  { MaxFn loc0 = new MaxFn (  )  ;  loc0 . processFirst ( arg0 )  ;  while  ( arg0 . hasNext (  )  )  { loc0 . processNext ( arg0 )  ;  } Constant loc1 = loc0 . value (  )  ;  return "maxof" + loc0 . fldname ;  }
long function (  )  { final long loc0 = System . currentTimeMillis (  )  ;  try { return loc0 - this . m_startTime ;  } catch  ( Exception e )  { return -1 ;  } }
void function (  )  { setUp (  )  ;  testGetMinutes (  )  ;  assertEquals ( 30 ,  time . getMinutes (  )  )  ;  }
Set < String >  function ( Jedis jedis )  { Set < String >  result = new HashSet < String >  (  )  ;  try { Set < String >  urlSet = jedis . keys ( urlSetKey ( "*" )  )  ;  for  ( String url : urlSet )  { String key = termCounterKey ( url )  ;  if  ( jedis . exists ( key )  )  { result . add ( key )  ;  } } } catch  ( Exception e )  { System . out . println ( "An error occurred while retrieving the TermCounter keys . " )  ;  e . printStackTrace (  )  ;  } return result ;  }
Site function ( String arg0 )  { log . debug ( "Getting site with id: {}" ,  arg0 )  ;  Site loc0 = siteRepository . findOne ( arg0 )  ;  return loc0 ;  }
public class Problem { ActionsFunction actionsFunction ;  StepCostFunction stepCostFunction ;  GoalTest goalTest ;  Object initialState ;  ResultFunction resultFunction ;  public Object getInitialState (  )  { return initialState ;  } public StepCostFunction getStepCostFunction (  )  { return stepCostFunction ;  } public ActionsFunction getActionsFunction (  )  { return actionsFunction ;  } public boolean isGoalState ( Object state )  { return goalTest . isGoalState ( state )  ;  } public GoalTest getGoalTest (  )  { return goalTest ;  } public void function (  )  { for  ( Object loc0 : actionsFunction . actions ( initialState )  )  { System . out . println ( loc0 . toString (  )  + ": " + actionsFunction . result ( initialState ,  loc0 )  )  ;  } } }
String function ( Date arg0 )  { String loc0 = "" ;  try { loc0 = timeAgoCss ( arg0 )  ;  } catch  ( Exception e )  { } return loc0 ;  }
public class InternalErrorHandler { public void function ( String arg0 )  { try { function ( arg0 )  ;  } catch  ( Exception loc0 )  { throw new Exception ( arg0 )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } finally { System . exit ( 0 )  ;  } } }
void function ( Object arg0 ,  Object arg1 ,  Object arg2 ,  Object arg3 ,  Object arg4 )  { try { TokenMapper . parentScope = 0 ;  TokenMapper . functionBracePositions = new ArrayList (  )  ;  TokenMapper . funcObjects = new ObjArray (  )  ;  TokenMapper . functionNum = 0 ;  TokenMapper . functionVarMappings = new ArrayList (  )  ;  TokenMapper . lastTokenCount = 0 ;  TokenMapper . replacedTokens = new ArrayList (  )  ;  } catch  ( Exception e )  { } }
void function ( HttpServletRequest arg0 )  { try { UserInfo user = new UserInfo (  )  ;  user . loginUser ( user . EMAIL ,  arg0 )  ;  HttpSession loc0 = arg0 . getSession ( false )  ;  if  ( loc0 != null )  { loc0 . removeAttribute ( "user" )  ;  } } catch  ( Exception loc1 )  { System . err . println ( "Error occurred while logging out the user: " + loc1 . getMessage (  )  )  ;  } }
public int function ( String arg0 )  { int loc0 ;  try { loc0 = Integer . parseInt ( arg0 )  ;  } catch  ( NumberFormatException loc1 )  { throw new IllegalArgumentException ( "Invalid MultiplicityRange bound string: " + loc1 . getMessage (  )  )  ;  } return loc0 ;  }
String function ( String arg0 )  { Class < ? >  loc0 = this . getTargetExtends (  )  ;  Class < ? >  [  ]  loc1 = this . getTargetImplements (  )  ;  String loc2 = this . mainMethodClassName ;  if  ( loc0 != null && loc0 . getName (  )  . equals ( arg0 )  )  { return loc0 . getName (  )  ;  } if  ( loc1 != null )  { for  ( Class < ? >  loc3 : loc1 )  { if  ( loc3 . getName (  )  . equals ( arg0 )  )  { return loc3 . getName (  )  ;  } } } if  ( loc2 != null && loc2 . equals ( arg0 )  )  { return loc2 ;  } return null ;  }
class RudpConstants { static byte ACK = getBitfield ( 6 )  ;  static UByte NUL_HEADER_LENGTH = new UByteImpl ( 8 )  ;  static UByte ACK_HEADER_LENGTH = new UByteImpl ( 8 )  ;  static UByte EACK_HEADER_LENGTH = new UByteImpl ( 8 )  ;  static byte NUL = getBitfield ( 3 )  ;  static byte RST = getBitfield ( 4 )  ;  static UByte SYN_HEADER_LENGTH = new UByteImpl ( 11 )  ;  static byte SYN = getBitfield ( 7 )  ;  static int CHECKSUM_INDEX = 12 ;  static byte EACK =  ( byte )  ( getBitfield ( 5 )  | getBitfield ( 6 )  )  ;  static UByte RST_HEADER_LENGTH = new UByteImpl ( 8 )  ;  static byte function ( int arg0 ,  int arg1 )  { assert arg0  > = 0 && arg0  < = 7 ;  assert arg1  > = 0 && arg1  < = 7 ;  final int shiftAmount = 7 - arg0 ;  final byte bit =  ( byte )  ( 1  <  <  shiftAmount )  ;  return  ( byte )  ( bit |  ( arg1  <  <   ( shiftAmount - 1 )  )  )  ;  } static byte getBitfield ( int bitIndex )  { return  ( byte )  ( 1  <  <   ( 7 - bitIndex )  )  ;  } }
Class function ( int arg0 ,  NotationName arg1 ,  Map < NotationName , Map < Integer , Class >  >  arg2 ,  String arg3 )  { NotationProviderFactory2 loc0 = NotationProviderFactory2 . getInstance (  )  ;  NotationProvider loc1 = loc0 . findNotation ( arg0 ,  arg1 )  ;  if  ( loc1 != null )  { return loc1 . getNotationProviderClass (  )  ;  } else { Map < Integer , Class >  loc2 = arg2 . get ( arg1 )  ;  if  ( loc2 != null )  { Class loc3 = loc2 . get ( arg0 )  ;  if  ( loc3 != null )  { return loc3 ;  } } } return null ;  }
void function ( byte [  ]  arg0 ,  String arg1 )  { try { FileOutputStream loc0 = new FileOutputStream ( arg1 )  ;  loc0 . write ( arg0 )  ;  loc0 . close (  )  ;  } catch  ( Exception loc1 )  { System . err . println ( "Error saving file's byte array: " + loc1 . toString (  )  )  ;  } System . out . println ( "File saved successfully . " )  ;  }
void function ( DirectedAcyclicGraphNode < T >  arg0 ,  DirectedAcyclicGraphNode < T >  arg1 )  { Preconditions . checkState ( arg0 . contains ( arg1 )  )  ;  arg0 . mChildren . remove ( arg1 )  ;  }
public Object function ( Object arg0 ,  String arg1 ,  Object [  ]  arg2 ,  Class < ? >  [  ]  arg3 )  { Class < ? >  clazz = getClass ( arg0 . getClass (  )  . getClassLoader (  )  ,  arg1 )  ;  Method method = getMethod ( arg0 ,  arg1 ,  arg3 )  ;  return method . invoke ( arg0 ,  arg2 )  ;  }
void function ( String arg0 ,  OperationSignature arg1 )  { if  ( !operations . containsKey ( arg1 )  )  { operations . put ( arg1 ,  new HashMap <  >  (  )  )  ;  } Map < String ,  OperationStats >  loc0 = operations . get ( arg1 )  ;  if  ( !loc0 . containsKey ( arg0 )  )  { loc0 . put ( arg0 ,  new OperationStats (  )  )  ;  } } This method adds an operation to the "operations" map of the "ClassStats" class .  It takes two arguments: "arg0" ,  which is the name of the operation to be added ,  and "arg1" ,  which is the signature of the operation .  The method first checks if the "operations" map already contains an entry with the given signature "arg1" .  If not ,  it creates a new entry with an empty HashMap as its value .  Then ,  the method retrieves the HashMap associated with the signature "arg1" and checks if it already contains an entry with the name "arg0" .  If not ,  it creates a new entry with an empty "OperationStats" object as its value .  Note that this method does not handle any exceptions that may be thrown during its execution . 
public static Script createCheckMultiSigScript ( byte [  ]  [  ]  signatures ,  byte [  ]  publicKeyBytes )  { checkArgument ( signatures . length  >  0 )  ;  checkArgument ( publicKeyBytes . length  >  0 )  ;  ScriptBuilder builder = new ScriptBuilder (  )  ;  builder . smallNum ( signatures . length )  ;  for  ( byte [  ]  signature : signatures )  { builder . data ( signature )  ;  } builder . smallNum ( 1 )  ;  builder . data ( publicKeyBytes )  ;  builder . smallNum ( signatures . length )  ;  builder . op ( OP_CHECKMULTISIG )  ;  return builder . build (  )  ;  }
void function (  )  { try { TimeTest obj = new TimeTest (  )  ;  int arg0 = 25 ;  // set invalid hour value obj . setHour ( arg0 )  ;  fail ( "Expected an IllegalArgumentException to be thrown" )  ;  } catch  ( IllegalArgumentException loc0 )  { } catch  ( Exception loc1 )  { fail ( "Unexpected exception thrown: " + loc1 . getMessage (  )  )  ;  } }
private void function ( TypedItem arg0 ,  String arg1 ,  String arg2 ,  boolean arg3 )  { String loc0 = "If using directly ,  consider using OwnedItem instead" ;  Tag loc1 = new Tag (  )  ;  loc1 . setKey ( "deprecated" )  ;  loc1 . setValue ( loc0 )  ;  addTag ( arg0 . getKey (  )  ,  loc1 )  ;  Tag loc2 = new Tag (  )  ;  loc2 . setKey ( arg1 )  ;  loc2 . setValue ( arg2 )  ;  addTag ( arg0 . getKey (  )  ,  loc2 )  ;  if  ( arg3 )  { putItemByTag ( arg0 ,  loc2 )  ;  } }
void function (  )  { try { RPCBlockReadRequest req = new RPCBlockReadRequest ( OFFSET ,  LOCK_ID ,  SESSION_ID ,  BLOCK_ID ,  mBuffer ,  LENGTH )  ;  int loc0 = req . getEncodedLength (  )  ;  ByteBuf buf = Unpooled . buffer (  )  ;  req . encode ( buf )  ;  RPCBlockReadRequest decodedReq = new RPCBlockReadRequest (  )  ;  decodedReq . decode ( buf )  ;  Assert . assertEquals ( decodedReq ,  req )  ;  int expectedLength = /* Calculate expected length based on the values of OFFSET ,  LOCK_ID ,  SESSION_ID ,  BLOCK_ID ,  LENGTH ,  and mBuffer */ ;  Assert . assertEquals ( loc0 ,  expectedLength )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  Assert . fail ( "Exception thrown during test: " + e . getMessage (  )  )  ;  } }
public int function (  )  { int loc0 = offset ;  return loc0 ;  }
Map < String ,  Double >  function ( String arg0 ,  double arg1 ,  String arg2 ,  double arg3 )  { fis . setInput ( arg0 ,  arg1 )  ;  fis . setInput ( arg2 ,  arg3 )  ;  Map < String ,  Double >  loc0 = fis . evaluate (  )  ;  return sortByValue ( loc0 )  ;  }
String function ( MessageReader arg0 )  { String loc0 = readAttributeValue ( arg0 ,  SOAP_ENCODING_REF_1_2 )  ;  if  ( loc0 != null )  { return loc0 ;  } else { return readAttributeValue ( arg0 ,  SOAP_ENCODING_REF_1_1 )  ;  } }
import java . util . List ;  import java . util . Hashtable ;  public class ExtendableMap { Hashtable < String , Point2D >  locationPositions ;  LabeledGraph < String , Double >  links ;  String function (  )  { List < String >  locList = getLocations (  )  ;  String loc = Util . selectRandomlyFromList ( locList )  ;  return loc ;  } void setPosition ( String loc ,  double x ,  double y )  { } void removeUnidirectionalLink ( String fromLocation ,  String toLocation )  { } void removeBidirectionalLink ( String fromLocation ,  String toLocation )  { } List < String >  getLocations (  )  { } void addUnidirectionalLink ( String fromLocation ,  String toLocation ,  Double distance )  { } List < String >  getLocationsLinkedTo ( String fromLocation )  { } Double getDistance ( String fromLocation ,  String toLocation )  { } void clearLinks (  )  { } Point2D getPosition ( String loc )  { } boolean isLocation ( String str )  { } void setDistAndDirToRefLocation ( String loc ,  double dist ,  int dir )  { } void clear (  )  { } void addBidirectionalLink ( String fromLocation ,  String toLocation ,  Double distance )  { } }
public static Object function ( Object arg0 ,  String arg1 )  { Object loc0 = null ;  if  ( arg0 instanceof ShareOpenGraphValueContainer )  { loc0 =  (  ( ShareOpenGraphValueContainer )  arg0 )  . get ( arg1 )  ;  } else if  ( arg0 instanceof Bundle )  { loc0 =  (  ( Bundle )  arg0 )  . get ( arg1 )  ;  } if  ( loc0 instanceof ShareOpenGraphObject )  { loc0 = String . valueOf ( loc0 )  ;  } return loc0 ;  }
void function ( PaymentChannelServer loc0 ,  StoredServerChannel loc1 )  { if  ( loc1 . connectedHandler != null )  { loc1 . connectedHandler . close (  )  ;  loc1 . clearConnectedHandler (  )  ;  } }
Date function ( String arg0 ,  String arg1 )  { Date loc0 ;  ParsePosition loc1 = new ParsePosition ( 0 )  ;  SimpleDateFormat loc2 = new SimpleDateFormat ( arg1 )  ;  loc0 = loc2 . parse ( arg0 ,  loc1 )  ;  return loc0 ;  }
boolean function ( boolean arg0 ,  String arg1 ,  String arg2 ,  String arg3 ,  String arg4 ,  String arg5 ,  String arg6 ,  String arg7 ,  String arg8 ,  String arg9 ,  String arg10 ,  String arg11 ,  String arg12 ,  String arg13 ,  FileSizeComparable loc0 ,  String arg14 ,  String arg15 )  { setSelected ( arg0 )  ;  language = arg1 ;  author_sort = arg2 ;  pubdate = arg3 ;  author = arg4 ;  title = arg5 ;  tagStr = arg6 ;  selected = arg7 ;  uuid = arg8 ;  filenameWithoutExtension = arg9 ;  path = arg10 ;  comment = arg11 ;  length = loc0 ;  rating = arg14 ;  title_sort = arg15 ;  List < String >  loc1 = new ArrayList < String >  (  )  ;  if  ( arg12 != null )  { String [  ]  loc2 = arg12 . split ( " , " )  ;  for  ( String loc3 : loc2 )  { loc1 . add ( loc3 . trim (  )  )  ;  } } tags = loc1 ;  List < String >  loc4 = new ArrayList < String >  (  )  ;  if  ( arg13 != null )  { String [  ]  loc5 = arg13 . split ( " , " )  ;  for  ( String loc6 : loc5 )  { loc4 . add ( loc6 . trim (  )  )  ;  } } formats = loc4 ;  return selected ;  }
void function ( Object arg0 )  { try { mArray . add ( arg0 )  ;  } catch  ( Exception loc0 )  { System . out . println ( "Failed to add item: " + loc0 . getMessage (  )  )  ;  } }
boolean function ( String arg0 ,  String arg1 )  { try { userService . renameRepositoryRole ( arg0 ,  arg1 )  ;  return true ;  } catch  ( Exception e )  { logger . error ( "An error occurred while renaming repository role: " + e . getMessage (  )  )  ;  return false ;  } }
class MQTTServiceActivator implements BundleActivator { IEnvironments environments=null ;  HashMap < String ,  MQTTConnectionFactory >  factories=new HashMap < String ,  MQTTConnectionFactory >  (  )  ;  AutoSIMMQTTConfig config=null ;  public void start ( BundleContext context )  { } public void function ( BundleContext arg0 )  { for  ( AutoSIMConnectionConfig loc0 : config . connections )  { environments . deregisterConnectionFactory ( loc0 . name )  ;  factories . remove ( loc0 . name )  ;  } } public void stop ( BundleContext context )  { } }
void function ( int arg0 ,  int arg1 ,  String arg2 ,  int arg3 )  { unifiedBreak ( arg0 ,  arg1 ,  arg2 ,  arg3 )  ;  }
public static void function (  )  { try { CollisionDJBX33X loc0 = new CollisionDJBX33X (  )  ;  String arg0 = "example" ;  int loc1 = loc0 . hashForth ( arg0 )  ;  int arg1 = 123456789 ;  assertEquals ( arg1 ,  loc1 )  ;  String loc2 = "Hash forward first 7 Characters" ;  System . out . println ( loc2 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { ways . clear (  )  ;  markers . clear (  )  ;  entityTree . clear (  )  ;  pois . clear (  )  ;  tracks . clear (  )  ;  nodes . clear (  )  ;  nextTrackId = 1 ;  entityClassifier . clear (  )  ;  entityClassifier . setEntityTypes ( new HashSet < EntityType >  (  )  )  ;  boundingBox = null ;  MapEvent event = new MapEvent ( this )  ;  event . setType ( MapEventType . RESET )  ;  fireMapDataEvent ( event )  ;  LOG . info ( "No data available after this reset . " )  ;  }
public boolean function (  )  { Map < SinkInfo ,  Set < SourceInfo >  >  loc0 = results ;  return loc0 . isEmpty (  )  ;  }
Rect function ( int arg0 ,  int arg1 )  { framingRect = new Rect ( 0 ,  0 ,  arg0 ,  arg1 )  ;  return getFramingRect (  )  ;  }
public String function (  )  { String loc0 = ACCESS_TOKEN_KEY ;  if  ( token == null )  { loc1 = "" ;  } else if  ( ALREADY_EXPIRED_EXPIRATION_TIME . equals ( expires )  || expires . before ( new Date (  )  )  )  { loc1 = "" ;  } else { loc1 = loc0 + "=" + token ;  } return loc1 ;  }
Map < String ,  String >  function ( String arg0 )  { Map < String ,  String >  groupAttributes = new HashMap <  >  (  )  ;  try { if  ( !isGroupExisting ( arg0 )  )  { logger . error ( "Group " + arg0 + " does not exist . " )  ;  return groupAttributes ;  } String groupId = getGroupId ( arg0 )  ;  groupAttributes = getGroupAttributesById ( groupId )  ;  } catch  ( Exception loc0 )  { logger . error ( "Failed to retrieve group attributes for group " + arg0 ,  loc0 )  ;  } return groupAttributes ;  }
long function (  )  { long loc0 = getTime (  )  ;  int loc1 =  ( int )  ( loc0 - lastFrame )  ;  lastFrame = loc0 ;  return loc1 ;  }
void function ( DenseMatrix64F arg0 ,  DenseMatrix64F arg1 )  { BlockMatrix64F loc0 = new BlockMatrix64F ( 1 ,  1 )  ;  loc0 . reshape ( arg0 . numRows ,  arg0 . numCols )  ;  ConvertDenseStruct . convert ( arg0 ,  loc0 )  ;  BlockMatrix64F loc1 = new BlockMatrix64F ( 1 ,  1 )  ;  loc1 . reshape ( arg1 . numRows ,  arg1 . numCols )  ;  ConvertDenseStruct . convert ( arg1 ,  loc1 )  ;  alg . setA ( loc0 )  ;  blockA . reshape ( loc0 . numRows ,  loc0 . numCols )  ;  ConvertBlock . convert ( loc0 ,  blockA )  ;  blockB . reshape ( loc1 . numRows ,  loc1 . numCols )  ;  ConvertBlock . convert ( loc1 ,  blockB )  ;  }
void function ( T arg0 )  { boolean loc0 = false ;  while  ( !loc0 )  { if  ( isHealthy ( arg0 )  )  { loc0 = true ;  } else { LOG . info ( "Unhealthy resource detected: {}" ,  arg0 )  ;  mLock . lock (  )  ;  try { remove ( arg0 )  ;  closeResourceSync ( arg0 )  ;  arg0 = acquire (  )  ;  } finally { mLock . unlock (  )  ;  } } } }
void function (  )  { MWVTest test = new MWVTest (  )  ;  test . setUp (  )  ;  test . testGetSpeedUnit (  )  ;  assertEquals ( arg0 ,  loc0 )  ;  }
ResourceSet function (  )  { ResourceSet loc0 = new ResourceSet (  )  ;  try { loc0 . setId ( arg0 )  ;  loc1 . saveNew ( loc0 )  ;  } catch  ( Exception loc2 )  { } return loc0 ;  }
void function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { System . out . println ( "Prints input in console for debugging . " )  ;  ArrayList < String >  loc0 = fis . getFunctionBlock (  )  . getVariables (  )  ;  System . out . println ( loc0 )  ;  String loc1 = fis . toString (  )  ;  System . out . println ( loc1 )  ;  Map < String ,  Double >  loc2 = fis . evaluate (  )  ;  System . out . println ( loc2 )  ;  }
void function ( String arg0 ,  int arg1 ,  int arg2 )  { try { FieldInfo loc0 = new FieldInfo ( arg1 ,  arg2 )  ;  info . put ( arg0 ,  loc0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
 @ Override public int function ( Object .  .  .  args )  { int loc0 = 17 ;  try { loc0 = 31 * loc0 +  ( args [ 0 ]  != null ? args [ 0 ]  . hashCode (  )  : 0 )  ;  loc0 = 31 * loc0 +  ( args [ 1 ]  != null ? args [ 1 ]  . hashCode (  )  : 0 )  ;  } catch  ( Exception e )  { } return loc0 ;  }
Set < String >  function (  )  { String loc0 = "Getting the ids of the registered object instances" ;  Set < String >  loc1 = Collections . unmodifiableSet ( instances . keySet (  )  )  ;  return loc1 ;  }
void function ( BufferedOutputStream arg0 ,  File arg1 )  { arg0 . write ( new byte [ 10 ]  ,  0 ,  10 )  ;  mStream . writeByteArrayWithRange (  )  ;  mStream . before (  )  ;  mStream . close (  )  ;  Mockito . verify ( arg0 )  . close (  )  ;  Mockito . verify ( arg0 )  . flush (  )  ;  mStream . verify (  )  ;  mLocalOutputStream . flush (  )  ;  }
public void function ( Object arg0 ,  Object arg1 )  { try { throw new UnsupportedOperationException (  )  ;  } catch  ( UnsupportedOperationException e )  { System . out . println ( "An exception was thrown: " + e . getMessage (  )  )  ;  } }
Class function ( Class arg0 ,  String arg1 )  { Class loc0 = getClassImpl ( arg0 ,  arg1 )  ;  Class loc1 = loc0 . getClass (  )  ;  return loc1 ;  }
String function ( final String arg0 ,  final UnderFileSystemUtils arg1 )  { arg1 . mkdirIfNotExists ( arg0 )  ;  LocalAlluxioMaster loc0 = new LocalAlluxioMaster (  )  ;  loc0 . start (  )  ;  return loc0 . getUri (  )  ;  }
private void function (  )  { try { boolean loc0 = true ;  // set useDirectBuffers ByteBuffer . setUseDirectBuffers ( loc0 )  ;  ByteBufferAllocator loc1 = new SimpleByteBufferAllocator (  )  ;  // set allocator ByteBuffer . setAllocator ( loc1 )  ;  } catch  ( Exception e )  { m_log . error ( "Exception occurred while setting up ByteBuffer . " ,  e )  ;  } }
arg0 function (  )  { arg0 loc0 = conditionsProvider ;  arg1 loc1 = new DefaultConditionsProvider (  )  ;  loc0 = loc1 ;  return loc0 ;  }
void function ( Object arg0 ,  Object arg1 ,  Object arg2 ,  Object arg3 ,  Object arg4 ,  Object arg5 ,  Object arg6 )  { if  ( blk != null )  { blk . unpin (  )  ;  } }
void function ( String arg0 ,  String arg1 )  { try { this . setTokenId ( arg0 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
public class AddressFacade { private AddressType address ;  private String getZip (  )  { return address . getPostalZone (  )  ;  } private String getStreet (  )  { return address . getStreetName (  )  + " " + address . getBuildingNumber (  )  ;  } private String getCity (  )  { return address . getCityName (  )  ;  } private String function (  )  { String loc0 = "" ;  try { loc0 = address . getState (  )  . getValue (  )  ;  } catch  ( NullPointerException e )  { loc0 = "Unknown" ;  } String loc1 = address . getCountrySubentityCode (  )  . getValue (  )  ;  return loc0 + " ,  " + loc1 ;  } }
void function ( long arg0 )  { unlockBlock ( arg0 )  ;  releaseBlockLockIfUnused ( arg0 )  ;  }
double function ( String arg0 ,  String arg1 )  { double loc0 = 0 . 00 ;  String loc1 = System . getProperty ( arg0 ,  arg1 )  ;  if  ( loc1 != null )  { loc0 = Double . parseDouble ( loc1 )  ;  } return loc0 ;  }
void function (  )  { ExpectedException loc0 = ExpectedException . none (  )  ;  loc0 . expect ( IllegalStateException . class )  ;  loc0 . expectMessage ( "Cannot unlock block " + TEST_BLOCK_ID + " as it is not locked" )  ;  mLockManager . unlockBlock ( TEST_BLOCK_ID )  ;  String loc1 = loc0 . getMessage (  )  ;  }
public String function (  )  { String loc0 = null ;  try { loc0 = this . checksumType ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
public class Camera { URL url ;  int framerate ;  String cameraIPAddress ;  String channel ;  int cameraPort ;  int compression ;  String resolution ;  public void setIPAddress ( String ipaddress ,  int port )  { this . cameraIPAddress = ipaddress ;  this . cameraPort = port ;  } public URL getURL (  )  { return this . url ;  } public void halt (  )  { } public void movePanTilt ( String direction )  { } public String composeURL ( String streamType )  { return "" ;  } public void runUrl ( String command )  { } public void start (  )  { } public void function ( String arg0 ,  String arg1 )  { String loc0 = arg0 . concat ( arg1 )  ;  try { String loc1 = String . valueOf ( loc0 )  ;  runUrl ( loc1 )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } } }
void function (  )  { setUpClass (  )  ;  setUp (  )  ;  dev = new Device (  )  ;  dev . setAddress ( "127 . 0 . 0 . 1" )  ;  String loc0 = dev . getAddress (  )  ;  System . out . println ( "Test of getAddress method ,  of class Device . " )  ;  assertEquals ( loc0 ,  "127 . 0 . 0 . 1" )  ;  tearDown (  )  ;  tearDownClass (  )  ;  }
long function ( Object arg0 )  { try { DefaultConditionsProvider loc0 =  ( DefaultConditionsProvider )  arg0 ;  return loc0 . maxLifetime ;  } catch  ( Exception loc1 )  { return 0L ;  // or any other default value } }
RouteCalculator function ( String arg0 ,  String arg1 )  { try { RouteCalculator loc0 = new RouteCalculator ( arg0 ,  arg1 )  ;  return loc0 ;  } catch ( Exception loc1 )  { System . err . println ( "Error occurred while instantiating RouteCalculator: " + loc1 . getMessage (  )  )  ;  return null ;  } }
void function ( String arg0 ,  String arg1 )  { String loc0 = FileUtils . getLocalFileOwner ( arg0 )  ;  String loc1 = FileUtils . getLocalFileGroup ( arg0 )  ;  short loc2 = FileUtils . getLocalFileMode ( arg0 )  ;  Set < PosixFilePermission >  loc3 = PosixFilePermissions . fromString ( arg1 )  ;  loc3 . add ( PosixFilePermission . OWNER_READ )  ;  loc3 . add ( PosixFilePermission . OWNER_WRITE )  ;  loc3 . add ( PosixFilePermission . GROUP_READ )  ;  loc3 . add ( PosixFilePermission . GROUP_WRITE )  ;  loc3 . add ( PosixFilePermission . OTHERS_READ )  ;  loc3 . add ( PosixFilePermission . OTHERS_WRITE )  ;  try { Files . setPosixFilePermissions ( Paths . get ( arg0 )  ,  loc3 )  ;  } catch  ( IOException e )  { LOG . error ( "Failed to set file permissions for " + arg0 ,  e )  ;  } }
void function ( InputStream arg0 ,  int arg1 )  { reader . setInputStream ( arg0 )  ;  if  ( reader . isRunning (  )  )  { reader . stop (  )  ;  } reader = new DefaultDataReader ( listeners ,  arg1 ,  LOGGER )  ;  }
void function (  )  { try { connection . close (  )  ;  Jamuz . getLogger (  )  . log ( Level . SEVERE ,  "Disconnect database" )  ;  } catch  ( Exception loc0 )  { Jamuz . getLogger (  )  . log ( Level . SEVERE ,  "Failed to disconnect database" ,  loc0 )  ;  } }
ArrayList < Date >  function (  )  { ArrayList < Date >  loc0 = new ArrayList < Date >  (  )  ;  if  ( dates == null )  { dates = new ArrayList < Date >  (  )  ;  } return this . dates ;  }
void function ( float arg0 ,  float arg1 ,  float arg2 ,  float arg3 ,  float arg4 )  { float loc0 = arg3 / 2 . 0f ;  float loc1 = arg2 / 2 . 0f ;  gl . glBindTexture ( GL . GL_TEXTURE_2D ,  textures [ 0 ]  )  ;  gl . glBegin ( GL . GL_QUADS )  ;  gl . glTexCoord2f ( 0 . 0f ,  0 . 0f )  ;  gl . glVertex3f ( -loc0 ,  -loc1 ,  arg3 )  ;  gl . glTexCoord2f ( 1 . 0f ,  0 . 0f )  ;  gl . glVertex3f ( loc0 ,  -loc1 ,  arg3 )  ;  gl . glTexCoord2f ( 1 . 0f ,  1 . 0f )  ;  gl . glVertex3f ( loc0 ,  loc1 ,  arg3 )  ;  gl . glTexCoord2f ( 0 . 0f ,  1 . 0f )  ;  gl . glVertex3f ( -loc0 ,  loc1 ,  arg3 )  ;  gl . glEnd (  )  ;  gl . glBindTexture ( GL . GL_TEXTURE_2D ,  textures [ 1 ]  )  ;  gl . glBegin ( GL . GL_QUADS )  ;  gl . glTexCoord2f ( 0 . 0f ,  0 . 0f )  ;  gl . glVertex3f ( loc0 ,  -loc1 ,  0 . 0f )  ;  gl . glTexCoord2f ( 1 . 0f ,  0 . 0f )  ;  gl . glVertex3f ( -loc0 ,  -loc1 ,  0 . 0f )  ;  gl . glTexCoord2f ( 1 . 0f ,  1 . 0f )  ;  gl . glVertex3f ( -loc0 ,  loc1 ,  0 . 0f )  ;  gl . glTexCoord2f ( 0 . 0f ,  1 . 0f )  ;  gl . glVertex3f ( loc0 ,  loc1 ,  0 . 0f )  ;  gl . glEnd (  )  ;  gl . glBindTexture ( GL . GL_TEXTURE_2D ,  textures [ 2 ]  )  ;  gl . glBegin ( GL . GL_QUADS )  ;  gl . glTexCoord2f ( 0 . 0f ,  0 . 0f )  ;  gl . glVertex3f ( -loc0 ,  -loc1 ,  0 . 0f )  ;  gl . glTexCoord2f ( 1 . 0f ,  0 . 0f )  ;  gl . glVertex3f ( -loc0 ,  -loc1 ,  arg3 )  ;  gl . glTexCoord2f ( 1 . 0f ,  1 . 0f )  ;  gl . glVertex3f ( -loc0 ,  loc1 ,  arg3 )  ;  gl . glTexCoord2f ( 0 . 0f ,  1 . 0f )  ;  gl . glVertex3f ( -loc0 ,  loc1 ,  0 . 0f )  ;  gl . glEnd (  )  ;  gl . glBindTexture ( GL . GL_TEXTURE_2D ,  textures [ 3 ]  )  ;  gl . glBegin ( GL . GL_QUADS )  ;  gl . glTexCoord2f ( 0 . 0f ,  0 . 0f )  ;  gl . glVertex3f ( loc0 ,  -loc1 ,  arg3 )  ;  gl . glTexCoord2f ( 1 . 0f ,  0 . 0f )  ;  gl . glVertex3f ( loc0 ,  -loc1 ,  0 . 0f )  ;  gl . glTexCoord2f ( 1 . 0f ,  1 . 0f )  ;  gl . glVertex3f ( loc0 ,  loc1 ,  0 . 0f )  ;  gl . glTexCoord2f ( 0 . 0f ,  1 . 0f )  ;  gl . glVertex3f ( loc0 ,  loc1 ,  arg3 )  ;  gl . glEnd (  )  ;  }
void function ( String arg0 )  { try { initInternal ( arg0 )  ;  Localizer . addResource ( arg0 )  ;  LOG . info ( "Default Locale is set and resources Bundles are loaded . " )  ;  } catch  ( Exception loc0 )  { LOG . error ( "Failed to initialize Translator" ,  loc0 )  ;  } }
String function ( String arg0 )  { String loc0 = PathUtils . cleanPath ( arg0 )  ;  String loc1 = FilenameUtils . getName ( loc0 )  ;  if  ( !loc1 . isEmpty (  )  )  { loc0 = loc0 . substring ( 0 ,  loc0 . length (  )  - loc1 . length (  )  )  ;  } return loc0 ;  }
public void function ( TrustManager [  ]  arg0 )  { try { trustManagers = arg0 ;  } catch  ( Exception loc0 )  { } }
void function ( EndpointReferenceType arg0 )  { try { setReplyTo ( arg0 )  ;  } catch  ( Exception loc0 )  { } }
String function (  )  { SimpleDateFormat sdf = new SimpleDateFormat ( "yyyy-MM-dd'T'HH:mm:ss'Z'" )  ;  sdf . setTimeZone ( TimeZone . getTimeZone ( "UTC" )  )  ;  Date loc0 = new Date (  )  ;  return sdf . format ( loc0 )  ;  }
public void function ( RowHeaderType arg0 ,  ColumnHeaderType arg1 ,  ValueType arg2 )  { if  ( arg0 == null || arg1 == null || arg2 == null )  { throw new IllegalArgumentException ( "Neither the row nor the column nor the value can be null . " )  ;  } try { Hashtable < ColumnHeaderType ,  ValueType >  loc0 = cells . get ( arg0 )  ;  if  ( loc0 == null )  { loc0 = new Hashtable <  >  (  )  ;  cells . put ( arg0 ,  loc0 )  ;  } loc0 . put ( arg1 ,  arg2 )  ;  } catch  ( NullPointerException e )  { System . err . println ( "NullPointerException: " + e . getMessage (  )  )  ;  } }
void function ( List < String >  arg0 )  { this . acceptedSignatureAlgorithms = arg0 ;  this . acceptedSignatureAlgorithms . add ( "RSA-SHA1" )  ;  // add default algorithm }
public void function ( String arg0 ,  String arg1 )  { try { LogEntryRequestTest test = new LogEntryRequestTest (  )  ;  test . instance . setResponseString ( arg0 ,  arg1 )  ;  System . out . println ( "Successfully called setResponseString with arguments: " + arg0 + " ,  " + arg1 )  ;  } catch  ( Exception loc0 )  { System . out . println ( "An exception occurred while calling setResponseString: " + loc0 . getMessage (  )  )  ;  } }
public void function ( Map < String ,  String >  arg0 )  { try { this . namespaceMap = arg0 ;  } catch  ( Exception loc0 )  { System . err . println ( "Error occurred while setting namespaceMap: " + loc0 . getMessage (  )  )  ;  } }
void function (  )  { RMCTest testObj = new RMCTest (  )  ;  RMCParser loc0 = new RMCParser (  )  ;  loc0 . parse ( testObj . EXAMPLE )  ;  assertEquals ( "A" ,  loc0 . getMode (  )  )  ;  }
void function (  )  { setUp (  )  ;  rmb . setSentence ( EXAMPLE )  ;  assertEquals ( "RUSKI" ,  rmb . getDestination (  )  )  ;  assertEquals ( "432 . 3" ,  Double . toString ( rmb . getRange (  )  )  )  ;  assertEquals ( "234 . 9" ,  Double . toString ( rmb . getBearing (  )  )  )  ;  assertNull ( rmb . getOriginId (  )  )  ;  assertNull ( rmb . getCrossTrackError (  )  )  ;  assertNull ( rmb . getStatus (  )  )  ;  assertNull ( rmb . getVelocity (  )  )  ;  rmb . setSteerTo ( true )  ;  assertTrue ( rmb . getSteerTo (  )  )  ;  rmb . setSteerTo ( false )  ;  assertFalse ( rmb . getSteerTo (  )  )  ;  rmb . setSteerTo ( null )  ;  assertNull ( rmb . getSteerTo (  )  )  ;  }
public int function ( IndexSelectPlan isp ) 
public String function ( SayHi instance )  { try { return instance . msg ;  } catch  ( Exception e )  { System . err . println ( "Error getting msg value: " + e . getMessage (  )  )  ;  return null ;  } }
int function ( XCommand < ? >  arg0 )  { int loc0 = priority ;  if  ( loc0 == 0 )  { loc0 = arg0 . getPriority (  )  ;  } return loc0 ;  }
String function ( String arg0 )  { String loc0 = getPrefix ( arg0 )  ;  if  ( loc0 == null )  { int loc1 = nsPrefixCount ++  ;  loc0 = NS_PREFIX_PREFIX + loc1 ;  add ( loc0 ,  arg0 )  ;  } return loc0 ;  }
public Object function ( Object arg0 )  { subst . put (  ( Formal )  arg0 ,   ( Actual )  arg0 )  ;  return arg0 ;  }
public Object function (  )  { BrowseOffersResponse . Return . OfferData . OfferMedia . OfferImage . Entry . Value loc0 = new BrowseOffersResponse . Return . OfferData . OfferMedia . OfferImage . Entry . Value (  )  ;  BrowseOffersResponse . Return . OfferData . OfferMedia . OfferImage . Entry loc1 = new BrowseOffersResponse . Return . OfferData . OfferMedia . OfferImage . Entry (  )  ;  BrowseOffersResponse . Return . OfferData . OfferMedia . OfferImage loc2 = new BrowseOffersResponse . Return . OfferData . OfferMedia . OfferImage (  )  ;  BrowseOffersResponse . Return . OfferData . Geo . Region . Country . State loc3 = new BrowseOffersResponse . Return . OfferData . Geo . Region . Country . State (  )  ;  BrowseOffersResponse . Return . OfferData . Geo . Region . Country loc4 = new BrowseOffersResponse . Return . OfferData . Geo . Region . Country (  )  ;  BrowseOffersResponse . Return . OfferData . Geo . Region loc5 = new BrowseOffersResponse . Return . OfferData . Geo . Region (  )  ;  BrowseOffersResponse . Return . OfferData . Seo loc6 = new BrowseOffersResponse . Return . OfferData . Seo (  )  ;  BrowseOffersResponse . Return . OfferData . Merchant loc7 = new BrowseOffersResponse . Return . OfferData . Merchant (  )  ;  BrowseOffersResponse . Return . OfferData loc8 = new BrowseOffersResponse . Return . OfferData (  )  ;  BrowseOffersResponse . Return loc9 = new BrowseOffersResponse . Return (  )  ;  BrowseOffersResponse loc10 = new BrowseOffersResponse (  )  ;  loc0 . setItem ( arg0 )  ;  loc1 . setValue ( loc0 )  ;  loc2 . getEntry (  )  . add ( loc1 )  ;  loc8 . setOfferMedia ( new BrowseOffersResponse . Return . OfferData . OfferMedia (  )  )  ;  loc8 . getOfferMedia (  )  . setOfferImage ( loc2 )  ;  loc8 . setGeo ( new BrowseOffersResponse . Return . OfferData . Geo (  )  )  ;  loc8 . getGeo (  )  . setRegion ( loc5 )  ;  loc5 . setCountry ( loc4 )  ;  loc4 . setState ( loc3 )  ;  loc8 . setSeo ( loc6 )  ;  loc8 . setMerchant ( loc7 )  ;  loc9 . setOfferData ( loc8 )  ;  loc10 . setReturn ( loc9 )  ;  return loc0 ;  }
void function (  )  { try { RTETest obj = new RTETest (  )  ;  int loc0 = -1 ;  obj . setSentenceIndex ( loc0 )  ;  fail ( "Expected IllegalArgumentException was not thrown" )  ;  } catch  ( IllegalArgumentException e )  { assertTrue ( e . getMessage (  )  . contains ( "Sentence index must be  > = 0" )  )  ;  } catch  ( Exception e )  { fail ( "Unexpected exception was thrown" )  ;  } }
void function (  )  { function (  )  ;  undoAction ( arg0 )  ;  item . changed (  )  ;  }
float function ( MotionEvent arg0 ,  int arg1 )  { int loc1 = MotionEventCompat . IMPL . getActionIndex ( arg0 )  ;  if  ( loc1  <  0 || loc1  > = MotionEventCompat . IMPL . getPointerCount ( arg0 )  )  { loc1 = 0 ;  } int loc2 = MotionEventCompat . IMPL . getPointerId ( arg0 ,  loc1 )  ;  if  ( arg1 == loc2 )  { return MotionEventCompat . IMPL . getX ( arg0 ,  loc1 )  ;  } else { throw new IllegalArgumentException ( "Invalid pointer id" )  ;  } }
long function (  )  { long result = 0L ;  try { result = mDir . getCommittedBytes (  )  ;  } catch  ( Exception e )  { } return result ;  }
import org . junit . Test ;  import static org . junit . Assert . assertEquals ;  public class CompleteFileOptionsTest { private long fileId ;  private long ufsLength ;  private String mountId ;  private boolean cached ;  public void fields (  )  { } public void equalsTest (  )  { } public void defaults (  )  { } private void setUfsLength ( long ufsLength )  { this . ufsLength = ufsLength ;  } private Object toThrift (  )  { } public void function (  )  { long arg0 = 12345L ;  long arg1 = 67890L ;  fields (  )  ;  defaults (  )  ;  setUfsLength ( arg0 )  ;  Object loc0 = toThrift (  )  ;  setUfsLength ( arg1 )  ;  Object loc1 = toThrift (  )  ;  assertEquals ( loc0 ,  loc1 )  ;  } }
ClassLoader function (  )  { ClassLoader loc0 = null ;  try { loc0 = ClassHelper . class . getClassLoader (  )  ;  } catch  ( Exception e )  { } if  ( loc0 == null )  { loc0 = ClassHelper . class . getClassLoader (  )  ;  } return loc0 ;  }
public static Class < ? >  function ( Class < ? >  arg0 ,  Map < Class < ? >  ,  Wrapper >  arg1 )  { Class < ? >  loc0 = arg0 . getSuperclass (  )  ;  boolean loc1 = arg0 . isDynamicClass (  )  ;  Wrapper loc2 = arg1 . get ( loc0 )  ;  arg1 . put ( arg0 ,  loc2 )  ;  return loc0 ;  }
public void function ( String arg0 ,  String arg1 )  { Plan loc0 = new Project ( p ,  schema )  ;  loc0 . open (  )  ;  Schema loc1 = loc0 . schema (  )  ;  loc0 . close (  )  ;  }
public void function ( int arg0 )  { int loc0 = arg0 ;  int [  ]  loc1 = new int [ loc0 + 1 ]  ;  for  ( int loc2 = 0 ;  loc2  <  loc1 . length ;  loc2 ++  )  { if  ( loc2  < = grado )  { loc1 [ loc2 ]  = coef [ loc2 ]  ;  } else { loc1 [ loc2 ]  = 0 ;  } } setCoeficientes ( loc1 )  ;  grado = loc0 ;  }
public static Response function ( RestUtils . RestCallable arg0 )  { try { Object loc0 = arg0 . call (  )  ;  if  ( loc0 != null )  { return createResponse ( loc0 )  ;  } else { return createErrorResponse ( "Null response returned from callable" )  ;  } } catch  ( Exception loc1 )  { LOG . error ( "Exception occurred during RestCallable call: {}" ,  loc1 . getMessage (  )  )  ;  return createErrorResponse ( loc1 . getMessage (  )  )  ;  } }
void function (  )  { try { instance . setYear ( arg0 )  ;  fail ( "Expected IllegalArgumentException was not thrown" )  ;  } catch  ( IllegalArgumentException loc0 )  { } }
public static QualifiedName function ( ASTConstructorDeclaration arg0 ,  ASTCompilationUnit arg1 )  { ASTClassOrInterfaceDeclaration loc0 = arg0 . getFirstParentOfType ( ASTClassOrInterfaceDeclaration . class )  ;  QualifiedName loc1 = loc0 . getQualifiedName (  )  ;  String loc2 = arg0 . getImage (  )  ;  ASTBlockStatement loc3 = arg0 . getFirstDescendantOfType ( ASTBlockStatement . class )  ;  QualifiedName loc4 = loc1 . makeOperationOf ( loc2 ,  loc3 )  ;  return loc4 ;  }
void function ( ApplicationManagementService arg0 )  { Log loc0 = LogFactory . getLog ( OAuth2ServiceComponent . class )  ;  BundleContext loc1 = bundleContext ;  if  ( loc0 . isDebugEnabled (  )  )  { loc0 . debug ( "Unsetting the Application management service implementation" )  ;  } OAuth2ServiceComponentHolder . setApplicationMgtService ( null )  ;  }
List < String >  function ( CertificateConstraintsType arg0 )  { List < String >  subjectDNConstraints = Collections . emptyList (  )  ;  DNConstraintsType loc0 = arg0 . getSubjectDNConstraints (  )  ;  if  ( loc0 != null && loc0 . isSetRegularExpression (  )  )  { String loc1 = loc0 . getRegularExpression (  )  ;  if  ( loc1 != null && !loc1 . isEmpty (  )  )  { subjectDNConstraints = loc0 . getRegularExpression (  )  ;  } } return subjectDNConstraints ;  }
void function (  )  { try { notificationController . deregisterUserSession ( null ,  mockServerMessage )  ;  } catch  ( NullPointerException loc0 )  { } }
TiledMap function ( Array < Asset >  arg0 ,  String arg1 ,  ShadowStruggles game )  { String loc0 = DataManager . resourcesToDirectory ( arg1 )  ;  FileMap loc1 = new FileMap ( loc0 )  ;  Array < Asset >  loc2 = arg0 ;  AssetManager loc3 = game . getAssets (  )  ;  loc2 . addAll ( arg0 )  ;  TiledMap loc4 = null ;  try { loc3 . load ( loc1 ,  TiledMap . class )  ;  loc3 . finishLoadingAsset ( loc1 )  ;  loc4 = loc3 . get ( loc1 ,  TiledMap . class )  ;  } catch  ( Exception loc5 )  { Loader . LOG . error ( "Failed to load TiledMap asset: " + arg1 ,  loc5 )  ;  } return loc4 ;  }
boolean function ( Collection arg0 ,  Collection arg1 )  { if  ( isEmpty ( arg0 )  || isEmpty ( arg1 )  )  { return false ;  } Iterator loc0 = arg1 . iterator (  )  ;  while  ( loc0 . hasNext (  )  )  { Object loc1 = loc0 . next (  )  ;  if  ( contains ( arg0 . iterator (  )  ,  loc1 )  )  { return true ;  } } return false ;  }
void function (  )  { Position loc0 = new Position ( 37 . 7749 ,  -122 . 4194 )  ;  String loc1 = loc0 . getLatHemisphere (  )  ;  String expected = "N" ;  assertEquals ( expected ,  loc1 )  ;  loc0 = new Position ( -33 . 8650 ,  151 . 2094 )  ;  loc1 = loc0 . getLatHemisphere (  )  ;  expected = "S" ;  assertEquals ( expected ,  loc1 )  ;  loc0 = new Position ( 0 ,  0 )  ;  loc1 = loc0 . getLatHemisphere (  )  ;  expected = "N" ;  assertEquals ( expected ,  loc1 )  ;  }
public PasswordCredentials function (  )  { PasswordCredentials loc0 = null ;  try { loc0 = new PasswordCredentials (  )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
ViolationNode createViolationNode ( final String arg0 ,  final int arg1 ,  final int arg2 ,  final int arg3 ,  final int arg4 ,  final String arg5 )  { return new ViolationNode ( arg0 ,  arg1 ,  arg2 ,  arg3 ,  arg4 ,  arg5 )  ;  } void function (  )  { final ViolationNode loc0 = createViolationNode ( "file1" ,  1 ,  2 ,  3 ,  4 ,  "var1" )  ;  final ViolationNode loc1 = createViolationNode ( "file1" ,  1 ,  2 ,  99 ,  4 ,  "var1" )  ;  assertFalse ( loc0 . equals ( loc1 )  )  ;  }
BigDecimal function (  )  { BigDecimal loc0 = this . expDataUnitId ;  return loc0 ;  }
void function (  )  { try { setUp (  )  ;  Date loc0 = new Date ( instance . getTime (  )  )  ;  Date loc1 = new Date ( instance . getTime (  )  )  ;  assertTrue ( loc0 . equals ( loc1 )  )  ;  } catch  ( Exception loc2 )  { } }
public void function ( List < RegPCLTestResultDetailsEntity >  arg0 )  { setRegPclTestResultDetails ( arg0 )  ;  }
void function (  )  { int arg0 = 30 ;  TimeTest timeTest = new TimeTest (  )  ;  timeTest . setUp (  )  ;  try { timeTest . time . setMinutes ( arg0 )  ;  } catch  ( IllegalArgumentException loc0 )  { fail ( "Unexpected exception: " + loc0 . getMessage (  )  )  ;  } int loc1 = timeTest . time . getMinutes (  )  ;  assertEquals ( arg0 ,  loc1 )  ;  }
public T function (  )  { T loc0 = null ;  try { loc0 = this . extractMin (  )  ;  this . add ( this . getWeight ( loc0 )  ,  loc0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
public String function ( String arg0 ,  String arg1 )  { String loc0 = arg0 ;  String loc1 = arg1 ;  try { if  ( loc0 . equalsIgnoreCase ( "title" )  )  { return loc1 . toUpperCase (  )  ;  } else if  ( loc0 . equals ( "name" )  )  { return loc1 ;  } else { return "" ;  } } catch  ( Exception e )  { LOG . error ( "Error occurred in function: " + e . getMessage (  )  )  ;  return "" ;  } }
TopKSelector < Integer >  function ( int arg0 )  { TopKSelector < Integer >  topKSelector = new TopKSelector <  >  ( arg0 ,  Ordering . natural (  )  . reverse (  )  ,  null ,  arg0 ,  null )  ;  return topKSelector ;  }
void function ( String arg0 ,  XKMSCacheToken arg1 )  { try { Element loc0 = new Element ( arg0 ,  arg1 )  ;  cache . put ( loc0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
public Bundle function (  )  { ShareOpenGraphValueContainer loc0 = this . clone (  )  ;  Bundle loc1 = loc0 . bundle ;  loc1 . size (  )  ;  // Forces the Bundle to parcel its contents return loc1 ;  }
public int function ( int arg0 )  { try { LaneData loc0 = getLaneData ( arg0 )  ;  return loc0 . getQuality (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return -1 ;  } }
String function (  )  { String loc0 = album ;  return loc0 ;  }
void function ( int arg0 )  { if  ( arg0  <  -13 || arg0  >  13 )  { throw new IllegalArgumentException ( "srini_string" )  ;  } this . offsetHours = arg0 ;  }
What would you like to know about the Java class named "SeedPeers"?
void function ( Source arg0 )  { sources . add ( arg0 )  ;  validator . setSchemaSources ( sources . toArray ( new Source [ sources . size (  )  ]  )  )  ;  }
public void function ( TMXTiledMap arg0 ,  int arg1 )  { TMXTile loc0 = new TMXTile (  )  ;  loc0 . setTextureRegion ( getTextureRegionFromGlobalTileID ( arg1 )  )  ;  arg0 . getTMXTile ( arg1 )  . setTextureRegion ( loc0 . getTextureRegion (  )  )  ;  }
void function ( Piloto arg0 )  { Comando loc0 = arg0 . proximoComando (  )  ;  try { loc0 . ejecutar ( this . getPartida (  )  )  ;  } catch  ( Exception loc1 )  { this . notificarObservadoresException ( arg0 ,  loc0 ,  loc1 )  ;  } }
public void function ( boolean arg0 )  { try { this . resetTimeout (  )  ;  this . timeoutEnabled = arg0 ;  } catch  ( Exception loc0 )  { } }
public Coin function (  )  { Coin loc0 = value . function (  )  ;  return loc0 ;  }
Items function (  )  { Items loc0 = items ;  return loc0 ;  }
public String function ( String arg0 ,  String arg1 ,  String arg2 ,  String arg3 )  { SortedMap < String ,  String >  loc0 = createParameterMap ( arg0 )  ;  String loc1 = timestamp (  )  ;  loc0 . put ( "Timestamp" ,  loc1 )  ;  loc0 . put ( "AWSAccessKeyId" ,  awsAccessKeyId )  ;  loc0 . put ( "AssociateTag" ,  associatetag )  ;  String loc2 = canonicalize ( loc0 )  ;  String loc3 = "GET\n" + endpoint + "\n" + REQUEST_URI + "\n" + loc2 ;  String loc4 = hmac ( loc3 )  ;  String loc5 = percentEncodeRfc3986 ( loc4 )  ;  loc0 . put ( "Signature" ,  loc5 )  ;  String loc6 = "http://" + endpoint + REQUEST_URI + "?" + canonicalize ( loc0 )  ;  return loc6 ;  }
Node function ( Node arg0 )  { if  ( node . equals ( arg0 )  )  { return node ;  } for  ( TreeNode loc0 : children )  { if  ( loc0 instanceof SimpleNodeTreeNodeAdapter )  { Node loc1 =  (  ( SimpleNodeTreeNodeAdapter )  loc0 )  . function ( arg0 )  ;  if  ( loc1 != null )  { return loc1 ;  } } } return null ;  }
void function ( final long arg0 ,  final long arg1 ,  final long arg2 )  { try { mThrown . expect ( IllegalStateException . class )  ;  mThrown . expectMessage ( "Lock not found for block " + arg1 + " with session " + arg2 )  ;  mLockManager . validateLock ( arg0 ,  arg1 ,  arg2 )  ;  } catch  ( final Exception loc0 )  { final String loc1 = loc0 . getMessage (  )  ;  assertEquals ( "Lock not found for block " + arg1 + " with session " + arg2 ,  loc1 )  ;  } }
import com . google . common . base . Preconditions ;  public class Example { public void function ( String arg0 ,  String arg1 )  { try { ServiceBuilder builder = new ServiceBuilder (  )   . apiKey ( arg0 )   . callback ( arg1 )  ;  Preconditions . checkNotNull ( builder ,  "Builder cannot be null" )  ;  } catch  ( Exception e )  { System . err . println ( "Error in function: " + e . getMessage (  )  )  ;  } } }
void function ( ClassType arg0 ,  EfgClassInfo arg1 )  { Type loc0 = type ( arg0 )  ;  EfgClassInfo loc1 = get ( arg0 )  ;  if  ( loc1 != null )  { return ;  } loc1 = new EfgClassInfo ( loc0 ,  position (  )  )  ;  put ( arg0 ,  loc1 )  ;  addAuto ( arg0 ,  loc1 )  ;  }
String function ( TaskStatus taskStatus )  { try { return taskStatus . getId (  )  ;  } catch  ( NullPointerException e )  { System . err . println ( "Error: " + e . getMessage (  )  )  ;  return null ;  } }
public void function ( Iterable < Range < C >  >  arg0 )  { for  ( Range < C >  loc0 : arg0 )  { remove ( loc0 )  ;  } }
String function ( DestinationFileExistsDTO arg0 )  { String loc0 = arg0 . getTestId (  )  ;  return loc0 ;  }
public static boolean function ( final MoverDState < DsT >  arg0 )  { MoverDState . VisitorAdapter < Boolean ,  DsT >  loc0 = new MoverDState . VisitorAdapter < Boolean ,  DsT >  ( Boolean . FALSE )  ;  return arg0 . accept ( loc0 )  . booleanValue (  )  ;  }  @ Override public Boolean visitDownloading ( final Downloading < DsT >  arg1 )  { return Boolean . TRUE ;  }
public static void function ( arg0 arg ,  arg1 arg1 )  { Configuration loc0 = arg . getConfiguration (  )  ;  boolean loc1 = arg . isCreateTables (  )  ;  Logger loc2 = LoggerFactory . getLogger ( SessionFactoryFactory . class )  ;  SessionFactory sessionFactory = loc0 . buildSessionFactory (  )  ;  loc2 . debug ( "Creating new Hibernate session factory . " )  ;  SchemaExport schemaExport = new SchemaExport ( loc0 )  ;  schemaExport . create ( loc1 ,  true )  ;  sessionFactory . createEntityManager (  )  ;  }
void function ( String arg0 )  { uri = arg0 ;  } Note: The method "function" sets the value of the "uri" attribute of the "StylesheetInfo" object to the value passed as the argument "arg0" . 
public Texture function ( String arg0 ,  HashMap < String ,  Texture >  arg1 )  { Texture loc0 = arg1 . get ( arg0 )  ;  if  ( loc0 == null )  { loc0 = new Texture ( arg0 )  ;  arg1 . put ( arg0 ,  loc0 )  ;  } return loc0 ;  }
Date function ( OAuth2RefreshTokenEntity arg0 )  { try { Date loc0 = arg0 . getExpiration (  )  ;  long loc1 = System . currentTimeMillis (  )  ;  long loc2 = loc0 . getTime (  )  ;  if  ( loc2  <  loc1 )  { return loc0 ;  } } catch  ( Exception e )  { } return null ;  }
String function ( String arg0 )  { String loc0 = null ;  if  ( s1 . hasField ( arg0 )  )  { loc0 = s1 . getString ( arg0 )  ;  } else if  ( s2 . hasField ( arg0 )  )  { loc0 = s2 . getString ( arg0 )  ;  } return loc0 ;  }
void function ( String arg0 ,  String arg1 )  { namespaceURI = arg0 ;  toURIType . setValue ( arg1 )  ;  }
String function (  )  { String loc0 = _stack_type ;  return loc0 ;  }
String function (  )  { String loc0 = "" ;  try { loc0 = mUri . getPath (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
boolean function ( int arg0 ,  Sha256Hash arg1 )  { Sha256Hash loc0 = checkpoints . get ( arg0 )  ;  if  ( loc0 == null )  { return true ;  } else { return loc0 . equals ( arg1 )  ;  } }
void function ( StandardRtfParser loc0 ,  byte [  ]  arg1 )  { loc0 . handleEvent ( new BinaryBytesEvent ( arg1 )  )  ;  }
public int function ( int defaultValue )  { int result = defaultValue ;  try { if  ( currentValue != null && !currentValue . trim (  )  . isEmpty (  )  )  { result = Integer . parseInt ( currentValue . trim (  )  )  ;  } } catch  ( NumberFormatException e )  { } return result ;  }
public void function ( DirectedAcyclicGraphNode < T >  arg0 )  { try { if  ( arg0 == null )  { throw new IllegalArgumentException ( "Parent node cannot be null . " )  ;  } if  ( this . mParents . contains ( arg0 )  )  { throw new IllegalArgumentException ( "The parent node already exists . " )  ;  } arg0 . addChild ( this )  ;  this . mParents . add ( arg0 )  ;  } catch  ( IllegalArgumentException e )  { System . out . println ( "Error: " + e . getMessage (  )  )  ;  } }
void function ( String arg0 )  { response . setContentType ( arg0 )  ;  }
String function ( FeedConfigResponse loc0 )  { String loc1 = loc0 . getTestId (  )  ;  return loc1 ;  }
public void function ( Source arg0 )  { Transformation transformation = new Transformation (  )  ;  try { transformation . setSource ( arg0 )  ;  } catch  ( Exception loc0 )  { } }
String function ( String arg0 ,  String arg1 )  { File loc0 = new File ( Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_MOVIES )  ,  DIR_NAME )  ;  if  ( !loc0 . mkdirs (  )  )  { Log . d ( TAG ,  "failed to create directory" )  ;  } if  ( !loc0 . canWrite (  )  )  { Log . d ( TAG ,  "no write access to directory" )  ;  } String loc1 = loc0 . getPath (  )  + File . separator + arg0 + "_" + getDateTimeString (  )  + arg1 ;  return loc1 ;  }
import java . io . BufferedReader ;  import java . io . InputStream ;  import java . io . InputStreamReader ;  import java . io . IOException ;  public class ResponseUtil { public static String function ( InputStream arg0 )  { BufferedReader loc0 = new BufferedReader ( new InputStreamReader ( arg0 )  )  ;  StringBuffer loc1 = new StringBuffer (  )  ;  String loc2 ;  try { while  (  ( loc2 = loc0 . readLine (  )  )  != null )  { loc1 . append ( loc2 )  ;  } loc0 . close (  )  ;  } catch  ( IOException loc3 )  { } return loc1 . toString (  )  ;  } }
void function ( Object arg0 ,  Object arg1 )  { try { Collection < PropPanelFactory >  locFactories = new ArrayList <  >  ( ppfactories )  ;  for  ( PropPanelFactory locFactory : locFactories )  { if  ( locFactory . equals ( arg0 )  )  { ppfactories . remove ( locFactory )  ;  break ;  } } } catch  ( Exception e )  { } }
void function (  )  { SelectionKey loc0 = m_socketChannel . keyFor ( m_selectorManager . getSelector (  )  )  ;  if  ( loc0 != null )  { loc0 . interestOps ( loc0 . interestOps (  )  | SelectionKey . OP_WRITE )  ;  } m_selectorManager . enableWriteForChannelLater ( m_socketChannel )  ;  }
void function (  )  { long arg0 = TimeUnit . MINUTES . toMillis ( 1 )  ;  String loc0 = WebUtils . convertMsToClockTime ( arg0 )  ;  String loc1 = "00:01:00" ;  Assert . assertEquals ( loc1 ,  loc0 )  ;  }
public void function ( TerminalDevice arg0 )  { try { TerminalDevice loc0 = repository . save ( arg0 )  ;  } catch  ( Exception loc1 )  { System . out . println ( "Error occurred while saving the terminal device: " + loc1 . getMessage (  )  )  ;  } }
boolean function ( String arg0 ,  String arg1 ,  int arg2 )  { String loc0 = analyseTrack ( arg0 ,  arg1 ,  "track" )  ;  if  ( loc0 != null && !loc0 . isEmpty (  )  )  { errorLevel = arg2 ;  value = loc0 ;  return false ;  } return true ;  }
import org . mockito . Mockito ;  public class OSSUnderFileSystemTest { private OSSUnderFileSystem mOSSUnderFileSystem ;  private String PATH = "path" ;  private String BUCKET_NAME = "bucket" ;  private String BUCKET_PREFIX = "prefix" ;  private OSSClient mClient ;  private String DST = "dst" ;  private String SRC = "src" ;  public void function (  )  { OSSUnderFileSystem loc0 = Mockito . mock ( OSSUnderFileSystem . class )  ;  AlluxioURI loc1 = new AlluxioURI ( "uri" )  ;  } private void deleteNonRecursiveOnServiceException (  )  { } private void renameOnServiceException (  )  { } private void deleteRecursiveOnServiceException (  )  { } }
void function ( Object arg0 ,  Object arg1 ,  Object arg2 ,  Object arg3 )  { int loc0 = fldpos ( 0 ,  "fieldName" )  ;  if  ( loc0 != -1 )  { setVal ( loc0 ,  "fieldName" ,  new Constant ( "fieldValue" )  )  ;  } tx . unpin ( currentblk )  ;  }
EndpointReferenceType function (  )  { EndpointReferenceType loc0 = new EndpointReferenceType (  )  ;  loc0 . setAddress ( new AttributedURIType (  )  )  ;  return loc0 ;  }
String function (  )  { String loc0 = _on_symbol . name (  )  ;  int loc1 = _to_state . index (  )  ;  return "Convert to a string . " + loc0 + loc1 ;  }
float function ( Element arg0 ,  String arg1 ,  String arg2 )  { NodeList loc0 = arg0 . getElementsByTagName ( arg1 )  ;  Element loc1 =  ( Element )  loc0 . item ( 0 )  ;  String loc2 = loc1 . getAttribute ( arg2 )  ;  return Float . parseFloat ( loc2 )  ;  }
public Object function ( Object arg0 ,  Object arg1 ,  List arg2 ) 
void function ( String arg0 )  { url = arg0 ;  type = null ;  }
public class XMLElement { String name = null ;  Attributes attributes = null ;  StringBuffer text = new StringBuffer ( 100 )  ;  int getNumAttributes (  )  { } void resetText (  )  { } String getAttributeName ( int i )  { } String getAttribute ( String attribute )  { } String getAttributeValue ( int i )  { } String getText (  )  { } void setAttributes ( Attributes a )  { } void setName ( String n )  { } String getName (  )  { } void addText ( String t )  { } void addText ( char [  ]  c ,  int offset ,  int len )  { } void setText ( String t )  { } public int function (  )  { int loc0 = 0 ;  try { loc0 = text . toString (  )  . length (  )  ;  } catch  ( NullPointerException e )  { } return loc0 ;  } }
void function (  )  { try { function (  )  ;  m_sipProxy . start (  )  ;  m_turnServer . start (  )  ;  synchronized  ( this )  { wait (  )  ;  } } catch  ( InterruptedException e )  { e . printStackTrace (  )  ;  } }
void function ( SshDataReceivedEvent arg0 )  { System . out . println ( "srini_string" )  ;  System . out . print ( arg0 . getData (  )  )  ;  }
public int function ( T arg0 )  { int loc0 = counter . getOrDefault ( arg0 ,  0 )  ;  return loc0 ;  }
public static DAOWrapper function ( DAOWrapper daoWrapper ,  double arg0 ,  double arg1 )  { try { daoWrapper . builder (  )   . setCoordinateRadius ( daoWrapper . getLoc_radius (  )  )   . setCreatedTime ( daoWrapper . getCreated_at (  )  )   . setPlaceName ( daoWrapper . getPlace_name (  )  )   . addText ( daoWrapper . getText (  )  )   . addField ( "screen_name" ,  daoWrapper . getScreen_name (  )  )   . addField ( "user_name" ,  daoWrapper . getUser_name (  )  )   . addField ( "user_id" ,  daoWrapper . getUser_id (  )  )   . addField ( "id_str" ,  daoWrapper . getId_str (  )  )   . addField ( "image" ,  daoWrapper . getImage (  )  )   . setUserid ( daoWrapper . getUser_id (  )  )   . setImage ( daoWrapper . getImage (  )  )   . setIDstr ( daoWrapper . getId_str (  )  )   . setAuthor ( daoWrapper . getUser_name (  )  ,  "unknown" )   . addField ( "lng" ,  Double . toString ( arg0 )  )   . addField ( "lat" ,  Double . toString ( arg1 )  )   . buildFieldJSON (  )  ;  } catch  ( Exception e )  { } return daoWrapper ;  }
XYLocation function ( XYLocation loc0 )  { return loc0 . north (  )  ;  }
Collection < GrantedAuthority >  function (  )  { try { Collection < GrantedAuthority >  loc0 = new ArrayList <  >  (  )  ;  loc0 . add ( new SimpleGrantedAuthority ( "ROLE_USER" )  )  ;  loc0 . add ( new SimpleGrantedAuthority ( "ROLE_ADMIN" )  )  ;  return loc0 ;  } catch  ( Exception e )  { System . out . println ( "Error occurred while retrieving granted authorities: " + e . getMessage (  )  )  ;  return null ;  } }
public void function ( DenseMatrix64F arg0 ,  DenseMatrix64F arg1 )  { try { DenseMatrix64F loc0 = new DenseMatrix64F ( arg0 )  ;  DenseMatrix64F loc1 = this . getSeed (  )  ;  loc1 . set ( loc0 )  ;  this . setSeed ( loc1 )  ;  } catch ( Exception e )  { e . printStackTrace (  )  ;  } }
GetOfferDetailsResponse . Return . DetailOfferData . OfferMedia . OfferImage . Entry . Value . Item function (  )  { GetOfferDetailsResponse . Return . DetailOfferData . OfferMedia . OfferImage . Entry . Value . Item loc0 = new GetOfferDetailsResponse . Return . DetailOfferData . OfferMedia . OfferImage . Entry . Value . Item (  )  ;  loc0 . setArg0 ( arg0 )  ;  loc0 . setArg1 ( arg1 )  ;  loc0 . setArg2 ( arg2 )  ;  loc0 . setArg3 ( arg3 )  ;  return loc0 ;  }
Type findTypeByName ( String name )  { Type result = null ;  TopLevelResolver loc0 = head ;  while  ( loc0 != null )  { result = loc0 . resolveType ( name )  ;  if  ( result != null )  { break ;  } loc0 = loc0 . getNext (  )  ;  } return result ;  }
void function ( ResourceTypeHandler arg0 ,  String arg1 )  { try { extensionsAllowed . get ( arg0 )  . clear (  )  ;  if  ( arg1 != null )  { Set < String >  loc0 = new HashSet <  >  (  )  ;  String [  ]  loc1 = arg1 . split ( " , " )  ;  for  ( String ext : loc1 )  { loc0 . add ( ext . trim (  )  )  ;  } extensionsDenied . put ( arg0 ,  loc0 )  ;  } } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
public void function ( String arg0 )  { try { String loc0 = CACHE_KEY + " . " + arg0 ;  Element element = cache . get ( loc0 )  ;  if  ( element == null )  { element = new Element ( loc0 ,  "" )  ;  cache . put ( element )  ;  } } catch  ( Exception e )  { System . out . println ( "Error occurred while adding identifier to cache: " + e . getMessage (  )  )  ;  } }
void function ( CSP arg0 )  { DomainRestoreInfo loc0 = new DomainRestoreInfo (  )  ;  FIFOQueue loc1 = new FIFOQueue ( arg0 . getVariables (  )  . length )  ;  for  ( Constraint c : arg0 . getConstraints (  )  )  { if  ( c . getScope (  )  . length == 2 )  { loc1 . addLast ( c )  ;  } } while  ( !loc1 . isEmpty (  )  )  { Constraint c =  ( Constraint )  loc1 . removeFirst (  )  ;  Variable xi = c . getScope (  )  [ 0 ]  ;  Variable xj = c . getScope (  )  [ 1 ]  ;  if  ( revise ( xi ,  xj ,  c ,  arg0 ,  loc0 )  )  { if  ( xi . size (  )  == 0 )  { loc0 . restore ( arg0 )  ;  return ;  } for  ( Constraint tmp : xi . getConstraints (  )  )  { if  ( !tmp . equals ( c )  )  { Variable xk = tmp . getScope (  )  [ 1 ]  ;  if  ( !xk . equals ( xi )  )  { loc1 . addLast ( tmp )  ;  } } } } } loc0 . restore ( arg0 )  ;  }
double function ( Position pos )  { double altitude = 0 . 0 ;  try { altitude = pos . getAltitude (  )  ;  } catch  ( Exception e )  { System . out . println ( "Error getting altitude: " + e . getMessage (  )  )  ;  } return altitude ;  }
ArrayList < Object >  function ( int arg0 )  { try { Node valueNode =  ( Node )  values . get ( arg0 )  ;  Object loc0 = parseValue ( valueNode )  ;  if  ( loc0 instanceof Object [  ]  )  { return new ArrayList <  >  ( Arrays . asList (  ( Object [  ]  )  loc0 )  )  ;  } else { throw new RuntimeException ( "Result value is not an array . " )  ;  } } catch  ( Exception e )  { return null ;  } }
public void function ( Object arg0 ,  Object arg1 )  { try { Hardware instance = Hardware . getInstance (  ( Context )  arg0 )  ;  assertNotNull ( "Hardware instance should not be null" ,  instance )  ;  instance . autodetect (  ( Context )  arg0 )  ;  boolean hasPenDigitizer = instance . mHasPenDigitizer ;  boolean hasPressureSensor = instance . hasPressureSensor (  )  ;  if  ( hasPenDigitizer && hasPressureSensor )  { } else { } } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
int function ( Parcel arg0 ,  boolean arg1 )  { int result = 0 ;  try { arg0 . writeInt ( arg1 ? 1 : 0 )  ;  } catch  ( Exception loc0 )  { result = -1 ;  } return result ;  }
void function ( EndpointResolver arg0 )  { try { resolvers . remove ( arg0 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
PrintStream function (  )  { PrintStream loc0 = debugGui . getConsole (  )  . getErr (  )  ;  function (  )  ;  return loc0 ;  }
int function ( NetworkParameters arg0 )  { int loc0 = 0 ;  try { loc0 = arg0 . getInterval (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
public Object function (  )  { ObjectFactory factory = new ObjectFactory (  )  ;  try { ComplexNode loc0 = factory . createComplexNode (  )  ;  return loc0 ;  } catch  ( Exception loc1 )  { System . err . println ( "Failed to create an instance of ComplexNode: " + loc1 . getMessage (  )  )  ;  return null ;  } }
public void function ( ArrayList < CanonicalGene >  arg0 )  { try { this . genes_in_ROI = arg0 ;  } catch  ( Exception e )  { System . out . println ( "Error setting genes in ROI: " + e . getMessage (  )  )  ;  } }
public static void function ( final Callable < ? >  arg0 ,  int arg1 )  { try { Future < ? >  loc0 = WaitForAsyncUtils . asyncFx ( arg0 )  ;  WaitForAsyncUtils . waitFor ( arg1 ,  TimeUnit . SECONDS ,  loc0 )  ;  WaitForAsyncUtils . waitForFxEvents (  )  ;  } catch  ( Exception e )  { throw new RuntimeException ( "Exception occurred while executing the Callable in the JavaFX thread" ,  e )  ;  } }
public void function ( String arg0 )  { try { this . add ( arg0 )  ;  } catch ( Exception loc0 )  { System . out . println ( "Failed to add string to log: " + loc0 . getMessage (  )  )  ;  } }
public static int function ( int arg0 ,  int arg1 )  { int loc0 = 0 ;  try { loc0 = arg0 * arg1 ;  } catch  ( Exception e )  { loc0 = 0 ;  } return 0xCafe123 ;  }
import java . util . Random ;  public class IceTieBreaker { private Random s_random = new Random (  )  ;  private byte [  ]  m_byteArray = new byte [ 8 ]  ;  byte [  ]  function ( int arg0 ,  int arg1 ,  long arg2 )  { s_random . setSeed ( arg0 + arg1 + arg2 )  ;  for  ( int loc0 = 0 ;  loc0  <  8 ;  loc0 ++  )  { m_byteArray [ loc0 ]  =  ( byte )  s_random . nextInt (  )  ;  } return m_byteArray ;  } }
public void function ( BigDecimal arg0 )  { BigDecimal loc0 = arg0 ;  setFileCount ( loc0 )  ;  }
int function (  )  { int loc0 = 0 ;  try { loc0 = getNumSteps (  )  * step / 100 ;  } catch  ( ArithmeticException e )  { System . out . println ( "An integer between 0 and 100 is expected" )  ;  e . printStackTrace (  )  ;  } return loc0 ;  }
public BrowseOffersResponse . Return . OfferData . Geo . Region function ( Object arg0 ,  Object arg1 )  { BrowseOffersResponse browseOffersResponse = createBrowseOffersResponse (  )  ;  BrowseOffersResponse . Return browseOffersResponseReturn = createBrowseOffersResponseReturn (  )  ;  BrowseOffersResponse . Return . OfferData browseOffersResponseReturnOfferData = createBrowseOffersResponseReturnOfferData (  )  ;  BrowseOffersResponse . Return . OfferData . Geo browseOffersResponseReturnOfferDataGeo = createBrowseOffersResponseReturnOfferDataGeo (  )  ;  BrowseOffersResponse . Return . OfferData . Geo . Region browseOffersResponseReturnOfferDataGeoRegion = browseOffersResponseReturnOfferDataGeo . createRegion (  )  ;  BrowseOffersResponse . Return . OfferData . Geo . Region . Country browseOffersResponseReturnOfferDataGeoRegionCountry = createBrowseOffersResponseReturnOfferDataGeoRegionCountry (  )  ;  return browseOffersResponseReturnOfferDataGeoRegion ;  }
int function ( int arg0 )  { int loc0 = 0 ;  try { loc0 = socketFactory . createSocket (  )  . getLocalPort (  )  ;  } catch  ( Exception loc1 )  { loc0 = arg0 ;  } return loc0 ;  }
void function (  )  { Set < Item >  loc0 = invMap . keySet (  )  ;  System . out . println ( "Inventory List:" )  ;  for  ( Item loc1 : loc0 )  { System . out . println ( loc1 . getUnlocalizedName (  )  + " : " + invMap . get ( loc1 )  )  ;  } }
void function ( FileSizeComparable arg0 ,  long arg1 ) { length = arg0 ;  new File ( path )  . setLastModified ( arg1 )  ;  } In this method ,  we are setting the length of a book object to the value of arg0 and the last modified time of its corresponding file to the value of arg1 . 
LanguageVersion function ( File arg0 )  { List < Language >  loc0 = getLanguagesForFile ( arg0 )  ;  if  ( !loc0 . isEmpty (  )  )  { Language loc1 = loc0 . get ( 0 )  ;  LanguageVersion loc2 = getDefaultLanguageVersion ( loc1 )  ;  return loc2 ;  } return null ;  }
void function (  )  { try { System . out . println ( "Testing getImage (  )  method .  .  . " )  ;  Device loc0 = new Device (  )  ;  loc0 . addCapability ( "testCap" ,  "testValue" )  ;  BufferedImage loc1 = loc0 . getImage (  )  ;  assertNotNull ( loc1 )  ;  assertEquals ( 100 ,  loc1 . getWidth (  )  )  ;  assertEquals ( 200 ,  loc1 . getHeight (  )  )  ;  System . out . println ( "getImage (  )  method test passed successfully!" )  ;  } catch  ( Exception e )  { fail ( "getImage (  )  method test failed: " + e . getMessage (  )  )  ;  } }
public int function ( int arg0 ,  String arg1 )  { int loc0 = -1 ;  // default value for dummy txid try { loc0 = op (  )  ;  // update txid with actual value loc0 = writeToLog (  )  ;  // update txid with actual value } catch  ( Exception e )  { undo ( loc0 )  ;  // undo any changes made by the operation System . err . println ( "An error occurred: " + e . getMessage (  )  )  ;  } finally { redo ( loc0 )  ;  // redo any changes made by the operation } return loc0 ;  }
public Builder function ( NetworkSegment arg0 )  { Builder loc0 = Builder . fromNetworkSegment ( arg0 )  ;  return loc0 ;  }
void function (  )  { try { int loc0 = 0 ;  LogEntryInterval loc1 = new LogEntryInterval (  )  ;  loc1 . setNumberRequests ( loc0 )  ;  System . out . println ( "Test of setNumberRequests method ,  of class LogEntryInterval . " )  ;  } catch ( Exception e )  { } }
import java . io . InputStream ;  import java . io . InputStreamReader ;  import java . io . Reader ;  public class IOUtils { public static Reader function ( String arg0 ,  int arg1 )  { InputStream loc0 = IOUtils . class . getResourceAsStream ( arg0 )  ;  return new InputStreamReader ( loc0 )  ;  } }
void function (  )  { DataNettyBuffer dataNettyBuffer = new DataNettyBuffer (  )  ;  ByteBuf loc0 = Unpooled . buffer ( LENGTH )  ;  loc0 . writeInt ( 42 )  ;  dataNettyBuffer . mBuffer = loc0 ;  ByteBuffer loc1 = dataNettyBuffer . getReadOnlyByteBuffer (  )  ;  assertTrue ( loc1 . isReadOnly (  )  )  ;  assertEquals ( LENGTH ,  loc1 . limit (  )  )  ;  ByteBuffer loc2 = dataNettyBuffer . nioBuffer (  )  ;  assertTrue ( loc2 . isReadOnly (  )  )  ;  assertEquals ( 0 ,  loc2 . position (  )  )  ;  assertEquals ( LENGTH ,  loc2 . limit (  )  )  ;  assertEquals ( 42 ,  loc2 . getInt (  )  )  ;  }
boolean function ( String arg0 )  { String loc0 = _baseURL + arg0 ;  ImageResource loc1 = _imageCache . get ( loc0 )  ;  if  ( loc1 == null )  { loc1 = getImageResource ( loc0 )  ;  if  ( loc1 != null )  { _imageCache . put ( loc0 ,  loc1 )  ;  } } return loc1 != null ;  }
void function ( Object arg0 ,  Json arg1 ,  JsonValue arg2 ,  ArrayList < String >  arg3 )  { Class < ? >  loc0 = arg0 . getClass (  )  ;  Field [  ]  loc1 = loc0 . getFields (  )  ;  for  ( Field loc2 : loc1 )  { if  ( arg3 . contains ( loc2 . getName (  )  )  )  { continue ;  } System . out . println ( "Serializing field: " + loc2 . getName (  )  )  ;  Object loc3 ;  try { loc3 = loc2 . get ( arg0 )  ;  } catch  ( IllegalAccessException e )  { continue ;  } arg1 . writeValue ( loc2 . getName (  )  ,  loc3 ,  arg2 )  ;  } }
List < MeanValue >  function (  )  { List < MeanValue >  loc0 = new ArrayList <  >  (  )  ;  try { loc0 = Collections . unmodifiableList ( metrics )  ;  } catch  ( NullPointerException e )  { System . err . println ( "metrics is null" )  ;  } return loc0 ;  }
public void function (  )  { try { AttackModel (  )  ;  ChartObject (  )  ;  ChartObjectTest loc0 = new ChartObjectTest (  )  ;  Object arg0 = null ;  Object arg1 = null ;  Object loc1 = loc0 . createOverlaidChart ( arg0 ,  arg1 )  ;  assertNotNull ( loc1 )  ;  } catch  ( Exception loc2 )  { } }
int function ( String arg0 ,  int arg1 ,  int arg2 )  { int loc0 = arg1 ;  int loc1 = 0 ;  while  ( loc0  <  arg2 )  { char loc2 = arg0 . charAt ( loc0 )  ;  if  ( !Character . isDigit ( loc2 )  )  { break ;  } loc1 ++  ;  loc0 ++  ;  } return loc1 ;  }
public int function (  )  { try { int loc0 = this . x ;  return loc0 ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  return 0 ;  } }
void function ( Long arg0 )  { try { testId = arg0 ;  } catch  ( Exception e )  { } }
void function ( Object arg0 ,  View arg1 ,  AccessibilityEvent arg2 )  { IMPL . onInitializeAccessibilityEvent ( arg0 ,  arg1 ,  arg2 )  ;  }
int function ( boolean arg0 )  { int loc0 = 0 ;  char loc1 = getType (  )  ;  if  ( Character . isDigit ( loc1 )  )  { loc0 = Character . digit ( loc1 ,  10 )  ;  if  ( arg0 )  { consume (  )  ;  } while  ( Character . isDigit ( getType (  )  )  )  { loc0 = loc0 * 10 + Character . digit ( getType (  )  ,  10 )  ;  if  ( arg0 )  { consume (  )  ;  } } return loc0 ;  } return 0 ;  }
String function (  )  { String loc0 = null ;  try { loc0 = getActValue (  )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
EaseUserProfileProvider function (  )  { return userProvider ;  }
public void function ( int arg0 )  { try { int loc0 = arg0 ;  this . value = loc0 ;  } catch  ( Exception e )  { System . out . println ( "An error occurred while setting the value of the internal integer: " + e . getMessage (  )  )  ;  } }
void function (  )  { HashMap < String ,  Object >  loc0 = new HashMap <  >  (  )  ;  loc0 . put ( Notification . NOTIFICATION_KEY_TITLE ,  null )  ;  Event arg0 = new Event ( Notification . TOPIC ,  loc0 )  ;  try { NotificationController loc1 = new NotificationController ( mockServerSession ,  mockServerMessage )  ;  loc1 . handleEvent ( arg0 )  ;  fail ( "Expected IllegalArgumentException to be thrown" )  ;  } catch  ( IllegalArgumentException e )  { } }
String function ( Module module )  { String moduleNameValue = null ;  try { moduleNameValue = module . getModuleName (  )  ;  } catch  ( Exception e )  { System . err . println ( "Error getting moduleName property value: " + e . getMessage (  )  )  ;  } return moduleNameValue ;  }
boolean function ( Class < ? >  arg0 )  { try { if  ( PRIMITIVE_TO_WRAPPER_TYPE . containsKey ( arg0 )  || WRAPPER_TO_PRIMITIVE_TYPE . containsKey ( arg0 )  )  { return true ;  } else { return false ;  } } catch  ( NullPointerException loc0 )  { return false ;  } }
double function ( DenseMatrix64F arg0 )  { D1Matrix64F loc0 = arg0 ;  double loc1 = normF ( loc0 )  ;  double loc2 = loc0 . getNumElements (  )  ;  double loc3 = 1 . 0 / loc1 ;  loc0 . div ( loc3 )  ;  return loc1 ;  }
void function ( TSTNode arg0 ,  String arg1 )  { ArrayList < String >  al = new ArrayList < String >  (  )  ;  traverse ( arg0 ,  arg1 )  ;  for  ( String loc0 : al )  { System . out . println ( loc0 )  ;  } }
ExceptionListener function (  )  { ExceptionListener loc0 = exceptionListener ;  return loc0 ;  }
void function (  )  { String loc0 = NetworkAddressUtils . getLocalHostName (  )  ;  mHostname = loc0 ;  LOG . info ( "Sets hostname: {}" ,  loc0 )  ;  }
void function ( CardAction arg0 ,  Image arg1 ,  Card arg2 )  { CardAction loc0 = arg0 . copy (  )  ;  loc0 . update ( arg1 )  ;  loc0 . update ( arg2 )  ;  loc0 . write ( JsonFactory . json )  ;  }
public Map < String ,  String >  function (  )  { Map < String ,  String >  result = new HashMap <  >  (  )  ;  try { result = this . attributes ;  } catch  ( Exception e )  { } return result ;  }
BigDecimal function ( BigDecimal arg0 )  { BigDecimal loc0 = new BigDecimal ( arg0 . toString (  )  )  ;  BigDecimal feedId = loc0 ;  return feedId ;  }
import org . ejml . data . DenseMatrix64F ;  import org . ejml . interfaces . decomposition . EigenDecomposition ;  public class SimpleEVD { DenseMatrix64F mat ;  EigenDecomposition < DenseMatrix64F >  eig ;  T getEigenVector ( int index )  { return eig . getEigenVector ( index )  ;  } EigenDecomposition getEVD (  )  { return eig ;  } int getNumberOfEigenvalues (  )  { return eig . getNumberOfEigenvalues (  )  ;  } int getIndexMax (  )  { return eig . getIndexMax (  )  ;  } int getIndexMin (  )  { return eig . getIndexMin (  )  ;  } double quality (  )  { return eig . quality (  )  ;  } public double function ( int arg0 )  { return eig . getEigenvalue ( arg0 )  ;  } }
CoordinatorStore function ( Object arg0 ,  Object arg1 )  { CoordinatorStore loc0 = null ;  try { loc0 = CoordinatorStore . newCoordinatorStore (  )  ;  loc0 . beginTransaction (  )  ;  return loc0 ;  } catch  ( Exception e )  { throw new StoreException ( ErrorCode . E0600 ,  "Error creating coordinator store: " + e . getMessage (  )  ,  e )  ;  } finally { if  ( loc0 != null )  { try { if  ( shouldCommitChanges (  )  )  { loc0 . commitTransaction (  )  ;  } loc0 . close (  )  ;  } catch  ( Exception e )  { throw new StoreException ( ErrorCode . E0600 ,  "Error closing coordinator store: " + e . getMessage (  )  ,  e )  ;  } } } }
public void function ( long arg0 )  { try { StoredTransactionOutput out = transactionOutputMap . get ( new StoredTransactionOutPoint ( hash ,  arg0 )  )  ;  if  ( out != null )  { removeUnspentTransactionOutput ( out )  ;  } } catch  ( Exception e )  { System . err . println ( "An exception occurred while executing function: " + e . getMessage (  )  )  ;  e . printStackTrace (  )  ;  } }
public Script createOpReturnScript ( byte [  ]  data )  { checkArgument ( data != null ,  "Data cannot be null" )  ;  ScriptBuilder builder = new ScriptBuilder (  )  ;  builder . op ( OP_RETURN )  ;  builder . data ( data )  ;  Script script = builder . build (  )  ;  return script ;  }
Class < ? extends Service >  function (  )  { return SchedulerService . class ;  }
public void function ( String arg0 ,  String arg1 )  { try { IdentityProviderMgtServiceStub loc0 = this . idPMgtStub ;  String loc1 = arg0 ;  IdentityProvider loc2 = loc0 . getIdPByName ( loc1 )  ;  if  ( loc2 != null )  { loc0 . deleteIdP ( loc1 )  ;  this . log . info ( "Identity Provider " + loc1 + " deleted successfully . " )  ;  } else { this . log . warn ( "Identity Provider " + loc1 + " not found in the tenant . " )  ;  } } catch  ( RemoteException e )  { this . log . error ( "Error while deleting Identity Provider " + arg0 + ": " + e . getMessage (  )  ,  e )  ;  throw new RuntimeException ( "Error while deleting Identity Provider " + arg0 + ": " + e . getMessage (  )  ,  e )  ;  } }
boolean function (  )  { return debugGui . isVisible (  )  ;  }
public static Document function ( String arg0 )  { Document loc0 = null ;  try { DocumentBuilderFactory loc1 = DocumentBuilderFactory . newInstance (  )  ;  loc1 . setNamespaceAware ( true )  ;  DocumentBuilder loc2 = loc1 . newDocumentBuilder (  )  ;  loc0 = loc2 . parse ( new InputSource ( new StringReader ( arg0 )  )  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
int function ( int arg0 )  { long INT_MASK = 0xffffffffL ;  long loc0 =  ( long )  arg0 & INT_MASK ;  if  ( loc0  < = 0x7fffffffL )  { return  ( int )  loc0 ;  } else { return -1 ^  ( int )   ( loc0 - 1L  <  <  32 )  ;  } }
public static String function ( ParameterDirectionKindEnum arg0 )  { String loc0 = arg0 . literalName ;  if  ( loc0 == null )  { throw new IllegalArgumentException ( "No literal name for enumeration value " + arg0 )  ;  } return loc0 ;  }
void function (  )  { prepare (  )  ;  String arg0 = "unknown_issuer" ;  ServerConfiguration loc0 = service . getServerConfiguration ( arg0 )  ;  assertThat ( loc0 ,  is ( nullValue (  )  )  )  ;  getServerConfiguration_success (  )  ;  }
void function ( IdentityProvider arg0 )  { try { updateResidentIdP ( arg0 )  ;  } catch  ( Exception loc0 )  { String loc1 = "Error occurred while updating Identity Provider: " + arg0 . getIdentityProviderName (  )  ;  log . error ( loc1 ,  loc0 )  ;  throw new RuntimeException ( loc1 ,  loc0 )  ;  } }
boolean function ( final HttpParams arg0 )  { try { if  ( arg0 == null )  { throw new IllegalArgumentException ( "HTTP parameters may not be null" )  ;  } boolean loc0 = arg0 . getBooleanParameter ( NIOReactorPNames . INTEREST_OPS_QUEUEING ,  false )  ;  return loc0 ;  } catch  ( IllegalArgumentException ex )  { return false ;  } }
String function ( String arg0 )  { try { String loc0 = "urn:oasis:names:tc:xacml:1 . 0:policy-combining-algorithm:first-applicable" ;  setGlobalPolicyAlgorithm ( loc0 )  ;  return getDecision ( arg0 )  ;  } catch  ( Exception loc1 )  { String loc2 = loc1 . getMessage (  )  ;  handleException ( "Error occurred while setting global policy combining algorithm: " + loc2 ,  loc1 )  ;  return null ;  } }
byte [  ]  function ( int arg0 )  { byte [  ]  loc0 ;  switch  ( arg0 )  { case 0xd9b4bef9: loc0 = new byte [  ]  {  ( byte )  0xf9 ,   ( byte )  0xbe ,   ( byte )  0xb4 ,   ( byte )  0xd9 } ;  break ;  case 0xfabfb5da: loc0 = new byte [  ]  {  ( byte )  0xda ,   ( byte )  0xb5 ,   ( byte )  0xbf ,   ( byte )  0xfa } ;  break ;  case 0x0b110907: loc0 = new byte [  ]  {  ( byte )  0x07 ,   ( byte )  0x09 ,   ( byte )  0x11 ,   ( byte )  0x0b } ;  break ;  default: throw new RuntimeException ( "Unknown packet header bytes: " + Integer . toHexString ( arg0 )  )  ;  } return loc0 ;  }
Map < String ,  String >  function (  )  { Map < String ,  String >  loc0 = new LinkedHashMap <  >  (  )  ;  String loc1 = currentValue . trim (  )  ;  if  ( loc1 . isEmpty (  )  )  { return loc0 ;  } List < String >  loc2 = getStrings (  )  ;  if  ( spaceDelimited )  { loc2 = getStrings ( SPACE_DELIMITED )  ;  } for  ( String loc3 : loc2 )  { String [  ]  loc4 = loc3 . split ( "=" ,  2 )  ;  if  ( loc4 . length != 2 )  { continue ;  } String loc5 = loc4 [ 0 ]  . trim (  )  ;  if  ( !caseSensitive )  { loc5 = loc5 . toLowerCase (  )  ;  } loc0 . put ( loc5 ,  loc4 [ 1 ]  . trim (  )  )  ;  } return loc0 ;  }
String function ( HttpServletRequest arg0 ,  IssuerServiceResponse arg1 )  { String loc0 = null ;  try { loc0 = arg1 . getIssuer (  )  ;  } catch  ( Exception loc1 )  { } if  ( loc0 == null || loc0 . isEmpty (  )  )  { loc0 = this . issuer ;  } return loc0 ;  }
public Object function ( Object arg0 )  { try { Object loc0 = getClass (  )  . newInstance (  )  ;  return loc0 ;  } catch  ( InstantiationException loc1 )  { throw ScriptRuntime . throwAsScriptRuntimeEx ( loc1 )  ;  } catch  ( IllegalAccessException loc2 )  { throw ScriptRuntime . throwAsScriptRuntimeEx ( loc2 )  ;  } }
BigInteger function (  )  { try { KeyPair loc0 = generateKeyPair (  )  ;  byte [  ]  loc1 = loc0 . getPublic (  )  . getEncoded (  )  ;  return new BigInteger ( loc1 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
public long function (  )  { long loc0 = 0 ;  try { loc0 = function (  )  ;  } catch  ( Exception loc1 )  { System . out . println ( "An error occurred while getting the Entrez Gene ID for Gene A: " + loc1 . getMessage (  )  )  ;  } return loc0 ;  }
String function ( Repository arg0 ,  RepositoryModel arg1 ,  String arg2 )  { String loc0 = StringUtils . escapeForHtml ( arg2 )  ;  loc0 = processTextRegex ( arg0 ,  arg1 . getName (  )  ,  loc0 )  ;  loc0 = StringUtils . breakLinesForHtml ( loc0 )  ;  return loc0 ;  }
Double function ( String arg0 ,  String arg1 )  { Double dist = null ;  List < String >  loc0Links = getLocationsLinkedTo ( arg0 )  ;  if  ( loc0Links != null && loc0Links . contains ( arg1 )  )  { dist = links . getWeight ( arg0 ,  arg1 )  ;  } return dist ;  }
JsonElement function ( Set < String >  arg0 ,  boolean arg1 )  { try { if  ( arg0 == null || arg0 . isEmpty (  )  )  { return JsonNull . INSTANCE ;  } else { Gson loc0 = gson ;  if  ( arg1 )  { loc0 = new GsonBuilder (  )  . serializeNulls (  )  . create (  )  ;  } return loc0 . toJsonTree ( arg0 ,  new TypeToken < Set < String >  >  (  )  {} . getType (  )  )  ;  } } catch  ( Exception loc1 )  { logger . error ( "Failed to translate set to JSON array" ,  loc1 )  ;  return null ;  } }
class SoftInputUtil { static void function ( Context arg0 ,  View arg1 )  { try { InputMethodManager loc0 =  ( InputMethodManager )  arg0 . getSystemService ( Context . INPUT_METHOD_SERVICE )  ;  loc0 . showSoftInput ( arg1 ,  InputMethodManager . SHOW_IMPLICIT )  ;  } catch  ( Exception loc1 )  { } } }
public Timestamp function (  )  { Timestamp loc0 = null ;  try { loc0 = this . receiptDate ;  } catch  ( Exception loc1 )  { } return loc0 ;  }
public Conduit function ( Object arg0 ,  Message arg1 )  { ConduitSelector loc0 = this . conduitSelector ;  if  ( loc0 != null )  { return loc0 . selectConduit ( arg1 )  ;  } else { HTTPConduit loc1 = this . getHttpConduit (  )  ;  return loc1 != null ? loc1 : null ;  } }
public static SpringChain function ( SpringConfig arg0 ,  SpringConfig arg1 )  { try { SpringChain loc0 = new SpringChain (  )  ;  loc0 . setControlSpringIndex ( -1 )  ;  loc0 . mMainSpringConfig = arg0 ;  loc0 . mAttachmentSpringConfig = arg1 ;  loc0 . mSprings . clear (  )  ;  loc0 . mListeners . clear (  )  ;  loc0 . registry . addSpringConfig ( arg0 ,  "default" )  ;  loc0 . registry . addSpringConfig ( arg1 ,  "attachment" )  ;  return loc0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
public String function ( GenericJSONBuilder builder ,  int arg0 )  { builder . setCoordinate ( this . lng ,  this . lat )   . setPlaceName ( this . place_name )   . addText ( this . text )   . setImage ( this . image )   . setUserid ( this . user_id )   . setCreatedTime ( this . created_at )   . addField ( "loc_radius" ,  Integer . toString ( loc_radius )  )   . addField ( "unknown_field" ,  "Not required" )  ;  return builder . buildFieldJSON (  )  ;  }
import java . util . List ;  import java . util . Map ;  import java . util . HashMap ;  public class Unifier { private SubstVisitor _substVisitor = new SubstVisitor (  )  ;  public Map < Variable ,  Term >  function ( FOLNode arg0 ,  FOLNode arg1 ,  Map < Variable ,  Term >  bindings )  { try { Map < Variable ,  Term >  loc0 = new HashMap <  >  ( bindings )  ;  Map < Variable ,  Term >  loc1 = new HashMap <  >  ( bindings )  ;  if  ( unify ( arg0 ,  arg1 ,  loc0 )  )  { return cascadeSubstitution ( loc0 ,  loc1 )  ;  } else { return null ;  } } catch  ( Exception e )  { return null ;  } } private boolean unify ( FOLNode x ,  FOLNode y ,  Map < Variable ,  Term >  theta )  throws Exception { } private List < ? extends FOLNode >  args ( FOLNode x )  { } private String op ( FOLNode x )  { } private Map < Variable ,  Term >  cascadeSubstitution ( Map < Variable ,  Term >  theta ,  Variable var ,  Term x )  { } private Map < Variable ,  Term >  unifyOps ( String x ,  String y ,  Map < Variable ,  Term >  theta )  { } private boolean occurCheck ( Map < Variable ,  Term >  theta ,  Variable var ,  FOLNode x )  { } private boolean isCompound ( FOLNode x )  { } private Map < Variable ,  Term >  unifyVar ( Variable var ,  FOLNode x ,  Map < Variable ,  Term >  theta )  { } }
String function (  @ Nonnull PublicKey arg0 )  { MessageDigest loc0 ;  byte [  ]  loc1 ;  try { loc0 = MessageDigest . getInstance ( "SHA-256" )  ;  loc0 . update ( arg0 . getEncoded (  )  )  ;  loc1 = loc0 . digest (  )  ;  } catch  ( NoSuchAlgorithmException e )  { throw new RuntimeException ( "Error: " + e . getMessage (  )  )  ;  } return new String ( loc1 )  ;  }
public TiledMapTileLayer function ( String arg0 ,  String arg1 )  { RpgMap loc0 = RpgMap . getInstance (  )  ;  TiledMap loc1 = loc0 . getMap (  )  ;  TiledMapTileLayer loc2 =  ( TiledMapTileLayer )  loc1 . getLayers (  )  . get ( arg1 )  ;  return loc2 ;  }
import javax . xml . transform . * ;  import javax . xml . transform . dom . DOMSource ;  import javax . xml . transform . stream . StreamSource ;  import javax . xml . transform . stream . StreamResult ;  import javax . xml . parsers . * ;  import org . w3c . dom . * ;  public class Convert { public static Document function ( Source arg0 )  { try { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance (  )  ;  DocumentBuilder builder = factory . newDocumentBuilder (  )  ;  if  ( arg0 instanceof DOMSource )  { Node node =  (  ( DOMSource )  arg0 )  . getNode (  )  ;  if  ( node instanceof Document )  { return  ( Document )  node ;  } } InputSource inputSource = toInputSource ( arg0 )  ;  Document doc = builder . newDocument (  )  ;  TransformerFactory tfactory = TransformerFactory . newInstance (  )  ;  Transformer transformer = tfactory . newTransformer (  )  ;  transformer . transform ( inputSource ,  new DOMResult ( doc )  )  ;  return doc ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } } private static InputSource toInputSource ( Source arg0 )  throws TransformerException { if  ( arg0 instanceof StreamSource )  { StreamSource streamSource =  ( StreamSource )  arg0 ;  if  ( streamSource . getInputStream (  )  != null )  { return new InputSource ( streamSource . getInputStream (  )  )  ;  } else if  ( streamSource . getReader (  )  != null )  { return new InputSource ( streamSource . getReader (  )  )  ;  } else { return new InputSource ( streamSource . getSystemId (  )  )  ;  } } else if  ( arg0 instanceof SAXSource )  { SAXSource saxSource =  ( SAXSource )  arg0 ;  return saxSource . getInputSource (  )  ;  } else if  ( arg0 instanceof DOMSource )  { DOMSource domSource =  ( DOMSource )  arg0 ;  Node node = domSource . getNode (  )  ;  String systemId = domSource . getSystemId (  )  ;  if  ( node instanceof Document )  { return new InputSource ( systemId )  ;  } else { StringWriter sw = new StringWriter (  )  ;  TransformerFactory tfactory = TransformerFactory . newInstance (  )  ;  Transformer transformer = tfactory . newTransformer (  )  ;  transformer . transform ( domSource ,  new StreamResult ( sw )  )  ;  return new InputSource ( systemId )  ;  } } else { throw new IllegalArgumentException ( "Unknown source type: " + arg0 . getClass (  )  . getName (  )  )  ;  } } }
String function ( String arg0 )  { String loc0 = "subgraph " + arg0 + " {" ;  graph . append ( loc0 )  ;  return loc0 ;  }
public class CoAPServiceActivator implements BundleActivator { IEnvironments environments = null ;  HashMap < String ,  CoAPConnectionFactory >  factories = new HashMap < String ,  CoAPConnectionFactory >  (  )  ;  AutoSIMCoAPConfig config = null ;  public void start ( BundleContext context )  { } public void function ( BundleContext arg0 )  { for  ( AutoSIMConnectionConfig loc0 : config . connections )  { environments . deregisterConnectionFactory ( loc0 . name )  ;  factories . remove ( loc0 . name )  ;  } } public void stop ( BundleContext context )  { } }
boolean function ( String arg0 )  { AbstractPlugin loc0 = getByName ( arg0 )  ;  if  ( loc0 != null )  { return remove ( loc0 )  ;  } return false ;  }
production function ( arg0 )  { _the_production = arg0 ;  }
void function (  )  { setUp (  )  ;  String expected = "Expected string representation of Device object" ;  dev . setDeviceID ( "Device ID" )  ;  dev . setDeviceName ( "Device Name" )  ;  dev . setAddress ( "Device Address" )  ;  dev . setType ( "Device Type" )  ;  dev . addCapability ( "Capability 1" )  ;  dev . addCapability ( "Capability 2" )  ;  String result = dev . toString (  )  ;  System . out . println ( "Testing toString method .  .  . " )  ;  System . out . println ( "Expected result: " + expected )  ;  System . out . println ( "Actual result: " + result )  ;  assertEquals ( expected ,  result )  ;  fail ( "The test case is a prototype . " )  ;  tearDown (  )  ;  }
List < String >  function ( RefLogEntry refLogEntry )  { List < String >  loc0 = refLogEntry . getChangedRefs ( Constants . R_TAGS )  ;  return loc0 ;  }
Object function ( String arg0 ,  String arg1 )  { Object loc0 = json . get ( arg0 )  ;  if  ( loc0 instanceof String && arg1 != null )  { loc0 =  (  ( String )  loc0 )  . replaceAll ( arg1 ,  "" )  ;  } return loc0 ;  }
int [  ]  recordedMovement = ourInstance . recordedMovement ;  void function ( int arg0 )  { int [  ]  locRecordedMovement = recordedMovement ;  locRecordedMovement [ 4 ]  = locRecordedMovement [ 3 ]  ;  locRecordedMovement [ 3 ]  = locRecordedMovement [ 2 ]  ;  locRecordedMovement [ 2 ]  = locRecordedMovement [ 1 ]  ;  locRecordedMovement [ 1 ]  = locRecordedMovement [ 0 ]  ;  locRecordedMovement [ 0 ]  = arg0 ;  }
public void function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { try { Preconditions . checkState ( mNettyBuf != null ,  "Netty ByteBuf is null" )  ;  Preconditions . checkState ( mNettyBuf . refCnt (  )   >  0 ,  "Netty ByteBuf has already been released" )  ;  mNettyBuf . release (  )  ;  } catch  ( Exception e )  { System . err . println ( "An error occurred while releasing the Netty ByteBuf: " + e . getMessage (  )  )  ;  } }
void function (  )  { try { UnderStoreBlockInStream loc0 = new UnderStoreBlockInStream ( TEST_FILENAME ,  FILE_LENGTH ,  BLOCK_LENGTH )  ;  loc0 . before (  )  ;  skipInternal ( loc0 ,  0 )  ;  loc0 . after (  )  ;  loc0 . close (  )  ;  } catch  ( IOException loc1 )  { loc1 . printStackTrace (  )  ;  } }
BookPreview function ( Book arg0 )  { BookPreview loc0 = null ;  UUID loc1 = arg0 . getUUID (  )  ;  for  ( BookPreview loc2 : data )  { if  ( loc2 . getUUID (  )  . equals ( loc1 )  )  { loc0 = loc2 . getPreview (  )  ;  break ;  } } return loc0 ;  }
String function (  )  { int loc0 = getHour (  )  ;  int loc1 = getMinutes (  )  ;  double loc2 = getSeconds (  )  ;  int loc3 = getOffsetHours (  )  ;  int loc4 = getOffsetMinutes (  )  ;  int loc5 =  ( int )  Math . floor ( loc4 / 60 . 0 )  ;  int loc6 = loc4 % 60 ;  return String . format ( TIME_PATTERN ,  loc0 ,  loc1 ,  loc2 ,  loc3 ,  loc5 ,  loc6 )  ;  }
class FeedTestConfig { Long batchId ;  String feedId ;  Long testId ;  Long runId ;  void setBatchId ( Long batchId )  { this . batchId = batchId ;  } void setTestId ( Long testId )  { this . testId = testId ;  } Long getTestId (  )  { return this . testId ;  } void setRunId ( Long runId )  { this . runId = runId ;  } Long getBatchId (  )  { return this . batchId ;  } String toString (  )  { return "Batch ID: " + this . batchId + " ,  Test ID: " + this . testId + " ,  Run ID: " + this . runId + " ,  Feed ID: " + this . feedId ;  } Long getRunId (  )  { return this . runId ;  } String getFeedId (  )  { return this . feedId ;  } void function ( Long arg0 ,  String arg1 )  { try { this . feedId = arg1 ;  } catch  ( Exception loc0 )  { System . out . println ( "Error setting feed ID: " + loc0 . getMessage (  )  )  ;  } } }
void function (  )  { Object loc0 = new DateTest (  )  ;  Object loc1 = new DateTest (  )  ;  assertFalse ( loc0 . equals ( null )  )  ;  assertFalse ( loc0 . equals ( "not a DateTest instance" )  )  ;  assertTrue ( loc0 . equals ( loc1 )  )  ;  }
public AppStatus function ( AppInstanceStatus .  .  .  instances )  { Builder builder = AppStatus . of ( UUID . randomUUID (  )  . toString (  )  )  ;  for  ( AppInstanceStatus instance : instances )  { builder . with ( instance )  ;  } return builder . build (  )  ;  }
ViolationNode function ( String arg0 ,  int arg1 ,  int arg2 ,  int arg3 ,  int arg4 ,  String arg5 )  { ViolationNode loc0 = createViolationNode ( arg0 ,  arg1 ,  arg2 ,  arg3 ,  arg4 ,  arg5 )  ;  ViolationNode loc1 = createViolationNode ( arg0 ,  arg1 ,  arg2 ,  arg3 ,  arg4 ,  "differentVariableName" )  ;  assertFalse ( loc0 . equals ( loc1 )  )  ;  return loc0 ;  }
DataTypesHelperDecorator { void function ( Object arg0 ,  Object arg1 )  { impl . function ( arg0 ,  arg1 )  ;  } }
void function ( int arg0 )  { setNumRows ( arg0 )  ;  }
void function ( String arg0 )  { if  ( arg0 != null )  { RegPCLTestResultDetailsEntity loc0 = new RegPCLTestResultDetailsEntity (  )  ;  loc0 . setMessage ( arg0 )  ;  List < RegPCLTestResultDetailsEntity >  loc1 = new ArrayList <  >  (  )  ;  loc1 . add ( loc0 )  ;  setRegPclTestResultDetails ( loc1 )  ;  setOutcomeType ( OutcomeType . FAIL )  ;  setRunStatus ( RunStatusType . FINISHED )  ;  updateLastModifiedTimeStamp (  )  ;  } }
void function ( int arg0 ,  String arg1 )  { int loc0 = 1000000 ;  for  ( int i = 0 ;  i  <  loc0 ;  i ++  )  { String loc1 = randomString ( 10 )  ;  byte [  ]  loc2 = randomBytes ( 10 )  ;  stripPrefixIfPresent ( loc1 ,  "prefix" )  ;  stripSuffixIfPresent ( loc1 ,  "suffix" )  ;  listToString ( getUnixGroups ( "user" )  )  ;  listToString ( getGroups ( "userName" )  )  ;  getValueFromStaticMapping ( "mapping" ,  "key" )  ;  sleepMs ( 10 )  ;  } }
Locale [  ]  function (  )  { Locale [  ]  loc0 = new Locale [  ] {Locale . ENGLISH ,  Locale . FRENCH ,  new Locale ( "srini_string" ,  "srini_string" )  ,  Locale . GERMAN ,  Locale . ITALIAN ,  Locale . CHINESE ,  Locale . UK} ;  return loc0 ;  }
Instrumentation function (  )  { return instrumentation ;  }
public long function (  )  { long loc0 = System . currentTimeMillis (  )  ;  long loc1 = this . lastMark ;  this . lastMark = loc0 ;  return loc0 - loc1 ;  }
String function ( ConfigSetUpDTO config )  { String loc0 = "" ;  try { loc0 = config . getPclFeedId (  )  ;  } catch  ( NullPointerException e )  { loc1 = "Pcl feed id not found . " ;  } return loc0 ;  }
public int function (  )  { int loc0 = 0 ;  try { loc0 = this . elem3 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
public static String function (  )  { Selector selector = new Selector (  )  ;  String order = selector . getOrder (  )  ;  return order ;  }
Node function ( Node arg0 )  { if  ( arg0 == null || arg0 . next == null )  { return arg0 ;  } Node loc0 = function ( arg0 . next )  ;  arg0 . next . next = arg0 ;  arg0 . next = null ;  return loc0 ;  }
OpenFileOptions function ( CreateFileOptions arg0 )  { OpenFileOptions loc0 = OpenFileOptions . defaults (  )  ;  loc0 . setReadType ( ReadType . CACHE )  ;  loc0 . setReadType ( ReadType . NO_CACHE )  ;  if  ( arg0 . getAlluxioStorageType (  )  . isStore (  )  )  { loc0 . setStorageType ( StorageType . STORE )  ;  } else { loc0 . setStorageType ( StorageType . NO_PERSIST )  ;  } return loc0 ;  }
public Element function ( Element arg0 )  { EncryptedKeyElement loc0 = m_EncryptedKeyElement ;  if  ( loc0 == null )  { LOG . debug ( "m_EncryptedKeyElement is null" )  ;  return null ;  } Element loc1 = loc0 . getKeyInfo (  )  ;  if  ( loc1 == null )  { LOG . debug ( "Failed to get KeyInfo element of EncryptedKeyElement" )  ;  return null ;  } return loc1 . getElement ( arg0 . getNamespaceURI (  )  ,  arg0 . getLocalName (  )  )  ;  }
void function ( Message arg0 ,  AddressingProperties arg1 ,  boolean arg2 )  { try { org . apache . cxf . ws . addressing . ContextUtils . storeMAPs ( arg0 ,  arg1 ,  arg2 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
String function (  )  { String loc0 = mSettings . getPackageName (  )  ;  return "intent://" + loc0 + "/reload#Intent ; " + "scheme=http ; S . browser_fallback_url=http://" + DevServerHelper . DEVICE_LOCALHOST + "/reloadJSBundle . html" + "?platform=android&dev=true&minify=false" + "&hot=false&assetPlugin= ; end" ;  }
public class RequestInputTest { void function (  )  { try { String loc0 = RequestInput . getString ( "Enter a string:" ,  new String [  ] {"option1" ,  "option2"} )  ;  System . out . println ( loc0 )  ;  } catch  ( Exception loc1 )  { System . out . println ( "Test method for { @ link com . sqa . em . util . helper . RequestInput#getString ( java . lang . String , java . lang . String [  ]  ) } . " )  ;  } } }
String function (  )  { WorkflowJobBean loc0 = getWorkflow (  )  ;  String loc1 = loc0 . getGroup (  )  ;  return loc1 ;  }
public void function ( String arg0 ,  String arg1 )  { try { String loc0 = arg1 . trim (  )  ;  if  ( loc0 . isEmpty (  )  )  { throw new IllegalArgumentException ( "Invalid argument: moduleName cannot be empty" )  ;  } this . moduleName = loc0 ;  } catch  ( Exception e )  { System . out . println ( "Error setting moduleName: " + e . getMessage (  )  )  ;  } }
void function ( T arg0 )  { try { if  ( checkDuplicate ( arg0 )  )  { throw new IllegalStateException ( "Duplicate object found" )  ;  } if  ( !free ( arg0 )  )  { System . gc (  )  ;  // if the free list is full ,  the object will be garbage collected } } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function ( String correlationId ,  Object arg0 )  { try { RabbitMQMessage message =  ( RabbitMQMessage )  arg0 ;  message . setCorrelationId ( correlationId )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
import org . junit . Assert ;  public class PlainSaslServerTest { byte sSEPARATOR = 0x00 ;  ExpectedException mThrown = ExpectedException . none (  )  ;  PlainSaslServer mPlainSaslServer = null ;  void function (  )  { String user = "testuser" ;  String password = "testpassword" ;  byte [  ]  response = getUserInfo ( user ,  password )  ;  Callback [  ]  callbacks = new Callback [  ]  { new PasswordCallback ( "Password: " ,  false )  } ;  mPlainSaslServer . evaluateResponse ( response )  ;  userIsNotSet (  )  ;  passwordIsNotSet (  )  ;  authenticationNotComplete (  )  ;  handle ( callbacks )  ;  String expectedAuthID = user + " @ " + mPlainSaslServer . getMechanismName (  )  ;  Assert . assertEquals ( expectedAuthID ,  mPlainSaslServer . getAuthorizationID (  )  )  ;  } byte [  ]  getUserInfo ( String arg0 ,  String arg1 )  { return null ;  } void authenticationNotComplete (  )  { } void unauthorizedCallback (  )  { } void before (  )  { } void passwordIsNotSet (  )  { } void userIsNotSet (  )  { } void handle ( Callback [  ]  loc0 )  { } }
void function ( IParserEvent arg0 ,  IParserEventHandler arg1 )  { handlerStack . push ( handler )  ;  handler = arg1 ;  handleEvent ( arg0 )  ;  handler = handlerStack . pop (  )  ;  } This method pushes the current handler onto a stack ,  sets a new handler ,  handles an event using the new handler ,  and then restores the original handler by popping it from the stack .  There are no exception-handling statements in this method . 
List < TempTable >  function ( Scan arg0 )  { SortPlan plan = new SortPlan (  )  ;  plan . comp = new RecordComparator (  )  ;  plan . tx = new Transaction (  )  ;  plan . sch = new Schema (  )  ;  List < TempTable >  runs = null ;  List < TempTable >  result = null ;  try { plan . open (  )  ;  runs = plan . splitIntoRuns ( arg0 )  ;  plan . close (  )  ;  int numRuns = runs . size (  )  ;  while  ( numRuns  >  2 )  { result = new ArrayList < TempTable >  (  )  ;  for  ( int i = 0 ;  i  <  numRuns ;  i += 2 )  { if  ( i == numRuns - 1 )  { result . add ( runs . get ( i )  )  ;  } else { TempTable loc0 = runs . get ( i )  ;  TempTable loc1 = runs . get ( i + 1 )  ;  TempTable merged = plan . mergeTwoRuns ( loc0 ,  loc1 )  ;  result . add ( merged )  ;  } } runs = result ;  numRuns = runs . size (  )  ;  } if  ( numRuns == 2 )  { result = plan . doAMergeIteration ( runs )  ;  } else { result = runs ;  } } finally { if  ( plan != null )  { plan . close (  )  ;  } } return result ;  }
private void function (  )  { try { boolean loc0 = mSubject . isReadOnly (  )  ;  if  ( loc0 )  { throw new LoginException ( "Subject is read-only" )  ;  } Set < User >  loc1 = mSubject . getPrincipals ( User . class )  ;  loc1 . remove ( mUser )  ;  Callback [  ]  loc2 = {new LogoutCallback (  ) } ;  mCallbackHandler . handle ( loc2 )  ;  } catch  ( LoginException e )  { e . printStackTrace (  )  ;  } catch  ( UnsupportedCallbackException e )  { e . printStackTrace (  )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } }
public class Sharer { private String postId ;  private boolean shouldFailOnDataError ;  public void setShouldFailOnDataError ( boolean shouldFailOnDataError )  { this . shouldFailOnDataError = shouldFailOnDataError ;  } public boolean getShouldFailOnDataError (  )  { return this . shouldFailOnDataError ;  } public String function (  )  { try { if  ( postId == null )  { throw new Exception ( "Post ID is null . " )  ;  } return postId ;  } catch  ( Exception loc0 )  { if  ( shouldFailOnDataError )  { } return null ;  } } }
boolean function ( int arg0 )  { int [  ]  loc0 = getAcceptableAddressCodes (  )  ;  for  ( int loc1 = 0 ;  loc1  <  loc0 . length ;  loc1 ++  )  { if  ( arg0 == loc0 [ loc1 ]  )  { return true ;  } } return false ;  }
boolean function ( boolean arg0 )  { boolean loc0 = appendSemicolon ;  try { appendSemicolon = arg0 ;  } catch  ( Exception e )  { } boolean loc1 = appendSemicolon ;  appendSemicolon = loc0 ;  return loc1 ;  }
public void function (  )  { RMCTest . RMCParser rmc = new RMCTest . RMCParser (  )  ;  rmc . setMode ( RMCTest . RMCParser . MODE_AUTONOMOUS )  ;  String arg0 = "Expected FAA mode" ;  String arg1 = RMCTest . RMCParser . MODE_AUTONOMOUS ;  String loc0 = "Unexpected FAA mode" ;  String loc1 = rmc . getMode (  )  ;  assertEquals ( arg0 ,  arg1 ,  loc0 ,  loc1 )  ;  }
int function ( int arg0 )  { int loc0 = RecordPage . EMPTY ;  RecordPage . this . tx . pin ( RecordPage . this . blk )  ;  for  ( RecordPage . this . currentslot = 0 ;  RecordPage . this . currentslot  <  RecordPage . this . ti . recordLength (  )  ;  RecordPage . this . currentslot ++  )  { if  ( RecordPage . this . searchFor ( RecordPage . INUSE )  && RecordPage . this . currentId (  )  == arg0 )  { loc0 = RecordPage . INUSE ;  break ;  } } return loc0 ;  }
public String function ( String arg0 ,  String arg1 )  { String fieldName = null ;  if  ( lhs . equals ( rhs )  && lhs . isFieldName ( arg0 )  && rhs . isFieldName ( arg1 )  )  { fieldName = rhs . asFieldName (  )  ;  } return fieldName ;  }
public void function ( String arg0 )  { actValue = arg0 ;  }
DiffBuilder function ( Object arg0 )  { DiffBuilder loc0 = new DiffBuilder (  )  ;  loc0 . ignoreComments (  )  . ignoreWhitespace ( true )  ;  loc0 . withNodeFilter ( node - >  ! ( node instanceof Text && node . getTextContent (  )  . trim (  )  . isEmpty (  )  )  )  ;  loc0 . withNodeMatcher ( loc0 . nodeMatcher )  ;  loc0 . withAttributeFilter ( loc0 . attributeFilter )  ;  loc0 . withNamespaceContext ( loc0 . namespaceContext )  ;  loc0 . withComparisonController ( loc0 . comparisonController )  ;  loc0 . withDifferenceEvaluator ( loc0 . differenceEvaluator )  ;  loc0 . withComparisonListeners ( loc0 . comparisonListeners )  ;  loc0 . withDifferenceListeners ( loc0 . differenceListeners )  ;  loc0 . checkForIdentical ( loc0 . COMPARISON_RESULTS_TO_CHECK )  ;  loc0 . checkForSimilar ( loc0 . CHECK_FOR_SIMILAR )  ;  loc0 . compare ( arg0 )  ;  loc0 . normalizeWhitespace ( true )  ;  return loc0 ;  }
RegistryBasedTrustedServiceStore registryBasedTrustedServiceStore = new RegistryBasedTrustedServiceStore (  )  ;  String arg1 = "default" ;  // Assuming the default realm name String loc0 = arg1 ;  String [  ]  loc1 = registryBasedTrustedServiceStore . getTrustedServiceClaims ( loc0 )  ; 
boolean function ( String key ,  boolean defaultValue )  { boolean result = defaultValue ;  try { result = bundle . getBoolean ( key ,  defaultValue )  ;  } catch  ( Exception e )  { } return result ;  }
public boolean function ( String arg0 ,  String arg1 )  { String logLevel = arg0 . toUpperCase (  )  ;  String logMessage = arg1 ;  if  ( logLevels . containsKey ( logLevel )  )  { int level = logLevels . get ( logLevel )  ;  if  ( level  <  logFilter . getLogLevel (  )  )  { return false ;  } } if  ( noFilter )  { return true ;  } Matcher matcher = filterPattern . matcher ( logMessage )  ;  if  ( matcher . matches (  )  )  { String matchedString = matcher . group ( 1 )  ;  if  ( logFilter . getFilterPattern (  )  . matcher ( matchedString )  . matches (  )  )  { return true ;  } } return false ;  }
public static void function ( BufferedByteWriter writer ,  int arg0 )  { try { writer . ensureCapacity ( 4 )  ;  ByteBuffer byteBuffer = writer . mWriter ;  byteBuffer . putInt ( arg0 )  ;  byte [  ]  bytes = byteBuffer . array (  )  ;  writer . put ( bytes [ 0 ]  )  ;  writer . put ( bytes [ 1 ]  )  ;  writer . put ( bytes [ 2 ]  )  ;  writer . put ( bytes [ 3 ]  )  ;  } catch  ( Exception e )  { } }
public void function ( AuthenticationHolderEntity arg0 )  { Date loc0 = new Date (  )  ;  if  ( arg0 != null )  { loc0 = arg0 . getAuthentication (  )  . getAuthenticationDate (  )  ;  } setAuthenticationHolder ( arg0 )  ;  }
void function (  )  { Iterator < AbstractPlugin >  loc0 = singleton . iterator (  )  ;  while  ( loc0 . hasNext (  )  )  { AbstractPlugin loc1 = loc0 . next (  )  ;  loc1 . removePluginObserver (  )  ;  singleton . removePlugin ( loc1 )  ;  } }
void function ( float arg0 )  { weight = arg0 ;  }
void function ( final InetSocketAddress arg0 ,  final Channel arg1 )  { Preconditions . checkArgument ( arg1 . isActive (  )  ,  "Channel is not active . " )  ;  Preconditions . checkArgument ( NETTY_CHANNEL_POOL_MAP . containsKey ( arg0 )  ,  "Unknown server address . " )  ;  final NettyChannelPool loc0 = NETTY_CHANNEL_POOL_MAP . get ( arg0 )  ;  if  ( loc0 != null )  { loc0 . release ( arg1 )  ;  } }
String function (  )  { return conf . get ( "oozie . system . id" )  ;  }
public void function ( ArrayList < Parcelable >  arg0 ,  String arg1 )  { bundle . putParcelableArrayList ( arg1 ,  arg0 )  ;  return ;  }
public URIBuilder function (  )  { URIBuilder uriBuilder = new URIBuilder (  )  ;  String loc0 = "exampleFragment" ;  uriBuilder . fragment ( loc0 )  ;  return uriBuilder ;  }
void function ( long arg0 )  { maximumKeySize = arg0 ;  }
public static void function ( int arg0 ,  int arg1 )  { int loc0 = 0 ;  try { loc0 = Configuration . getInt ( PropertyKey . WORKER_SESSION_TIMEOUT_MS )  ;  } catch  ( Exception e )  { } if  ( loc0 != arg0 )  { } mSessionTimeoutMs = arg1 ;  SessionInfoTest session = new SessionInfoTest (  )  ;  session . constructor (  )  ;  session . timeout (  )  ;  try { session . constructorWithException (  )  ;  } catch  ( Exception e )  { } session . getSessionId (  )  ;  if  ( DELTA  <  MIN_LEN || DELTA  >  MAX_LEN )  { } }
Map < SpringConfig ,  String >  function (  )  { Map < SpringConfig ,  String >  loc0 = mSpringConfigMap ;  return Collections . unmodifiableMap ( loc0 )  ;  }
import java . text . SimpleDateFormat ;  import java . util . Date ;  import java . util . TimeZone ;  public class ELConstantsFunctions { long MB = KB * 1024 ;  int SUBMIT_DAYS = 24 * 60 ;  int SUBMIT_HOURS = 60 ;  long PB = TB * 1024 ;  long TB = GB * 1024 ;  long GB = MB * 1024 ;  int SUBMIT_MINUTES = 1 ;  long KB = 1024 ;  public String function (  )  { SimpleDateFormat dateFormat = new SimpleDateFormat ( "yyyy-MM-dd'T'HH:mm:ss'Z'" )  ;  dateFormat . setTimeZone ( TimeZone . getTimeZone ( "UTC" )  )  ;  Date currentDate = new Date (  )  ;  String formattedDate = dateFormat . format ( currentDate )  ;  return formattedDate ;  } public String trim ( String input )  { return input . trim (  )  ;  } public String concat ( String s1 ,  String s2 )  { return s1 . concat ( s2 )  ;  } public Object firstNotNull ( Object o1 ,  Object o2 )  { return o1 != null ? o1 : o2 ;  } public String urlEncode ( String input )  { return "" ;  } }
void function (  )  { try { m_log . info ( "Synchronizing directory contents .  .  . " )  ;  m_storedDirectoryContents = new HashSet <  >  ( m_newDirectoryContents )  ;  m_markedForRemoval = false ;  } catch  ( Exception loc0 )  { m_log . error ( "Error occurred while synchronizing directory contents: " + loc0 . getMessage (  )  ,  loc0 )  ;  } }
void function ( String arg0 ,  String arg1 )  { try { addTablesSQL ( arg0 ,  arg1 )  ;  } catch  ( Exception loc0 )  { System . err . println ( "Error occurred while adding tables SQL: " + loc0 . getMessage (  )  )  ;  } }
void function (  )  { try { individualStructures . clear (  )  ;  } catch ( Exception loc0 )  { System . out . println ( "An exception occurred while trying to clear the individual structures: " + loc0 . getMessage (  )  )  ;  } }
LanguageVersion function (  )  { LanguageVersion loc0 = this . languageVersion ;  return loc0 ;  }
SignatureProperties function (  )  { SignatureProperties loc0 = new SignatureProperties (  )  ;  loc0 . setSignatureAlgorithm ( WSConstants . RSA )  ;  loc0 . setSignatureDigestAlgorithm ( WSConstants . SHA1 )  ;  loc0 . setSignatureCanonicalizationAlgorithm ( WSConstants . C14N_EXCL_OMIT_COMMENTS )  ;  loc0 . setSignatureKeyIdentifier ( SecurityTokenConstants . KeyIdentifier_X509SubjectName )  ;  loc0 . setUseSingleCertificate ( true )  ;  loc0 . setCallbackHandler ( getCallbackHandler (  )  )  ;  loc0 . setCrypto ( getSignatureCrypto (  )  )  ;  loc0 . load ( getSignaturePropertiesFile (  )  )  ;  return loc0 ;  }
public class ModifyData { Predicate pred ;  String tblname ;  Expression newval ;  String fldname ;  String tableName (  )  { return tblname ;  } Expression newValue (  )  { return newval ;  } String targetField (  )  { return fldname ;  } Predicate function (  )  { return pred . function (  )  ;  } }
boolean function ( DenseMatrix64F arg0 )  { boolean loc0 = MatrixFeatures . isDiagonalPositive ( arg0 ,  TOL )  ;  return loc0 ;  }
void function ( ByteBuffer arg0 ,  int arg1 )  { int loc0 = arg1 & 0xFF ;  arg0 . putInt (  ( byte )  loc0 )  ;  }
public void function ( String loginName ,  Client client )  { try { UserSubject loc0 = new UserSubject ( loginName )  ;  this . subject = loc0 ;  this . client = client ;  this . preAuthorized = true ;  } catch  ( Exception e )  { System . out . println ( "Error occurred while setting subject: " + e . getMessage (  )  )  ;  } }
void function ( boolean arg0 ,  Object arg1 ,  int arg2 )  { setBreakOnExceptions ( arg0 )  ;  getMenubar (  )  ;  setSelected ( arg1 ,  arg2 )  ;  }
public float function ( int arg0 )  { float loc0 ,  loc1 ;  try { loc0 =  (  ( float ) arg0 / dotsPerInch )  * unitsPerInch ;  loc1 =  ( loc0 / dotsPerDeg )  + originLat ;  } catch  ( Exception e )  { System . out . println ( "An error occurred: " + e . getMessage (  )  )  ;  return 0 . 0f ;  } return loc1 ;  }
USAddress function (  )  { try { ObjectFactory objFactory = new ObjectFactory (  )  ;  return objFactory . createUSAddress (  )  ;  } catch  ( Exception loc0 )  { return null ;  } }
void function (  )  { Executor loc0 = MoreExecutors . renamingDecorator ( executor (  )  ,  new Supplier < String >  (  )  {  @ Override public String get (  )  { return serviceName (  )  ;  } } )  ;  loc0 . execute ( new Runnable (  )  {  @ Override public void run (  )  { try { startUp (  )  ;  notifyStarted (  )  ;  if  ( isRunning (  )  )  { try { AbstractExecutionThreadService . this . run (  )  ;  } catch  ( Throwable t )  { try { shutDown (  )  ;  } catch  ( Exception loc1 )  { logger . log ( Level . WARNING ,  "Error while attempting to shut down the service after failure . " ,  loc1 )  ;  } notifyFailed ( t )  ;  return ;  } } shutDown (  )  ;  notifyStopped (  )  ;  } catch  ( Throwable t )  { notifyFailed ( t )  ;  } } } )  ;  }
JSONObject function ( int arg0 )  { Object loc0 = mArray . get ( arg0 )  ;  return loc0 == null ? null : loc0 instanceof JSONObject ?  ( JSONObject )  loc0 : null ;  }
public class NaiveDeterminant { private static int [  ]  PermuteArray ( int [  ]  arr ,  int a ,  int b )  { int temp = arr [ a ]  ;  arr [ a ]  = arr [ b ]  ;  arr [ b ]  = temp ;  return arr ;  } private static double recursive ( DenseMatrix64F mat )  { int size = mat . numCols ;  double det = 0 ;  if  ( size == 1 )  { return mat . get ( 0 ,  0 )  ;  } else if  ( size == 2 )  { return mat . get ( 0 ,  0 )  * mat . get ( 1 ,  1 )  - mat . get ( 0 ,  1 )  * mat . get ( 1 ,  0 )  ;  } else { int [  ]  indices = new int [ size ]  ;  for  ( int i = 0 ;  i  <  size ;  i ++  )  { indices [ i ]  = i ;  } for  ( int i = 0 ;  i  <  size ;  i ++  )  { DenseMatrix64F submat = new DenseMatrix64F ( size - 1 ,  size - 1 )  ;  for  ( int j = 1 ;  j  <  size ;  j ++  )  { for  ( int k = 0 ;  k  <  size ;  k ++  )  { if  ( k  <  i )  { submat . set ( j - 1 ,  k ,  mat . get ( j ,  k )  )  ;  } else if  ( k  >  i )  { submat . set ( j - 1 ,  k - 1 ,  mat . get ( j ,  k )  )  ;  } } } det += Math . pow ( -1 ,  i )  * mat . get ( 0 ,  i )  * recursive ( submat )  ;  indices = next ( indices )  ;  } } return det ;  } public static double function ( DenseMatrix64F arg0 )  { int n = arg0 . numCols ;  int [  ]  indices = new int [ n ]  ;  for  ( int i = 0 ;  i  <  n ;  i ++  )  { indices [ i ]  = i ;  } double sum = 0 ;  do { int sign = 1 ;  for  ( int i = 0 ;  i  <  n ;  i ++  )  { for  ( int j = i + 1 ;  j  <  n ;  j ++  )  { if  ( arg0 . get ( i ,  indices [ i ]  )   >  arg0 . get ( j ,  indices [ j ]  )  )  { indices = PermuteArray ( indices ,  i ,  j )  ;  sign *= -1 ;  } } } double prod = 1 ;  for  ( int i = 0 ;  i  <  n ;  i ++  )  { prod *= arg0 . get ( i ,  indices [ i ]  )  ;  } sum += sign * prod ;  indices = next ( indices )  ;  } while  ( indices != null )  ;  return sum ;  } private static int [  ]  next ( int [  ]  indices )  { int n = indices . length ;  int i = n - 2 ;  while  ( i  > = 0 && indices [ i ]   > = indices [ i + 1 ]  )  { i --  ;  } if  ( i  <  0 )  { return null ;  } int j = n - 1 ;  while  ( indices [ i ]   > = indices [ j ]  )  { j --  ;  } indices = PermuteArray ( indices ,  i ,  j )  ;  int k = i + 1 ;  int l = n - 1 ;  while  ( k  <  l )  { indices = PermuteArray ( indices ,  k ,  l )  ;  k ++  ;  l --  ;  } return indices ;  } }
public Dish function ( String arg0 )  { Dish loc0 = null ;  try { loc0 = dishRepository . findBySiteUrlId ( arg0 )  ;  } catch  ( Exception loc1 )  { log . error ( "Error occurred while getting dish by site url: " + arg0 ,  loc1 )  ;  } return loc0 ;  }
String function (  )  { String uniqueId ;  try { java . rmi . server . UID uid = new java . rmi . server . UID (  )  ;  uniqueId = uid . toString (  )  ;  } catch  ( Exception e )  { uniqueId = null ;  } return uniqueId ;  }
void function (  )  { if  ( errorCount == 0 )  { return ;  } System . out . println ( "Flushing errors for " + name )  ;  flushed = true ;  errorCount = 0 ;  tooManyErrors ( null )  ;  }
void function ( ServiceID arg0 ,  int arg1 ,  int arg2 ,  InetAddress arg3 )  { long loc0 = generateXid (  )  ;  ServiceInfo loc1 = new ServiceInfo ( arg0 ,  arg1 ,  arg2 ,  arg3 )  ;  byte [  ]  loc2 = loc1 . toBytes (  )  ;  byte [  ]  loc3 = createRequestPacket ( loc0 ,  Constants . METHOD_ADD_SERVICE ,  loc2 )  ;  sendPacket ( loc3 )  ;  } Note: I assume that the methods "generateXid (  ) " ,  "ServiceInfo . toBytes (  ) " ,  "createRequestPacket (  ) " ,  and "sendPacket (  ) " are already defined elsewhere . 
public List < String >  function (  )  { List < String >  loc0 = new ArrayList <  >  (  )  ;  try { loc0 = registeredScopes . function (  )  ;  } catch  ( Exception loc1 )  { } return loc0 ;  }
void function ( File arg0 )  { try { TempFileUtils . traverseDir ( arg0 ,  new FileAction (  )  {  @ Override public void act ( File arg1 )  { arg1 . delete (  )  ;  } } )  ;  arg0 . delete (  )  ;  } catch  ( IOException e )  { String errorMessage = TempFileUtils . error ( "Error deleting directory" ,  e )  ;  TempFileUtils . LOG . error ( errorMessage )  ;  } }
String function ( String arg0 ,  String arg1 )  { String loc0 = arg0 + "#" + arg1 + " (  ) " ;  return loc0 ;  }
public void function ( boolean arg0 )  { valid = true ;  if  ( type == TYPE_BOOLEAN )  { valueBoolean = arg0 ;  } else if  ( type == TYPE_INTEGER_SIGNED )  { valueInteger =  ( int )  arg0 ;  } else if  ( type == TYPE_INTEGER_UNSIGNED )  { if  ( arg0 )  { valueInteger = 1 ;  } else { valueInteger = 0 ;  } } else if  ( type == TYPE_DOUBLE_SIGNED )  { valueDouble =  ( double )  arg0 ;  } else if  ( type == TYPE_DOUBLE_UNSIGNED )  { if  ( arg0 )  { valueDouble = 1 . 0 ;  } else { valueDouble = 0 . 0 ;  } } else if  ( type == TYPE_STRING )  { valueString = arg0 ? "true" : "false" ;  } else if  ( type == TYPE_RADIO )  { } else if  ( type == TYPE_CHECK )  { valueCheck = new boolean [  ]  {arg0} ;  } }
void function (  )  { Collections . shuffle ( pilotos )  ;  List < ? extends Piloto >  loc0 = getPilotos (  )  ;  for  ( Piloto loc1 : loc0 )  { runTurno ( loc1 )  ;  } long loc2 = rondas . incrementAndGet (  )  ;  notificarObservadoresRondaTerminada ( loc2 )  ;  }
String function (  )  { String loc0 = "" ;  try { loc0 = request . getOriginalPath (  )  ;  if  ( loc0 . endsWith ( "/" )  )  { loc0 = loc0 . substring ( 0 ,  loc0 . length (  )  - 1 )  ;  } } catch  ( Exception loc1 )  { } return loc0 ;  }
public static void function (  )  { long loc0 = IdUtils . createFileId (  )  ;  long loc1 = IdUtils . createFileId (  )  ;  Assert . assertNotEquals ( "Tests if output of IdUtils#createFileId ( long )  is valid . " ,  loc0 ,  loc1 )  ;  }
List < PropertyDescriptor < ? >  >  function (  )  { List < PropertyDescriptor < ? >  >  loc0 = new ArrayList <  >  (  )  ;  try { loc0 . addAll ( propertyDescriptors )  ;  } catch  ( Exception e )  { } return loc0 ;  }
Reader reader ;  String dataSourceName ;  ReaderDataSource ( Reader reader ,  String dataSourceName )  { this . reader = reader ;  this . dataSourceName = dataSourceName ;  } String getDataSourceName (  )  { return dataSourceName ;  } String getNiceFileName ( boolean shortNames ,  String inputFileName )  { } String toString (  )  { return dataSourceName ;  } void setDataSourceName ( String dataSourceName )  { this . dataSourceName = dataSourceName ;  } ReaderInputStream function (  )  { ReaderInputStream loc0 = null ;  try { loc0 = new ReaderInputStream ( reader )  ;  } catch  ( IOException e )  { } return loc0 ;  }
void function ( String arg0 )  { String loc0 = arg0 . trim (  )  ;  failedAttrib = loc0 ;  }
void function ( Profile arg0 )  { try { if  ( !isInitiated (  )  )  { notInitialized ( "ProfileFacade" )  ;  return ;  } getManager (  )  . registerProfile ( arg0 )  ;  } catch  ( Exception e )  { System . err . println ( "Error registering profile: " + e . getMessage (  )  )  ;  } }
boolean function ( Method arg0 ,  Method arg1 ,  Map < TypeVariable ,  Type >  arg2 )  { Method loc0 = findGenericDeclaration ( arg0 )  ;  if  ( loc0 == null )  { loc0 = arg0 ;  } if  ( loc0 != arg1 )  { return false ;  } Type [  ]  loc1 = arg0 . getGenericParameterTypes (  )  ;  Type [  ]  loc2 = arg1 . getGenericParameterTypes (  )  ;  if  ( loc1 . length != loc2 . length )  { return false ;  } for  ( int i = 0 ;  i  <  loc1 . length ;  i ++  )  { Type loc3 = BridgeMethodResolver . eraseType ( loc2 [ i ]  ,  arg2 )  ;  Type loc4 = BridgeMethodResolver . resolveType ( loc1 [ i ]  ,  arg2 )  ;  if  ( !loc3 . equals ( loc4 )  )  { return isResolvedTypeMatch ( loc1 [ i ]  ,  loc2 [ i ]  ,  arg2 )  ;  } } return true ;  }
void function ( Color arg0 )  { canvas . setForegroundColor ( arg0 )  ;  canvas . fillCircle (  ( int )  circle . x ,   ( int )  circle . y ,  diameter )  ;  }
public Object function ( String arg0 )  { Object loc0 = null ;  try { if  ( vars . containsKey ( arg0 )  )  { loc0 = vars . get ( arg0 )  ;  } else { String loc1 = String . format ( "Variable %s not found" ,  arg0 )  ;  throw new RuntimeException ( loc1 )  ;  } } catch  ( RuntimeException e )  { String loc2 = String . format ( "Error resolving variable %s" ,  arg0 )  ;  throw new RuntimeException ( loc2 ,  e )  ;  } return loc0 ;  }
public void function (  )  { try { final Path loc0 = new Path ( "srini_string" )  ;  final String loc1 = HadoopUtils . getPathWithoutScheme ( loc0 )  ;  Assert . assertFalse ( "srini_string" . equals ( loc1 )  )  ;  } catch  ( Exception e )  { System . out . println ( "This test doesn't work the way you might expect .  If you take the URI . create ( \"hdfs://localhost:1234/foo/bar/baz?please=dont&amp ; show=up\" )  . getPath it will return /foo/bar/baz .  If you go through Hadoop's Path using Path ( String )  then Hadoop injects the query params into the path ,  so when you call toURI it gives a different response . " )  ;  } }
public int function (  )  { try { Rectangle2D bounds = circle . getBounds2D (  )  ;  int loc0 =  ( int )  bounds . getX (  )  ;  return loc0 ;  } catch  ( Exception e )  { System . out . println ( "Exception caught: " + e . getMessage (  )  )  ;  return -1 ;  // return -1 to indicate an error } }
public float function ( short arg0 ,  float arg1 )  { try { short loc0 = arg0 ;  float loc1 = arg1 ;  if  ( loc0 != FSCssPrimitiveValue . CSS_NUMBER && loc0 != FSCssPrimitiveValue . CSS_PX && loc0 != FSCssPrimitiveValue . CSS_PT && loc0 != FSCssPrimitiveValue . CSS_PC && loc0 != FSCssPrimitiveValue . CSS_MM && loc0 != FSCssPrimitiveValue . CSS_CM && loc0 != FSCssPrimitiveValue . CSS_IN )  { throw new FSCssException ( "Invalid unit type" )  ;  } if  ( primitiveType == FSCssPrimitiveValue . CSS_NUMBER )  { return floatValue ;  } else if  ( primitiveType == loc0 )  { return loc1 ;  } else { float convertedValue = convertValue ( primitiveType ,  loc0 ,  loc1 )  ;  return convertedValue ;  } } catch  ( Exception e )  { e . printStackTrace (  )  ;  return 0 . 0f ;  } }
void function ( long arg0 ,  long arg1 )  { mBlocksToMoveIn . add ( arg0 )  ;  mBlocksToMoveInSize += arg1 ;  }
public static WSDLFactory function (  )  { WSDLCorbaFactory factory = new WSDLCorbaFactory (  )  ;  String implName = factory . findFactoryImplName (  )  ;  if  ( implName == null )  { implName = System . getProperty ( factory . PROPERTY_NAME )  ;  if  ( implName == null )  { String propFileName = factory . getFullPropertyFileName (  )  ;  Properties props = new Properties (  )  ;  try  ( InputStream is = ClassLoader . getSystemResourceAsStream ( propFileName )  )  { if  ( is != null )  { props . load ( is )  ;  } } catch  ( IOException e )  { } implName = props . getProperty ( factory . PROPERTY_NAME )  ;  } if  ( implName == null )  { implName = factory . DEFAULT_FACTORY_IMPL_NAME ;  } } try { return  ( WSDLFactory )  factory . newInstance ( implName ,  null )  ;  } catch  ( IllegalAccessException | InstantiationException | ClassNotFoundException e )  { throw new RuntimeException ( e )  ;  } }
public static List < String >  function ( Set < String >  arg0 )  { List < String >  loc0 = new ArrayList <  >  (  )  ;  try { if  ( EaseAtMessageHelper . instance == null )  { EaseAtMessageHelper . instance = new EaseAtMessageHelper (  )  ;  } for  ( String groupId : arg0 )  { if  ( EaseAtMessageHelper . instance . hasAtMeMsg ( groupId )  )  { loc0 . add ( groupId )  ;  } } } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
import java . beans . PropertyDescriptor ;  public class PropertyUtil { private static final Object [  ]  NO_ARGUMENTS = new Object [ 0 ]  ;  public static PropertyDescriptor function ( Object arg0 ,  String arg1 ,  Object arg2 )  { PropertyDescriptor [  ]  loc0 = propertyDescriptorsFor ( arg0 ,  arg2 . getClass (  )  )  ;  for  ( PropertyDescriptor loc1 : loc0 )  { if  ( loc1 . getName (  )  . equals ( arg1 )  )  { return loc1 ;  } } return null ;  } private static PropertyDescriptor [  ]  propertyDescriptorsFor ( Object fromObj ,  Class < Object >  stopClass )  { } }
public void function ( int arg0 )  { try { if  ( arg0  <  0 || arg0  >  59 )  { throw new IllegalArgumentException ( "Invalid minute value: " + arg0 )  ;  } this . minutes = arg0 ;  } catch  ( IllegalArgumentException ex )  { System . out . println ( "An error occurred: " + ex . getMessage (  )  )  ;  } }
String function ( Coin arg0 )  { try { return arg0 . toPlainString (  )  ;  } catch  ( NumberFormatException e )  { return "Invalid coin value" ;  } }
void function ( JPanel arg0 )  { uiStack . addToStack ( arg0 )  ;  }
boolean function (  )  { TypeCreationOptions loc0 = new TypeCreationOptions (  )  ;  loc0 . setQualifyAttributes ( arg0 )  ;  loc0 . setDefaultMinOccurs ( arg1 )  ;  loc0 . setDefaultExtensibleAttributes ( arg2 )  ;  loc0 . setQualifyElements ( arg3 )  ;  loc0 . setDefaultNillable ( arg4 )  ;  loc0 . setDefaultExtensibleElements ( arg5 )  ;  return loc0 . isDefaultNillable (  )  ;  }
List < SAXParseException >  function ( Source arg0 )  { List < SAXParseException >  loc0 = new ArrayList <  >  (  )  ;  try { if  ( validator == null )  { validator = JAXPValidatorFactory . createValidator (  )  ;  for  ( Source s : sources )  { validator . addSchemaSource ( s )  ;  } } List < ValidationProblem >  loc1 = validator . validateInstance ( arg0 )  ;  loc0 = problemToExceptionList ( loc1 )  ;  } catch  ( Exception e )  { } return loc0 ;  }
void function ( Object arg0 ,  Object arg1 )  { DiffBuilder builder = new DiffBuilder (  )  ;  try { ComparisonListener listener = new ComparisonListener (  )  {  @ Override public void comparisonPerformed ( Comparison loc0 ,  ComparisonResult loc1 )  { if  ( loc1 != ComparisonResult . EQUAL )  { } } } ;  builder . withComparisonListeners ( Arrays . asList ( listener )  )  ;  builder . compare ( arg0 )  . withTest ( arg1 )  . checkForIdentical (  )  . build (  )  ;  } catch  ( Exception e )  { } }
void function ( ConduitSelector arg0 )  { this . conduitSelector = arg0 ;  }
Message function ( Message arg0 )  { Exchange loc0 = arg0 . getExchange (  )  ;  Message loc1 = loc0 . getOutFaultMessage (  )  ;  Object loc2 = loc1 . get ( Message . RESPONSE_CODE )  ;  if  ( loc2 instanceof Integer )  { int loc3 =  ( Integer ) loc2 ;  if  ( loc3  > = 400 )  { return loc1 ;  } } loc2 = loc1 . get ( Message . PROTOCOL_HEADERS )  ;  if  ( loc2 instanceof Map )  { Map < ? ,  ? >  loc4 =  ( Map < ? ,  ? >  ) loc2 ;  List < ? >  loc5 =  ( List < ? >  ) loc4 . get ( "Content-Type" )  ;  if  ( loc5 != null && !loc5 . isEmpty (  )  )  { Object loc6 = loc5 . get ( 0 )  ;  if  ( loc6 instanceof String )  { String loc7 =  ( String ) loc6 ;  if  ( loc7 . indexOf ( "xml" )  != -1 || loc7 . indexOf ( "soap" )  != -1 )  { return loc1 ;  } } } } Object loc8 = loc1 . get ( Message . CONTENT_TYPE )  ;  if  ( loc8 instanceof String )  { String loc9 =  ( String ) loc8 ;  if  ( loc9 . indexOf ( "xml" )  != -1 || loc9 . indexOf ( "soap" )  != -1 )  { return loc1 ;  } } return null ;  }
class SoftInputUtil { void function ( Context arg0 ,  View arg1 )  { InputMethodManager loc0 =  ( InputMethodManager )  arg0 . getSystemService ( Context . INPUT_METHOD_SERVICE )  ;  try { loc0 . hideSoftInputFromWindow ( arg1 . getWindowToken (  )  ,  0 )  ;  } catch  ( Exception loc1 )  { } } }
BigDecimal function ( RegPCLTestResultEntity arg0 )  { BigDecimal loc0 = arg0 . getRunId (  )  ;  return loc0 ;  }
String function ( AuthenticationRequest authReq )  { String loc0 = "" ;  try { loc0 = authReq . getTenantDomain (  )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
Rect function (  )  { Rect loc0 = new Rect (  )  ;  loc0 . setLeftTopRightBottom ( 0 ,  0 ,  0 ,  0 )  ;  return loc0 ;  }
List < Playlist >  function (  )  { List < Playlist >  loc0 = new ArrayList <  >  (  )  ;  try { Collection < Playlist >  loc1 = playlists . values (  )  ;  loc0 . addAll ( loc1 )  ;  Collections . sort ( loc0 )  ;  } catch  ( Exception e )  { logger . error ( "An error occurred while executing function: " + e . getMessage (  )  )  ;  } return loc0 ;  }
public void function ( String arg0 ,  String arg1 ,  String arg2 ,  String arg3 )  { try { Class . forName ( arg0 )  ;  Connection loc0 = DriverManager . getConnection ( arg1 ,  arg2 ,  arg3 )  ;  Documents loc1 =  ( Documents )  Class . forName ( "Documents" )  . newInstance (  )  ;  loc1 . con = loc0 ;  loc1 . createDb (  )  ;  } catch  ( ClassNotFoundException | SQLException | InstantiationException | IllegalAccessException e )  { e . printStackTrace (  )  ;  } }
void function ( XsdStringType arg0 )  { paramName . setParamValue ( arg0 )  ;  }
public boolean function ( String arg0 )  { XMLResource loc0 = _uriResolver . resolve ( arg0 ,  getBaseURL (  )  )  ;  if  ( loc0 != null )  { String loc1 = loc0 . getURI (  )  ;  return _imageResourceLoader . isVisited ( loc1 )  ;  } return false ;  }
String function ( String arg0 )  { try { if  ( arg0 == null )  { throw new NullPointerException (  )  ;  } return DAVRepository . class . getName (  )  + "srini_string" + arg0 ;  } catch  ( NullPointerException e )  { return null ;  } }
void function ( Object arg0 )  { _out . writeStreamingObject ( arg0 )  ;  }
void function ( CPDTest loc0 ,  int loc1 ,  File loc2 ,  String loc3 )  { NoFileAssertListener noFileAssertListener = new NoFileAssertListener (  )  ;  loc0 . cpd . setListener ( noFileAssertListener )  ;  loc0 . setCpdListener (  )  ;  loc0 . add ( loc2 ,  loc3 )  ;  loc0 . verify (  )  ;  }
void function (  )  { long arg0 = TEST_ID + 1 ;  long arg1 = TEST_ID + 2 ;  mGenerator . setNextContainerId ( arg0 )  ;  long loc0 = mGenerator . getNewContainerId (  )  ;  assertEquals ( arg0 ,  loc0 )  ;  mGenerator . setNextContainerId ( arg1 )  ;  long loc1 = mGenerator . getNewContainerId (  )  ;  assertEquals ( arg1 ,  loc1 )  ;  }
void function ( int arg0 ,  int arg1 )  { int loc0 = arg0 ;  int loc1 = arg1 ;  TestBlockInnerRankUpdate test = new TestBlockInnerRankUpdate (  )  ;  test . checkRankNUpdate ( loc0 ,  loc1 )  ;  }
public void function (  )  { try { ServerSession loc0 = mock ( ServerSession . class )  ;  when ( loc0 . getId (  )  )  . thenReturn ( null )  ;  notificationController . registerUserSession ( loc0 ,  mockServerMessage )  ;  fail ( "Expected a NullPointerException to be thrown" )  ;  } catch  ( NullPointerException e )  { } catch  ( Exception e )  { fail ( "Unexpected exception thrown: " + e . getMessage (  )  )  ;  } }
public int function ( int arg0 ,  int arg1 )  { Dimension loc0 = panel . getPreferredSize (  )  ;  Rectangle loc1 = new Rectangle (  )  ;  loc1 . width = arg0 ;  loc1 . height = arg1 ;  panel . setSize ( loc1 . width ,  loc1 . height )  ;  panel . validate (  )  ;  layout (  ( Graphics2D ) panel . getGraphics (  )  ,  loc0 )  ;  return Math . max ( panel . getWidth (  )  ,  loc0 . width )  ;  }
double [  ]  [  ]  function ( double [  ]  [  ]  arg0 )  { int loc0 = arg0 . length ;  int loc1 = arg0 [ 0 ]  . length ;  int loc2 = Math . min ( loc0 ,  loc1 )  ;  QR . setExpectedMaxSize ( loc0 ,  loc1 )  ;  QR . reshape ( loc0 ,  loc1 )  ;  numCols = loc1 ;  numRows = loc0 ;  minLength = loc2 ;  v = new double [ loc0 ]  ;  for  ( int j = 0 ;  j  <  loc2 ;  j ++  )  { householder ( j )  ;  } return QR . getData (  )  ;  }
import java . io . * ;  import java . net . URL ;  public class ResourceLoader { private int TIMEOUT ;  public void function ( String arg0 ,  String arg1 )  { InputStream loc0 = null ;  try { File loc1 = new File ( arg0 )  ;  if  ( loc1 . exists (  )  )  { loc0 = new FileInputStream ( loc1 )  ;  } else { URL loc2 = new URL ( arg1 )  ;  loc0 = loc2 . openStream (  )  ;  if  ( loc0 == null )  { loc0 = getClassLoader (  )  . getResourceAsStream ( arg0 )  ;  } } } catch  ( FileNotFoundException | RuleSetNotFoundException e )  { e . printStackTrace (  )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } finally { if  ( loc0 != null )  { try { loc0 . close (  )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } } } } }
public int function ( Object arg0 ,  Object arg1 )  { int loc0 = 0 ;  try { OrderLineType loc1 =  (  ( OrderLineTypeFacade )  arg0 )  . getLineItem (  )  ;  loc0 = loc1 . getQuantity (  )  . getValue (  )  . intValue (  )  ;  } catch  ( Exception loc2 )  { loc0 = 0 ;  } return loc0 ;  }
public void function ( String arg0 ,  Gistic arg1 )  { try { arg1 . setCytoband ( arg0 )  ;  } catch  ( Exception loc0 )  { System . out . println ( "An error occurred while setting the cytoband: " + loc0 . getMessage (  )  )  ;  } }
public ValidateAccess function (  )  { ValidateAccess loc0 = new ValidateAccess (  )  ;  return loc0 ;  }
String function ( HttpServletRequest arg0 )  { String loc0 = arg0 . getParameter ( WebService . FORMAT )  ;  String result = "" ;  if  ( loc0 != null )  { result = loc0 . toLowerCase (  )  ;  } return result ;  }
void function ( DishCollection arg0 )  { DishCollection loc0 = dishCollectionRepository . save ( arg0 )  ;  log . debug ( "Saved a dishCollection with id {}" ,  loc0 . getId (  )  )  ;  }
import java . io . File ;  import java . math . BigInteger ;  public class Sha256Hash { public static Sha256Hash ZERO_HASH = new Sha256Hash ( new byte [ 32 ]  )  ;  private byte [  ]  bytes ;  public Sha256Hash ( byte [  ]  bytes )  { this . bytes = bytes ;  } public byte [  ]  getBytes (  )  { return bytes ;  } public Sha256Hash hashFileContents ( File f )  { return null ;  } public int hashCode (  )  { return 0 ;  } public boolean equals ( Object other )  { return false ;  } public String toString (  )  { return null ;  } public int compareTo ( Object o )  { return 0 ;  } public Sha256Hash create ( byte [  ]  contents )  { return null ;  } public BigInteger toBigInteger (  )  { return null ;  } public Sha256Hash duplicate (  )  { return null ;  } public static byte [  ]  doubleDigest ( byte [  ]  input )  { return null ;  } public static Sha256Hash function ( byte [  ]  arg0 ,  byte [  ]  arg1 )  { byte [  ]  loc0 = doubleDigest ( arg0 )  ;  return new Sha256Hash ( doubleDigest ( loc0 ,  arg1 )  )  ;  } private static byte [  ]  doubleDigest ( byte [  ]  input1 ,  byte [  ]  input2 )  { return null ;  } }
void function ( Object arg0 ,  Object arg1 )  { WorkflowAppService loc0 =  ( WorkflowAppService )  arg0 ;  Services loc1 =  ( Services )  arg1 ;  loc0 . init ( loc1 )  ;  loc0 . systemLibPath = loc0 . getSystemLibPath (  )  ;  Configuration loc2 = new XConfiguration (  )  ;  loc2 . set ( WorkflowAppService . HADOOP_USER ,  loc1 . getConf (  )  . get ( WorkflowAppService . HADOOP_USER )  )  ;  loc2 . set ( WorkflowAppService . HADOOP_UGI ,  loc1 . getConf (  )  . get ( WorkflowAppService . HADOOP_UGI )  )  ;  loc2 . set ( WorkflowAppService . HADOOP_JT_KERBEROS_NAME ,  loc1 . getConf (  )  . get ( WorkflowAppService . HADOOP_JT_KERBEROS_NAME )  )  ;  loc2 . set ( WorkflowAppService . HADOOP_NN_KERBEROS_NAME ,  loc1 . getConf (  )  . get ( WorkflowAppService . HADOOP_NN_KERBEROS_NAME )  )  ;  String loc3 = loc1 . getConf (  )  . get ( WorkflowAppService . APP_LIB_PATH_LIST )  ;  loc2 . set ( WorkflowAppService . APP_LIB_PATH_LIST ,  loc3 )  ;  Configuration loc4 = loc0 . createProtoActionConf ( loc2 ,  null ,  true )  ;  Path loc5 = loc0 . systemLibPath ;  FileSystem loc6 = loc5 . getFileSystem ( loc4 )  ;  List < String >  loc7 = loc0 . getLibFiles ( loc6 ,  loc5 )  ;  WorkflowLib loc8 = new WorkflowLib ( loc4 )  ;  loc8 . init ( loc0 . systemLibPath ,  loc7 )  ;  String loc9 = loc0 . readDefinition ( "" ,  "" ,  "" ,  null )  ;  loc0 . parseDef ( loc9 )  ;  }
String function (  )  { try { Calendar loc0 = GregorianCalendar . getInstance (  )  ;  String loc1 = fromCalendar ( loc0 )  ;  return loc1 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return null ;  }
public Object function ( final Object arg0 )  { try { final Source loc0 = Input . from ( arg0 )  . build (  )  ;  return new DiffBuilder ( loc0 ,  controlSource ,  comparisonResultsToCheck )   . withNamespaceContext ( namespaceContext )   . ignoreComments ( ignoreComments )   . ignoreWhitespace ( ignoreWhitespace )   . withNodeMatcher ( nodeMatcher )   . withComparisonListeners ( comparisonListeners )   . withDifferenceListeners ( differenceListeners )   . withComparisonController ( comparisonController )   . withDifferenceEvaluator ( differenceEvaluator )   . withNodeFilter ( nodeFilter )   . withAttributeFilter ( attributeFilter )   . checkForIdentical (  )   . checkForSimilar (  )   . normalizeWhitespace (  )   . build (  )   . getDifferences (  )  ;  } catch  ( final Exception e )  { throw new RuntimeException ( "Failed to create DiffBuilder" ,  e )  ;  } }
public static void function ( JSONObject arg0 ,  String arg1 ,  Object arg2 )  { try { arg0 . put ( arg1 ,  arg2 )  ;  } catch  ( JSONException loc0 )  { LOG . warn ( "Failed to put name/value pair in JSON object: " + arg1 + "/" + arg2 ,  loc0 )  ;  } }
public DenseMatrix64F function (  )  { DenseMatrix64F loc0 = svd . getV ( null ,  true )  ;  return loc0 ;  }
public String function (  )  { String loc0 = mAlias ;  return loc0 ;  }
class TurnLauncher { Logger LOG = LoggerFactory . getLogger ( TurnLauncher . class )  ;  TurnServer m_turnServer ;  void function ( String [  ]  arg0 )  { try { LOG . debug ( "Launching the SIP and TURN servers . " )  ;  TurnLauncher loc0 = new TurnLauncher (  )  ;  loc0 . start (  )  ;  } catch  ( Throwable loc1 )  { LOG . error ( "Error while launching the servers . " ,  loc1 )  ;  } } void stop (  )  { } void start (  )  { } }
void function ( byte [  ]  arg0 )  { projectSecret = arg0 ;  }
public static String function ( String arg0 ,  String arg1 )  { String loc0 = arg0 . trim (  )  ;  Date loc1 = new Date (  )  ;  SimpleDateFormat loc2 = new SimpleDateFormat ( "yyyy-MM-dd" )  ;  loc1 = Date . valueOf ( loc0 )  ;  String loc3 = loc2 . format ( loc1 )  ;  return "Formatted date: " + loc3 ;  }
int function ( SymmetricQrAlgorithm arg0 ,  double arg1 ,  double arg2 )  { int loc0 = 0 ;  for  ( int i = 0 ;  i  <  arg0 . getNumberOfEigenvalues (  )  ;  i ++  )  { double loc1 = arg0 . getEigenvalue ( i )  ;  if  ( Math . abs ( loc1 - arg1 )   < = arg2 )  { loc0 ++  ;  } } return loc0 ;  }
public void function ( ServiceInfo arg0 ,  BasicNameManager arg1 )  { try { arg1 . initialize ( arg0 ,  null )  ;  } catch  ( Exception loc0 )  { } }
class ConfigurationFactory { IConfigurationFactory SINGLETON ;  ConfigurationHandler handler = new ConfigurationProperties (  )  ;  IConfigurationFactory getInstance (  )  { } String function (  )  { ConfigurationHandler loc0 = handler . function (  )  ;  return "Returns the customized configuration for the user . " ;  } }
FederationProposal function ( String arg0 )  { FederationProposal loc0 = null ;  for  ( FederationProposal proposal : getPendingFederationProposals (  )  )  { if  ( proposal . getToken (  )  . equals ( arg0 )  )  { loc0 = proposal ;  break ;  } } return loc0 ;  }
void function ( String arg0 )  { _cssText = "Not supported ,  class is immutable .  Sets the string representation of the current value . " ;  }
public void function (  )  { Block loc0 = new Block (  )  ;  String loc1 = loc0 . fileName (  )  ;  int loc2 = loc0 . number (  )  ;  pg . read ( loc0 )  ;  int loc3 = pg . getInt ( LogMgr . LAST_POS )  ;  }
Object function ( Object arg0 ,  Object arg1 ,  Object arg2 ,  Object arg3 ,  Object arg4 ,  Object arg5 )  throws Exception { Object loc0 = new Object (  )  ;  InitialContext loc1 = new InitialContext (  )  ;  loc0 = loc1 . lookup (  ( String )  arg0 )  ;  Class < ? >  loc2 = loc0 . getClass (  )  ;  loc2 . getMethod (  ( String )  arg1 )  . invoke ( loc0 )  ;  loc0 . getClass (  )  . getMethod (  ( String )  arg2 ,  MessageDrivenContext . class )  . invoke ( loc0 ,  arg3 )  ;  loc0 . getClass (  )  . getMethod (  ( String )  arg4 )  . invoke ( loc0 )  ;  return loc0 ;  }
public List < String >  function (  )  { List < String >  loc0 = acceptedEncryptionAlgorithms ;  return loc0 ;  }
public void function ( BundleContext arg0 )  { for  ( AutoSIMConnectionConfig loc0 : config . connections )  { environments . deregisterConnectionFactory ( loc0 . name )  ;  factories . remove ( loc0 . name )  ;  } }
public static String function ( String [  ]  arg0 ,  Object [  ]  [  ]  arg1 )  { try { Borders FULL = Borders . of ( Borders . BORDER_FLIP_AND_DOUBLE )  ;  FlipTable table = new FlipTable ( arg0 ,  arg1 ,  FULL )  ;  return table . toString (  )  ;  } catch  ( Exception e )  { System . err . println ( "An error occurred while creating the table: " + e . getMessage (  )  )  ;  return "" ;  } }
public Object function ( Object arg0 ,  Object arg1 )  { Node loc0 =  ( Node )  arg0 ;  Node loc1 =  ( Node )  arg1 ;  String loc2 = this . xpath ;  ComparisonType loc3 = this . type ;  Object loc4 = this . value ;  Object loc5 = null ;  switch  ( loc3 )  { case NODELIST_CONTAINS: NodeList nodeList0 =  ( NodeList )  loc0 ;  NodeList nodeList1 =  ( NodeList )  loc1 ;  loc5 = ComparisonUtils . containsNodeList ( nodeList0 ,  nodeList1 ,  loc2 )  ;  break ;  case NODELIST_EQUALS: NodeList nodeList2 =  ( NodeList )  loc0 ;  NodeList nodeList3 =  ( NodeList )  loc1 ;  loc5 = ComparisonUtils . compareNodeList ( nodeList2 ,  nodeList3 ,  loc2 )  ;  break ;  case NODELIST_LENGTH: NodeList nodeList4 =  ( NodeList )  loc0 ;  NodeList nodeList5 =  ( NodeList )  loc1 ;  loc5 = ComparisonUtils . compareNodeListLength ( nodeList4 ,  nodeList5 ,  loc2 )  ;  break ;  case NODE_EQUALS: Node node0 =  ( Node )  loc0 ;  Node node1 =  ( Node )  loc1 ;  loc5 = ComparisonUtils . compareNodes ( node0 ,  node1 ,  loc2 )  ;  break ;  case STRING_CONTAINS: String str0 =  ( String )  loc0 ;  String str1 =  ( String )  loc1 ;  loc5 = ComparisonUtils . containsString ( str0 ,  str1 ,  loc2 )  ;  break ;  case STRING_EQUALS: String str2 =  ( String )  loc0 ;  String str3 =  ( String )  loc1 ;  loc5 = ComparisonUtils . compareStrings ( str2 ,  str3 ,  loc2 )  ;  break ;  case OBJECT_EQUALS: loc5 = ComparisonUtils . compareObjects ( loc0 ,  loc1 ,  loc2 )  ;  break ;  case OBJECT_INSTANCE: loc5 = ComparisonUtils . instanceOf ( loc0 ,   ( Class < ? >  )  loc4 ,  loc2 )  ;  break ;  case OBJECT_NULL: loc5 = ComparisonUtils . isNull ( loc0 ,  loc2 )  ;  break ;  case NUMBER_EQUALS: Number num0 =  ( Number )  loc0 ;  Number num1 =  ( Number )  loc1 ;  loc5 = ComparisonUtils . compareNumbers ( num0 ,  num1 ,  loc2 )  ;  break ;  case BOOLEAN_EQUALS: Boolean bool0 =  ( Boolean )  loc0 ;  Boolean bool1 =  ( Boolean )  loc1 ;  loc5 = ComparisonUtils . compareBooleans ( bool0 ,  bool1 ,  loc2 )  ;  break ;  } Detail loc6 = this . getTestDetails (  )  ;  Detail loc7 = this . getControlDetails (  )  ;  String loc8 = ComparisonUtils . getResultString ( loc5 ,  loc3 )  ;  String loc9 = this . toString ( new ComparisonFormatter (  )  )  ;  Detail loc10 = new Detail ( loc8 ,  loc9 )  ;  this . test = loc6 ;  this . control = loc7 ;  this . target = loc5 ;  return loc5 ;  }
Object function ( Object arg0 ,  Object arg1 )  { ActivityGraphsHelper loc0 =  ( ActivityGraphsHelper )  impl ;  loc0 . removeContent ( arg0 ,  arg1 )  ;  return null ;  }
import java . util . concurrent . TimeUnit ;  import org . junit . Assert ;  public class WebUtilsTest { void function (  )  { long arg0 = 1000L ;  String loc0 = WebUtils . convertMsToClockTime ( arg0 )  ;  Assert . assertEquals ( "00:00:01" ,  loc0 )  ;  } void convertToClockTimeWithOneMinute30Seconds (  )  { } void convertToClockTimeWithShortValue (  )  { } void convertToClockTimeWithOneMinute (  )  { } void convertToClockTimeWithOneHour (  )  { } void convertToClockTimeWithOneDay (  )  { } void convertToClockTimeWithOneDay4Hours10Minutes45SecondsWithStopwatch (  )  { } void convertToClockTimeWithNegativeValue (  )  { } void convertToClockTimeWithOneDay4Hours10Minutes45Seconds (  )  { } void convertToClockTimeWithOneHour10Minutes45Seconds (  )  { } }
public String function ( Object arg0 )  { if  ( ! ( arg0 instanceof VisibilityKindEnum )  )  { throw new IllegalArgumentException ( "Argument must be of type VisibilityKindEnum . " )  ;  } VisibilityKindEnum loc0 =  ( VisibilityKindEnum )  arg0 ;  if  ( loc0 . equals ( VK_PACKAGE )  )  { return "vk_package" ;  } else if  ( loc0 . equals ( VK_PRIVATE )  )  { return "vk_private" ;  } else if  ( loc0 . equals ( VK_PUBLIC )  )  { return "vk_public" ;  } else if  ( loc0 . equals ( VK_PROTECTED )  )  { return "vk_protected" ;  } else { throw new IllegalArgumentException ( "Invalid argument value . " )  ;  } }
List < ClassdiagramNode >  function (  )  { List < ClassdiagramNode >  loc0 = new ArrayList < ClassdiagramNode >  (  )  ;  loc0 . addAll ( downlinks )  ;  return loc0 ;  }
I'm sorry ,  I cannot comply with your request as it does not make sense .  The task you are asking me to perform is to define a method named "function" that calls itself and returns a string named `runtimeDir` ,  with no explanation or context provided .  Additionally ,  the member variables and functions you listed do not seem to be related to this task .  If you could provide more information or context about what you are trying to achieve ,  I would be happy to help you write a method or code snippet that accomplishes your goal . 
public boolean function (  )  { boolean loc0 = false ;  try { if  ( !currentValue . isEmpty (  )  )  { loc0 = Boolean . parseBoolean ( currentValue . trim (  )  )  ;  } } catch  ( Exception e )  { loc0 = Boolean . parseBoolean ( defaultValue . trim (  )  )  ;  } return loc0 ;  }
void function (  )  { int loc0 = getProgress (  )  ;  int loc1 = getMax (  )  ;  setProgress ( loc0 )  ;  }
void function (  )  { setUp (  )  ;  Time loc0 = new Time ( 13 ,  30 ,  45 )  ;  Time loc1 = new Time ( 13 ,  30 ,  45 )  ;  loc1 . setSeconds ( 50 )  ;  assertEquals ( 13 ,  time . getHour (  )  )  ;  assertEquals ( loc0 ,  loc1 )  ;  }
int function ( DatePicker arg0 )  { Calendar loc0 = Calendar . getInstance (  )  ;  loc0 . set ( arg0 . getYear (  )  ,  arg0 . getMonth (  )  ,  arg0 . getDayOfMonth (  )  )  ;  Date loc1 = loc0 . getTime (  )  ;  int dayOfMonth = loc0 . get ( Calendar . DAY_OF_MONTH )  ;  int month = loc0 . get ( Calendar . MONTH )  ;  int year = loc0 . get ( Calendar . YEAR )  ;  return dayOfMonth ;  }
void function ( Timestamp arg0 )  { try { setCreatedDate ( arg0 )  ;  } catch ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
boolean function ( Collection arg0 ,  Collection arg1 )  { boolean loc0 = true ;  for  ( Object loc1 : arg1 )  { if  ( !arg0 . contains ( loc1 )  || !loc1 . equals ( arg0 . stream (  )  . filter ( loc1::equals )  . findFirst (  )  . get (  )  )  )  { loc0 = false ;  break ;  } } return loc0 ;  }
NodeVisitor function ( Node arg0 )  { NodeVisitor loc0 = begin (  )  ;  loc0 . lang = lang ;  return loc0 ;  }
XsdStringType function (  )  { XsdStringType loc0 = null ;  try { loc0 = this . paramValue ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
public String function ( String arg0 )  { String loc0 = null ;  try { loc0 = String . valueOf ( arg0 )  ;  loc0 = loc0 . toUpperCase (  )  ;  } catch  ( Exception e )  { System . err . println ( "Caught an exception: " + e . getMessage (  )  )  ;  } try { if  ( loc0 == null )  { throw new IllegalArgumentException ( "Input string cannot be null . " )  ;  } loc0 = loc0 . replaceAll ( "\\s+" ,  "" )  ;  } catch  ( Exception e )  { System . err . println ( "Caught an exception: " + e . getMessage (  )  )  ;  } return loc0 ;  }
int function ( ViewConfigurationCompat arg0 ,  ViewConfiguration arg1 )  { int loc0 ;  try { if  ( arg0 . IMPL != null )  { loc0 = arg0 . IMPL . getScaledPagingTouchSlop ( arg1 )  ;  } else { loc0 = arg1 . getScaledTouchSlop (  )  ;  } } catch  ( Exception e )  { loc0 = arg1 . getScaledTouchSlop (  )  ;  } return loc0 ;  }
TypeNode function ( String fmt ,  Object .  .  .  subst )  { Lexer loc0 = lexer ( fmt ,  pos ,  subst )  ;  QQParser loc1 = parser ( loc0 ,  ts ,  nf ,  eq )  ;  return  ( TypeNode )  parse ( loc1 . typeNode (  )  ,  fmt ,  subst )  ;  }
public void function (  )  { String EXAMPLE="$GPRMB , A , 0 . 00 , R ,  , RUSKI , 5536 . 200 , N , 01436 . 500 , E , 432 . 3 , 234 . 9 ,  , V*58" ;  RMBSentence rmb = new RMBSentence ( EXAMPLE )  ;  RMBSentence empty = new RMBSentence (  )  ;  try { rmb . setSteerTo ( null )  ;  fail ( "Expected IllegalArgumentException not thrown" )  ;  } catch  ( IllegalArgumentException e )  { assertTrue ( e . getMessage (  )  . contains ( "null" )  )  ;  } catch  ( Exception e )  { fail ( "Unexpected exception thrown: " + e . getClass (  )  . getSimpleName (  )  )  ;  } try { rmb . setSteerTo ( CompassPoint . EAST )  ;  assertEquals ( CompassPoint . EAST ,  rmb . getSteerTo (  )  )  ;  } catch  ( Exception e )  { fail ( "Unexpected exception thrown: " + e . getClass (  )  . getSimpleName (  )  )  ;  } }
void function ( Object arg0 ,  Object arg1 )  { if  ( connectedHandler != null )  { connectedHandler . close (  )  ;  } }
void function ( final PropertyChangeListener arg0 )  { try { m_PropertyChangeSupport . addPropertyChangeListener ( arg0 )  ;  } catch  ( Exception loc0 )  { } }
Client function ( Object arg0 ,  String arg1 ,  int arg2 )  { Client loc0 = client . function ( arg0 ,  arg1 ,  arg2 )  ;  return loc0 ;  }
String function ( AccessibilityServiceInfo arg0 )  { String result = "" ;  try { result = IMPL . getDescription ( arg0 )  ;  } catch  ( Exception e )  { } return result ;  }
void function ( Locale loc0 ,  String loc1 )  { try { Locale . setDefault ( loc0 )  ;  HashMap < String ,  ResourceBundle >  loc2 = new HashMap <  >  (  )  ;  Translator . BUNDLES_PATH = loc1 ;  Translator . bundles = loc2 ;  Translator . initialized = false ;  Translator . classLoaders . clear (  )  ;  } catch  ( Exception loc3 )  { Translator . LOG . warning ( "Error occurred while changing locale: " + loc3 . getMessage (  )  )  ;  } }
public Script function ( Address arg0 ,  byte [  ]  arg1 ,  int arg2 )  { List < ECKey >  pubKeys = arg0 . getPubKey (  )  ;  byte [  ]  pubKeyHash = arg0 . getHash (  )  ;  Script redeemScript = ScriptBuilder . createMultiSigOutputScript ( arg2 ,  pubKeys )  ;  byte [  ]  redeemScriptHash = Utils . sha256hash160 ( redeemScript . getProgram (  )  )  ;  Script p2shOutputScript = ScriptBuilder . createP2SHOutputScript ( redeemScriptHash )  ;  ScriptBuilder scriptBuilder = new ScriptBuilder (  )  ;  scriptBuilder . data ( arg1 )  ;  scriptBuilder . data ( redeemScript . getProgram (  )  )  ;  Script scriptSig ;  if  ( arg1 == null )  { scriptSig = scriptBuilder . smallNum ( 0 )  . build (  )  ;  } else { TransactionSignature transactionSignature = new TransactionSignature ( arg1 ,  SigHash . ALL ,  false )  ;  scriptSig = scriptBuilder . smallNum ( 0 )  . data ( transactionSignature . encodeToBitcoin (  )  )  . build (  )  ;  } return scriptSig ;  }
Timestamp function (  )  { try { return this . receiptDate ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
void function ( boolean arg0 )  { enforceKnownIssuer = arg0 ;  }
public ValidateAccess function ( ValidateTokenResponse loc0 ,  String loc1 )  { ValidateAccess loc2 = loc0 . access ;  loc2 . getAccess ( loc1 )  ;  return loc2 ;  }
public void function ( String arg0 )  { String loc0 = null ;  try { loc0 = arg0 . toUpperCase (  )  ;  VERSION = loc0 ;  } catch  ( NullPointerException e )  { System . out . println ( "Argument cannot be null . " )  ;  } catch  ( Exception e )  { System . out . println ( "An error occurred while making the version public . " )  ;  } }
void function ( int arg0 ,  int arg1 )  { int loc0 = arg0 / ti . getRecordsPerPage (  )  ;  int loc1 = arg0 % ti . getRecordsPerPage (  )  ;  currentblknum = loc0 + ti . getStartBlk (  )  ;  rp . read ( currentblknum ,  tx )  ;  currentRid = new RID ( currentblknum ,  loc1 )  ;  rp . moveToId ( currentRid )  ;  }
void function ( WalkDirection arg0 )  { viewer . moveCharacter2d ( arg0 )  ;  }
BlockWorkerClient acquireWorkerClient ( final InetSocketAddress arg0 )  { Preconditions . checkNotNull ( arg0 )  ;  final long loc0 = IdUtils . getRandomNonNegativeLong (  )  ;  BlockWorkerClient loc1 = null ;  while  ( loc1 == null )  { try { loc1 = RetryHandlingBlockWorkerClient . get ( arg0 ,  this )  ;  } catch  ( IOException e )  { LOG . warn ( "Failed to create worker client for {} ,  retrying .  .  . " ,  arg0 ,  e )  ;  } } return loc1 ;  }
String function ( String arg0 ,  String arg1 )  { RegPCLTestResultDetailsEntityPK loc0 = getId (  )  ;  String loc1 = loc0 . getTestId (  )  ;  String loc2 = loc0 . getDataSetId (  )  ;  String loc3 = loc0 . getTestName (  )  ;  String loc4 = getFailedAttrib (  )  ;  return loc4 ;  }
public void function ( Map < String , Object >  arg0 ,  String arg1 ,  String arg2 ,  String arg3 ,  String arg4 ,  String arg5 ,  String arg6 )  { try { arg0 . put ( "replyTo" ,  arg1 )  ;  arg0 . put ( "contentEncoding" ,  arg2 )  ;  arg0 . put ( "messageId" ,  arg3 )  ;  arg0 . put ( "correlationId" ,  arg4 )  ;  arg0 . put ( "soapAction" ,  arg5 )  ;  arg0 . put ( "contentType" ,  arg6 )  ;  } catch  ( Exception loc0 )  { System . out . println ( "Error while setting headers: " + loc0 . getMessage (  )  )  ;  } }
 @ Override public int hashCode (  )  { int loc0 ;  try { loc0 = super . hashCode (  )  ;  } catch  ( Exception e )  { loc0 = 0 ;  } return loc0 ;  }
ValidatedItemDTO [  ]  function ( String arg0 ,  boolean arg1 )  { try { return stub . validateAuthnRequest ( arg0 ,  arg1 )  ;  } catch  ( RemoteException loc0 )  { log . error ( "srini_string" ,  loc0 )  ;  throw new AxisFault ( loc0 . getMessage (  )  ,  loc0 )  ;  } }
Sha256Hash function ( Block arg0 )  { try { byte [  ]  loc0 = arg0 . cloneAsHeader (  )  . bitcoinSerialize (  )  ;  Sha256Hash loc1 = Sha256Hash . wrapReversed ( Sha256Hash . hashTwice ( loc0 )  )  ;  BigInteger loc2 = new BigInteger ( 1 ,  loc1 . getBytes (  )  )  ;  BigInteger loc3 = getProofOfWorkLimit (  )  ;  if  ( loc2 . compareTo ( loc3 )   >  0 )  { throw new VerificationException ( "Block header hash is higher than target: " + loc1 . toString (  )  )  ;  } return loc1 ;  } catch  ( IOException e )  { throw new RuntimeException ( e )  ;  // Cannot happen .  } }
void function ( String arg0 ,  String arg1 )  throws IOException { File loc0 = new File ( arg0 )  ;  File loc1 = new File ( arg1 )  ;  Files . move ( loc0 ,  loc1 )  ;  }
List < Object >  function ( JSONArray arg0 )  { List < Object >  nodes = new ArrayList <  >  (  )  ;  for  ( Object loc0 : arg0 )  { JSONObject loc1 =  ( JSONObject )  loc0 ;  nodes . add ( new JsonCoordinatorAction (  loc1 . getString ( "missingDependencies" )  ,  loc1 . getInt ( "actionNumber" )  ,  new Date ( loc1 . getLong ( "createdTime" )  )  ,  Status . valueOf ( loc1 . getString ( "status" )  )  ,  loc1 . getString ( "createdConf" )  ,  loc1 . getString ( "errorCode" )  ,  loc1 . getString ( "type" )  ,  loc1 . getString ( "actionXml" )  ,  loc1 . getString ( "externalStatus" )  ,  new Date ( loc1 . getLong ( "lastModifiedTime" )  )  ,  loc1 . getString ( "jobId" )  ,  loc1 . optInt ( "timeOut" ,  0 )  ,  loc1 . getString ( "id" )  ,  loc1 . getString ( "consoleUrl" )  ,  loc1 . getString ( "runConf" )  ,  new Date ( loc1 . getLong ( "nominalTime" )  )  ,  loc1 . getString ( "trackerUri" )  ,  loc1 . optString ( "errorMessage" ,  "" )  ,  loc1 . optString ( "externalId" ,  "" )   )  )  ;  } return nodes ;  }
void function (  )  { try { md5Cache . clear (  )  ;  System . out . println ( "MD5 cache cleaned . " )  ;  } catch  ( Exception loc0 )  { System . err . println ( "Error while cleaning MD5 cache: " + loc0 . getMessage (  )  )  ;  } }
public String function (  )  { try { return this . inactivationReasonType ;  } catch  ( Exception e )  { } }
public void function ( Object arg0 ,  Object arg1 )  { try { } catch  ( Exception e )  { log . error ( "Logs and wraps the given exception . " ,  e )  ;  throw new AxisFault ( "Exception occurred: " + e . getMessage (  )  )  ;  } }
ByteBuffer function ( int arg0 )  { ByteBuffer loc0 = ByteBuffer . allocate ( arg0 * 4 )  ;  for  ( int loc1 = 0 ;  loc1  <  arg0 ;  loc1 ++  )  { loc0 . putInt ( loc1 )  ;  } loc0 . flip (  )  ;  return loc0 ;  }
int function ( int arg0 ,  double arg1 ,  Timestamp arg2 ,  long arg3 ,  double arg4 ,  int arg5 )  { int loc0 = lane_id ;  return loc0 ;  }
boolean function ( String arg0 )  { for  ( int loc0 = 0 ;  loc0  <  arg0 . length (  )  ;  loc0 ++  )  { if  ( loc0 == 0 )  { if  ( !Character . isJavaIdentifierStart ( arg0 . charAt ( loc0 )  )  )  { return false ;  } } else { if  ( !Character . isJavaIdentifierPart ( arg0 . charAt ( loc0 )  )  )  { return false ;  } } } return true ;  }
boolean function (  )  { Configuration config = getFactory (  )  . getConfigurationHandler (  )  ;  return config . loadDefault (  )  ;  }
void function ( List < Double >  arg0 )  { try { profits . add ( arg0 )  ;  } catch  ( Exception e )  { System . err . println ( "Error occurred while adding utility values to profits: " + e . getMessage (  )  )  ;  } }
public void function ( int arg0 )  { try { StoredTransactionOutput removedOutput = transactionOutputMap . remove ( new StoredTransactionOutPoint ( hash ,  arg0 )  )  ;  if  ( removedOutput == null )  { throw new IllegalArgumentException ( "Output at index " + arg0 + " not found" )  ;  } tempSetRemoved . get (  )  . add ( new StoredTransactionOutPoint ( hash ,  arg0 )  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function ( InStreamOptions options ,  long arg0 )  { options . mSeekBufferSizeBytes = arg0 ;  }
String function ( Date arg0 ,  DateTimeFormat arg1 ,  boolean arg2 )  { try { DateTime loc0 = new DateTime (  )  ;  if  ( arg2 )  { loc0 = loc0 . withZone ( DateTimeZone . getDefault (  )  )  ;  } else { loc0 = loc0 . withZone ( DateTimeZone . UTC )  ;  } String loc1 = formatUTC ( loc0 . toDate (  )  ,  arg1 ,  false )  ;  return formatUTCtoSqlUTC ( parseUTC ( loc1 ,  arg1 )  )  ;  } catch  ( Exception e )  { return null ;  } }
import java . util . * ;  public class FrequencyCounter < T >  { Map < T ,  Integer >  counter ;  public FrequencyCounter (  )  { counter = new HashMap <  >  (  )  ;  } void function ( T arg0 )  { Integer loc0 = counter . get ( arg0 )  ;  if  ( loc0 == null )  { counter . put ( arg0 ,  1 )  ;  } else { counter . put ( arg0 ,  loc0 + 1 )  ;  } } Double probabilityOf ( T key )  { Integer count = counter . get ( key )  ;  if  ( count == null )  { return 0 . 0 ;  } double totalCount = 0 . 0 ;  for  ( Integer val : counter . values (  )  )  { totalCount += val ;  } return count / totalCount ;  } String toString (  )  { StringBuilder sb = new StringBuilder (  )  ;  for  ( Map . Entry < T ,  Integer >  entry : counter . entrySet (  )  )  { sb . append ( entry . getKey (  )  )  . append ( ": " )  . append ( entry . getValue (  )  )  . append ( "\n" )  ;  } return sb . toString (  )  ;  } Set < T >  getStates (  )  { return counter . keySet (  )  ;  } Integer getCount ( T key )  { return counter . get ( key )  ;  } }
public void function ( List < TestResultDTO >  arg0 )  { try { List < TestResultDTO >  loc0 = new ArrayList <  >  ( arg0 )  ;  this . testResultLst = loc0 ;  } catch  ( Exception e )  { } }
public Scriptable function ( Context arg0 ,  Scriptable arg1 ,  Object arg2 ,  Class < ? >  arg3 )  { try { Object loc0 = new NativeJavaObject ( arg1 ,  arg2 ,  arg3 )  ;  return  ( Scriptable )  loc0 ;  } catch  ( Exception loc1 )  { return null ;  } }
public String function (  )  { String loc0 = "" ;  try { loc0 = mTierAlias ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
PaymentChannelServerState function ( Wallet arg0 ,  TransactionBroadcaster arg1 )  { final Transaction contract = this . contract ;  checkArgument ( contract != null ,  "Cannot call getOrCreateState on a stored channel without a contract" )  ;  final Sha256Hash hash = contract . getHash (  )  ;  final byte [  ]  scriptBytes = clientOutput . getScriptBytes (  )  ;  final Script scriptPubKey = new Script ( scriptBytes )  ;  final PaymentChannelServerState loc0 = PaymentChannelServerState . getChannelState (  arg0 ,  contract ,  refundTransactionUnlockTimeSecs ,  scriptPubKey ,  myKey )  ;  final TransactionOutput loc1 = loc0 . getOutput (  )  ;  final TransactionSignature sig ;  if  ( bestValueToMe != null && bestValueSignature != null )  { sig = TransactionSignature . decodeFromBitcoin ( bestValueSignature )  ;  } else { sig = null ;  } final BigInteger loc2 = loc1 . getValue (  )  ;  if  ( bestValueToMe != null && loc2 . compareTo ( bestValueToMe )  == 0 )  { if  ( sig == null || !sig . verify ( hash ,  myKey )  )  { throw new IllegalStateException ( "Server's signature on best value is missing or incorrect" )  ;  } } if  ( connectedHandler != null && connectedHandler != this )  { connectedHandler . checkState (  )  ;  } return loc0 ;  }
String function ( String arg0 ,  String arg1 )  { NamespacePrefixAccumulator accumulator = new NamespacePrefixAccumulator (  )  ;  String prefix = accumulator . getPrefix ( arg0 )  ;  accumulator . collect ( prefix ,  arg1 )  ;  return prefix ;  }
Plan function ( Plan arg0 ,  int arg1 ,  List < Buffer >  arg2 )  { Plan loc0 = arg0 . materialize (  )  ;  Schema loc1 = loc0 . schema (  )  ;  TempTable loc2 = copyRecordsFrom ( loc0 )  ;  TableInfo loc3 = loc2 . getTableInfo (  )  ;  int loc4 = loc3 . recordLength (  )  ;  long loc5 = loc3 . numRecords (  )  ;  int loc6 = Math . min ( arg1 ,   ( int )   ( loc2 . getRecCount (  )  / loc4 )  )  ;  int loc7 =  ( int )  Math . ceil (  ( double )  loc5 / loc6 )  ;  List < Plan >  loc8 = new ArrayList <  >  (  )  ;  for  ( int i = 0 ;  i  <  loc5 ;  i += loc7 )  { int loc9 = Math . min ( loc7 ,   ( int )   ( loc5 - i )  )  ;  loc8 . add ( new ChunkPlan ( loc2 ,  loc9 ,  i )  )  ;  } MultiBufferProductScan loc10 = new MultiBufferProductScan ( loc8 ,  arg2 )  ;  loc10 . open (  )  ;  return loc10 ;  }
void function ( boolean arg0 )  { _highPriority = arg0 ;  }
ServerSession function ( String arg0 )  { ServerSession loc0 = null ;  try { loc0 = userSessionMap . get ( arg0 )  ;  } catch  ( Exception e )  { LOGGER . error ( "Error occurred while obtaining ServerSession for user " + arg0 ,  e )  ;  } return loc0 ;  }
public String function (  )  { try { String loc0 = this . applicationDescription ;  return loc0 ;  } catch  ( Exception loc1 )  { System . err . println ( "An error occurred while getting the application description: " + loc1 . getMessage (  )  )  ;  return null ;  } }
List < String >  function (  )  { List < String >  locList = new ArrayList < String >  (  )  ;  try { locList = links . getVertexLabels (  )  ;  } catch  ( Exception e )  { } return locList ;  }
public Object function ( String arg0 )  { try { if  ( groupfields . contains ( arg0 )  )  { return groupval . getVal ( arg0 )  ;  } else { for  ( AggregationFn loc0 : aggfns )  { if  ( loc0 . fieldName (  )  . equals ( arg0 )  )  { return loc0 . value (  )  ;  } } } throw new RuntimeException ( "Field not found: " + arg0 )  ;  } catch  ( Exception e )  { return null ;  // Return null to indicate an error occurred } }
public String function (  )  { String loc0 = this . testData ;  return loc0 ;  }
public void function ( String arg0 ,  String arg1 )  { try { LocalAlluxioClusterResource locResource = new LocalAlluxioClusterResource . Builder (  )   . setStartCluster ( true )   . setNumWorkers ( 2 )   . build (  )  ;  locResource . start (  )  ;  Map < PropertyKey ,  String >  locConfig = new HashMap <  >  (  )  ;  locConfig . put ( PropertyKey . fromString ( arg0 )  ,  arg1 )  ;  locResource . get (  )  . getMaster (  )  . getMetaMaster (  )  . getContext (  )  . mergeFrom ( PropertyKey . CONF ,  locConfig )  ;  System . out . println ( locResource . toString (  )  )  ;  } catch  ( Exception e )  { System . out . println ( "An error occurred: " + e . getMessage (  )  )  ;  e . printStackTrace (  )  ;  } }
String function ( String arg0 ,  String [  ]  arg1 )  { try { if  ( StringUtils . isEmpty ( arg0 )  )  { throw new IdentityValidationException ( "Input cannot be empty" )  ;  } if  ( isValidOverBlackListPatterns ( arg0 ,  arg1 )  )  { return arg0 ;  } else { String blackListPatternString = getPatternString ( arg1 )  ;  String errorMsg = String . format ( "%s%s%s%s%s" ,  msgSection1 ,  arg0 ,  msgSection3 ,  blackListPatternString ,  msgSection4 )  ;  throw new IdentityValidationException ( errorMsg )  ;  } } catch  ( IdentityValidationException e )  { throw e ;  } catch  ( Exception e )  { throw new IdentityValidationException ( "Error occurred while validating input" ,  e )  ;  } }
Schema function (  )  { Schema loc0 = srcplan . schema (  )  ;  return loc0 ;  }
Result function ( Result arg0 ,  ResultEntry arg1 ,  ResultObserver arg2 ,  String arg3 )  { arg0 . add ( arg1 )  ;  boolean loc0 = arg0 . contains ( arg1 )  ;  List < String >  loc1 = arg0 . getSources ( arg2 )  ;  arg0 . addObserverLogSource ( arg2 ,  arg3 )  ;  return arg0 ;  }
import java . awt . Color ;  import java . util . HashMap ;  import java . util . Map ;  import java . util . Set ;  public class ColorFactory { private double MIN_TINT_FACTOR = 0 . 2 ;  private double FIXED_TINT_FACTOR = 0 . 875 ;  private double MAX_TINT_FACTOR = 1 ;  public Map < Object , String >  function ( Set < Object >  arg0 ,  Color arg1 )  { Map < Object , String >  resultMap = new HashMap <  >  (  )  ;  for  ( Object key : arg0 )  { Color randomColor = getRandomColor (  )  ;  Color tintedColor = tintColor ( randomColor ,  FIXED_TINT_FACTOR )  ;  resultMap . put ( key ,  getColorString ( tintedColor )  )  ;  } return resultMap ;  } public Map < Object , String >  getGraduatedColorMap ( Set < Object >  keys ,  Color baseColor )  { } public Color tintColor ( Color origColor ,  double tintFactor )  { } public Color getRandomColor (  )  { } public int applyTint ( int color ,  double tintFactor )  { } public String getColorString ( Color color )  { } }
void function ( int arg0 ,  int arg1 ) { try { GeneticAlgorithm geneticAlgorithm = new GeneticAlgorithm (  )  ;  geneticAlgorithm . setPopulationSize ( 0 )  ;  geneticAlgorithm . setIterations ( 0 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
Element function ( Document arg0 ,  Element arg1 )  { Element domainsAssignmentElement = arg0 . createElement ( "DomainsAssignment" )  ;  RIFLDocument doc = getDocument (  )  ;  List < SourceSinkDomPair >  domainAssignments = doc . getDomainAssignments (  )  ;  for  ( SourceSinkDomPair loc0 : domainAssignments )  { Element domainAssignmentElement = arg0 . createElement ( "DomainAssignment" )  ;  writeSourceSinkDomPair ( loc0 ,  arg0 ,  domainAssignmentElement )  ;  domainAssignmentElement . setAttribute ( "dom" ,  loc0 . getDomain (  )  )  ;  domainsAssignmentElement . appendChild ( domainAssignmentElement )  ;  } arg1 . appendChild ( domainsAssignmentElement )  ;  return domainsAssignmentElement ;  }
import java . util . * ;  import org . w3c . dom . * ;  public class XMLRPCResult { private String VALUE = "value" ;  private String NAME = "name" ;  private String FAULT = "fault" ;  private String MEMBER = "member" ;  private TimeZone tz ;  private ArrayList < Object >  values = new ArrayList <  >  (  )  ;  public Object parseValue ( Node valueNode )  { } public String getStringValue ( int index )  { } public List getValues (  )  { } public Map < String ,  Object >  getStructValue ( int index )  { } public Double getDoubleValue ( int index )  { } public void parse ( Document doc )  { } public Integer getIntegerValue ( int index )  { } public Boolean getBooleanValue ( int index )  { } public Date getDateValue ( int index )  { } public ArrayList < Object >  parseArray ( Node valueNode )  { } public HashMap < String ,  Object >  parseStruct ( Node valueNode )  { } public List < Object >  getArrayValue ( int index )  { } public byte [  ]  getBinaryValue ( int index )  { } void function ( Object arg0 ,  Object arg1 )  { try { List < Object >  loc0 =  ( List < Object >  )  arg0 ;  int loc1 = loc0 . size (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } } }
void function ( String arg0 ,  int arg1 ,  boolean arg2 )  { Configuration config = Configuration . getConfiguration (  )  ;  String loc0 = config . getString ( Argo . KEY_INPUT_SOURCE_ENCODING )  ;  if  ( loc0 == null || !loc0 . equals ( arg0 )  )  { config . setProperty ( Argo . KEY_INPUT_SOURCE_ENCODING ,  arg0 )  ;  config . setProperty ( "inputSourceEncodingChanged" ,  Boolean . TRUE . toString (  )  )  ;  } }
class XDebug { Date stopTime ;  ArrayList parameters ;  long timeElapsed ;  HttpServletRequest request ;  ArrayList messages ;  Date startTime ;  void addParameter ( int type ,  String name ,  String value )  { } void addParameter ( int type ,  String name ,  int value )  { } void addParameter ( int type ,  String name ,  boolean value )  { } ArrayList getDebugMessages (  )  { } HttpServletRequest getRequest (  )  { } String getCompleteLog (  )  { } ArrayList getParameters (  )  { } void startTimer (  )  { } void stopTimer (  )  { } long getTimeElapsed (  )  { } void function (  )  { Class loc0 = getClass (  )  ;  XDebugMessage loc1 = new XDebugMessage (  )  ;  String loc2 = getName (  )  ;  messages . add ( loc1 )  ;  } }
void function ( int arg0 ,  long arg1 )  { MetadataEditorCompat metadataEditor = editMetadata ( true )  ;  metadataEditor . putLong ( arg0 ,  arg1 )  ;  metadataEditor . apply (  )  ;  return ;  }
void function (  )  { GeneralMotorCon loc0 = GeneralMotorCon . getInstance (  )  ;  loc0 . appendToConsole (  )  ;  loc0 . setLedsAnimation ( arg0 )  ;  loc0 . spinLeft (  )  ;  loc0 . doFor ( arg1 )  ;  loc0 . hover (  )  ;  }
 @ RequestMapping ( value = "/ingredients/{id}" ,  method = RequestMethod . GET )  public ResponseEntity < Ingredient >  function (  @ PathVariable String arg0 )  { log . debug ( "REST request to get Ingredient : {}" ,  arg0 )  ;  Optional < Ingredient >  loc0 = ingredientService . findOne ( arg0 )  ;  return loc0 . map ( result - >  new ResponseEntity <  >  ( result ,  HttpStatus . OK )  )   . orElse ( new ResponseEntity <  >  ( HttpStatus . NOT_FOUND )  )  ;  }
public void function ( Element arg0 )  { try { testNode ( arg0 ,  NodeTest . ELEMENT )  ;  } catch  ( Exception e )  { System . out . println ( "Template delegator for testNode (  )  method .  OVERRIDE to add custom logic" )  ;  } }
import java . sql . * ;  public class DbConn { Connection connection ;  DbInfo info ;  DbInfo getInfo (  )  { return info ;  } Connection getConnection (  )  { return connection ;  } boolean connect (  )  { return true ;  } void disconnect (  )  { } String function ( String arg0 ,  int arg1 ,  double arg2 )  { String loc0 = "" ;  try { Statement stmt = connection . createStatement (  )  ;  ResultSet rs = stmt . executeQuery ( "SELECT * FROM my_table WHERE id = " + arg1 )  ;  if  ( rs . next (  )  )  { loc0 = rs . getString ( arg0 )  ;  } rs . close (  )  ;  stmt . close (  )  ;  } catch  ( SQLException e )  { System . out . println ( "Error executing query: " + e . getMessage (  )  )  ;  } if  ( loc0 . equals ( "" )  )  { loc0 = "{Empty}" ;  } return loc0 ;  } }
class Reflection { String function ( String arg0 )  { String packageName = "" ;  try { int loc0 = arg0 . lastIndexOf ( " . " )  ;  if  ( loc0  > = 0 )  { String className = arg0 . substring ( loc0 + 1 )  ;  if  ( Character . isLowerCase ( className . charAt ( 0 )  )  )  { throw new IllegalArgumentException ( "Invalid class name: " + className )  ;  } packageName = arg0 . substring ( 0 ,  loc0 )  ;  } } catch  ( Exception loc1 )  { } return packageName ;  } }
 @ Override boolean function ( Object arg0 )  { if  ( arg0 == this )  { return true ;  } if  ( ! ( arg0 instanceof SimpleTypedNameDeclaration )  )  { return false ;  } SimpleTypedNameDeclaration loc0 =  ( SimpleTypedNameDeclaration )  arg0 ;  if  ( this . internalEquals ( loc0 )  )  { return true ;  } return this . internalEqualsNext ( loc0 )  && canCast ( this . type ,  loc0 . type )  && canCast ( loc0 . type ,  this . type )  ;  } private static boolean canCast ( Class < ? >  from ,  Class < ? >  to )  { if  ( from . equals ( to )  )  { return true ;  } if  ( from . isPrimitive (  )  )  { return from == byte . class &&  ( to == short . class || to == int . class || to == long . class || to == float . class || to == double . class )  || from == short . class &&  ( to == int . class || to == long . class || to == float . class || to == double . class )  || from == char . class &&  ( to == int . class || to == long . class || to == float . class || to == double . class )  || from == int . class &&  ( to == long . class || to == float . class || to == double . class )  || from == long . class &&  ( to == float . class || to == double . class )  || from == float . class && to == double . class ;  } else { return to . isAssignableFrom ( from )  ;  } }
String function (  )  { String loc0 = "" ;  try { loc0 = lineItem . getLineItem (  )  . getItem (  )  . getSellersItemIdentification (  )  . getID (  )  . getValue (  )  ;  } catch  ( Exception e )  { System . err . println ( "Error occurred while getting the part number: " + e . getMessage (  )  )  ;  } return loc0 ;  }
void function ( int arg0 )  { state . skipAfterUnicodeChar = arg0 ;  } Note: I have assumed that the variable "state" is a member variable of the class "StandardRtfParser" and "skipAfterUnicodeChar" is a member variable of the class "ParserState" .  Also ,  please make sure to handle any exceptions that may occur when calling this method in your code . 
void function ( final TMXTile arg0 ,  final TMXTiledMap arg1 ,  final int arg2 )  { try { arg0 . setGlobalTileID ( arg1 ,  arg2 )  ;  } catch  ( Exception loc0 )  { System . err . println ( "An error occurred while setting global tile ID: " + loc0 . getMessage (  )  )  ;  } }
void function (  )  { BlockStoreMetaTest testInstance = new BlockStoreMetaTest (  )  ;  testInstance . before (  )  ;  long loc0 = testInstance . mBlockStoreMeta . getCapacityBytes (  )  ;  long loc1 = testInstance . mMetadataManager . getDefaultTotalCapacityBytes (  )  ;  assertEquals ( loc1 ,  loc0 )  ;  testInstance . mBlockStoreMeta . shutdown (  )  ;  testInstance . mBlockStoreMetaFull . shutdown (  )  ;  testInstance . mMetadataManager . close (  )  ;  try { testInstance . mTestFolder . delete (  )  ;  } catch  ( IOException e )  { } }
String function (  )  throws IOException { lines . clear (  )  ;  lineBuf . loc0 (  )  ;  while  ( true )  { int n = readable . read ( buf )  ;  if  ( n == -1 )  { break ;  } cbuf . loc0 (  )  ;  cbuf . limit ( n )  ;  lineBuf . add ( cbuf )  ;  } lineBuf . poll (  )  ;  return lines . peek (  )  ;  }
void function (  )  { GSVTest test = new GSVTest (  )  ;  int arg0 = 3 ;  test . setSentenceCount ( arg0 )  ;  int loc0 = test . getSentenceCount (  )  ;  assertEquals ( arg0 ,  loc0 )  ;  }
void function ( String arg0 )  { String loc0 = arg0 . trim (  )  ;  String loc1 = loc0 . replaceAll ( " " ,  "_" )  . toLowerCase (  )  ;  String loc2 = "/res/drawable-xxhdpi/" + loc1 + " . png" ;  setIconPath ( loc2 )  ;  }
public void function ( String arg0 ,  String arg1 ,  String arg2 ,  String arg3 )  { Proxy loc0 = properties . getProxy (  )  ;  if  ( isProxyEnabled (  )  && loc0 . getUsername (  )  == null )  { Authentication loc1 = getAuth (  )  ;  String loc2 = getUsername (  )  ;  String loc3 = getPassword (  )  ;  if  ( loc1 != null && loc2 != null && loc3 != null )  { loc0 . setUsername ( loc2 )  ;  loc0 . setPassword ( loc3 )  ;  } } }
public void function ( InputStream arg0 ,  IParserEventHandler arg1 )  { DefaultEventHandler eventHandler = new DefaultEventHandler (  )  ;  RawRtfParser parser = new RawRtfParser ( eventHandler )  ;  parser . parse ( arg0 )  ;  }
Result function ( List < String >  arg0 ,  ResultObserver arg1 )  { Result loc0 = new Result (  )  ;  for  ( ResultEntry loc1 : this . log )  { if  ( !arg0 . contains ( loc1 . getSource (  )  )  && loc1 . getLevel (  )  . equals ( ResultLevel . SUCCESS )  )  { loc0 . add ( loc1 )  ;  } } loc1 . setSources ( arg1 ,  arg0 )  ;  this . addObserverLogSource ( arg1 ,  arg0 )  ;  this . add ( loc1 )  ;  return loc0 ;  }
class TestNormOps { DenseMatrix64F loc0 = new DenseMatrix64F ( 5 , 1 , true , 0 . 3 , 1 , -2 , 3 , 4 )  ;  Random loc1 = new Random ( 234 )  ;  DenseMatrix64F loc2 = new DenseMatrix64F ( 3 , 4 )  ;  DenseMatrix64F loc3 = new DenseMatrix64F ( 3 , 2 , true , 0 . 2 , 1 , -2 , 3 , 6 , 5 )  ;  DenseMatrix64F loc4 = new DenseMatrix64F ( 2 , 2 , true , 0 . 2 , 1 , -2 , 3 )  ;  void function (  )  { NormOps . conditionP2 ( loc0 , loc1 , loc2 , loc3 , loc4 )  ;  assertEquals ( 0 . 1059 , NormOps . conditionP ( loc3 , 2 )  , UtilEjml . TEST_F64 )  ;  checkUncountable ( NormOps . inducedP1 ( loc4 )  )  ;  } }
import com . aliyun . openservices . oss . OSSClient ;  import com . aliyun . openservices . oss . model . ObjectListing ;  import org . apache . hadoop . conf . Configuration ;  import org . apache . hadoop . fs . Path ;  import org . apache . hadoop . fs . aliyun . oss . AliyunOSSTestUtils ;  import org . apache . hadoop . fs . aliyun . oss . OSSFileSystem ;  import org . apache . hadoop . fs . aliyun . oss . OSSTestUtils ;  import org . junit . Before ;  import org . junit . Test ;  import org . mockito . Matchers ;  import org . mockito . Mockito ;  import static org . junit . Assert . assertFalse ;  public class OSSUnderFileSystemTest { private OSSUnderFileSystem mOSSUnderFileSystem ;  private String PATH = "path" ;  private String BUCKET_NAME = "bucket" ;  private String BUCKET_PREFIX = "prefix" ;  private OSSClient mClient ;  private String DST = "dst" ;  private String SRC = "src" ;   @ Before public void before (  )  { Configuration conf = new Configuration (  )  ;  conf . set ( "fs . oss . impl . disable . cache" ,  "true" )  ;  mClient = Mockito . mock ( OSSClient . class )  ;  mOSSUnderFileSystem = new OSSUnderFileSystem ( mClient ,  conf )  ;  }  @ Test public void function (  )  { try { Mockito . when ( mClient . listObjects ( Matchers . anyString (  )  ,  Matchers . anyString (  )  )  )   . thenThrow ( new RuntimeException ( "Test exception" )  )  ;  mOSSUnderFileSystem . delete ( PATH ,  true )  ;  assertFalse ( "Should have thrown exception" ,  true )  ;  } catch  ( Exception e )  { assertFalse ( e instanceof AssertionError )  ;  } } }
List < Language >  function ( File arg0 )  { List < Language >  loc0 = new ArrayList <  >  (  )  ;  try { LanguageVersion loc1 = getDefaultLanguageVersionForFile ( arg0 )  ;  if  ( loc1 != null )  { loc0 . add ( loc1 . getLanguage (  )  )  ;  } } catch  ( IOException e )  { } if  ( loc0 . isEmpty (  )  )  { String loc2 = arg0 . getName (  )  ;  if  ( loc2 != null )  { String loc3 = getExtension ( loc2 )  ;  if  ( loc3 != null )  { LanguageVersion loc4 = getDefaultLanguageVersion ( Language . findByExtension ( loc3 )  )  ;  if  ( loc4 != null )  { loc0 . add ( loc4 . getLanguage (  )  )  ;  } } } } return loc0 ;  }
void function ( Set < Method >  arg0 ,  Class < ? >  .  .  .  arg1 )  { suppressedTests . addAll ( Arrays . asList ( arg1 )  . suppressing ( arg0 )  )  ;  }
void function ( AudioManager arg0 ,  RemoteControlClientCompat arg1 )  { if  ( sHasRemoteControlAPIs )  { arg0 . registerRemoteControlClient ( arg1 . getActualRemoteControlClientObject (  )  )  ;  } else { } }
public long function (  )  { try { return this . messagesSent ;  } catch  ( Exception loc0 )  { System . err . println ( "Error in getting the number of messages sent: " + loc0 . getMessage (  )  )  ;  return -1 ;  } }
lalr_item function (  )  { if  ( size (  )  == 0 )  { return null ;  } Iterator < lalr_item >  loc0 = _all . values (  )  . iterator (  )  ;  lalr_item loc1 = loc0 . next (  )  ;  loc0 . remove (  )  ;  return loc1 ;  }
class URLConnectionInfo { URI theURI ;  URI function (  )  { return theURI ;  } }
void function ( String arg0 )  { ServletContext loc0 = this . config . getServletContext (  )  ;  String loc1 = this . config . getFilterName (  )  ;  String loc2 = loc1 + "srini_string" + arg0 ;  loc0 . log ( loc2 )  ;  }
public String function ( Map < ClaimMapping , List < String >  >  arg0 )  { String loc0 = null ;  return loc0 ;  }
GSVSentence gsv ;  String EXAMPLE="$GPGSV , 3 , 2 , 12 , 15 , 56 , 182 , 51 , 17 , 38 , 163 , 47 , 18 , 63 , 058 , 50 , 21 , 53 , 329 , 47*73" ;  GSVSentence empty ;  void function (  )  { GSVParser parser = new GSVParser ( "srini_string" )  ;  List < SatelliteInfo >  loc1 = parser . getSatelliteInfo (  )  ;  assertEquals ( 2 ,  loc1 . size (  )  )  ;  testSatelliteInfo ( loc1 . get ( 0 )  ,  "srini_string" ,  56 ,  182 ,  51 )  ;  testSatelliteInfo ( loc1 . get ( 1 )  ,  "srini_string" ,  38 ,  163 ,  47 )  ;  }
import static org . junit . Assert . assertTrue ;  import org . junit . Before ;  import org . junit . Test ;  public class DataByteBufferTest { private ByteBuffer mBuffer = null ;  private final int LENGTH = 5 ;   @ Before void before (  )  { mBuffer = ByteBuffer . allocate ( LENGTH )  ;  }  @ Test void function (  )  { DataByteBuffer loc0 = new DataByteBuffer ( mBuffer )  ;  byte [  ]  loc1 = loc0 . getNettyOutput (  )  ;  assertTrue ( loc1 . length == LENGTH )  ;  }  @ Test void length (  )  { assertTrue ( mBuffer . capacity (  )  == LENGTH )  ;  }  @ Test void readOnlyByteBuffer (  )  { ByteBuffer loc2 = mBuffer . asReadOnlyBuffer (  )  ;  assertTrue ( loc2 . isReadOnly (  )  )  ;  } }
boolean function (  )  { return loggingEnabled ;  }
RegisteredClient function ( String arg0 )  { RegisteredClient loc0 = null ;  try { Map < String ,  RegisteredClient >  loc1 = getClients (  )  ;  loc0 = loc1 . values (  )  . stream (  )   . filter ( client - >  arg0 . equals ( client . getIssuer (  )  . toString (  )  )  )   . findFirst (  )  . orElse ( null )  ;  } catch  ( Exception loc2 )  { loc2 . printStackTrace (  )  ;  } return loc0 ;  }
public String function ( String arg0 )  { String loc0 = arg0 ;  int loc1 = loc0 . lastIndexOf ( " . " )  ;  if  ( loc1  > = 0 )  { loc0 = loc0 . substring ( 0 ,  loc1 )  ;  } return loc0 ;  }
boolean function ( String arg0 ,  FieldSigMask arg1 )  { for  ( FieldSignature loc0 : fields . keySet (  )  )  { if  ( arg1 . covers ( loc0 )  && loc0 . getName (  )  . equals ( arg0 )  )  { Set < String >  loc1 = fields . get ( loc0 )  ;  if  ( loc1 != null && loc1 . contains ( arg0 )  )  { return true ;  } } } return false ;  }
Object function ( TreePath arg0 ,  Object arg1 )  { Object loc0 = arg0 . getLastPathComponent (  )  ;  TreePath loc1 = arg0 . getParentPath (  )  ;  int loc2 = arg1 == null ? -1 : getIndexOfChild ( loc0 ,  arg1 )  ;  if  ( loc1 != null )  { int [  ]  loc3 = {loc2} ;  Object [  ]  loc4 = {arg1} ;  fireChildrenChanged ( loc1 ,  loc3 ,  loc4 )  ;  } else { fireChildChanged ( arg0 ,  loc2 ,  arg1 )  ;  } return null ;  }
void function ( ServiceID arg0 ,  int arg1 ,  int arg2 ,  InetAddress arg3 )  { long loc0 = 0 ;  int loc1 = RETVAL_ERROR ;  ServiceInfo [  ]  loc2 = null ;  loc0 = performServiceRemovalRequest ( arg0 ,  arg1 ,  arg2 ,  arg3 )  ;  waitForRemovalCompletion ( loc0 )  ;  loc1 = checkRemovalStatus ( loc0 )  ;  if  ( loc1 == RETVAL_OK )  { loc2 = getServiceInformation (  )  ;  if  ( loc2 != null )  { processServiceInformation ( loc2 )  ;  } else { System . out . println ( getRetvalString ( RETVAL_NOENTRY )  )  ;  } } else if  ( loc1 == RETVAL_NOENTRY )  { System . out . println ( getRetvalString ( loc1 )  )  ;  } else { System . out . println ( getRetvalString ( loc1 )  )  ;  } } Note: This implementation assumes the existence of the following helper methods: "long performServiceRemovalRequest ( ServiceID id ,  int flags ,  int prefixBits ,  InetAddress addr ) " ,  "void waitForRemovalCompletion ( long xid ) " ,  "int checkRemovalStatus ( long xid ) " ,  "ServiceInfo [  ]  getServiceInformation (  ) " ,  "void processServiceInformation ( ServiceInfo [  ]  info ) " . 
void function ( String arg0 )  { testId = arg0 ;  }
void function (  )  { Set < InetSocketAddress >  loc0 = m_connections . keySet (  )  ;  Iterator < InetSocketAddress >  loc1 = loc0 . iterator (  )  ;  while  ( loc1 . hasNext (  )  )  { InetSocketAddress arg0 = loc1 . next (  )  ;  IoSession loc2 = m_connections . get ( arg0 )  ;  if  ( loc2 != null )  { loc2 . closeNow (  )  ;  } loc1 . remove (  )  ;  m_trackedRemoteHosts . remove ( arg0 . getAddress (  )  )  ;  m_permittedAddresses . remove ( arg0 . getAddress (  )  )  ;  } m_connections . clear (  )  ;  m_allocatedTurnServer = null ;  }
JSONArray function ( List < JsonWorkflowJob >  arg0 )  { JSONArray loc0 = new JSONArray (  )  ;  for  ( JsonWorkflowJob loc1 : arg0 )  { JSONObject loc2 = loc1 . toJSONObject (  )  ;  loc2 . put ( "actions" ,  new JSONArray ( loc1 . getActions (  )  )  )  ;  loc0 . add ( loc2 )  ;  } return loc0 ;  }
boolean function (  )  { if  ( arg0 . getMrnaValue (  )  != null && arg0 . getMrnaValue (  )  == MRNA . DOWNREGULATED )  { return true ;  } return false ;  } Note: It's unclear what the inputs  ( arguments )  for this method should be ,  so I've used generic names  ( arg0 ,  arg1 )  instead .  It's also unclear where the variables CNA ,  GeneticEventComparator ,  and RPPA come from ,  so I've omitted them from the implementation of this method . 
Verb function (  )  { return Verb . POST ;  }
boolean function ( boolean arg0 )  { boolean loc0 = arg0 ;  mCascade = loc0 ;  return true ;  }
MRNA function ( GeneticEventImpl arg0 )  { MRNA loc0 = arg0 . getMrnaValue (  )  ;  if  ( loc0 == null )  { return null ;  } if  ( loc0 . getFoldChange (  )   >  1 . 0 )  { return loc0 ;  } else { return null ;  } }
int function ( DagELFunctions obj )  { WorkflowJobBean loc0 = obj . getWorkflow (  )  ;  int loc1 = loc0 . getRun (  )  ;  return loc1 ;  }
public void function ( List < ChildNumber >  arg0 ,  DeterministicKey arg1 )  { try { ImmutableList < ChildNumber >  path = ImmutableList . copyOf ( arg0 )  ;  ImmutableList < ChildNumber >  parentPath = path . subList ( 0 ,  path . size (  )  - 1 )  ;  ChildNumber childNumber = path . get ( path . size (  )  - 1 )  ;  Map < ImmutableList < ChildNumber >  ,  DeterministicKey >  loc0 = this . keys ;  DeterministicKey parent = loc0 . get ( parentPath )  ;  if  ( parent == null )  { throw new IllegalArgumentException ( "Parent does not exist in the heirarchy" )  ;  } int loc1 = parent . getChildNumber (  )  . num (  )  + 1 ;  if  ( loc1 != childNumber . num (  )  )  { throw new IllegalArgumentException ( "Cannot insert key at index " + childNumber . num (  )  + " ,  because it would imply missing index " + loc1 )  ;  } parent . put ( loc1 ,  arg1 )  ;  loc0 . put ( path ,  arg1 )  ;  this . lastChildNumbers . put ( parentPath ,  childNumber )  ;  } catch  ( Exception e )  { System . err . println ( "Error inserting key into hierarchy: " + e . getMessage (  )  )  ;  } }
public List < TestResultDTO >  function ( TestResultsDTO arg0 )  { List < TestResultDTO >  loc0 = new ArrayList <  >  (  )  ;  try { loc0 = arg0 . getTestResultLst (  )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
Element function ( KeyInfoElement arg0 )  { Element loc0 = arg0 . getKeyInfoElement (  )  ;  NodeList loc1 = loc0 . getElementsByTagNameNS ( "*" ,  "EncryptedKey" )  ;  if  ( loc1 . getLength (  )   >  0 )  { Element loc2 =  ( Element )  loc1 . item ( 0 )  ;  return loc2 ;  } else { LOG . warning ( "Failed to get EncryptedKeyElement object from KeyInfoElement object . " )  ;  return null ;  } }
void function ( String arg0 )  { try { failedImages . add ( arg0 )  ;  } catch  ( Exception loc0 )  { System . err . println ( "Failed to add image URL to tracker: " + loc0 . getMessage (  )  )  ;  } }
void function ( boolean arg0 )  { isCurrentScenario = arg0 ;  }
void function ( File arg0 )  throws IOException { Scanner loc0 = new Scanner ( arg0 )  ;  loc0 . useDelimiter ( "srini_string" )  ;  while ( loc0 . hasNext (  )  )  { _ignoreWords . add ( loc0 . next (  )  )  ;  } loc0 . close (  )  ;  }
void function ( String arg0 ,  String arg1 )  { try { loc0 = arg1 ;  setChecksum ( loc0 )  ;  } catch  ( Exception loc1 )  { } }
void function ( Result arg0 )  { Trans < Object >  trans = new Trans < Object >  (  )  ;  trans . withExceptionHandling ( new Trans < Object >  (  )  { public Object transform (  )  { transformation . transformTo ( arg0 )  ;  return null ;  } } )  ;  }
void function ( Node arg0 )  { Node loc0 = graph . removeVertex ( arg0 )  ;  String loc1 = loc0 . getId (  )  ;  boolean loc2 = nodesByIds . remove ( loc1 )  != null ;  Collection < Edge >  loc3 = graph . remove ( loc0 )  ;  }
void function ( RuleSet ruleSet )  { try { Language language = ruleSet . getLanguage (  )  == null ? LanguageRegistry . getLanguage ( "java" )  : ruleSet . getLanguage (  )  ;  synchronized  ( ruleSets )  { boolean replaced = false ;  for  ( int i = 0 ;  i  <  ruleSets . size (  )  ;  i ++  )  { RuleSet existingRuleSet = ruleSets . get ( i )  ;  if  ( existingRuleSet . getLanguage (  )  . equals ( language )  )  { ruleSets . set ( i ,  ruleSet )  ;  replaced = true ;  break ;  } } if  ( !replaced )  { ruleSets . add ( ruleSet )  ;  } } ruleChain . addRuleSet ( ruleSet )  ;  } catch  ( Exception loc0 )  { } }
void function ( XmlCursor arg0 ,  String arg1 ,  Set arg2 ,  Map arg3 )  { String loc0 = arg0 . getName (  )  . getLocalPart (  )  ;  String loc1 = arg0 . getNamespaceURI (  )  ;  String loc2 =  ( String ) arg3 . get ( loc1 )  ;  int loc3 = loc2 . size (  )  ;  arg2 . add ( loc0 )  ;  arg3 . put ( loc1 ,  loc0 )  ;  Object loc4 = arg1 ;  loc4 . add ( new Object [  ]  { loc0 ,  loc1 } )  ;  }
GetOfferDetailsResponse . Return . DetailOfferData function (  )  { GetOfferDetailsResponse . Return . DetailOfferData loc0 = new GetOfferDetailsResponse . Return . DetailOfferData (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataRedemptionAddresses (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataTargetGeos (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataOfferDisplay (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataSourceGeos (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataTargetGeosGeo (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataOfferMedia (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataProducts (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataMerchant (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataFulfillmentPartner (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataSeo (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataMerchantAddresses (  )  ;  return loc0 ;  }
Supplier < T >  function ( Supplier < T >  arg0 ,  Function < ? super F ,  T >  arg1 )  { Preconditions . checkNotNull ( arg0 )  ;  return new ThreadSafeSupplier < T >  ( new Suppliers . Supplier < T >  (  )  {  @ Override public T get (  )  { synchronized  ( arg0 )  { if  ( !initialized )  { value = arg1 . apply ( supplier . get (  )  )  ;  initialized = true ;  } if  ( expirationNanos  >  0 && System . nanoTime (  )  - durationNanos  >  expirationNanos )  { initialized = false ;  } return value ;  } } } )  ;  }
public class HiddenMarkovModel { Matrix prior = null ;  RandomVariable stateVariable = null ;  Matrix transitionModel = null ;  Map < Object ,  Matrix >  sensorModel = null ;  FiniteDomain stateVariableDomain = null ;  Matrix createUnitMessage (  )  { } Matrix normalize ( Matrix m )  { } Matrix getPrior (  )  { } RandomVariable getStateVariable (  )  { } Matrix getEvidence ( List < AssignmentProposition >  evidence )  { } Matrix getTransitionModel (  )  { } Map < Object ,  Matrix >  getSensorModel (  )  { } Matrix function ( Matrix arg0 )  { Matrix loc0 = arg0 . getValues (  )  ;  Matrix loc1 = new Matrix ( loc0 . getRowDimension (  )  ,  1 )  ;  for  ( int i = 0 ;  i  <  loc0 . getRowDimension (  )  ;  i ++  )  { loc1 . set ( i ,  0 ,  loc0 . get ( i ,  0 )  )  ;  } return loc1 ;  } }
List < Node >  function ( Object arg0 ,  Object arg1 )  { List < Node >  loc0 = new ArrayList <  >  (  )  ;  try { loc0 . addAll ( evaluationResults )  ;  } catch  ( Exception loc1 )  { LOGGER . log ( Level . SEVERE ,  "Error retrieving evaluation results" ,  loc1 )  ;  } return loc0 ;  }
boolean function (  )  { return services != null ;  }
private void function ( int requestedBytes )  { int remainingBytes = mWriter . remaining (  )  ;  if  ( remainingBytes  <  requestedBytes )  { int newCapacity = mBuffer . length + requestedBytes - remainingBytes ;  byte [  ]  newBuffer = new byte [ newCapacity ]  ;  System . arraycopy ( mBuffer ,  0 ,  newBuffer ,  0 ,  mWriter . position (  )  )  ;  mWriter = ByteBuffer . wrap ( newBuffer )  ;  mBuffer = newBuffer ;  } }
String function (  )  throws BadSyntaxException { if  ( !matchStringConstant (  )  )  { throw new BadSyntaxException (  )  ;  } String loc0 = tok . sval ;  nextToken (  )  ;  return loc0 ;  }
boolean function ( Integer arg0 )  { try { return graph . addNode ( arg0 )  ;  } catch  ( UnsupportedOperationException e )  { return false ;  } catch  ( IllegalArgumentException e )  { throw new RuntimeException ( ERROR_ADDED_SELF_LOOP )  ;  } catch  ( NullPointerException e )  { throw new RuntimeException ( ERROR_NODE_NOT_IN_GRAPH )  ;  } catch  ( Exception e )  { throw new RuntimeException ( ERROR_ELEMENT_NOT_IN_GRAPH )  ;  } }
List < String >  function ( List < String >  arg0 ,  ResourceBundle arg1 )  { List < String >  loc0 = null ;  try { loc0 = new ArrayList <  >  ( arg0 )  ;  loc0 . addAll ( getProduceMediaTypes (  )  )  ;  } catch  ( Exception loc1 )  { LOG . log ( Level . WARNING ,  BUNDLE . getString ( "PRODUCE_TYPES_FAILURE_MSG" )  ,  loc1 )  ;  } return loc0 ;  }
Message function ( String arg0 )  { try { Object loc0 = JSONValue . parseWithException ( arg0 )  ;  return parseJSONValueToMessage ( loc0 )  ;  } catch  ( ParseException loc1 )  { throw new ParserException ( "Unable to parse message: " + arg0 ,  loc1 )  ;  } }
public DenseMatrix64F function ( int arg0 ,  int arg1 )  { DenseMatrix64F matrix = new DenseMatrix64F ( arg0 ,  arg1 )  ;  int numRows = matrix . getNumRows (  )  ;  int numCols = matrix . getNumCols (  )  ;  int min = Math . min ( numRows ,  numCols )  ;  double [  ]  diag = new double [ min ]  ;  double [  ]  off = new double [ min-1 ]  ;  int loc0 = Math . max ( 1 ,  min-1 )  ;  matrix . handleB ( matrix ,  false ,  arg0 ,  arg1 ,  min )  ;  matrix . getDiagonal ( diag ,  off )  ;  return matrix ;  }
public String function (  )  { String result = "" ;  try { result = label (  )  ;  result += " converted to a string . " ;  } catch  ( Exception loc0 )  { result = "Error: " + loc0 . getMessage (  )  ;  } return result ;  }
String function ( MediaInfo arg0 ,  int arg1 )  { Uri loc0 = getImageUri ( arg0 ,  arg1 )  ;  return loc0 . toString (  )  ;  }
public static long function (  )  { long loc0 = 0 ;  try { loc0 = RpcStatus . totalElapsed . get (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
String function ( BufferedReader loc0 ,  String loc1 )  { String line ;  try { while  (  ( line = loc0 . readLine (  )  )  != null )  { line = line . trim (  )  ;  if  ( !line . startsWith ( "#" )  )  { break ;  } } line = line . trim (  )  ;  return line ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
double function ( double arg0 )  { final double loc0 = 95 . 56789 ;  VTGSentence vtg = new VTGSentence ( EXAMPLE )  ;  vtg . setMagneticCourse ( loc0 )  ;  assertTrue ( vtg . toString (  )  . contains ( "srini_string" )  )  ;  assertEquals ( loc0 ,  vtg . getMagneticCourse (  )  ,  0 . 1 )  ;  return arg0 ;  }
void function ( MessageContext arg0 )  { try { mc = arg0 ;  } catch  ( Exception e )  { } }
 @ Override public int function ( Object arg0 ,  Object arg1 )  { int loc0 = Objects . hashCode ( arg0 )  ;  int loc1 = Objects . hashCode ( arg1 )  ;  return loc0 * loc1 ;  }
public class SimpleSVD { private DenseMatrix64F mat ;  private SingularValueDecomposition < DenseMatrix64F >  svd ;  private SimpleMatrix U ,  V ,  W ;  public int rank (  )  { return svd . rank (  )  ;  } public SimpleMatrix nullSpace (  )  { return new SimpleMatrix ( svd . nullSpace (  )  )  ;  } public int nullity (  )  { return mat . numCols - rank (  )  ;  } public SimpleMatrix getU (  )  { return U ;  } public double quality (  )  { return svd . quality (  )  ;  } public SimpleMatrix getV (  )  { return V ;  } public SimpleMatrix getW (  )  { return W ;  } public SingularValueDecomposition getSVD (  )  { return svd ;  } public double function ( int arg0 ,  int arg1 )  { try { return W . get ( arg0 ,  arg1 )  ;  } catch  ( Exception e )  { System . err . println ( "Error: " + e . getMessage (  )  )  ;  return Double . NaN ;  } } }
public static Object [  ]  function ( Object arg0 ,  Object arg1 )  { List < RuleSet >  loc0 = null ;  try { loc0 =  (  ( RuleSets )  arg0 )  . ruleSets ;  return loc0 . toArray (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return null ;  }
int function ( String arg0 )  { int loc0 = 0 ;  try { loc0 = Integer . parseInt ( params . get ( arg0 )  )  ;  } catch  ( NumberFormatException e )  { loc0 = 0 ;  } return loc0 ;  }
boolean function ( Bits arg0 )  { try { return this . imply ( arg0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function ( Object arg0 ,  Object arg1 )  { try { } catch  ( Exception loc0 )  { LOG . warn ( "Failed to perform additional operations before disconnecting: " + loc0 . getMessage (  )  )  ;  } }
void function ( String arg0 )  { isActive = arg0 ;  }
String function (  )  { String loc0 = pg . getString ( pos )  ;  pos += loc0 . length (  )  ;  return loc0 ;  }
CascadedStyle function ( List < PropertyValue >  arg0 ,  PropertyDeclaration arg1 ,  CSSName arg2 ,  CascadedStyle arg3 ,  Iterator < PropertyDeclaration >  arg4 )  { List < PropertyValue >  loc0 = Collections . singletonList ( new PropertyValue ( arg2 ,  arg1 . getIdent (  )  )  )  ;  PropertyDeclaration loc1 = new PropertyDeclaration ( arg2 ,  loc0 )  ;  CascadedStyle loc2 = new CascadedStyle ( arg3 )  ;  loc2 . addProperties ( arg4 )  ;  loc2 . add ( loc1 )  ;  return loc2 . createLayoutStyle (  )  ;  }
String function (  )  { String loc0 = avoidNull ( xmlParser . getTitle (  )  )  ;  String loc1 = avoidNull ( getMessage (  )  )  ;  return loc0 + ": " + loc1 ;  }
int function ( Object arg0 ,  int arg1 )  { int loc0 = System . identityHashCode ( arg0 )  ;  int loc1 = loc0 & _mask ;  while  ( _keys [ loc1 ]  != null )  { if  ( _keys [ loc1 ]  == arg0 || _keys [ loc1 ]  == DELETED )  { break ;  } loc1 =  ( loc1 + 1 )  & _mask ;  } _keys [ loc1 ]  = arg0 ;  _values [ loc1 ]  = arg1 ;  if  ( _keys [ loc1 ]  == null )  { _size ++  ;  } if  ( _size  >  _mask * 3 / 4 )  { resize ( _mask * 2 + 1 )  ;  } return NULL ;  }
public int function (  )  { int loc0 = placementHint ;  return loc0 ;  }
URI function ( QName arg0 )  { for  ( ServiceContractResolver loc0 : resolvers )  { URI loc1 = loc0 . resolveContractLocation ( arg0 )  ;  if  ( loc1 != null )  { return loc1 ;  } } return null ;  }
boolean function ( OthelloSide arg0 )  { return !hasMoves ( arg0 )  ;  }
void function (  )  { setUp (  )  ;  Properties loc0 = getResourceBundleAsProperties (  )  ;  assertNotNull ( loc0 )  ;  String loc1 = getName (  )  ;  assertNotNull ( loc1 )  ;  System . out . println ( "Test of getResourceBundleAsProperties method ,  of class DBType . " )  ;  Properties loc2 = includeProperties ;  assertNotNull ( loc2 )  ;  Properties loc3 = testProperties ;  assertNotNull ( loc3 )  ;  Properties loc4 = getBundle (  )  . getProperties (  )  ;  assertNotNull ( loc4 )  ;  assertEquals ( loc0 . getProperty ( "testKey" )  ,  loc4 . getProperty ( "testKey" )  )  ;  tearDown (  )  ;  }
void function ( Runnable task )  { synchronized  ( internalLock )  { queue . add ( task )  ;  if  ( !isWorkerRunning )  { startQueueWorker (  )  ;  } } }
public void function ( Date arg0 )  { try { Date loc0 = arg0 ;  this . setExpires ( loc0 )  ;  } catch  ( Exception loc1 )  { } }
public boolean function ( Message arg0 ,  ClassResourceInfo arg1 )  { int loc0 = 5 ;  String loc1 = "Basic" ;  Log loc2 = LogFactory . getLog ( BasicAuthHandler . class )  ;  boolean loc3 = false ;  if  ( arg0 != null )  { List < String >  authHeaders = arg0 . getHeaders (  )  . get ( "Authorization" )  ;  if  ( authHeaders != null )  { for  ( String authHeader : authHeaders )  { if  ( authHeader . startsWith ( loc1 )  )  { loc3 = true ;  break ;  } } } } if  ( !loc3 && arg1 != null )  { loc3 = arg1 . getResourceClass (  )  . isAnnotationPresent ( PermitAll . class )  ;  } if  ( !loc3 && arg1 != null )  { loc3 = arg1 . getResourceMethod (  )  . isAnnotationPresent ( PermitAll . class )  ;  } return loc3 ;  }
int function ( int arg0 ,  int arg1 )  { long loc0 = UnsignedInts . toLong ( arg0 )  ;  long loc1 = UnsignedInts . toLong ( arg1 )  ;  try { return  ( int )   ( loc0 / loc1 )  ;  } catch  ( ArithmeticException e )  { return UnsignedInts . parseUnsignedInt ( "4294967295" )  ;  } }
Type function ( Type arg0 )  { try { Type [  ]  loc0 = TypeUtils . getSingleTypeParameter ( arg0 )  ;  if  ( loc0 == null )  { return null ;  } return loc0 [ 0 ]  ;  } catch  ( Exception e )  { return null ;  } }
import javax . xml . namespace . QName ;  import javax . xml . stream . XMLStreamReader ;  import org . apache . cxf . aegis . AegisContext ;  import org . apache . cxf . aegis . type . AegisType ;  import org . apache . cxf . common . logging . LogUtils ;  import java . lang . reflect . Type ;  import java . util . Map ;  public class TypeUtil { private static final Logger LOG = LogUtils . getL7dLogger ( TypeUtil . class )  ;  public static void function ( Type arg0 ,  Object arg1 ,  AegisType arg2 ,  Map < String ,  AegisType >  arg3 )  { AegisContext globalContext = new AegisContext (  )  ;  try { AegisType loc0 = getWriteTypeStandalone ( arg0 ,  globalContext ,  arg1 ,  arg2 )  ;  Map < Type ,  AegisType >  loc1 = getTypeMapping ( globalContext )  ;  AegisType loc2 = getTypeCreator ( globalContext )  . createType ( arg0 )  ;  } catch  ( Exception e )  { LOG . warning ( "An error occurred while calling TypeUtil methods in function (  )  . " ,  e )  ;  } } public static AegisType getWriteTypeStandalone ( Type arg0 ,  AegisContext arg1 ,  Object arg2 ,  AegisType arg3 )  { return null ;  // Implementation goes here } public static Map < Type ,  AegisType >  getTypeMapping ( AegisContext arg0 )  { return null ;  // Implementation goes here } public static AegisContext . TypeCreator getTypeCreator ( AegisContext arg0 )  { return null ;  // Implementation goes here } public static AegisType createType ( Type arg0 )  { return null ;  // Implementation goes here } }
public String function (  )  { RMManager loc0 = reliableEndpoint . getManager (  )  ;  IdGenerator loc1 = loc0 . getIdGenerator (  )  ;  String sequenceIdentifier = loc1 . generateSequenceIdentifier (  )  ;  return sequenceIdentifier ;  }
int function ( String arg0 )  { try { SortPlan sortPlan = new SortPlan ( p ,  comp ,  tx ,  sch )  ;  Scan s = sortPlan . open (  )  ;  int distinctValuesCount = s . distinctValues ( arg0 )  ;  s . close (  )  ;  return distinctValuesCount ;  } catch  ( Exception e )  { } return -1 ;  }
import java . nio . ByteBuffer ;  import java . security . MessageDigest ;  import java . security . NoSuchAlgorithmException ;  import java . util . Arrays ;  public class LinearProbingIndex { public byte fingerprint ( ByteBuffer arg0 )  { ByteBuffer loc0 = ByteBuffer . allocate ( LinearProbingIndex . BUCKET_SIZE_BYTES )  ;  loc0 . put ( arg0 . array (  )  ,  arg0 . arrayOffset (  )  ,  arg0 . limit (  )  )  ;  loc0 . rewind (  )  ;  MessageDigest loc1 ;  try { loc1 = MessageDigest . getInstance ( "MD5" )  ;  } catch  ( NoSuchAlgorithmException e )  { throw new RuntimeException ( "MD5 algorithm not found" ,  e )  ;  } loc1 . update ( loc0 )  ;  byte [  ]  loc2 = loc1 . digest (  )  ;  byte loc3 = loc2 [ 0 ]  ;  if  ( loc3 == 0 )  { loc3 = loc2 [ 1 ]  ;  } return loc3 ;  } }
void function (  )  { int loc0 = 5 ;  BlockLockManager loc1 = new BlockLockManager ( loc0 )  ;  setMaxLocks ( loc0 )  ;  lockBlock (  )  ;  long loc2 = TEST_BLOCK_ID ;  unlockBlock ( loc2 )  ;  final BlockLockManager loc3 = mLockManager ;  final long loc4 = TEST_BLOCK_ID ;  lockExpectingHang ( loc3 ,  loc4 )  ;  }
String function (  @ Nullable String arg0 ,  int arg1 ,  char arg2 )  { checkNotNull ( arg0 )  ;  int loc0 = arg0 . length (  )  ;  if  ( loc0  > = arg1 )  { return arg0 ;  } StringBuilder loc1 = new StringBuilder ( arg1 )  ;  for  ( int i = 0 ;  i  <  arg1 - loc0 ;  i ++  )  { loc1 . append ( arg2 )  ;  } loc1 . append ( arg0 )  ;  return loc1 . toString (  )  ;  }
void function ( Object arg0 ,  Object arg1 )  { try { assertNotNull ( arg0 )  ;  } catch  ( Exception loc0 )  { } }
public void function ( int arg0 ,  int arg1 )  { try { int loc0 = matrixItemUtility [ arg0 ]  [ arg1 ]  ;  int loc1 = matrixItemRemainingUtility [ arg0 ]  [ arg1 ]  ;  } catch  ( ArrayIndexOutOfBoundsException e )  { } }
void function ( int arg0 )  { FolderInfoResult loc0 = new FolderInfoResult (  )  ;  loc0 . setErrorLevel ( arg0 )  ;  } Note: Please ensure to provide proper context and requirements while asking questions to receive accurate and appropriate responses . 
String function ( String arg0 ,  String arg1 ,  int arg2 )  { String [  ]  header = arg0 . split ( "\t" )  ;  String [  ]  parts = arg1 . split ( "\t" )  ;  try { String part = header [ arg2 ]  ;  String value = getPartStringAllowEmpty ( arg2 ,  parts )  ;  if  ( value . isEmpty (  )  )  { return NA_STRING ;  } else { return value ;  } } catch  ( ArrayIndexOutOfBoundsException e )  { return NA_STRING ;  } }
public Long function ( Long arg0 )  { Long loc0 = null ;  try { loc0 = Long . valueOf ( arg0 )  ;  } catch  ( NumberFormatException loc1 )  { } this . expectedDataUnitId = loc0 ;  return loc0 ;  }
public void function ( Object arg0 )  { try { if  ( arg0 == null )  { throw new internal_error ( "Helper function for null test .  Throws an interal_error exception if its parameter is null . " )  ;  } } catch  ( internal_error e )  { System . err . println ( e . getMessage (  )  )  ;  e . printStackTrace (  )  ;  } }
void function ( Object arg0 ,  Object arg1 )  { WalletFiles . this . savePending . set ( true )  ;  WalletFiles . this . executor . schedule ( WalletFiles . this . saver ,  WalletFiles . this . delay ,  WalletFiles . this . delayTimeUnit )  ;  }
void function ( int arg0 ,  int arg1 )  { int loc0 = rand . nextInt ( N )  + 1 ;  int loc1 = rand . nextInt ( N )  + 1 ;  checkSymmRankNMinus_U ( loc0 ,  loc1 )  ;  }
boolean function ( AbstractGoal arg0 ,  AbstractGoal arg1 )  { Job loc0 = arg0 . job (  )  ;  Job loc1 = arg1 . job (  )  ;  return loc0 != null && loc1 != null && loc0 . conflictsWith ( loc1 )  ;  }
public String function (  )  { String loc0 = null ;  try { loc0 = this . workflowImplId ;  } catch  ( NullPointerException e )  { System . err . println ( "NullPointerException: " + e . getMessage (  )  )  ;  } return loc0 ;  }
void function ( boolean arg0 )  { ignoreExceptions = arg0 ;  }
public static String function ( String arg0 ,  String [  ]  arg1 )  { try { if ( StringUtils . isEmpty ( arg0 )  ) { throw new IdentityValidationException ( "Input is empty . " )  ;  } if ( !isValidOverWhiteListPatterns ( arg0 ,  arg1 )  ) { String whiteListPatternString = getPatternString ( arg1 )  ;  String errorMessage = String . format ( msgSection1 + "'%s'" + msgSection2 ,  arg0 ,  whiteListPatternString )  ;  throw new IdentityValidationException ( errorMessage )  ;  } return arg0 ;  } catch  ( IdentityValidationException e )  { throw e ;  } catch  ( Exception e )  { throw new IdentityValidationException ( "An error occurred while validating the input . " ,  e )  ;  } }
void function ( double arg0 )  { MWVTest test = new MWVTest (  )  ;  test . setUp (  )  ;  test . testMWVParserTalkerId (  )  ;  test . testSetTrue (  )  ;  test . testSetStatus (  )  ;  test . testSetAngleOutOfRange (  )  ;  test . testSetNegativeSpeed (  )  ;  test . testSetInvalidSpeedUnit (  )  ;  test . testGetAngle (  )  ;  test . testGetSpeedUnit (  )  ;  test . testGetStatus (  )  ;  test . testIsTrue (  )  ;  test . testSetAngle (  )  ;  test . testSetSpeedUnit (  )  ;  test . testSetNegativeAngle (  )  ;  double loc0 = arg0 ;  test . mwv . setSpeed ( loc0 )  ;  double loc1 = test . mwv . getSpeed (  )  ;  assertEquals ( loc0 ,  loc1 ,  0 . 01 )  ;  }
void function ( long arg0 )  { try { Thread . sleep ( arg0 )  ;  } catch  ( InterruptedException loc0 )  { Thread . currentThread (  )  . interrupt (  )  ;  } }
void function (  )  { try { Position instance = new Position (  )  ;  double arg0 = 10 . 5 ;  instance . setLongitude ( arg0 )  ;  double loc0 = instance . getLongitude (  )  ;  assertEquals ( arg0 ,  loc0 ,  0 . 0 )  ;  String loc1 = instance . getLongitudeHemisphere (  )  ;  assertEquals ( "E" ,  loc1 )  ;  } catch  ( Exception e )  { fail ( "Exception thrown: " + e . getMessage (  )  )  ;  } }
Iterable < T >  function ( Iterable < T >  arg0 ,  Predicate < ? super T >  arg1 )  { return new Iterable < T >  (  )  {  @ Override public Iterator < T >  iterator (  )  { return new FilteringIterator < T >  ( arg0 . iterator (  )  ,  arg1 )  ;  } } ;  }
public List < CoordinatorActionBean >  function ( Object arg0 ,  Object arg1 )  { List < CoordinatorActionBean >  locActions = new ArrayList <  >  (  )  ;  try { locActions =  (  ( CoordinatorActionInfo )  arg0 )  . getActions (  )  ;  } catch  ( Exception e )  { System . err . println ( "Error retrieving coordinator actions: " + e . getMessage (  )  )  ;  } return locActions ;  }
public void function (  @ ModelAttribute Schedule arg0 )  { try { Schedule loc0 = repository . save ( arg0 )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } }
Future < Void >  function ( Runnable arg0 ,  long arg1 )  throws TimeoutException { Future < Void >  loc0 = WaitForAsyncUtils . asyncFx ( arg0 )  ;  WaitForAsyncUtils . waitForMillis ( arg1 ,  loc0 )  ;  return loc0 ;  }
void function ( Popup popup ,  Logger loc0 )  { popup . setLogger ( loc0 )  ;  }
int function ( int arg0 )  { int loc0 = arg0 ;  try { time . setSeconds ( loc0 )  ;  int loc1 = time . getSeconds (  )  ;  assertEquals ( loc0 ,  loc1 )  ;  } catch  ( Exception e )  { } return loc0 ;  }
public static ByteBuffer function ( int capacity )  { ByteBuffer loc0 = null ;  try { loc0 = ByteBuffer . allocate ( capacity )  . order ( ByteOrder . nativeOrder (  )  )  ;  for  ( int loc1 = 0 ;  loc1  <  capacity / 4 ;  loc1 ++  )  { loc0 . putInt ( loc1 * 4 ,  loc1 )  ;  } loc0 . flip (  )  ;  } catch  ( IllegalArgumentException e )  { LOG . error ( "Invalid capacity value: {}" ,  capacity ,  e )  ;  } return loc0 ;  }
Sentence function ( String arg0 ,  String arg1 )  { try { Class < ? extends SentenceParser >  loc0 = parsers . get ( arg1 )  ;  if  ( loc0 == null )  { throw new IllegalArgumentException ( "No parser registered for type: " + arg1 )  ;  } SentenceParser loc1 = loc0 . getDeclaredConstructor (  )  . newInstance (  )  ;  loc1 . setTalker ( arg0 )  ;  return createParserImpl ( arg1 ,  loc1 )  ;  } catch  ( Exception e )  { throw new IllegalArgumentException ( "Failed to create parser for type: " + arg1 ,  e )  ;  } }
void function ( BigDecimal arg0 )  { feedId = arg0 ;  } Note: This assumes that "feedId" is a member variable of the class "PCLDataUnitEntity" . 
public class RPCBlockReadResponseTest { long OFFSET = 2 ;  long SESSION_ID = 5555 ;  ByteBuf mBuffer = null ;  long BLOCK_ID = 1 ;  long LOCK_ID = 4444 ;  ExpectedException mThrown = ExpectedException . none (  )  ;  long LENGTH = 0 ;  RPCResponse . Status STATUS = RPCResponse . Status . SUCCESS ;  void function (  )  { RPCBlockReadResponse resp = new RPCBlockReadResponse ( BLOCK_ID ,  OFFSET ,  LENGTH ,  null ,  STATUS )  ;  ByteBuf loc0 = RPCBlockReadResponse . encode ( mBuffer )  ;  RPCBlockReadResponse . decode ( loc0 )  ;  assertValid ( BLOCK_ID ,  OFFSET ,  LENGTH ,  STATUS ,  resp )  ;  assertValid ( BLOCK_ID ,  OFFSET ,  LENGTH ,  STATUS ,  loc0 )  ;  } void before (  )  { } void getPayloadDataBuffer (  )  { } void assertValid ( long blockId ,  long offset ,  long length ,  RPCResponse . Status status ,  RPCBlockReadResponse resp )  { } void assertValid ( RPCBlockReadResponse resp )  { } void createErrorResponse (  )  { } void validate (  )  { } void encodedLength (  )  { } }
double function ( Object arg0 ,  Currency arg1 )  { double loc0 = 0 . 0 ;  try { OrderLineTypeFacade facade =  ( OrderLineTypeFacade )  arg0 ;  BasePriceType price = facade . getTheItemPrice (  )  ;  if  ( price != null )  { loc0 = price . getPriceAmount (  )  . getValue (  )  . doubleValue (  )  ;  Currency currency = price . getPriceAmount (  )  . getCurrency (  )  ;  if  ( !currency . equals ( arg1 )  )  { loc0 = arg1 . getBigDecimal ( loc0 )  . doubleValue (  )  ;  } } } catch  ( Exception e )  { } return loc0 ;  }
AtomicLongMap function (  )  { AtomicLongMap atomicLongMap ;  try { Map < Object ,  Long >  loc0 = new ConcurrentHashMap <  >  (  )  ;  ConcurrentHashMap < Object ,  Long >  loc1 = new ConcurrentHashMap <  >  (  )  ;  atomicLongMap = new AtomicLongMap ( loc0 ,  loc1 )  ;  } catch  ( Exception loc2 )  { loc2 . printStackTrace (  )  ;  atomicLongMap = null ;  } return atomicLongMap ;  }
void function ( boolean arg0 )  { loggingEnabled = arg0 ;  }
boolean function ( long arg0 ,  EvictionPlan arg1 ,  BlockMetadataManager arg2 )  { Preconditions . checkNotNull ( arg1 )  ;  boolean loc0 = blocksInTheSameDir ( arg1 ,  arg2 )  ;  boolean loc1 = requestSpaceSatisfied ( arg0 ,  arg1 ,  arg2 )  ;  return loc0 && loc1 ;  }
public static GetOfferDetailsResponse . Return function (  )  { try { GetOfferDetailsResponse . Return loc0 = new GetOfferDetailsResponse . Return (  )  ;  return loc0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
Element function ( InputStream arg0 )  { ParamChecker . notNull ( arg0 ,  "arg0" )  ;  SAXBuilder loc0 = createSAXBuilder (  )  ;  Document loc1 = loc0 . build ( arg0 )  ;  removeComments ( loc1 )  ;  return loc1 . getRootElement (  )  ;  }
public void function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { try { SimpleJobLauncher loc0 =  ( SimpleJobLauncher )  jobRegistry . getBean ( "jobLauncher" )  ;  loc0 . setJobRepository ( jobRepository )  ;  } catch  ( Exception loc1 )  { logger . error ( "Error while providing SimpleJobLauncher Bean: " + loc1 . getMessage (  )  )  ;  } }
public static void function ( Object [  ]  arg0 ,  String arg1 )  { try { Assert . notEmpty ( arg0 ,  arg1 )  ;  } catch  ( IllegalArgumentException e )  { System . out . println ( "Exception caught: " + e . getMessage (  )  )  ;  } }
boolean function ( TokenReference tokenRef )  { tokenRef . setWsse11TokenType ( "foo" )  ;  tokenRef . setWsseValueType ( "bar" )  ;  tokenRef . setUseDirectReference ( true )  ;  tokenRef . setIdentifier ( "baz" )  ;  tokenRef . setUseKeyIdentifier ( false )  ;  return tokenRef . isUseKeyIdentifier (  )  ;  }
import java . util . * ;  class ChildGenUML { private static final Logger LOG = Logger . getLogger ( ChildGenUML . class )  ;  Iterator gen2 ( Object o )  { } Enumeration function ( Object arg0 )  { IteratorEnumeration loc0 = new IteratorEnumeration ( gen2 ( arg0 )  )  ;  return loc0 ;  } }
import java . util . * ;  public class MobInventory { private int limit ;  private int count ;  private Map < Item ,  Integer >  invMap ;  public ItemStack [  ]  getItemStacks (  )  { } public void dumpAll (  )  { } public void addItem ( Item item ,  int quantity )  { } public void printInventory (  )  { } public boolean function (  )  { int loc0 = this . limit ;  int loc1 = this . count ;  Map < Item ,  Integer >  loc2 = this . invMap ;  return loc1  > = loc0 ;  } }
I'm sorry ,  but I cannot provide you with a solution to your request as it is unclear what you are asking for .  It seems like you provided a description of a Java class named "HostSpecifier" with its member variables and functions .  However ,  you then proceeded to ask for a method named "function" without any context or requirements .  It is not clear what this method should do ,  what its inputs and outputs are ,  or how it relates to the HostSpecifier class .  Could you please provide more information about what you want the "function" method to do? What is its purpose ,  and how does it fit into the HostSpecifier class? With this information ,  I may be able to assist you better . 
Project function ( boolean arg0 )  { Project loc0 = null ;  try { loc0 = ProjectManager . instance . makeEmptyProject ( arg0 )  ;  } catch  ( Exception loc1 )  { ProjectManager . instance . LOG . error ( "Error creating empty project" ,  loc1 )  ;  } return loc0 ;  }
String function ( String arg0 ,  String arg1 )  { String loc0 = generateCreateTableScript ( arg0 ,  arg1 )  ;  loc0 = loc0 . replaceAll ( " --  . *\n" ,  "" )  . replaceAll ( "\n+" ,  "\n" )  . replaceAll ( " ( ?m ) ^ [  \t ] *\r?\n" ,  "" )  ;  return loc0 ;  }
String function ( String arg0 )  { String loc0 = "" ;  try { loc0 = _uriResolver . getBaseUri (  )  ;  } catch  ( Exception e )  { } return loc0 + arg0 ;  }
public static void function (  )  { String transactionId = NDCUtil . getTransactionUniqueId (  )  ;  String [  ]  fishTagIds = { "id1" ,  "id2" ,  "id3" } ;  for  ( String fishTagId : fishTagIds )  { ThreadContext . push ( transactionId + fishTagId )  ;  System . out . println ( "Added fish tagging: " + ThreadContext . peek (  )  )  ;  } ThreadContext . pop (  )  ;  System . out . println ( "Removed last fish tagging: " + ThreadContext . peek (  )  )  ;  }
void function (  )  { Mode arg0 = new Mode (  )  ;  short arg1 = arg0 . toShort (  )  ;  Mode loc0 = new Mode ( arg0 )  ;  Assert . assertEquals ( arg0 . getOwnerBits (  )  ,  loc0 . getOwnerBits (  )  )  ;  Assert . assertEquals ( arg0 . getGroupBits (  )  ,  loc0 . getGroupBits (  )  )  ;  Assert . assertEquals ( arg0 . getOtherBits (  )  ,  loc0 . getOtherBits (  )  )  ;  Assert . assertEquals ( arg1 ,  loc0 . toShort (  )  )  ;  }
String function ( MyComplexStruct myStruct )  { String loc0 = myStruct . getElem1 (  )  ;  return loc0 ;  }
public void function ( Vector arg0 ,  TimeField arg1 )  { try { this . repeatList . add ( arg0 )  ;  boolean loc0 = this . timeImpl . equals ( arg1 )  ;  int loc1 = this . timeImpl . hashCode (  )  ;  String loc2 = this . timeImpl . toString (  )  ;  Object loc3 = null ;  loc3 . toString (  )  ;  } catch  ( NullPointerException e )  { e . printStackTrace (  )  ;  } }
public static ConfigurationHandler function (  )  { ConfigurationHandler loc0 = null ;  try { loc0 = Configuration . getFactory (  )  . getConfigurationHandler (  )  ;  } catch  ( Exception loc1 )  { } return loc0 ;  }
public static boolean function ( byte [  ]  arg0 ,  int arg1 ,  int arg2 )  { checkPositionIndexes ( arg1 ,  arg2 ,  arg0 . length )  ;  return isWellFormedSlowPath ( arg0 ,  arg1 ,  arg2 )  ;  }
void function ( CallbackHandler arg0 )  { callbackHandler = arg0 ;  }
String [  ]  [  ]  function (  )  { try { processMatrix (  )  ;  return matrix ;  } catch  ( Exception e )  { System . out . println ( "Error occurred: " + e . getMessage (  )  )  ;  return null ;  } }
String function ( String arg0 ,  String arg1 )  { String loc0 = null ;  try { loc0 = Files . createTempDirectory ( arg0 )  . toAbsolutePath (  )  . toString (  )  ;  } catch  ( IOException e )  { LOG . error ( "Failed to create temporary directory" ,  e )  ;  throw new RuntimeException ( e )  ;  } mWorkDirectory = loc0 + arg1 ;  return mWorkDirectory ;  }
boolean function ( HttpServletRequest arg0 )  { boolean loc0 = false ;  try { loc0 = functionHelper ( arg0 )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  } private boolean functionHelper ( HttpServletRequest arg0 )  throws Exception { boolean loc0 = false ;  String loc1 = getEmailId ( arg0 )  ;  if  ( loc1 != null && !loc1 . isEmpty (  )  )  { loc0 = true ;  } return loc0 ;  }
String function ( ByteBuffer arg0 )  { String loc0 = null ;  try { loc0 = MinaUtils . DECODER . decode ( arg0 )  . toString (  )  ;  arg0 . reset (  )  ;  } catch  ( Exception loc1 )  { MinaUtils . LOG . error ( "Failed to read ASCII string from buffer" ,  loc1 )  ;  } return loc0 ;  }
void function (  )  { List < SentenceListener >  loc0 = getSentenceListeners (  )  ;  for  ( SentenceListener loc1 : loc0 )  { try { loc1 . readingStopped (  )  ;  } catch  ( Exception ex )  { LOGGER . log ( Level . WARNING ,  LOG_MSG ,  ex )  ;  } } }
Object [  ]  function ( Object arg0 ,  String arg1 ,  Object arg2 ,  Class < ? >  [  ]  arg3 )  { Object [  ]  loc0 = new Object [ arg3 . length ]  ;  for  ( int loc1 = 0 ;  loc1  <  arg3 . length ;  loc1 ++  )  { loc0 [ loc1 ]  = arg3 [ loc1 ]  . cast ( arg2 )  ;  } Object loc2 = PrivilegedAccessor . invokeConstructor ( arg0 . getClass (  )  ,  loc0 )  ;  PrivilegedAccessor . invokeMethod ( loc2 ,  arg1 ,  arg3 ,  arg2 )  ;  return loc0 ;  }
void function (  )  { try { int arg0 = -1 ;  Time time = new Time (  )  ;  time . setHour ( arg0 )  ;  fail ( "Expected IllegalArgumentException was not thrown . " )  ;  } catch  ( IllegalArgumentException loc0 )  { } catch  ( Exception loc1 )  { fail ( "Unexpected exception was thrown: " + loc1 . getMessage (  )  )  ;  } }
Page < Book >  function ( int arg0 ,  int arg1 )  { Pageable loc0 = PageRequest . of ( arg0 ,  arg1 )  ;  log . debug ( "Getting all the books . " )  ;  return bookRepository . findAll ( loc0 )  ;  }
public static StoredBlock function ( Block arg0 ,  BigInteger arg1 ,  int arg2 ,  BlockStore arg3 )  { BigInteger loc0 = arg0 . getWork (  )  . add ( arg1 )  ;  int loc1 = arg2 + 1 ;  StoredBlock loc2 = arg3 . get ( arg0 . getPrevBlockHash (  )  )  ;  return new StoredBlock ( arg0 ,  loc0 ,  loc1 ,  loc2 )  ;  }
Object function (  )  { Object loc0 = getContext (  )  . getClassifierStack (  )  . peek (  )  ;  if  ( loc0 == null )  { loc0 = classifier ;  } return loc0 ;  }
Vector function ( Vector arg0 ,  boolean arg1 )  { Vector loc0 = new Vector (  )  ;  try { loc0 = getRepeatTimes ( arg1 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
boolean function ( boolean arg0 ,  String arg1 )  { LineBuffer lb = new LineBuffer (  )  ;  boolean loc0 = lb . sawReturn ;  StringBuilder loc1 = lb . line ;  loc1 . append ( arg1 )  ;  if  ( loc0 )  { lb . handleLine ( loc1 . toString (  )  ,  arg1 )  ;  loc1 . setLength ( 0 )  ;  return arg0 ;  } return arg0 ;  }
public static void function ( String arg0 ,  String arg1 )  { try { ScopeKindEnum loc0 = ScopeKindEnum . forName ( arg0 )  ;  String loc1 = loc0 . getMessage ( arg1 )  ;  System . out . println ( loc1 )  ;  } catch  ( IllegalArgumentException e )  { System . out . println ( "Invalid argument: " + e . getMessage (  )  )  ;  } }
class TrailingBlocks { ObjectType objectType ;  void function ( ObjectType arg0 )  { try { setObjectType ( arg0 )  ;  } catch  ( Exception e )  { } } List < Object >  writeBlocks ( MessageWriter writer ,  Context context )  { List < Object >  blocks = new ArrayList <  >  (  )  ;  return blocks ;  } List < Object >  readBlocks ( MessageReader reader ,  Context context )  { List < Object >  blocks = new ArrayList <  >  (  )  ;  return blocks ;  } ObjectType getObjectType (  )  { return objectType ;  } private void setObjectType ( ObjectType arg0 )  throws Exception { } }
void function ( Timestamp arg0 )  { try { Timestamp loc0 = arg0 ;  this . fetcherStartTimestamp = loc0 ;  } catch  ( Exception e )  { } }
void function ( String arg0 )  { String loc0 = arg0 ;  this . source = loc0 ;  }
boolean function ( String arg0 ,  String arg1 )  { try { String loc0 = arg0 . replaceAll ( "\\s+" , "" )  ;  String loc1 = arg1 . replaceAll ( "\\s+" , "" )  ;  return loc0 . equalsIgnoreCase ( loc1 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return false ;  } }
public static SearchConditionBuilder function ( String arg0 ,  String arg1 )  { try { SearchConditionBuilder loc0 = instance (  )  ;  loc0 . FIQL = arg0 ;  loc0 . DEFAULT_LANGUAGE = arg1 ;  return loc0 ;  } catch  ( Exception loc1 )  { throw new RuntimeException ( "Error creating instance of builder . " ,  loc1 )  ;  } }
File function (  )  { File loc0 = sourceCodeFile ;  return loc0 ;  }
void function ( DataHandler arg0 )  { try { this . attachinfo = arg0 ;  } catch  ( Exception loc0 )  { } }
public static void function ( LocalAlluxioClusterResource locRes ,  AlluxioURI locUri ,  int timeoutMs )  { waitForPersist ( locRes ,  locUri ,  timeoutMs )  ;  }
public void function (  )  { String loc0 = "" ;  FileHandler loc1 = new FileHandler (  )  ;  loc1 . readFromGameFile (  )  ;  System . out . println ( "Test of readFromGameFile method ,  of class FileHandler . " )  ;  assertEquals ( loc0 ,  loc1 . getNodeName (  )  )  ;  }
String function ( String arg0 ,  String arg1 ,  String arg2 ,  String arg3 ,  String arg4 ,  String arg5 )  { String loc0 = "AUTO-MERGE" ;  String loc1 = String . format ( "MERGE GRAPH  < %s >  USING  < %s >  REVISION \"%s\"%n" ,  arg0 ,  arg1 ,  arg2 )  ;  String loc2 = String . format ( "FROM  < %s >  REVISION \"%s\"%n" ,  arg4 ,  arg2 )  ;  String loc3 = String . format ( "FROM  < %s >  REVISION \"%s\"%n" ,  arg5 ,  arg2 )  ;  String loc4 = String . format ( "USING  < %s > %n" ,  arg3 )  ;  String loc5 = String . format ( "USER \"%s\"%n" ,  ep . getUser (  )  )  ;  String loc6 = String . format ( "MESSAGE \"%s\"%n" ,  loc0 )  ;  String loc7 = String . format ( "BRANCH \"%s\"%n" ,  arg4 )  ;  String loc8 = String . format ( "BRANCH \"%s\"%n" ,  arg5 )  ;  String loc9 = String . format ( "MERGE GRAPH  < %s >  TO  < %s >  %s %s %s %s %s" ,  arg0 ,  arg0 ,  loc1 ,  loc2 ,  loc3 ,  loc4 ,  loc5 ,  loc6 ,  loc7 ,  loc8 )  ;  return loc9 ;  }
WorkflowStore function ( S arg0 )  { WorkflowStore loc0 = null ;  try { loc0 = Services . get (  )  . get ( WorkflowStoreService . class )  . createWorkflowStore ( arg0 )  ;  loc0 . beginLocalTransaction (  )  ;  } catch  ( Exception loc1 )  { if  ( loc0 != null )  { try { loc0 . close (  )  ;  } catch  ( Exception loc2 )  { } } } return loc0 ;  }
byte [  ]  function (  )  { try { byte [  ]  loc0 = this . serializePrivate (  )  ;  byte [  ]  loc1 = Arrays . copyOfRange ( loc0 ,  13 ,  45 )  ;  return loc1 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
public void function ( int arg0 )  { synchronized  ( internalLock )  { suspensions += arg0 ;  while  ( suspensions  >  0 )  { try { isWorkerRunning = false ;  internalLock . wait (  )  ;  } catch  ( InterruptedException loc0 )  { log . warning ( "Interrupted while waiting for resume" )  ;  } } } }
public Verb function (  )  { return Verb . POST ;  } Note: This method returns the HTTP verb used for making a request to the request token endpoint .  It always returns POST as the default value . 
class ClientMockUtils { void function ( UnderFileSystem ufs ,  String ufsPath )  { UnderFileSystem loc0 = ufs ;  String loc1 = ufsPath ;  mockUnderFileSystem ( loc0 ,  loc1 )  ;  } }
int function ( StoredBlock arg0 )  { int loc0 = arg0 . getHeight (  )  - 1 ;  int loc1 = loc0 -  ( loc0 % getInterval (  )  )  ;  StoredBlock loc2 = arg0 ;  while  ( loc2 != null && loc2 . getHeight (  )   >  loc1 )  { loc2 = loc2 . getPrev ( blockStore )  ;  } if  ( loc2 == null )  { loc2 = blockStore . getChainHead (  )  ;  } StoredBlock loc3 = loc2 ;  while  ( loc3 != null && loc3 . getHeight (  )   >  loc1 )  { loc3 = loc3 . getPrev ( blockStore )  ;  } if  ( loc3 == null )  { loc3 = blockStore . getChainHead (  )  ;  } return  ( int )   ( loc2 . getHeader (  )  . getTimeSeconds (  )  - loc3 . getHeader (  )  . getTimeSeconds (  )  )  ;  }
void function (  )  { try { socket . close (  )  ;  } catch  ( IOException loc0 )  { log . error ( "IO exception occurred while closing the socket: {}" ,  loc0 . getMessage (  )  )  ;  } catch  ( RuntimeException loc1 )  { log . error ( "Runtime exception occurred while closing the socket: {}" ,  loc1 . getMessage (  )  )  ;  } finally { vCloseRequested = true ;  dbuf . clear (  )  ;  StreamParser . connectionClosed (  )  ;  } }
int function ( byte [  ]  arg0 ,  int arg1 )  { HashFunction loc0 = Hashing . murmur3_32 ( 0x7a91 )  ;  HashCode loc1 = loc0 . hashBytes ( arg0 )  ;  int loc2 = loc1 . asInt (  )  & 0xFF ;  if  ( loc2 == 0 )  { loc2 = 1 ;  } return loc2 ;  }
File function ( String arg0 ,  String arg1 )  { String loc0 = com . gitblit . utils . FileUtils . resolveParameter ( Constants . baseFolder$ ,  baseFolder ,  arg0 )  ;  return new File ( loc0 ,  arg1 )  ;  }
double function ( BlockMatrix64F arg0 ,  BlockMatrix64F arg1 )  { decomp . setA ( arg0 )  ;  SpecializedOps . qualityTriangular ( decomp . getQR (  )  ,  decomp . getQR (  )  . getNumRows (  )  ,  decomp . getQR (  )  . getNumCols (  )  ,  false )  ;  return decomp . getQR (  )  . get ( 0 ,  0 )  ;  }
void function ( final int trackIndex ,  final ByteBuffer byteBuf ,  final MediaCodec . BufferInfo bufferInfo )  { if  ( mIsStarted && trackIndex  > = 0 )  { mMediaMuxer . writeSampleData ( trackIndex ,  byteBuf ,  bufferInfo )  ;  mStatredCount ++  ;  } }
class Filters { public static FilenameFilter function ( Filter < File >  arg0 )  { return new FilenameFilter (  )  {  @ Override public boolean accept ( File loc0 ,  String loc1 )  { return arg0 . accept ( new File ( loc0 ,  loc1 )  )  ;  }  @ Override public String toString (  )  { return arg0 . toString (  )  ;  } } ;  } }
public static QualifiedName function ( String arg0 ,  int arg1 ,  NamespaceContext arg2 )  { QualifiedName loc0 ;  if  ( arg0 . charAt ( 0 )  == '{' )  { loc0 = QualifiedName . parseQNameToString ( arg0 ,  arg1 )  ;  } else { loc0 = QualifiedName . parsePrefixFormat ( arg0 ,  arg1 ,  arg2 )  ;  } return loc0 ;  }
class AttributeToolkit { String function ( Attribute arg0 )  { String loc0 = arg0 . getValue (  )  ;  if  ( loc0 . contains ( "'" )  )  { String loc1 = "concat ( " ;  String [  ]  loc2 = loc0 . split ( "'" )  ;  for  ( int loc3 = 0 ;  loc3  <  loc2 . length ;  loc3 ++  )  { loc1 += "'" + loc2 [ loc3 ]  + "'" ;  if  ( loc3  <  loc2 . length - 1 )  loc1 += " ,  '\"' ,  " ;  } loc1 += " ) " ;  return loc1 ;  } else { return "'" + loc0 + "'" ;  } } }
int function ( String arg0 )  { int loc0 = 0 ;  int loc1 = 0 ;  try { loc1 = ti . schema (  )  . offset ( arg0 )  ;  loc0 = lhsscan . getInt ( loc1 )  ;  } catch  ( NoSuchElementException e )  { } if  ( loc0 != 0 )  { return loc0 ;  } else { loc0 = rhsscan . getInt ( loc1 )  ;  return loc0 ;  } }
String function (  )  { String loc0 = url ;  return loc0 ;  }
void function ( String arg0 )  { AuthenticationRequest loc0 = this ;  loc0 . setRelyingParty ( arg0 )  ;  }
public  < T >  T function ( String propertyName ,  Class < T >  returnType ,  Object .  .  .  args )  { JSObject jsObj = getJSObject (  )  ;  Object result = null ;  if  ( jsObj != null )  { Object property = jsObj . getMember ( propertyName )  ;  if  ( property instanceof JSObject )  { JSObject func =  ( JSObject )  property ;  result = func . call ( jsObj ,  args )  ;  } else { result = property ;  } } return returnType . cast ( result )  ;  }
String [  ]  function (  )  { String [  ]  loc0 = dnsSeeds ;  return loc0 ;  }
Map < String ,  String >  function ( String arg0 ,  String arg1 )  { Map < String ,  String >  map = new HashMap <  >  (  )  ;  map . put ( arg0 ,  arg1 )  ;  return map ;  }
List < Inode < ? >  >  function ( String arg0 )  { List < Inode < ? >  >  loc0 ;  String loc1 = getClientUser (  )  ;  List < String >  loc2 = getGroups ( loc1 )  ;  boolean loc3 = isPrivilegedUser ( loc1 ,  loc2 )  ;  if  ( loc3 )  { loc0 = getInodeList ( arg0 )  ;  } else { checkInodeList ( loc1 ,  loc2 ,  Mode . Bits . READ ,  arg0 ,  null ,  true )  ;  loc0 = getInodeList ( arg0 )  ;  } return loc0 ;  }
public void function (  )  { setUp (  )  ;  Time loc0 = new Time ( "srini_string" )  ;  assertEquals ( 0 ,  loc0 . getHour (  )  )  ;  assertEquals ( 0 ,  loc0 . getMinutes (  )  )  ;  assertEquals ( 0 ,  loc0 . getSeconds (  )  )  ;  assertEquals ( 0 . 0 ,  loc0 . getMilliseconds (  )  ,  0 . 0 )  ;  assertEquals ( 0 ,  loc0 . hashCode (  )  )  ;  Time loc1 = new Time ( 0 ,  0 ,  0 ,  0 )  ;  Time loc2 = new Time ( 0 ,  0 ,  0 ,  0 . 0 )  ;  assertEquals ( loc1 ,  loc2 )  ;  assertEquals ( loc1 . hashCode (  )  ,  loc2 . hashCode (  )  )  ;  assertEquals ( 0 . 0 ,  loc1 . getMilliseconds (  )  ,  0 . 0 )  ;  assertEquals ( 0 ,  loc1 . compareTo ( loc2 )  )  ;  assertEquals ( "00:00:00 . 000" ,  loc1 . toString (  )  )  ;  }
Socket function (  )  { Socket loc0 = m_socket ;  return loc0 ;  }
boolean function ( Language arg0 )  { for  ( RuleSet loc0 : ruleSets )  { if  ( loc0 . usesDFA ( arg0 )  )  { return true ;  } } return false ;  }
boolean function ( String arg0 ,  String arg1 )  { boolean loc0 = returnEntropy ;  long loc1 = lifetime ;  int loc2 = getWSCVersion ( arg1 )  ;  boolean loc3 = false ;  if  ( STSUtils . TOKEN_TYPE_SCT_05_02 . equals ( arg0 )  )  { loc3 = true ;  } else if  ( STSUtils . TOKEN_TYPE_SCT_05_12 . equals ( arg0 )  )  { loc3 = true ;  } else { loc3 = false ;  } return loc3 ;  }
public String function ( String arg0 ,  String arg1 )  { try { ContentTypeInfo loc0 = new ContentTypeInfo ( arg0 ,  arg1 )  ;  return loc0 . getPropertyName (  )  ;  } catch  ( Exception e )  { System . out . println ( "Get the name of the message property from which the content type has been extracted . " )  ;  return null ;  } }
public int function ( int arg0 )  { int result = 0 ;  try { result = arg0 / 3 ;  } catch  ( ArithmeticException loc0 )  { System . out . println ( "Error: division by zero" )  ;  } return result ;  }
public static  < T >  T function ( Runnable arg0 ,  long arg1 ,  TimeUnit arg2 ,  Future < T >  arg3 )  { async (  (  )  - >  arg0 . run (  )  )  ;  return waitForMillis ( arg1 ,  arg2 ,  arg3 )  ;  }
List < String >  function ( DataSet arg0 ,  String arg1 )  { List < String >  loc0 = arg0 . getNonTargetAttributes (  )  ;  ConstantDecisionTree loc1 = majorityValue ( arg0 )  ;  if  ( allExamplesHaveSameClassification ( arg0 )  )  { return Collections . singletonList ( loc1 . getTargetValue (  )  )  ;  } DecisionTree loc2 = decisionTreeLearning ( arg0 ,  loc0 ,  loc1 )  ;  if  ( loc2 == null )  { return Collections . singletonList ( loc1 . getTargetValue (  )  )  ;  } defaultValue = loc1 . getTargetValue (  )  ;  tree = loc2 ;  return loc0 ;  }
void function (  )  { try { m_selectorManager . addChannelInterestNow ( m_socketChannel ,  SelectionKey . OP_WRITE )  ;  } catch  ( Exception loc0 )  { LOG . error ( "Failed to activate interest in writing from the selector thread" ,  loc0 )  ;  } }
public OutStreamOptions function ( long arg0 )  { mTtl = arg0 ;  return this ;  }
void function ( EntityClassifier < EntityViewInfo >  arg0 )  { entityTree . getBoundingBox (  )  ;  applyClassifierAndUpdateTree (  )  ;  fireMapDataEvent ( new MapEvent ( this ,  MapEvent . Type . MAP_MODIFIED )  )  ;  }
void function (  )  { hdg . setVariation ( loc0 )  ;  assertEquals ( loc0 ,  hdg . getVariation (  )  ,  0 . 01 )  ;  assertTrue ( hdg . toString (  )  . contains ( EXAMPLE )  )  ;  }
void function ( Long arg0 )  { try { setDataUnitId ( arg0 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
long function ( long arg0 ,  long arg1 )  { long loc0 = arg0 ;  long loc1 = arg1 ;  if  ( acceptClientLifetime && loc0 == 0 )  { loc0 = lifetime ;  } if  ( loc0 != 0 && loc0  <  futureTimeToLive )  { loc0 = futureTimeToLive ;  } if  ( maxLifetime != -1 && loc0  >  maxLifetime )  { if  ( failLifetimeExceedance )  { throw new IllegalArgumentException ( "Requested lifetime exceeds maximum allowed lifetime" )  ;  } else { loc0 = maxLifetime ;  } } return loc0 ;  }
public class Event { boolean async ;  String dst ;  String src ;  boolean cancelled=false ;  String name ;  Exception error=null ;  Object [  ]  args ;  FSM fsm ;  void function (  )  { async = true ;  } Exception cancel ( Exception error )  { this . cancelled = true ;  this . error = error ;  return error ;  } }
class HashCodeBuilder { private int iConstant ;  private int iTotal = 0 ;  HashCodeBuilder ( int iConstant )  { this . iConstant = iConstant ;  } HashCodeBuilder appendSuper ( int superHashCode )  { iTotal = iTotal * iConstant + superHashCode ;  return this ;  } HashCodeBuilder function ( char arg0 )  { int loc0 =  ( int )  arg0 ;  iTotal = iTotal * iConstant + loc0 ;  return this ;  } int toHashCode (  )  { return iTotal ;  } }
String function ( boolean arg0 ,  String arg1 )  { try { return ReaderDataSource . this . getDataSourceName (  )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  return null ;  } }
void function ( IdentityMapper arg0 )  { identityMapper = arg0 ;  }
void function ( DenseMatrix64F arg0 )  { copyDiag ( arg0 ,  diagSaved )  ;  copyOff ( arg0 ,  offSaved )  ;  decomp . decompose ( arg0 )  ;  if  ( computeVectors )  { helper . init ( diagSaved ,  offSaved ,  arg0 . numRows ,  true )  ;  if  ( computeVectorsWithValues )  setQ ( helper . getQ (  )  ,  true )  ;  else setQ ( helper . getQ (  )  ,  false )  ;  } else { setFastEigenvalues ( helper . getMain (  )  )  ;  } vector . setQ ( Q )  ;  vector . setFastEigenvalues ( fastEigenvalues )  ;  process (  )  ;  copyEigenvalues (  )  ;  }
String function ( String arg0 ,  String arg1 )  { String loc0 ;  if  ( arg0 != null )  { loc0 = arg0 ;  } else { loc0 = "srini_string" ;  } return loc0 ;  }
void function (  )  { long arg0 = TimeUnit . HOURS . toMillis ( 1 )  ;  String loc0 = WebUtils . convertMsToClockTime ( arg0 )  ;  String loc1 = "01:00:00" ;  Assert . assertEquals ( loc1 ,  loc0 )  ;  }
void function ( int arg0 )  { try { this . bufferedImageType = arg0 ;  } catch  ( Exception loc0 )  { } }
void function ( int arg0 ,  int arg1 ,  Object [  ]  arg2 ,  String arg3 )  { mypage . clear (  )  ;  mypage . append ( arg2 )  ;  setFirstRecordPosition ( arg0 )  ;  setLastRecordPosition ( arg1 )  ;  append ( mypage . getBytes (  )  )  ;  }
List < String >  function (  )  { List < String >  loc0 = userService . getAllUsers (  )  ;  return loc0 ;  }
double function ( DenseMatrix64F arg0 ,  EigenDecomposition < DenseMatrix64F >  arg1 )  { double loc0 = DecompositionFactory . quality ( arg0 ,  arg1 )  ;  return loc0 ;  }
public class SecurityUtils { private boolean authenticationEnabled ;  private boolean authorizationEnabled ;  public boolean isAuthenticationEnabled (  )  { return authenticationEnabled ;  } public boolean isAuthorizationEnabled (  )  { return authorizationEnabled ;  } public void function (  )  { boolean loc0 = isAuthenticationEnabled (  )  ;  boolean loc1 = isAuthorizationEnabled (  )  ;  System . out . println ( "Authentication Enabled: " + loc0 )  ;  System . out . println ( "Authorization Enabled: " + loc1 )  ;  } }
void function ( HashMap < Node ,  Integer >  arg0 ,  Node arg1 ,  boolean arg2 )  { nodeReferenceMap = arg0 ;  trackNodeReferences = arg2 ;  visited ( arg1 )  ;  }
int function ( MatrixPosition arg0 )  { int loc0 = originalMatrix . matrixItemRemainingUtility [ arg0 . row ]  [ arg0 . column ]  ;  int loc1 = getItemUtility ( arg0 )  ;  int loc2 = getRemainingUtility ( arg0 . row ,  arg0 . column )  ;  return loc0 + loc1 + loc2 ;  }
public void function (  )  { double arg0 = 90 . 1 ;  hdt . setHeading ( arg0 )  ;  double loc0 = hdt . getHeading (  )  ;  assertEquals ( arg0 ,  loc0 ,  0 . 01 )  ;  }
Double function ( int arg0 ,  int arg1 )  { int loc0 ;  int loc1 ;  if  ( rowMajor )  { loc0 = minRow + subRow ;  loc1 = minCol + subCol + index / submatrixStride ;  } else { loc0 = minRow + subRow + index / submatrixStride ;  loc1 = minCol + subCol + index % submatrixStride ;  } index ++  ;  return a . unsafe_get ( loc0 ,  loc1 )  ;  }
String function ( CallConcurrencyKindEnum arg0 )  { String loc0 = arg0 . literalName ;  return loc0 ;  }
int function (  )  { return _column ;  }
void function ( Crypto arg0 )  { signatureCrypto = arg0 ;  } In this method ,  we are setting the value of the member variable "signatureCrypto" to the value passed as an argument "arg0" .  There is no exception handling done in this method . 
public void function (  )  { RMCTest test = new RMCTest (  )  ;  test . setUp (  )  ;  final double arg0 = 180 . 0 ;  test . rmc . setCourse ( arg0 )  ;  final boolean loc0 = test . EXAMPLE . contains ( " , 180 . 0 , " )  ;  assertTrue ( loc0 )  ;  final String loc1 = test . rmc . toString (  )  ;  final String loc2 = "Course=" + arg0 ;  assertTrue ( loc1 . contains ( loc2 )  )  ;  final double loc3 = test . rmc . getCourse (  )  ;  assertEquals ( arg0 ,  loc3 ,  0 . 0 )  ;  }
int function ( int arg0 ,  int arg1 ,  int arg2 )  { int loc0 = arg0 + arg1 + arg2 ;  progressMonitor . setMaxValue ( loc0 )  ;  return progressMonitor . getMaxValue (  )  ;  }
void function ( Date arg0 )  { GregorianCalendar calendar = new GregorianCalendar (  )  ;  calendar . setTime ( arg0 )  ;  int loc0 = calendar . get ( Calendar . HOUR_OF_DAY )  ;  int loc1 = calendar . get ( Calendar . MINUTE )  ;  double loc2 = calendar . get ( Calendar . SECOND )  ;  Time time = new Time (  )  ;  time . setHour ( loc0 )  ;  time . setMinutes ( loc1 )  ;  time . setSeconds ( loc2 )  ;  }
void function ( Stack < Tag >  arg0 ,  int arg1 )  { while  ( !arg0 . empty (  )  )  { Tag loc0 = arg0 . pop (  )  ;  TagStyle loc1 = getStyle ( loc0 . tag )  ;  if  ( loc1 != null && loc1 . closeTag != null )  { int loc2 = arg1 ;  if  ( loc0 . start != -1 && loc0 . end != -1 )  { loc2 = loc0 . end ;  } builder . append ( loc1 . closeTag )  ;  builder . setSpan ( new StyleSpan ( Typeface . BOLD )  ,  loc0 . start ,  loc2 ,  Spannable . SPAN_EXCLUSIVE_EXCLUSIVE )  ;  } } }
String [  ]  function ( int arg0 ,  int arg1 ,  HeuristicFunction arg2 )  { int loc0 = 3 ;  int loc1 = 2 ;  int loc2 = 6 ;  int loc3 = 4 ;  int loc4 = 5 ;  SearchFactory instance ;  int loc5 = 0 ;  int loc6 = 0 ;  int loc7 = 1 ;  int loc8 = 7 ;  int loc9 = 1 ;  return new String [  ] { "UC_SEARCH" ,  "ID_SEARCH" ,  "RBF_SEARCH" ,  "GBF_SEARCH" ,  "ASTAR_SEARCH" ,  "TREE_SEARCH" ,  "GRAPH_SEARCH" ,  "HILL_SEARCH" ,  "BF_SEARCH" ,  "srini_string" } ;  }
void function ( String arg0 ,  String arg1 ,  String arg2 ,  TripleObjectTypeEnum arg3 ,  String loc0 )  { String loc1 = arg0 . trim (  )  ;  String loc2 = arg1 . trim (  )  ;  String loc3 = arg2 . trim (  )  ;  setObjectType ( arg3 )  ;  setSubject ( loc1 )  ;  setPredicate ( loc2 )  ;  setObject ( loc3 )  ;  }
String function ( String arg0 ,  Object arg1 )  { String stringValue = String . valueOf ( arg0 )  ;  MoreObjects . ValueHolder valueHolder = MoreObjects . addHolder ( arg1 )  ;  return stringValue ;  }
Conduit function (  )  { Conduit loc0 = getConduit (  )  ;  if  ( loc0 instanceof HTTPConduit )  { return  ( HTTPConduit )  loc0 ;  } return null ;  }
int function ( int arg0 ,  int arg1 )  { setInputMode (  )  ;  int loc0 = remaining (  )  ;  return loc0 ;  }
public class SecurityConfigParams { private String allowedRoles ;  private String keyAlias ;  private String privateStore ;  private boolean isServerPrincipalPasswordEncrypted = true ;  private String serverPrincipalPassword ;  private String trustStores ;  public void setServerPrincipalPasswordEncrypted ( boolean isServerPrincipalPasswordEncrypted )  { this . isServerPrincipalPasswordEncrypted = isServerPrincipalPasswordEncrypted ;  } public boolean isServerPrincipalPasswordEncrypted (  )  { return isServerPrincipalPasswordEncrypted ;  } public String getTrustStores (  )  { return trustStores ;  } public void setTrustStores ( String trustStores )  { this . trustStores = trustStores ;  } public String getServerPrincipalPassword (  )  { return serverPrincipalPassword ;  } public void setServerPrincipalPassword ( String serverPrincipalPassword )  { this . serverPrincipalPassword = serverPrincipalPassword ;  } public String getPrivateStore (  )  { return privateStore ;  } public void setPrivateStore ( String privateStore )  { this . privateStore = privateStore ;  } public String getKeyAlias (  )  { return keyAlias ;  } public void setKeyAlias ( String keyAlias )  { this . keyAlias = keyAlias ;  } public String getAllowedRoles (  )  { return allowedRoles ;  } public void setAllowedRoles ( String allowedRoles )  { this . allowedRoles = allowedRoles ;  } public String function ( String arg0 ,  String arg1 ,  String arg2 )  { String loc0 = "" ;  String loc1 = "" ;  String loc2 = "" ;  try { loc0 = function (  )  ;  loc1 = getInstance (  )  ;  loc2 = getFirstProperty (  )  ;  } catch  ( Exception e )  { } if  ( getKeyAlias (  )  != null && !getKeyAlias (  )  . isEmpty (  )  )  { return getKeyAlias (  )  ;  } return loc0 + loc1 + loc2 ;  } private String function (  )  { } private String getInstance (  )  { } private String getFirstProperty (  )  { } }
public static float function ( double arg0 ,  double arg1 ,  double arg2 )  { float loc0 =  ( float )   (  ( arg0 + arg1 )  / 2 . 0 * arg2 )  ;  return loc0 ;  }
Map < String ,  String >  function ( String arg0 )  { Map < String ,  String >  loc0 = new LinkedHashMap <  >  (  )  ;  List < String >  loc1 = getStrings ( arg0 )  ;  for  ( String loc2 : loc1 )  { String [  ]  loc3 = loc2 . split ( "=" )  ;  loc0 . put ( loc3 [ 0 ]  ,  loc3 [ 1 ]  )  ;  } return loc0 ;  }
AbstractAction function ( Object arg0 ,  Object arg1 )  { ProjectActions theInstance ;  AbstractAction redoAction ;  ActionUndo undoAction ;  theInstance = ProjectActions . getInstance (  )  ;  redoAction = theInstance . getRedoAction (  )  ;  undoAction = theInstance . undoAction ;  return undoAction . function ( arg0 ,  arg1 )  ;  }
void function ( Sentence arg0 )  { for  ( ProviderListener < T >  loc0 : listeners )  { loc0 . providerUpdate ( createProviderEvent (  )  ,  arg0 )  ;  } }
int function ( Collection < Object >  arg0 ,  Collection < Object >  arg1 )  { int loc0 = 0 ;  for  ( Object item : arg1 )  { if  ( !arg0 . contains ( item )  )  { arg0 . add ( item )  ;  loc0 ++  ;  } } return loc0 ;  }
public void function ( O arg0 ,  int arg1 )  { DocumentElement < O >  loc0 = new DocumentElement <  >  (  )  ;  IntegerHolder loc1 = new IntegerHolder (  )  ;  loc1 . set ( arg1 )  ;  data . put ( arg0 ,  loc0 )  ;  count . inc (  )  ;  wordCountMultiSet += arg1 ;  }
void function ( FullyQualifiedClassType arg0 )  { handlerClass = arg0 ;  }
String function ( IndividualStructure arg0 )  { String loc0 = arg0 . individualUri ;  return loc0 ;  }
import javax . swing . JOptionPane ;  public class Popup { String appName = "JaMuz" ;  Logger logger = null ;  void error ( String str )  { } void error ( String str ,  Exception ex )  { } void error ( Exception ex )  { } void error ( String methodName ,  String sql ,  Exception ex )  { } void setLogger ( Logger logger )  { } void popupError ( String str )  { } void warning ( String str )  { } void function ( String arg0 )  { JOptionPane . showMessageDialog ( null ,  arg0 )  ;  } }
int function (  )  { int loc0 = getLengthFromFormat ( false )  ;  return loc0 ;  }
void function (  )  { byte loc0 = 0x00 ;  ExpectedException loc1 = ExpectedException . none (  )  ;  PlainSaslServer loc2 = null ;  Callback [  ]  loc3 = new MockCallbackHandler (  )  . getCallbacks (  )  ;  loc2 = new PlainSaslServer (  )  ;  loc2 . handle ( loc3 )  ;  }
List < SequenceWithUtility >  function (  )  { List < SequenceWithUtility >  loc0 = new ArrayList <  >  (  )  ;  for  ( SequenceWithUtility loc1 : sequences )  { loc0 . add ( loc1 )  ;  } return loc0 ;  }
Boolean function ( int arg0 )  { try { Object loc0 = values . get ( arg0 )  ;  if  ( loc0 instanceof Boolean )  { return  ( Boolean )  loc0 ;  } else if  ( loc0 instanceof Integer )  { return  (  ( Integer )  loc0 )  != 0 ;  } else if  ( loc0 instanceof String )  { return Boolean . parseBoolean (  ( String )  loc0 )  ;  } else { throw new IllegalStateException ( "Cannot convert result value to boolean . " )  ;  } } catch  ( IndexOutOfBoundsException e )  { throw new IllegalStateException ( "Result value is not available . " ,  e )  ;  } }
void function ( boolean arg0 )  { DragDropTouchListener loc0 = new DragDropTouchListener (  )  ;  loc0 . enabled = arg0 ;  }
public static CommandHandler function ( String arg0 )  { try { return CommandHandler . valueOf ( arg0 )  ;  } catch  ( IllegalArgumentException ex )  { return null ;  } }
String function ( String arg0 ,  String arg1 )  { roleClassifierType = arg0 ;  roleClassifier = arg1 ;  }
String function ( String arg0 )  { URL loc0 = findResource ( arg0 )  ;  InputStream loc1 = null ;  String loc2 = null ;  try { loc1 = loc0 . openStream (  )  ;  loc2 = IOUtils . toString ( loc1 ,  "UTF-8" )  ;  } catch  ( IOException loc3 )  { log ( "Failed to read resource: " + arg0 ,  loc3 )  ;  } finally { IOUtils . closeQuietly ( loc1 )  ;  } return loc2 ;  }
void function ( FMLInitializationEvent arg0 ,  ServerProxy arg1 )  { modInstance . registerRenders (  )  ;  }
import java . math . BigInteger ;  public class AttackerUtility { int findLCM ( final int a ,  final int b )  { return  ( a * b )  / function ( BigInteger . valueOf ( a )  ,  BigInteger . valueOf ( b )  )  . intValue (  )  ;  } BigInteger findLCM ( final BigInteger ba ,  final BigInteger bb )  { return ba . multiply ( bb )  . divide ( function ( ba ,  bb )  )  ;  } BigInteger findLCM ( final List < BigInteger >  numbers )  { BigInteger lcm = numbers . get ( 0 )  ;  for  ( int i = 1 ;  i  <  numbers . size (  )  ;  i ++  )  { lcm = findLCM ( lcm ,  numbers . get ( i )  )  ;  } return lcm ;  } byte [  ]  correctSize ( final byte [  ]  array ,  final int blockSize ,  final boolean removeSignByte )  { return null ;  } BigInteger function ( final BigInteger arg0 ,  final BigInteger arg1 )  { BigInteger loc0 = arg0 ;  BigInteger loc1 = arg1 ;  while  ( loc1 . compareTo ( BigInteger . ZERO )  != 0 )  { BigInteger temp = loc0 . mod ( loc1 )  ;  loc0 = loc1 ;  loc1 = temp ;  } return loc0 . abs (  )  ;  } }
public Integer function ( Integer arg0 ,  List < T >  arg1 )  { Integer loc0 = 0 ;  if  ( arg1 != null )  { loc0 = arg1 . size (  )  ;  } if  ( loc0  >  arg0 )  { return loc0 - arg0 ;  } return null ;  }
class FeedConfigResponse { String batchId ;  String runStatus ;  String reason ;  String feedId ;  String testId ;  String getBatchId (  )  {  .  .  .  } String toString (  )  {  .  .  .  } String getFeedId (  )  {  .  .  .  } void setTestId ( String testId )  {  .  .  .  } void setRunStatus ( String runStatus )  {  .  .  .  } void setReason ( String reason )  {  .  .  .  } String getReason (  )  {  .  .  .  } String getRunStatus (  )  {  .  .  .  } void setBatchId ( String batchId )  {  .  .  .  } String getTestId (  )  {  .  .  .  } boolean isFeedRunnable (  )  {  .  .  .  } void function ( String arg0 )  { String loc0 = arg0 ;  this . feedId = loc0 ;  } }
short function ( short arg0 ,  String arg1 )  { return CSS_PRIMITIVE_VALUE ;  }
MatrixPosition function ( int arg0 ,  int arg1 )  { int loc0 = arg0 % originalMatrix . getNumRows (  )  ;  int loc1 = arg1 % originalMatrix . getNumColumns (  )  ;  return new MatrixPosition ( loc0 ,  loc1 ,  getLocalSequenceUtility ( new MatrixPosition ( loc0 ,  loc1 )  )  )  ;  }
AccessPermission function ( String arg0 )  { String [  ]  loc0 = arg0 . split ( ":" )  ;  String loc1 = loc0 [ loc0 . length - 1 ]  ;  if  ( loc1 . endsWith ( " . git" )  )  { loc1 = loc1 . substring ( 0 ,  loc1 . length (  )  - 4 )  ;  } loc1 = loc1 . toLowerCase (  )  ;  AccessPermission loc2 = permissionFromRole ( loc0 [ 0 ]  )  ;  if  ( loc2 == null )  { return null ;  } RepositoryModel loc3 = repositoryFromRole ( loc0 [ 0 ]  ,  loc1 )  ;  if  ( loc3 == null )  { return null ;  } String loc4 = loc3 . name ;  if  ( loc0 . length == 1 )  { put ( permissions ,  loc4 ,  loc2 )  ;  } else { String loc5 = loc0 [ 1 ]  . toLowerCase (  )  ;  if  ( loc5 . equals ( "read" )  )  { loc2 = AccessPermission . READ ;  } else if  ( loc5 . equals ( "write" )  )  { loc2 = AccessPermission . WRITE ;  } else if  ( loc5 . equals ( "admin" )  )  { loc2 = AccessPermission . ADMIN ;  } else { add ( preReceiveScripts ,  "echo \"Invalid permission: " + loc0 [ 1 ]  + "\"" )  ;  return null ;  } put ( permissions ,  loc4 ,  loc2 )  ;  } return loc2 ;  }
List < T >  function ( List < T >  arg0 ,  T arg1 )  { arg0 . add ( arg1 )  ;  return arg0 ;  }
boolean function ( StoredBlock arg0 )  { int loc0 = this . chainWork . compareTo ( arg0 . getChainWork (  )  )  ;  return loc0  >  0 ;  }
String function (  )  { String result = "" ;  if  ( this . placeId != null )  { result = this . placeId ;  } return result ;  }
void function ( boolean arg0 )  { setTypedTime ( arg0 )  ;  setEncoding ( "UTF-8" )  ;  }
ByteBuffer function ( String arg0 )  { try { byte [  ]  loc0 = arg0 . getBytes ( "US-ASCII" )  ;  ByteBuffer loc1 = ByteBuffer . wrap ( loc0 )  ;  return loc1 ;  } catch  ( UnsupportedEncodingException loc2 )  { ByteBuffer loc3 = ByteBuffer . allocate ( 0 )  ;  LOG . error ( "Error converting string to byte buffer . " ,  loc2 )  ;  return loc3 ;  } }
Here's an example implementation of the "function" method with the changes requested: ``` import alluxio . Constants ;  import alluxio . LocalAlluxioClusterResource ;  import alluxio . client . block . BlockMasterClient ;  import alluxio . client . block . BlockWorkerClient ;  import alluxio . client . file . FileSystem ;  import alluxio . client . file . URIStatus ;  import alluxio . client . file . options . CreateFileOptions ;  import alluxio . exception . AlluxioException ;  import alluxio . uri . AlluxioURI ;  import alluxio . wire . BlockInfo ;  import alluxio . wire . DataServerMessage ;  import alluxio . worker . block . io . BlockWriter ;  import alluxio . worker . block . io . LocalFileBlockWriter ;  import alluxio . worker . block . remote . RemoteBlockReader ;  import alluxio . worker . block . sync . ManuallyScheduleHeartbeat ;  import alluxio . worker . block . sync . ManuallyScheduleHeartbeat . HeartbeatContext ;  import org . junit . Assert ;  import org . junit . ClassRule ;  import org . junit . Test ;  import java . io . File ;  import java . io . IOException ;  import java . nio . ByteBuffer ;  import java . util . Collection ;  import java . util . LinkedList ;  import java . util . List ;  public class DataServerIntegrationTest {  @ ClassRule public static LocalAlluxioClusterResource sLocalAlluxioClusterResource = new LocalAlluxioClusterResource . Builder (  )   . setProperty ( Constants . WORKER_MEMORY_SIZE ,  "100MB" )   . setProperty ( Constants . WORKER_NETWORK_NETTY_CHANNEL_POOL_SIZE ,  "10" )   . build (  )  ;  private int WORKER_CAPACITY_BYTES = Constants . MB ;  private BlockWorkerClient mBlockWorkerClient ;  private BlockMasterClient mBlockMasterClient ;  private ManuallyScheduleHeartbeat sManuallySchedule = new ManuallyScheduleHeartbeat ( HeartbeatContext . WORKER_BLOCK_SYNC )  ;  private FileSystem mFileSystem = null ;  private void assertValid ( DataServerMessage msg ,  ByteBuffer expectedData ,  long blockId ,  long offset ,  long length )  { } private void assertValid ( DataServerMessage msg ,  int expectedSize ,  long blockId ,  long offset ,  long length )  { } private void readThroughClient (  )  throws Exception { } private void readTooLarge (  )  throws Exception { } private BlockInfo getFirstBlockInfo ( AlluxioURI uri )  throws Exception { } private void readPartialTest2 (  )  throws Exception { } private void readPartialTest1 (  )  throws Exception { } private void after (  )  throws Exception { } private void negativeOffset (  )  throws Exception { } private void multiRead (  )  throws Exception { } private void readThroughClientNonExistent (  )  throws Exception { } private ByteBuffer readRemotely ( RemoteBlockReader client ,  BlockInfo block ,  int length )  throws Exception { } private void before (  )  throws Exception { } private void tooLargeOffset (  )  throws Exception { } private void lengthTooSmall (  )  throws Exception { } private void assertError ( DataServerMessage msg ,  long blockId )  { } private void readMultiFiles (  )  throws Exception { } private void read (  )  throws Exception { } private Collection < Object [  ]  >  data (  )  { return null ;  } private void function ( Object arg0 ,  Object arg1 ,  Object
boolean function (  )  { Date loc0 = new Date (  )  ;  return loc0 . after ( expires )  ;  }
Builder function ( String arg0 )  { Builder builder = new Builder (  )  ;  builder . addEscape ( safeMin ,  arg0 )  ;  builder . addEscape ( safeMax ,  arg0 )  ;  if  ( unsafeReplacement != null )  { builder . setUnsafeReplacement ( arg0 )  ;  } else if  ( "" . equals ( unsafeReplacement )  )  { builder . setUnsafeReplacement ( null )  ;  } for  ( Map . Entry < Character ,  String >  entry : replacementMap . entrySet (  )  )  { char key = entry . getKey (  )  ;  String value = entry . getValue (  )  ;  builder . addEscape ( key ,  value )  ;  } return builder ;  }
class CliUtils { private static final Logger LOG = LoggerFactory . getLogger ( Constants . LOGGER_TYPE )  ;  static boolean function ( final Callable < Boolean >  arg0 )  { boolean loc0 = false ;  try { loc0 = arg0 . call (  )  ;  } catch  ( Exception loc1 )  { LOG . error ( "srini_string" + arg0 ,  loc1 )  ;  } CliUtils . printPassInfo ( loc0 )  ;  return loc0 ;  } void printPassInfo ( boolean pass )  { } }
void function ( Object arg0 ,  int arg1 )  { Block loc0 = fileName . append ( arg0 )  ;  BTreePage loc1 = new BTreePage ( tx ,  ti ,  loc0 ,  arg1 )  ;  BTPageFormatter loc2 = new BTPageFormatter (  )  ;  loc2 . format ( loc1 )  ;  }
boolean function ( int arg0 ,  int arg1 )  { for  ( int loc0 = 0 ;  loc0  <  arg0 ;  loc0 ++  )  { if  ( loc0  <  arg1 ++  )  { return false ;  } } return true ;  }
void function ( Object arg0 ,  Object arg1 )  { Object loc0 = new Object (  )  ;  Object loc1 = new Object (  )  ;  RpcConnection conn = null ;  try { conn = new RpcConnection (  )  ;  conn . setup (  ( String )  arg0 ,   ( char [  ]  )  arg1 ,  conn . defaultHost ,  conn . defaultPort ,  conn . defaultSsl )  ;  Object result = conn . exec ( "methodName" ,  new Object [  ] {} )  ;  } finally { if  ( conn != null )  { conn . finalize (  )  ;  conn . close (  )  ;  } } }
void function ( Class arg0 ,  Connection arg1 )  { JdbcUtil util = new JdbcUtil (  )  ;  util . enableForeignKeyCheck ( arg1 )  ;  util . closeAll ( arg0 ,  arg1 ,  null ,  null )  ;  util . logMessage ( "Frees Database Connection . " )  ;  util . closeAll ( null ,  arg1 ,  null )  ;  String name = util . getName (  )  ;  util . setDataSource ( util . initDataSource (  )  )  ;  }
List < String >  function ( UserSubject arg0 )  { List < String >  loc0 = arg0 . getRoles (  )  ;  return loc0 ;  }
Mode function ( Mode arg0 )  { Mode loc0 = arg0 . applyDirectoryUMask (  )  ;  return loc0 . applyFileUMask (  )  ;  }
public class FuzzyBrain { EntityPlayer player ;  EntityMobWithInventory mob ;  int ticker ;  World world ;  FuzzyInterpreter fin ;  FuzzyTasker futa ;  void setInputs (  )  { } boolean setAction ( String action )  { } void printInputs (  )  { } void function (  )  { setInputs (  )  ;  boolean success = setAction ( "attack" )  ;  if  ( success )  { futa . nextStep (  )  ;  } } }
int function ( int arg0 ,  int arg1 ,  UtilityList loc0 )  { int support = 0 ;  for  ( int i = 0 ;  i  <  loc0 . elements . size (  )  ;  i ++  )  { Element element = loc0 . elements . get ( i )  ;  if  ( element . itemset . contains ( arg0 )  && element . itemset . contains ( arg1 )  )  { support += element . utility ;  } } return support ;  }
void function (  )  { GeneralMotorCon loc0 = GeneralMotorCon . getInstance (  )  ;  loc0 . appendToConsole ( "Right Move the drone a little to the right" )  ;  loc0 . goRight (  )  ;  loc0 . doFor ( arg0 - >  { loc0 . hover (  )  ;  } ,  loc1 - >  500 )  ;  }
public static ELEvaluator function (  )  { return ELEvaluator . current . get (  )  ;  }
boolean function ( File arg0 ,  boolean arg1 ,  Map < String ,  FileChannel >  arg2 )  { boolean loc0 = false ;  if  ( !arg0 . exists (  )  )  { arg0 . mkdir (  )  ;  loc0 = true ;  } this . dbDirectory = arg0 ;  this . isNew = arg1 ;  this . openFiles = arg2 ;  return loc0 ;  }
public static  < T >  Function < T ,  T >  function ( T value )  { try { return Functions . constantFunction ( value )  ;  } catch  ( Exception e )  { return arg0 - >  value ;  } }
String function (  )  { String loc0 = getWsse11TokenType (  )  ;  return loc0 ;  }
void function ( String arg0 )  { String loc0 = arg0 ;  this . resultCode = loc0 ;  }
void function ( String type ,  String username ,  char [  ]  password ,  String host ,  int port ,  boolean ssl )  { RpcConnection rpcConn = new RpcConnection (  )  ;  rpcConn . setup ( username ,  password ,  host ,  port ,  ssl )  ;  }
void function (  )  { Set < BlacklistedSite >  loc0 = new HashSet <  >  (  )  ;  BlacklistedSite loc1 = new BlacklistedSite ( uri1 )  ;  BlacklistedSite loc2 = new BlacklistedSite ( uri2 )  ;  loc0 . add ( loc1 )  ;  loc0 . add ( loc2 )  ;  prepare (  )  ;  Mockito . when ( mockRepository . getAll (  )  )  . thenReturn ( loc0 )  ;  assertTrue ( service . isBlacklisted ( uri1 )  )  ;  assertTrue ( service . isBlacklisted ( uri2 )  )  ;  assertFalse ( service . isBlacklisted ( uri3 )  )  ;  Mockito . verify ( mockRepository ,  times ( 3 )  )  . getAll (  )  ;  Mockito . verify ( mockRepository ,  never (  )  )  . save ( Mockito . any (  )  )  ;  Mockito . reset ( mockRepository )  ;  }
public static int function ( String arg0 ,  int arg1 )  { Objects . requireNonNull ( arg0 )  ;  long loc0 = Long . parseLong ( arg0 ,  arg1 )  ;  if  ( loc0  <  0 || loc0  >  UnsignedInts . INT_MASK )  { throw new NumberFormatException ( "Input string " + arg0 + " in base " + arg1 + " is not in the range of unsigned int" )  ;  } return  ( int )  loc0 ;  }
public AuthenticationHolderEntity function (  )  { String loc0 = PARAM_DATE ;  String loc1 = QUERY_BY_VALUE ;  String loc2 = QUERY_EXPIRATION_BY_DATE ;  Date loc3 = getExpiration (  )  ;  List < AuthorizationCodeEntity >  loc4 = getEntityManager (  )  . createNamedQuery ( loc1 ,  AuthorizationCodeEntity . class )   . setParameter ( loc0 ,  getCode (  )  )  . getResultList (  )  ;  if  ( loc4 . isEmpty (  )  )  { return null ;  } AuthorizationCodeEntity loc5 = loc4 . iterator (  )  . next (  )  ;  if  ( loc3 != null && new Date (  )  . after ( loc3 )  )  { getEntityManager (  )  . createNamedQuery ( loc2 )  . setParameter ( loc0 ,  loc3 )  . executeUpdate (  )  ;  return null ;  } loc5 . setExpiration ( loc3 )  ;  getEntityManager (  )  . merge ( loc5 )  ;  return loc5 . getAuthenticationHolder (  )  ;  }
void function (  )  { try { RTEParser parser = new RTEParser (  )  ;  int arg0 = 5 ;  parser . setSentenceCount ( arg0 )  ;  int loc0 = parser . getSentenceCount (  )  ;  assertEquals ( arg0 ,  loc0 )  ;  int arg1 = -1 ;  parser . setSentenceCount ( arg1 )  ;  fail ( "Expected IllegalArgumentException was not thrown . " )  ;  } catch  ( IllegalArgumentException e )  { String loc1 = e . getMessage (  )  ;  assertTrue ( loc1 . contains ( "Sentence count cannot be negative" )  )  ;  } catch  ( Exception e )  { String loc2 = e . getClass (  )  . getSimpleName (  )  ;  assertEquals ( "IllegalArgumentException" ,  loc2 )  ;  } }
public Script createCheckMultiSigProgram ( List < TransactionSignature >  arg0 ,  ScriptBuilder arg1 ,  boolean arg2 )  { int loc0 = arg0 . size (  )  ;  ScriptBuilder loc1 = arg1 . smallNum ( loc0 )  ;  for  ( TransactionSignature loc2 : arg0 )  { loc1 . data ( loc2 . encodeToBitcoin (  )  )  ;  } if  ( arg2 )  { loc1 . data ( arg1 . build (  )  . getProgram (  )  )  ;  } return loc1 . build (  )  ;  }
public class SecurityUtils { private enum AuthType { AUTHENTICATION ,  AUTHORIZATION } private boolean isAuthEnabled ;  private boolean isSecEnabled ;  public boolean isAuthorizationEnabled (  )  { return isSecEnabled && getEnum ( AuthType . AUTHORIZATION )  == AuthType . AUTHORIZATION ;  } public boolean isSecurityEnabled (  )  { return isSecEnabled &&  ( isAuthEnabled || getEnum ( AuthType . AUTHORIZATION )  == AuthType . AUTHORIZATION )  ;  } public void function ( Object arg0 ,  Object arg1 )  { AuthType loc0 = getEnum ( arg0 )  ;  AuthType loc1 = AuthType . AUTHENTICATION ;  if  ( loc0 . equals ( loc1 )  )  { isAuthEnabled =  ( boolean )  arg1 ;  } else { isSecEnabled =  ( boolean )  arg1 ;  } } private AuthType getEnum ( Object obj )  { return AuthType . valueOf ( obj . toString (  )  )  ;  } }
public class Difference { String referencedRevisionLabelB ;  String referencedRevisionB ;  Triple triple ;  SDDTripleStateEnum tripleResolutionState ;  ResolutionStateEnum resolutionState ;  String referencedRevisionA ;  String referencedRevisionLabelA ;  void setTriple ( Triple arg0 )  { triple = arg0 ;  } void setReferencedRevisionA ( String arg0 )  { referencedRevisionA = arg0 ;  } String getReferencedRevisionB (  )  { return referencedRevisionB ;  } void setResolutionState ( ResolutionStateEnum arg0 )  { resolutionState = arg0 ;  } String getReferencedRevisionLabelA (  )  { return referencedRevisionLabelA ;  } void setReferencedRevisionLabelA ( String arg0 )  { referencedRevisionLabelA = arg0 ;  } SDDTripleStateEnum getTripleResolutionState (  )  { return tripleResolutionState ;  } Triple getTriple (  )  { return triple ;  } void setTripleResolutionState ( SDDTripleStateEnum arg0 )  { tripleResolutionState = arg0 ;  } String getReferencedRevisionA (  )  { return referencedRevisionA ;  } String getReferencedRevisionLabelB (  )  { return referencedRevisionLabelB ;  } void setReferencedRevisionB ( String arg0 )  { referencedRevisionB = arg0 ;  } ResolutionStateEnum getResolutionState (  )  { return resolutionState ;  } void function (  )  { referencedRevisionLabelB = "Set the referenced revision label in B . " ;  } }
double [  ]  function ( double [  ]  arg0 )  { double [  ]  loc0 = null ;  try { int length = Math . min ( arg0 . length ,  arg1 . length )  ;  loc0 = new double [ length ]  ;  for  ( int i = 0 ;  i  <  length ;  i ++  )  { loc0 [ i ]  = Math . abs ( arg0 [ i ]  )  ;  } } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
import java . util . HashMap ;  import java . util . Map ;  import javax . annotation . Nullable ;  public class Escapers { Escaper NULL_ESCAPER = new CharEscaper (  )  {  @ Override public String escape ( String string )  { return checkNotNull ( string )  ;  }  @ Override protected char [  ]  escape ( char c )  { return null ;  } } ;  Map < Character ,  String >  replacementMap = new HashMap < Character ,  String >  (  )  ;  char safeMax = Character . MAX_VALUE ;  String unsafeReplacement = null ;  char safeMin = Character . MIN_VALUE ;  public void function (  )  { Builder builder = builder (  )  ;  builder . function (  )  ;  } Builder builder (  )  { return new Builder (  )  ;  } String escape ( String string )  { return builder (  )  . escape ( string )  ;  } char [  ]  escape ( char c )  { return builder (  )  . escape ( c )  ;  } Escaper nullEscaper (  )  { return builder (  )  . nullEscaper (  )  ;  } Builder addEscape ( char c ,  String replacement )  { return builder (  )  . addEscape ( c ,  replacement )  ;  } String stringOrNull ( char [  ]  in )  { return builder (  )  . stringOrNull ( in )  ;  } UnicodeEscaper asUnicodeEscaper ( Escaper escaper )  { return builder (  )  . asUnicodeEscaper ( escaper )  ;  } String computeReplacement ( CharEscaper escaper ,  char c )  { return builder (  )  . computeReplacement ( escaper ,  c )  ;  } String computeReplacement ( UnicodeEscaper escaper ,  int cp )  { return builder (  )  . computeReplacement ( escaper ,  cp )  ;  } UnicodeEscaper wrap ( final CharEscaper escaper )  { return builder (  )  . wrap ( escaper )  ;  } Builder setUnsafeReplacement (  @ Nullable String unsafeReplacement )  { return builder (  )  . setUnsafeReplacement ( unsafeReplacement )  ;  } Escaper build (  )  { return builder (  )  . build (  )  ;  } public class Builder { public Builder (  )  { } public void function (  )  { } public Builder addEscape ( char c ,  String replacement )  { return this ;  } public Escaper build (  )  { return null ;  } } public abstract class CharEscaper extends Escaper { } public abstract class Escaper { } public abstract class UnicodeEscaper extends CharEscaper { } }
import javax . sound . sampled . * ;  import java . util . List ;  public class PlayerFlac { DataLine . Info info ;  List listeners ;  SourceDataLine line ;  String filePath ;  Thread playerThread ;  FLACDecoder decoder ;  AudioFormat fmt ;  void function (  )  { listeners . add ( arg0 )  ;  } String play ( String filePath )  { return null ;  } void processStreamInfo ( StreamInfo streamInfo )  { } void processPCM ( ByteData pcm )  { } void stop (  )  { } void update ( LineEvent event )  { } void run (  )  { } void removeListener ( LineListener listener )  { } void decode ( String inFileName )  { } }
public long function ( Object arg0 ,  Object arg1 )  { startTimer (  )  ;  stopTimer (  )  ;  return timeElapsed ;  }
import java . awt . * ;  import java . util . Map ;  public class ScalingOptions { DownscaleQuality downscalingHint ;  int targetHeight ;  Object renderingHint ;  int targetWidth ;  public int getTargetHeight (  )  { return targetHeight ;  } public DownscaleQuality getDownscalingHint (  )  { return downscalingHint ;  } public void setTargetWidth ( int targetWidth )  { this . targetWidth = targetWidth ;  } public int getTargetWidth (  )  { return targetWidth ;  } public boolean sizeMatches ( int w ,  int h )  { return targetWidth == w && targetHeight == h ;  } public boolean sizeMatches ( Image img )  { return sizeMatches ( img . getWidth ( null )  ,  img . getHeight ( null )  )  ;  } public Object getRenderingHint (  )  { return renderingHint ;  } public void setTargetDimensions ( Dimension dim )  { targetWidth = dim . width ;  targetHeight = dim . height ;  } public Map getRenderingHints (  )  { return null ;  } public void setTargetHeight ( int targetHeight )  { this . targetHeight = targetHeight ;  } public void function ( Graphics2D arg0 ,  Image arg1 )  { Map renderingHints = null ;  try { renderingHints = getRenderingHints (  )  ;  } catch  ( Exception e )  { } if  ( renderingHints != null )  { arg0 . setRenderingHints ( renderingHints )  ;  } } }
String function (  )  { String loc0 = classnamePrefix ;  if  ( loc0 == null )  { Object loc1 = getContext (  )  ;  Object loc2 = getClassifier (  )  ;  while  ( loc2 == null && loc1 != null )  { loc2 =  (  ( Context )  loc1 )  . getClassifier (  )  ;  loc1 =  (  ( Context )  loc1 )  . getParent (  )  ;  } if  ( loc2 != null )  { loc0 =  (  ( Object )  loc2 )  . toString (  )  + "$" ;  } } return loc0 ;  }
import java . io . File ;  import java . io . InputStream ;  public class OsmReader { private Logger LOG = Logger . getLogger ( "aimax . osm" )  ;  public void function ( File arg0 ,  MapBuilder arg1 )  { try { InputStream loc0 = createFileStream ( arg0 )  ;  parseMap ( loc0 ,  arg1 )  ;  } catch  ( Exception loc1 )  { LOG . log ( Level . SEVERE ,  "Failed to read file: " + arg0 ,  loc1 )  ;  } } private InputStream createFileStream ( File loc0 )  throws IOException { return new FileInputStream ( loc0 )  ;  } private void parseMap ( InputStream loc0 ,  MapBuilder loc1 )  throws Exception { } }
public byte [  ]  function ( int arg0 )  { Node valueNode =  ( Node )  values . get ( arg0 )  ;  Object loc0 = parseValue ( valueNode )  ;  if  ( loc0 instanceof byte [  ]  )  { return  ( byte [  ]  )  loc0 ;  } else { IllegalStateException e = new IllegalStateException ( "Result value is not binary data" )  ;  throw e ;  } }
public void function ( long arg0 ,  long arg1 )  throws InterruptedException { Thread loc0 = new Thread (  (  )  - >  { mLockManager . lockBlock ( arg0 ,  arg1 ,  BlockLockType . SHARED )  ;  } )  ;  loc0 . start (  )  ;  loc0 . join (  )  ;  Assert . assertTrue ( mLockManager . isLocked ( arg0 ,  arg1 )  )  ;  }
Iterator < Type >  iterator (  )  { Iterator < Type >  arg0 = v . iterator (  )  ;  while  ( arg0 . hasNext (  )  )  { Type loc0 = arg0 . next (  )  ;  if  ( ts . isSubtype ( loc0 ,  arg1 )  )  { arg0 . remove (  )  ;  } } }
EndpointReferenceType function (   )  { return faultTo ;  }
class EaseEmojicon { int icon ;  String name ;  Type type ;  String iconPath ;  String identityCode ;  String bigIconPath ;  int bigIcon ;  String emojiText ;  void function ( String arg0 )  { this . name = arg0 ;  } String getIdentityCode (  )  { return identityCode ;  } int getBigIcon (  )  { return bigIcon ;  } void setType ( Type type )  { this . type = type ;  } int getIcon (  )  { return icon ;  } String getEmojiText (  )  { return emojiText ;  } void setEmojiText ( String emojiText )  { this . emojiText = emojiText ;  } String getIconPath (  )  { return iconPath ;  } void setBigIconPath ( String bigIconPath )  { this . bigIconPath = bigIconPath ;  } String newEmojiText ( int codePoint )  { return Character . toString (  ( char )  codePoint )  ;  } String getName (  )  { return name ;  } void setBigIcon ( int dynamicIcon )  { this . bigIcon = dynamicIcon ;  } void setIdentityCode ( String identityCode )  { this . identityCode = identityCode ;  } void setIconPath ( String iconPath )  { this . iconPath = iconPath ;  } String getBigIconPath (  )  { return bigIconPath ;  } void setIcon ( int icon )  { this . icon = icon ;  } Type getType (  )  { return type ;  } }
public void function ( long arg0 )  { try { Util . getCurrentTime (  )  ;  } catch  ( Exception loc0 )  { System . err . println ( "Exception occurred while calling Util . getCurrentTime (  ) : " + loc0 . getMessage (  )  )  ;  } this . lastFeedbacktime = Util . getCurrentTime (  )  ;  this . sequenceNumber = arg0 ;  }
void function ( String arg0 ,  String arg1 )  { roleClassifier = arg0 ;  if  ( arg1 != null )  { roleClassifierType = arg1 ;  } }
private void function (  )  { int bufferSize = 10 ;  mTestStream = new TestBufferedBlockOutStream ( bufferSize )  ;  byte [  ]  expectedBytes = Arrays . copyOfRange ( INCREASING_BYTES ,  0 ,   ( int ) BLOCK_LENGTH )  ;  for  ( int i = 0 ;  i  <  BLOCK_LENGTH ;  i ++  )  { byte byteToWrite = INCREASING_BYTES [ i ]  ;  mTestStream . write ( byteToWrite )  ;  } assertEquals ( BLOCK_LENGTH ,  mTestStream . size (  )  )  ;  mTestStream . flush (  )  ;  assertEquals ( BLOCK_LENGTH ,  mTestStream . size (  )  )  ;  byte [  ]  actualBytes = mTestStream . toByteArray (  )  ;  assertArrayEquals ( expectedBytes ,  Arrays . copyOfRange ( actualBytes ,  0 ,   ( int ) BLOCK_LENGTH )  )  ;  }
void function  ( short arg0 )  { put16 (  ( short )   ( arg0 & 0xFFFF )  )  ;  }
public void function ( InodeFile arg0 )  { TtlBucket loc0 = getBucketContaining ( arg0 )  ;  if  ( loc0 != null )  { loc0 . removeFile ( arg0 )  ;  } }
String function ( Module module )  { String loc0 = module . noRun ;  return loc0 ;  }
public void function ( PermissionChecker arg0 ,  InodeTree arg1 ,  Mode . Bits arg2 ,  String arg3 ,  List < Inode < ? >  >  arg4 ,  boolean arg5 )  { if  ( arg1 == null )  { return ;  } String loc0 = arg0 . getClientUser (  )  ;  List < String >  loc1 = arg0 . getGroups ( loc0 )  ;  arg0 . checkInodeList ( loc0 ,  loc1 ,  arg2 ,  arg3 ,  arg4 ,  arg5 )  ;  }
String function ( String arg0 ,  String arg1 ,  String arg2 ,  String arg3 ,  String arg4 )  { String loc0 = String . format ( "DELETE WHERE { GRAPH  < %s/%s >  { %s } }" ,  arg2 ,  arg3 ,  arg4 )  ;  return ep . sparql ( loc0 )  ;  }
void function (  )  { mThrown . expect ( LineageNotFoundException . class )  ;  mThrown . expectMessage ( "Lineage with ID 123 does not exist . " )  ;  long loc0 = 123 ;  try { mLineageStore . deleteLineage ( loc0 )  ;  } catch  ( LineageNotFoundException loc1 )  { assertEquals ( loc0 ,  loc1 . getLineageId (  )  )  ;  throw loc1 ;  } }
boolean function (  )  { int loc0 = getOption ( 0 )  ;  return loc0 != -1 ;  }
public String function (  )  { try { CString loc0 = new CString (  )  ;  loc0 . setValue ( handlerName )  ;  return loc0 . getValue (  )  ;  } catch  ( Exception loc1 )  { return null ;  } }
void function ( SshDisconnectedEvent arg0 )  { System . out . println ( "Captures SshDisconnectedEvent: " + arg0 . getHost (  )  )  ;  connected = false ;  }
public long function ( RMMessage arg0 )  { long loc0 = 0 ;  try { List < InputStream >  loc1 = arg0 . getAttachments (  )  ;  if  ( loc1 != null && !loc1 . isEmpty (  )  )  { for  ( InputStream loc2 : loc1 )  { if  ( loc2 != null )  { loc2 . close (  )  ;  } } } InputStream loc3 = arg0 . getContent (  )  ;  if  ( loc3 != null )  { loc3 . close (  )  ;  } loc0 = arg0 . getMessageNumber (  )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
List < String >  function ( CertificateConstraintsType arg0 )  { CertConstraintsJaxBUtils loc0 = new CertConstraintsJaxBUtils (  )  ;  CertConstraints loc1 = loc0 . createCertConstraints ( arg0 )  ;  List < String >  loc2 = loc1 . getIssuerDNConstraints (  )  . getRegularExpression (  )  ;  if  ( !loc1 . getIssuerDNConstraints (  )  . isSetIssuerDNConstraints (  )  )  { loc2 = Collections . emptyList (  )  ;  } return loc2 ;  }
public void function ( List < String >  arg0 )  { try { this . registeredAudiences = new LinkedList < String >  ( arg0 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
ArrayList < ScriptChunk >  chunks = new ArrayList < ScriptChunk >  (  )  ;  void function ( byte [  ]  arg0 ,  List < TransactionSignature >  arg1 ,  List < ECKey >  arg2 ,  int arg3 )  { chunks . add ( new ScriptChunk ( OP_0 ,  null )  )  ;  for  ( ECKey key : arg2 )  { chunks . add ( new ScriptChunk ( key . getPubKey (  )  ,  null )  )  ;  } chunks . add ( new ScriptChunk ( arg3 ,  null )  )  ;  byte [  ]  multisigProgramBytes = createRedeemScript ( arg3 ,  arg2 )  . getProgram (  )  ;  List < byte [  ]  >  signatures = new ArrayList < byte [  ]  >  (  )  ;  for  ( TransactionSignature signature : arg1 )  { signatures . add ( signature . encodeToBitcoin (  )  )  ;  } byte [  ]  multisigInputScriptBytes = createMultiSigInputScriptBytes ( signatures ,  multisigProgramBytes )  ;  chunks . add ( new ScriptChunk ( multisigInputScriptBytes . length ,  multisigInputScriptBytes )  )  ;  chunks . add ( new ScriptChunk ( OP_CHECKMULTISIG ,  null )  )  ;  }
long function ( int arg0 )  { try { long loc0 = arg0 & UnsignedInts . INT_MASK ;  return loc0 ;  } catch  ( Exception e )  { } }
FileDescriptor function (  )  { return fd ;  }
Page < Site >  function ( Pageable arg0 )  { log . debug ( "Finding all sites" )  ;  return siteRepository . findAll ( arg0 )  ;  } void function ( String arg0 )  { log . debug ( "Deleting site with id: {}" ,  arg0 )  ;  siteRepository . delete ( arg0 )  ;  } Site function (  )  { log . debug ( "Finding site with host: webnauan . com" )  ;  return siteRepository . findByHost ( "webnauan . com" )  ;  } Site function ( Site arg0 )  { log . debug ( "Saving site: {}" ,  arg0 )  ;  return siteRepository . save ( arg0 )  ;  } Site function ( String arg0 )  { log . debug ( "Finding site with id: {}" ,  arg0 )  ;  return siteRepository . findOne ( arg0 )  ;  }
byte [  ]  function ( int arg0 ,  int arg1 )  { ByteBuffer buffer = ByteBuffer . wrap ( BufferUtils . getIncreasingByteArray ( arg0 ,  arg1 )  )  ;  return BufferUtils . newByteArrayFromByteBuffer ( buffer )  ;  }
public void function (  )  { ttm . setStatus ( true )  ;  assertTrue ( ttm . toString (  )  . contains ( "net . sf . marineapi . nmea . parser . TTMParser#setStatus (  ) " )  )  ;  }
boolean function ( String arg0 )  { int loc0 = arg0 . length (  )  ;  if  ( loc0  >  1 && arg0 . charAt ( 1 )  == ':' && Character . isLetter ( arg0 . charAt ( 0 )  )  )  { return true ;  } return false ;  }
public static void function ( final int blockLength ,  final D1Submatrix64F arg0 ,  final D1Submatrix64F arg1 ,  final int row ,  final double gamma )  { final double half = 0 . 5 ;  final double y = arg0 . get ( row ,  arg1 . col0 (  )  )  ;  double u = BlockHouseHolder . innerProdRow ( blockLength ,  arg1 ,  row ,  arg0 ,  row ,  0 )  ;  u *= half * gamma ;  for  ( int i = arg1 . col0 (  )  ;  i  <  arg1 . col1 (  )  ;  i ++  )  { final double loc0 = arg1 . get ( row ,  i )  ;  final double loc1 = arg1 . get ( row ,  i )  - u * arg1 . get ( row ,  i )  ;  arg1 . set ( row ,  i ,  loc1 )  ;  y -= half * loc0 * u ;  } arg0 . set ( row ,  arg1 . col0 (  )  ,  y )  ;  }
String function ( String arg0 )  { String loc0 = arg0 . replaceAll ( ": [ 0-9 ] +" ,  "" )  ;  // Remove port number int loc1 = loc0 . indexOf ( '?' )  ;  if  ( loc1 != -1 )  { loc0 = loc0 . substring ( 0 ,  loc1 )  ;  // Remove query string } loc0 = loc0 . replace ( " " ,  "%20" )  ;  // Replace spaces with %20 loc0 = loc0 . replace ( "\\" ,  "/" )  ;  // Replace backslashes with forward slashes return loc0 ;  }
public int function (  )  { OthelloBoard loc0 = this . copy (  )  . taken ;  loc0 . andNot ( this . black )  ;  int loc1 = loc0 . cardinality (  )  ;  return 64 - loc1 - this . countBlack (  )  ;  }
BookPreview function ( UUID arg0 )  { for  ( BookPreview loc0 : instance . data )  { if  ( loc0 . getUUID (  )  == arg0 )  { return loc0 ;  } } return null ;  }
public int function (  )  { int loc0 = allNodes . size (  )  ;  return loc0 ;  }
DagEngine function ( String arg0 ,  String arg1 )  { try { return new DagEngine (  )  ;  } catch  ( Exception loc0 )  { System . out . println ( "Error creating Dag engine: " + loc0 . getMessage (  )  )  ;  return null ;  } }
import java . io . InputStream ;  import org . junit . Assert ;  public class ResourceLoaderTest { public void function ( String loc0 ,  ResourceLoader loc1 )  { InputStream loc2 = null ;  InputStream loc3 = loc1 . getResourceStream ( loc0 )  ;  Assert . assertNotNull ( "Test of getResourceStream method ,  of class ResourceLoader . " ,  loc3 )  ;  System . out . println ( "Resource loaded successfully!" )  ;  } }
void function ( Iterable < ? extends T >  arg0 )  { offerAll ( arg0 . iterator (  )  )  ;  }
public ProjectValidation function (  )  { ProjectValidation loc0 = null ;  try { loc0 = new ProjectValidation (  )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
boolean function ( Map < String ,  String >  arg0 ,  String arg1 ,  String arg2 )  { if  ( arg0 == null || arg1 . isEmpty (  )  || arg2 . isEmpty (  )  )  { return false ;  } arg0 . put ( arg1 ,  arg2 )  ;  return true ;  }
Object function ( Object arg0 ,  Object arg1 )  { Object loc0 = arg0 ;  Object loc1 = arg1 ;  if  ( loc0 != null )  { return loc0 ;  } else { return loc1 ;  } }
String function (  )  { String loc0 = this . csr ;  return loc0 ;  }
void function ( String arg0 ,  Throwable arg1 )  { if  ( URLogs . issIsLogEnabled (  )  )  { String loc0 = URLogs . getContent ( URLogs . getCurrentStackTraceElement (  )  )  ;  String loc1 = arg1 . getMessage (  )  ;  try { arg1 . printStackTrace (  )  ;  Log . e ( URLogs . getsApplicationTag (  )  ,  loc1 )  ;  } catch  ( Exception loc2 )  { Log . e ( URLogs . getsApplicationTag (  )  ,  loc1 )  ;  } } }
Set < String >  function (  )  { Set < String >  loc0 = null ;  try { loc0 = this . recentlyGrantedPermissions ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
boolean function ( Fiat arg0 ,  Fiat arg1 )  { return arg0 . compareTo ( arg1 )   <  0 ;  }
void function ( String arg0 ,  Object arg1 )  { try { AuthenticationRequest authRequest =  ( AuthenticationRequest )  arg1 ;  authRequest . setType ( arg0 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
String function ( String arg0 )  { try { String loc0 = CacheUtil . md5sum ( arg0 )  ;  return loc0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return null ;  }
void function ( BufferedByteWriter writer ,  int arg0 )  { writer . ensureCapacity ( 4 )  ;  writer . put (  ( byte )  ( arg0  >  >  24 )  )  ;  writer . put (  ( byte )  ( arg0  >  >  16 )  )  ;  writer . put (  ( byte )  ( arg0  >  >  8 )  )  ;  writer . put (  ( byte ) arg0 )  ;  }
String function ( Object arg0 ,  Object arg1 )  { String result = "" ;  Object facade = arg0 ;  Object modelElement = arg1 ;  if  ( facade != null && facade . getFacade (  )  != null && modelElement != null )  { if  ( facade . getFacade (  )  . isAAttribute ( modelElement )  )  { if  ( facade . getFacade (  )  . isReadOnly ( modelElement )  )  { result = generateFinalKeyword (  )  ;  } } else if  ( facade . getFacade (  )  . isAOperation ( modelElement )  )  { if  ( facade . getFacade (  )  . isLeaf ( modelElement )  )  { result = generateFinalKeyword (  )  ;  } } } return result ;  } String generateFinalKeyword (  )  { return "final" ;  }
DenseMatrix64F function (  )  { svd = new SingularValueDecomposition <  >  ( mat )  ;  int size = Math . min ( mat . numRows (  )  ,  mat . numCols (  )  )  ;  DenseMatrix64F diag = new DenseMatrix64F ( size ,  size )  ;  for  ( int loc0 = 0 ;  loc0  <  size ;  loc0 ++  )  { diag . set ( loc0 ,  loc0 ,  svd . getSingularValues (  )  [ loc0 ]  )  ;  } return diag ;  }
class OpenIDClaimMapper { private static final String LN_AXSCHEMA="AxSchema" ;  private static final String LN_CLAIM="Claim" ;  private static final String OPENID_CLAIM_MAPPER_FILE_PATH="/openid-claim-mapper . xml" ;  private static final String LN_SREG="SReg" ;  private static final String LN_OPENID_SCHEMA="OpenIDSchema" ;  private static final String LN_CLAIM_MAPPER="ClaimMapper" ;  private static OpenIDClaimMapper instance = null ;  private static HashMap < String , String >  axMapping = new HashMap < String , String >  (  )  ;  private static HashMap < String , String >  sregMapping = new HashMap < String , String >  (  )  ;  private OpenIDClaimMapper (  )  { process ( OPENID_CLAIM_MAPPER_FILE_PATH )  ;  } public static OpenIDClaimMapper function (  )  { if  ( instance == null )  { synchronized ( OpenIDClaimMapper . class )  { if  ( instance == null )  { instance = new OpenIDClaimMapper (  )  ;  } } } return instance ;  } public HashMap < String , String >  getSregMapping (  )  { return sregMapping ;  } public HashMap < String , String >  getAxMapping (  )  { return axMapping ;  } private void process ( String filePath )  { } private void process ( OMElement initialClaims )  { } }
void function ( Hessian2Input arg0 )  { if  ( arg0 != null )  { HessianFreeList < Hessian2Input >  loc0 = _freeHessian2Input ;  synchronized  ( loc0 )  { if  ( loc0 . size (  )   <  32 )  { loc0 . add ( arg0 )  ;  } } } }
public static void function ( String [  ]  arg0 )  { SshExample loc0 = null ;  try { loc0 = new SshExample (  )  ;  loc0 . connected = true ;  } catch  ( Exception loc1 )  { System . out . println ( "Exception occurred: " + loc1 . getMessage (  )  )  ;  } }
String [  ]  function ( String arg0 )  { String loc0 = arg0 . replaceAll ( " [ ^a-zA-Z\\s ] " ,  "" )  . toLowerCase (  )  ;  // remove punctuation marks loc0 = loc0 . replaceAll ( " < ! --  . *? --  > " ,  "" )  ;  // remove comments loc0 = loc0 . replaceAll ( " < summary >  . *? < /summary > " ,  "" )  ;  // remove summary String [  ]  loc1 = loc0 . split ( "\\s+" )  ;  // split into tokens return loc1 ;  }
Abstraction function ( Abstraction arg0 ,  Value arg1 ,  Stmt arg2 )  { Abstraction loc0 = arg0 ;  while  ( loc0 != null && !loc0 . isAbstractionReached (  )  )  { loc0 = loc0 . getAbstractionAtNode ( arg1 ,  arg2 )  ;  } return loc0 ;  }
int function ( TtlBucket arg0 ,  TtlBucket arg1 )  { long loc0 = arg0 . getTtlIntervalStartTimeMs (  )  ;  long loc1 = arg1 . getTtlIntervalStartTimeMs (  )  ;  return Long . compare ( loc0 ,  loc1 )  ;  }
Document function ( InputStream arg0 ,  LuceneDocumentMetadata arg1 ,  boolean arg2 ,  boolean arg3 )  { Document doc = extractor . extractAll ( arg0 ,  arg1 ,  arg2 ,  arg3 )  ;  return doc ;  }
List < T >  function (  )  { try { Arrays . sort ( buffer ,  0 ,  bufferSize ,  comparator )  ;  int size = Math . min ( k ,  bufferSize )  ;  T [  ]  copy = Arrays . copyOf ( buffer ,  size )  ;  Arrays . fill ( buffer ,  0 ,  bufferSize ,  null )  ;  return Collections . unmodifiableList ( Arrays . asList ( copy )  )  ;  } catch  ( Exception e )  { } }
void function (  )  { ZDAParser zdaParser = new ZDAParser (  )  ;  zdaParser . parse ( EXAMPLE )  ;  Date loc0 = zdaParser . getTime (  )  ;  assertNotNull ( loc0 )  ;  assertEquals ( loc0 . getTime (  )  ,  1091417375000L )  ;  }
import static org . junit . Assert . assertEquals ;  public class DateTest { Date instance ;  GregorianCalendar cal ;  void function (  )  { try { int loc0 = cal . get ( Calendar . DAY_OF_MONTH )  ;  int loc1 = instance . getDay (  )  ;  assertEquals ( loc0 ,  loc1 )  ;  } catch  ( Exception e )  { } } }
void function (  )  { LanguageVersion loc0 = LanguageRegistry . findLanguageVersionByTerseName ( terseName ,  version )  ;  assertEquals ( expected ,  loc0 )  ;  }
public static String function ( String arg0 ,  String arg1 )  { String loc0 = AlluxioShellUtils . escape ( arg0 )  ;  String loc1 = AlluxioShellUtils . SPECIAL_REGEX_CHARS . matcher ( loc0 )  . replaceAll ( "\\\\$0" )  ;  return loc1 . replace ( "*" ,  " . *" )  . replace ( "?" ,  " . " )  ;  }
public void function ( BigDecimal arg0 )  { try { expDataUnitId = arg0 ;  } catch  ( Exception e )  { } }
class Metrics { PackageStats TOP_LEVEL_PACKAGE = new PackageStats (  )  ;  OperationMetric calculator ;  double get ( ClassMetricKey key ,  ASTClassOrInterfaceDeclaration node )  ;  double get ( OperationMetricKey key ,  ASTMethodOrConstructorDeclaration node )  ;  PackageStats getTopLevelPackageStats (  )  ;  OperationMetric function (  )  { return calculator ;  } }
public class GSVTest { GSVSentence gsv ;  String EXAMPLE = "$GPGSV , 3 , 2 , 12 , 15 , 56 , 182 , 51 , 17 , 38 , 163 , 47 , 18 , 63 , 058 , 50 , 21 , 53 , 329 , 47*73" ;  GSVSentence empty ;  void function (  )  { assertEquals ( arg0 ,  arg1 . getSentenceIndex (  )  )  ;  } void testSetSatelliteCount (  )  { } void testSetSatelliteInfo (  )  { } void testSetSentenceCount (  )  { } void testIsLast (  )  { } void testSatelliteInfo ( SatelliteInfo si ,  String id ,  int elevation ,  int azimuth ,  int noise )  { } void setUp (  )  { } void testIsFirst (  )  { } void testGetSatelliteCount (  )  { } void testGetSatelliteInfo (  )  { } void testParserGlonassGSV (  )  { } void testGetSentenceCount (  )  { } void testGetSatelliteInfoWithEmptyFields (  )  { } void testConstructor (  )  { } void testGetSatelliteInfoWithShortSentence (  )  { } }
SiteUrl function ( String arg0 ,  String arg1 ,  String arg2 )  { SiteUrl siteUrl = new SiteUrl ( arg0 ,  arg1 ,  arg2 )  ;  log . debug ( "Creating a new SiteUrl: {}" ,  siteUrl )  ;  SiteUrl savedSiteUrl = siteUrlRepository . save ( siteUrl )  ;  return savedSiteUrl ;  }
DataServerMessage function (  )  { DataServerMessage loc0 = new DataServerMessage (  )  ;  DataServerMessage loc1 = new DataServerMessage ( false ,  RPCMessage . Type . DATA_REQUEST )  ;  ByteBuffer loc2 = ByteBuffer . allocate ( DataServerMessage . REQUEST_HEADER_LENGTH )  ;  return loc1 ;  }
public class Store { private EntityManager entityManager ;  public boolean contains ( Object entity )  { } public boolean isClosed (  )  { } public void beginTrx (  )  { } public void commitTrx (  )  { } public void closeTrx (  )  { } public String getConnection (  )  { } public EntityManager getEntityManager (  )  { } public void rollbackTrx (  )  { } public String getFlushMode (  )  { } public boolean isDetached ( Object o )  { } public void function (  )  { EntityTransaction loc0 = entityManager . getTransaction (  )  ;  boolean loc1 = loc0 . isActive (  )  ;  } }
void function (  )  { try { TTMParser loc0 = new TTMParser ( EXAMPLE )  ;  loc0 . setTimeToCPA ( 10 . 0 )  ;  double loc1 = loc0 . getTimeToCPA (  )  ;  assertEquals ( 10 . 0 ,  loc1 ,  0 . 0 )  ;  } catch  ( Exception loc2 )  { fail ( "Unexpected exception thrown: " + loc2 . getMessage (  )  )  ;  } }
class SshExample { boolean connected = false ;  void main ( String [  ]  args )  { } void dataReceived ( SshDataReceivedEvent ev )  { } void connected ( SshConnectedEvent ev )  { } void function ( SshDisconnectedEvent arg0 )  { connected = false ;  System . out . println ( "Disconnected from " + arg0 . getHost (  )  )  ;  } }
String function ( String arg0 )  { String loc0 = value ;  setValue ( arg0 )  ;  String loc1 = value ;  setValue ( loc0 )  ;  return loc1 ;  }
boolean function (  )  { boolean loc0 = ts . next (  )  ;  if  ( !loc0 )  { return false ;  } RID loc1 = ts . getRid (  )  ;  while  ( !val . equals ( idx . getDataRecord ( ts . getRid (  )  )  . getVal ( "dataval" )  )  )  { loc0 = ts . next (  )  ;  if  ( !loc0 )  { return false ;  } loc1 = ts . getRid (  )  ;  } moveToRid ( loc1 )  ;  return true ;  }
void function (  )  { mBlockStream = mEOFBlockStream ;  int loc0 =  ( int )  BLOCK_LENGTH ;  seekInternal ( mBlockStream ,  loc0 )  ;  }
void function (  )  { try { int arg0 = 6 ;  // replace with desired argument value instance . setMonth ( arg0 )  ;  fail ( "Expected IllegalArgumentException was not thrown" )  ;  } catch  ( IllegalArgumentException loc0 )  { } catch  ( Exception loc1 )  { fail ( "Unexpected exception thrown: " + loc1 )  ;  } }
String function ( Set < String >  arg0 ,  FitnessFunction arg1 ,  int iterations ,  int populationSize ,  double mutationProbability ,  int individualLength ,  Character [  ]  finiteAlphabet )  { GeneticAlgorithm geneticAlgorithm = new GeneticAlgorithm (  )  ;  geneticAlgorithm . validatePopulation ( arg0 )  ;  geneticAlgorithm . clearInstrumentation (  )  ;  geneticAlgorithm . setPopulationSize ( populationSize )  ;  geneticAlgorithm . mutationProbability = mutationProbability ;  geneticAlgorithm . individualLength = individualLength ;  geneticAlgorithm . finiteAlphabet = finiteAlphabet ;  geneticAlgorithm . setIterations ( iterations )  ;  return geneticAlgorithm . ga ( arg0 ,  arg1 )  ;  }
public RPPA function ( GeneticEventImpl loc0 ,  int loc1 ,  String loc2 )  { RPPA loc3 = loc0 . rppaValue ;  return loc3 ;  }
void function ( QName arg0 )  { path . addLast ( attributes . get ( arg0 )  )  ;  path . getLast (  )  ;  attributes . get ( arg0 )  ;  }
EncryptionProperties function (  )  { EncryptionProperties loc0 = new EncryptionProperties (  )  ;  loc0 . setEncryptionAlgorithm ( encryptionProperties . getEncryptionAlgorithm (  )  )  ;  loc0 . setKeyWrapAlgorithm ( encryptionProperties . getKeyWrapAlgorithm (  )  )  ;  loc0 . setEncryptionName ( encryptionProperties . getEncryptionName (  )  )  ;  return loc0 ;  }
public AccessToken function ( List < String >  arg0 ,  String arg1 ,  String arg2 )  { AccessToken accessToken = null ;  try { accessToken = getAccessTokenForUser ( arg0 ,  Mode . SHARED ,  arg1 )  ;  } catch  ( Exception e )  { System . err . println ( "Error getting access token for shared test user: " + e . getMessage (  )  )  ;  } return accessToken ;  }
public static void function (  @ Nullable Closeable arg0 ,  boolean arg1 )  { if  ( arg0 == null )  { return ;  } boolean loc0 = arg1 ;  try { arg0 . close (  )  ;  loc0 = false ;  } catch  ( IOException e )  { logger . log ( Level . WARNING ,  "IOException thrown while closing Closeable" ,  e )  ;  if  ( loc0 )  { logger . log ( Level . WARNING ,  "IOException swallowed while closing Closeable" ,  e )  ;  } else { throw new RuntimeException ( e )  ;  } } }
void function ( final String arg0 ,  final String arg1 )  { try { properties . setProperty ( arg0 ,  arg1 )  ;  logger . info ( "Setter for a property .  If the property already exists ,  the value will be overridden . " )  ;  } catch  ( Exception loc0 )  { logger . error ( "Error setting property: " + loc0 . getMessage (  )  )  ;  } }
public class RSSFeed { private String _title ;  private String _image ;  private List < RSSItem >  _items ;  private String _description ;  private String _language ;  private String _link ;  private String _rss_link ;  void setItems ( List < RSSItem >  items )  { this . _items = items ;  } String getTitle (  )  { return this . _title ;  } String get_image (  )  { return this . _image ;  } String getDescription (  )  { return this . _description ;  } String getLanguage (  )  { return this . _language ;  } String getLink (  )  { return this . _link ;  } String getRSSLink (  )  { return this . _rss_link ;  } void set_image ( String _image )  { this . _image = _image ;  } void function (  )  { try { String loc0 = getTitle (  )  ;  String loc1 = get_image (  )  ;  String loc2 = getDescription (  )  ;  String loc3 = getLanguage (  )  ;  String loc4 = getLink (  )  ;  String loc5 = getRSSLink (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } } }
void function ( Item arg0 ,  int arg1 )  { int loc0 = Math . min ( arg1 ,  limit - count )  ;  if  ( invMap . containsKey ( arg0 )  )  { loc0 = Math . min ( loc0 ,  limit - count - invMap . get ( arg0 )  )  ;  invMap . put ( arg0 ,  invMap . get ( arg0 )  + loc0 )  ;  } else { invMap . put ( arg0 ,  loc0 )  ;  } count += loc0 ;  }
void function (  )  { Date arg0 = new Date (  )  ;  Date arg1 = new Date (  )  ;  assertEquals ( arg0 ,  arg1 )  ;  }
int function (  )  { int locResult = -1 ;  try { if  ( !vstack . empty (  )  )  { locResult = vstack . peek (  )  . intValue (  )  ;  } else { throw new Exception ( "Stack is empty" )  ;  } } catch  ( Exception e )  { System . out . println ( "Error: " + e . getMessage (  )  )  ;  } return locResult ;  }
public static String function ( String arg0 )  { String loc0 = arg0 ;  try { int loc1 = loc0 . lastIndexOf ( "/" )  ;  if  ( loc1 == -1 )  { return loc0 ;  } return loc0 . substring ( 0 ,  loc1 )  ;  } catch  ( Exception e )  { return null ;  } }
void function (  )  { SetAttributeOptions loc0 = SetAttributeOptions . defaults (  )  ;  Assert . assertNull ( loc0 . getOwner (  )  )  ;  Assert . assertNull ( loc0 . getGroup (  )  )  ;  Assert . assertNull ( loc0 . getPermissions (  )  )  ;  }
int function ( int arg0 ,  int arg1 ,  int arg2 ,  int arg3 )  { int loc0 =  ( arg0 & 0x7FFFFFFF )  | ChildNumber . HARDENED_BIT ;  if  ( arg1  <  0 || arg1  >  0x7FFFFFFF )  { throw new IllegalArgumentException ( "arg1 is out of range" )  ;  } if  ( arg2  <  0 || arg2  >  0x7FFFFFFF )  { throw new IllegalArgumentException ( "arg2 is out of range" )  ;  } if  ( arg3  <  0 || arg3  >  0x7FFFFFFF )  { throw new IllegalArgumentException ( "arg3 is out of range" )  ;  } loc0 |= arg1 ;  loc0  <  < = 31 ;  loc0 |= arg2 ;  loc0  <  < = 32 ;  loc0 |= arg3 ;  return loc0 ;  }
void function ( List < String >  arg0 )  { try { produceMediaTypes = arg0 ;  LOG . info ( "Custom produce media types set: {}" ,  produceMediaTypes )  ;  } catch  ( Exception loc0 )  { LOG . warning ( "Error setting custom produce media types: " + loc0 . getMessage (  )  )  ;  } }
boolean function ( String arg0 )  { boolean loc0 = !arg0 . isEmpty (  )  ;  return loc0 ;  }
void function (  )  { Mockito . when ( mClient . listObjectsV2 ( Matchers . any ( ListObjectsV2Request . class )  )  )   . thenThrow ( AmazonClientException . class )  ;  try { mS3UnderFileSystem . delete ( PATH ,  true )  ;  Assert . assertFalse ( "Expected an exception to be thrown . " ,  true )  ;  } catch  ( AmazonClientException ex )  { Mockito . verify ( mClient )  . listObjectsV2 ( Matchers . any ( ListObjectsV2Request . class )  )  ;  Mockito . verify ( mClient )  . deleteObjects ( Matchers . any ( DeleteObjectsRequest . class )  )  ;  Mockito . verify ( mS3UnderFileSystem )  . delete ( PATH ,  true )  ;  } }
int function ( int arg0 )  { requestedCameraId = arg0 ;  camera = null ;  try { camera = OpenCamera . open ( requestedCameraId )  ;  if  ( camera == null )  { return OpenCameraInterface . NO_CAMERA ;  } configManager . initFromCameraParameters ( camera )  ;  configManager . setDesiredCameraParameters ( camera )  ;  autoFocusManager = new AutoFocusManager ( context ,  camera )  ;  return requestedCameraId ;  } catch  ( Exception e )  { if  ( camera != null )  { camera . release (  )  ;  camera = null ;  } return OpenCameraInterface . NO_CAMERA ;  } }
List < ByteBuffer >  function ( List < ByteBuffer >  arg0 )  { List < ByteBuffer >  loc0 = new ArrayList <  >  ( arg0 . size (  )  )  ;  for  ( int loc1 = 0 ;  loc1  <  arg0 . size (  )  ;  loc1 ++  )  { ByteBuffer loc2 = arg0 . get ( loc1 )  ;  loc0 . add ( cloneByteBuffer ( loc2 )  )  ;  } return loc0 ;  }
String function ( GameRequestContent arg0 )  { String loc0 = null ;  try { loc0 = arg0 . getTitle (  )  ;  } catch  ( NullPointerException e )  { } return loc0 ;  }
void function ( VertexLabelType arg0 ,  VertexLabelType arg1 ,  EdgeLabelType arg2 )  { Hashtable < VertexLabelType ,  EdgeLabelType >  loc0 = checkForNewVertex ( arg0 )  ;  loc0 . put ( arg1 ,  arg2 )  ;  }
import com . facebook . react . bridge . Arguments ;  import com . facebook . react . bridge . WritableMap ;  public class AsyncStorageErrorUtil { public static WritableMap function ( String arg0 ,  String arg1 ,  String arg2 )  { WritableMap loc0 = Arguments . createMap (  )  ;  try { loc0 . putString ( "key" ,  arg0 )  ;  loc0 . putString ( "message" ,  arg1 )  ;  loc0 . putMap ( "userInfo" ,  Arguments . createMap (  )  )  ;  loc0 . getMap ( "userInfo" )  . putString ( "key" ,  arg0 )  ;  loc0 . getMap ( "userInfo" )  . putString ( "problem" ,  arg2 )  ;  } catch  ( Exception e )  { } return loc0 ;  } public static WritableMap getInvalidValueError (  @ Nullable String key )  { } public static WritableMap getDBError (  @ Nullable String key )  { } public static WritableMap getInvalidKeyError (  @ Nullable String key )  { } }
List function (  )  { List loc0 = new ArrayList (  )  ;  try { loc0 . addAll ( LOGGER_NAMES )  ;  } catch  ( Exception loc1 )  { } return loc0 ;  }
public void function ( JobsGroup arg0 ,  String arg1 )  { JobsGroup loc0 = null ;  synchronized  ( jobs )  { if  ( jobs . isEmpty (  )  )  { jobs . put ( arg0 . getId (  )  ,  arg0 )  ;  } else { loc0 = jobs . put ( arg0 . getId (  )  ,  arg0 )  ;  } } if  ( loc0 != null )  { controller . groupFinished ( loc0 ,  arg1 )  ;  controller . finishRunningJobs ( arg1 )  ;  } arg0 . run (  )  ;  }
public int function ( int arg0 ,  int arg1 ,  int arg2 ,  CoordinatorJobInfo arg3 )  { int offset = 0 ;  // initialize offset to 0 try { int len = arg3 . getLen (  )  ;  // get the total number of jobs int start = arg0 ;  // starting index int total = arg1 ;  // total number of jobs to return int end = start + total - 1 ;  // ending index if  ( end  > = len )  { // make sure the ending index is not greater than the total number of jobs end = len - 1 ;  } offset = start ;  // set the offset to the starting index List < CoordinatorJobBean >  jobs = arg3 . getCoordJobs (  )  ;  // get the list of jobs for  ( int i = start ;  i  < = end ;  i ++  )  { CoordinatorJobBean loc0 = jobs . get ( i )  ;  // get the job at the current index } } catch  ( Exception loc1 )  { // catch any exception that occurs loc1 . printStackTrace (  )  ;  // print the stack trace for debugging purposes } return offset ;  // return the offset }
public void function ( UriPrefixPair [  ]  arg0 )  { try { UriPrefixPair [  ]  loc0 = arg0 ;  this . packagePrefixes = loc0 ;  } catch  ( Exception e )  { } }
public void function ( long arg0 )  { try { this . seqId = arg0 ;  System . out . println ( "Seq id has been set to " + arg0 )  ;  } catch  ( Exception e )  { System . out . println ( "An error occurred while setting the seq id: " + e . getMessage (  )  )  ;  } }
ProfileData function ( ArrayList < ProfileData >  arg0 ,  ArrayList < String >  arg1 ,  ArrayList < String >  arg2 )  { HashMap < String ,  String >  loc0 = new HashMap <  >  (  )  ;  ArrayList < String >  loc1 = new ArrayList <  >  (  )  ;  ArrayList < String >  loc2 = new ArrayList <  >  (  )  ;  ProfileMerger loc3 = new ProfileMerger (  )  ;  loc3 . createUnion ( arg0 ,  arg1 ,  arg2 )  ;  loc3 . mergeProfiles ( loc0 ,  arg0 ,  arg1 ,  arg2 )  ;  for  ( String key : loc0 . keySet (  )  )  { loc1 . add ( key )  ;  loc2 . add ( loc0 . get ( key )  )  ;  } String loc4 = String . join ( ProfileMerger . VALUE_SEPARATOR ,  loc2 )  ;  ProfileData loc5 = new ProfileData (  )  ;  loc5 . setGeneSymbols ( String . join ( ProfileMerger . VALUE_SEPARATOR ,  loc1 )  )  ;  loc5 . setProfileData ( loc4 )  ;  return loc5 ;  }
import org . ejml . data . DenseMatrix64F ;  import org . ejml . ops . CommonOps ;  import org . ejml . ops . MatrixFeatures ;  import org . ejml . ops . VectorVectorMult ;  public class SpecializedOps { public static DenseMatrix64F function ( DenseMatrix64F arg0 ,  DenseMatrix64F arg1 ,  double arg2 )  { DenseMatrix64F loc0 ,  loc1 ;  if  ( !MatrixFeatures . isVector ( arg0 )  || !MatrixFeatures . isVector ( arg1 )  )  { throw new IllegalArgumentException ( "Inputs must be vectors" )  ;  } if  ( arg0 . getNumRows (  )  != arg1 . getNumRows (  )  )  { throw new IllegalArgumentException ( "Vectors must have same length" )  ;  } loc0 = new DenseMatrix64F ( arg0 . getNumRows (  )  ,  arg0 . getNumCols (  )  )  ;  CommonOps . identity ( loc0 )  ;  loc1 = new DenseMatrix64F ( arg0 . getNumRows (  )  ,  arg0 . getNumRows (  )  )  ;  VectorVectorMult . householder ( arg2 ,  arg0 ,  arg1 ,  loc1 )  ;  CommonOps . multAddTransB ( -arg2 ,  arg1 ,  arg0 ,  loc1 ,  loc0 )  ;  return loc0 ;  } }
Bits function ( Bits arg0 ,  Bits arg1 ,  Bits arg2 )  { Bits loc0 = this . and ( arg0 . not (  )  )  ;  Bits loc1 = arg1 . or ( loc0 )  ;  Bits loc2 = loc1 . and ( arg2 . not (  )  )  ;  Bits loc3 = this . getOtherBits (  )  . and ( arg2 )  ;  Bits loc4 = loc2 . or ( loc3 )  ;  return new Bits ( loc4 ,  this . getOwnerBits (  )  ,  this . getGroupBits (  )  )  ;  }
public static Waypoint function ( Position pos )  { try { String name = "Waypoint" ;  double lat = pos . getLatitude (  )  ;  double lon = pos . getLongitude (  )  ;  return Waypoint . new ( name ,  lat ,  lon )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
void function ( long arg0 )  { testId = arg0 ;  }
boolean function ( boolean arg0 )  { saveW = arg0 ;  dataW = new BlockMatrix64F ( 1 ,  1 )  ;  dataWTA = new BlockMatrix64F ( 1 ,  1 )  ;  return saveW ;  }
void function ( final ProtocolHandler arg0 )  { try { m_readHandler . setProtocolHandler ( arg0 )  ;  } catch  ( Exception loc0 )  { LOG . error ( "Failed to set protocol handler: {}" ,  loc0 . getMessage (  )  )  ;  } }
void function (  )  { boolean loc0 = isRaw (  )  ;  format . checkType ( 'B' ,  loc0 )  ;  int loc1 = getByteArrayLength (  )  ;  byte [  ]  loc2 = new byte [ loc1 ]  ;  getByteArrayInternal ( loc1 ,  loc2 ,  0 ,  loc1 )  ;  }
public void function (  )  { LogoutRequestSender instance = LogoutRequestSender . getInstance (  )  ;  SingleLogoutRequestDTO loc0 = new SingleLogoutRequestDTO (  )  ;  SingleLogoutRequestDTO [  ]  loc1 = new SingleLogoutRequestDTO [  ] {loc0} ;  instance . logoutReqDTO = loc0 ;  instance . sendLogoutRequests ( loc1 )  ;  instance . threadPool . execute ( instance )  ;  }
int function (  )  { int locResult = 0 ;  try { locResult = this . num ;  } catch  ( Exception e )  { System . out . println ( "An error occurred while retrieving the numerator: " + e . getMessage (  )  )  ;  } return locResult ;  }
String function ( String arg0 )  { String loc0 = "" ;  try { loc0 = new AlluxioURI ( arg0 )  . getPath (  )  ;  loc0 = loc0 . endsWith ( SEPARATOR )  ? loc0 . substring ( 0 ,  loc0 . length (  )  - 1 )  : loc0 ;  int loc1 = loc0 . lastIndexOf ( SEPARATOR )  ;  return loc0 . substring ( loc1 + 1 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return "" ;  } }
public void function ( XKMSRequestType arg0 ,  XKMSResponseFactory arg1 )  { try { String loc0 = arg0 . getRequestId (  )  ;  ResultType loc1 = arg1 . createResponse ( arg0 )  ;  arg1 . copyOpaqueClientData ( arg0 ,  loc1 )  ;  arg1 . copyServiceName ( arg0 ,  loc1 )  ;  arg1 . setRequestId ( loc1 ,  loc0 )  ;  arg1 . getId ( loc1 )  ;  } catch  ( Exception e )  { } }
public boolean function ( Object arg0 ,  Object arg1 )  { try { JSObject loc0 =  ( JSObject )  arg0 ;  JavascriptObject loc1 =  ( JavascriptObject )  arg1 ;  if  ( loc0 instanceof JSObject && loc1 instanceof JavascriptObject )  { if  ( loc0 . equals ( loc1 . getJSObject (  )  )  )  { Object propertyValue = loc1 . getProperty ( "propertyName" )  ;  if  ( propertyValue instanceof String )  { String strValue =  ( String )  propertyValue ;  if  ( !strValue . equals ( "undefined" )  )  { return true ;  } } } } return false ;  } catch  ( Exception e )  { return false ;  } }
void function (  )  { Page loc0 = getPage (  )  ;  draw ( canvas ,  bitmap )  ;  view . invalidate (  )  ;  }
public void function (  )  { final int arg0 = 40 ;  final double arg1 = 32 . 1234 ;  instance . setLatitude ( arg0 ,  arg1 )  ;  assertTrue ( instance . toString (  )  . contains ( "4000 . 1234 , N" )  )  ;  final double loc0 = instance . parseLatitude (  )  ;  assertEquals ( arg1 ,  loc0 / 60 ,  0 . 00001 )  ;  }
void function ( CharSequence arg0 ,  int arg1 ,  int arg2 ,  int arg3 )  { try { mTextView . removeTextChangedListener ( mChangeListener )  ;  } catch ( Exception loc0 )  { } }
public void function ( String arg0 ,  HighLevelChangeRenaming arg1 )  { try { if ( highLevelChangesRenaming . containsKey ( arg0 )  ) { System . out . println ( "Add a high level change  ( renaming )  .  If the difference group identifier already exists the old high level change  ( renaming )  will be overwritten . " )  ;  } highLevelChangesRenaming . put ( arg0 ,  arg1 )  ;  } catch ( Exception e )  { System . out . println ( "An error occurred while adding a high level change  ( renaming ) : " + e . getMessage (  )  )  ;  } }
void function ( String arg0 ,  Bundle arg1 ,  RequestListener arg2 ,  Object arg3 )  { fb . request ( arg0 ,  arg1 ,  null ,  arg2 ,  arg3 )  ;  }
void function ( Rotation arg0 )  { this . rotation = arg0 ;  for  ( StateListener loc0 : this . listeners )  { loc0 . onRotationChanged ( this . rotation )  ;  } }
int function ( char [  ]  arg0 ,  char [  ]  arg1 )  { try { int loc0 = 0 ;  int loc1 = 0 ;  int len = 0 ;  boolean matched = true ;  while  ( matched && loc1  <  arg1 . length )  { if  ( arg0 [ loc0 ]  == arg1 [ loc1 ]  )  { loc0 ++  ;  loc1 ++  ;  len ++  ;  } else { loc0 = 0 ;  len = 0 ;  matched = false ;  } } if  ( !matched )  { return 0 ;  } else { return len ;  } } catch  ( Exception e )  { e . printStackTrace (  )  ;  return 0 ;  } }
import io . netty . buffer . ByteBuf ;  import io . netty . buffer . ByteBufAllocator ;  import io . netty . util . internal . BufferUtils ;  import java . nio . ByteBuffer ;  public class DataByteBufferTest { private ByteBuffer mBuffer = null ;  private final int LENGTH = 5 ;  public void function (  )  { try { int arg0 = 0 ;  int arg1 = 10 ;  ByteBuffer loc0 = BufferUtils . getIncreasingByteBuffer ( LENGTH )  ;  ByteBuf loc1 = ByteBufAllocator . DEFAULT . directBuffer ( LENGTH )  ;  mBuffer = loc0 . asReadOnlyBuffer (  )  ;  loc1 . writeBytes ( mBuffer )  ;  } catch  ( Exception e )  { } } public void length (  )  { } public void readOnlyByteBuffer (  )  { } public void nettyOutput (  )  { } }
void function (  )  { setUp (  )  ;  testConstructor (  )  ;  testSetWaypointIds (  )  ;  testSetRouteId (  )  ;  testSetSentenceCount (  )  ;  testSetSentenceIndex (  )  ;  testGetWaypointIds (  )  ;  testGetRouteId (  )  ;  testGetSentenceCount (  )  ;  testGetSentenceIndex (  )  ;  testIsActiveRoute (  )  ;  testIsWorkingRoute (  )  ;  testSetRouteTypeActive (  )  ;  testSetRouteTypeWorking (  )  ;  testAddWaypointId (  )  ;  testSetSentenceIndexWithNegativeValue (  )  ;  testSetSentenceCountWithNegativeValue (  )  ;  testIsLast (  )  ;  rte . isFirst (  )  ;  assertTrue ( rte . isEmpty (  )  )  ;  testGetWaypointCount (  )  ;  }
public void function ( List < RSSItem >  arg0 )  { try { _items = arg0 ;  } catch  ( Exception e )  { System . out . println ( "Error setting RSS items: " + e . getMessage (  )  )  ;  } }
void function ( long arg0 )  { try { setGeneB ( arg0 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
void function (  )  { mThrown . expect ( ClosedChannelException . class )  ;  byte [  ]  loc0 = getIncreasingByteBuffer (  ( int )  TEST_BLOCK_SIZE )  ;  before (  )  ;  mWriter . append ( loc0 )  ;  mWriter . getChannel (  )  . close (  )  ;  mWriter . append ( loc0 )  ;  mWriter . close (  )  ;  assertEquals (  ( int )  TEST_BLOCK_SIZE ,  mFolder . getRoot (  )  . length (  )  )  ;  }
void function (  )  { long arg0 = MAX_SEQUENCE_NUMBER ;  long arg1 = 12345678L ;  BlockId blockId = new BlockId (  )  ;  blockId . createBlockId ( arg0 ,  arg1 )  ;  long loc0 = arg0  <  <  32L ;  long loc1 = arg1 & 0xFFFFFFFFL ;  long actual = blockId . getBlockId (  )  ;  long expected = loc0 | loc1 ;  assertEquals ( expected ,  actual )  ;  }
void function ( RestSearcher arg0 )  { try { YahooSearchTest . LOG . debug ( "Starting full test . " )  ;  YahooSearchTest yahooSearchTest = new YahooSearchTest (  )  ;  yahooSearchTest . runFullTest ( new YahooImageSearcher (  )  )  ;  YahooSearchTest . LOG . debug ( "Finished full test . " )  ;  } catch  ( Exception loc0 )  { YahooSearchTest . LOG . error ( "Error occurred while running full test . " ,  loc0 )  ;  } }
public Node function ( String fmt ,  Object .  .  .  subst )  { QQParser parser = parser ( lexer ( fmt ,  pos ,  subst )  ,  null ,  null ,  null )  ;  Node result = parse ( STMT ,  fmt ,  subst )  . toStmt (  )  ;  NodeVisitor < Void >  commentRemover = new NodeVisitor < Void >  (  )  {  @ Override public Node leave ( Node old ,  Node n ,  NodeVisitor < ? >  v )  { if  ( n instanceof SourceFile )  { return  (  ( SourceFile )  n )  . source ( old . position (  )  )  ;  } else { return n . position ( old . position (  )  )  ;  } } } ;  result = result . visit ( commentRemover )  ;  NodeVisitor < String >  localVarRenamer = new NodeVisitor < String >  (  )  { int count = 0 ;   @ Override public Node leave ( Node old ,  Node n ,  NodeVisitor < ? >  v )  { if  ( n instanceof Local )  { Local loc =  ( Local )  n ;  return loc . localInstance ( loc . localInstance (  )  . name (  )  + count ++  )  ;  } else { return n ;  } } } ;  result = result . visit ( localVarRenamer )  ;  List < Node >  nodeList = new ArrayList <  >  (  )  ;  NodeVisitor < Void >  arrayConverter = new NodeVisitor < Void >  (  )  {  @ Override public Node leave ( Node old ,  Node n ,  NodeVisitor < ? >  v )  { nodeList . add ( n )  ;  return n ;  } } ;  result . visit ( arrayConverter )  ;  return nodeList . toArray ( new Node [ nodeList . size (  )  ]  )  ;  }
public List < String >  function (  )  { List < String >  loc0 = new LinkedList < String >  (  )  ;  loc0 . addAll ( redirectUris )  ;  loc0 . add ( applicationWebUri )  ;  return loc0 ;  }
byte [  ]  function (  )  { byte [  ]  loc0 = null ;  try { loc0 = this . errors ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
public int function ( CancerStudy arg0 ,  CancerStudy arg1 )  { String loc0 = arg0 . getName (  )  ;  String loc1 = arg1 . getName (  )  ;  return loc0 . compareTo ( loc1 )  ;  }
public static boolean function ( final String arg0 ,  final String arg1 )  { try { String loc0 = arg0 . toLowerCase (  )  ;  String loc1 = arg1 . toLowerCase (  )  ;  if  ( loc0 . equals ( loc1 )  )  { return true ;  } if  ( !loc0 . startsWith ( " . " )  )  { loc0 = " . " + loc0 ;  } if  ( !loc1 . startsWith ( " . " )  )  { loc1 = " . " + loc1 ;  } if  ( loc0 . endsWith ( loc1 )  )  { return true ;  } int dotIndex = loc0 . indexOf ( " . " )  ;  if  ( dotIndex  >  0 )  { String substring = loc0 . substring ( dotIndex )  ;  if  ( substring . equals ( loc1 )  )  { return true ;  } } } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return false ;  }
ListIterator < BasicLogRecord >  function (  )  { flush (  )  ;  LogIterator loc0 = new LogIterator (  )  ;  List < BasicLogRecord >  loc1 = new ArrayList <  >  (  )  ;  while  ( loc0 . hasNext (  )  )  { BasicLogRecord loc2 = loc0 . next (  )  ;  loc1 . add ( loc2 )  ;  } Collections . reverse ( loc1 )  ;  return loc1 . listIterator (  )  ;  }
GetOfferDetailsResponse . Return . DetailOfferData . Merchant . Addresses function (  )  { GetOfferDetailsResponse . Return . DetailOfferData detailOfferData = createGetOfferDetailsResponseReturnDetailOfferData (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . Merchant merchant = detailOfferData . createMerchant (  )  ;  return merchant . createAddresses (  )  ;  }
void function ( String arg0 )  { FileChannel fileChannel = null ;  try { fileChannel = new FileOutputStream ( arg0 ,  true )  . getChannel (  )  ;  fileChannel . write ( contents )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } finally { try { if  ( fileChannel != null )  { fileChannel . close (  )  ;  } } catch  ( IOException e )  { e . printStackTrace (  )  ;  } } }
void function ( Node arg0 ,  NodeTest arg1 )  { CountingNodeTester tester = new CountingNodeTester (  )  ;  arg0 . test ( tester )  ;  tester . noMoreNodes ( arg1 )  ;  int loc0 = tester . actualNumNodes ;  int loc1 = tester . expectedNumNodes ;  if  ( loc0 != loc1 )  { System . out . println ( "Failed: expected " + loc1 + " nodes ,  but found " + loc0 + " nodes" )  ;  } else { System . out . println ( "Passed: found " + loc0 + " nodes as expected" )  ;  } tester . resetCounter (  )  ;  }
class ReportResult { int differencesResolutionChanged = 0 ;  int conflictsNotApproved = 0 ;  void function ( int arg0 )  { conflictsNotApproved = arg0 ;  } void incrementCounterDifferencesResolutionChanged (  )  { differencesResolutionChanged ++  ;  } void incrementCounterConflictsNotApproved (  )  { conflictsNotApproved ++  ;  } void setDifferencesResolutionChanged ( int loc0 )  { differencesResolutionChanged = loc0 ;  } void decrementCounterDifferencesResolutionChanged (  )  { differencesResolutionChanged --  ;  } int getConflictsNotApproved (  )  { return conflictsNotApproved ;  } int getDifferencesResolutionChanged (  )  { return differencesResolutionChanged ;  } }
EdgeLabelType function ( VertexLabelType arg0 ,  VertexLabelType arg1 )  { EdgeLabelType loc0 = globalEdgeLookup . get ( arg0 )  . remove ( arg1 )  ;  return loc0 ;  }
void function ( EntityLivingBase arg0 ,  World arg1 ,  int arg2 ,  int arg3 ,  EntityMobWithInventory arg4 )  { attackTarget = arg0 ;  world = arg1 ;  cooldown = arg2 ;  currCooldown = arg3 ;  mob = arg4 ;  if ( hasAttackTarget (  )  )  { double loc0 = getDistanceSqFromTarget (  )  ;  if  ( loc0  < = 256 . 0D )  { nextStep (  )  ;  } else { mob . getNavigator (  )  . tryMoveToEntityLiving ( attackTarget )  ;  } } }
private void function ( String arg0 ,  String arg1 )  { String loc0 = FederationUtils . asLink ( arg0 ,  arg1 ,  null )  ;  String loc1 = FederationUtils . asLink ( loc0 + "/rpc?req=LIST_SETTINGS" ,  arg1 ,  null )  ;  Map < String ,  String >  loc2 = FederationUtils . retrieveJson ( loc1 ,  FederationUtils . SETTINGS_TYPE )  ;  }
boolean function ( CharSequence arg0 ,  int arg1 )  { char loc0 = arg0 . charAt ( arg1 )  ;  if  ( Character . isHighSurrogate ( loc0 )  )  { if  ( arg1 + 1  <  arg0 . length (  )  )  { char loc1 = arg0 . charAt ( arg1 + 1 )  ;  if  ( Character . isLowSurrogate ( loc1 )  )  { return true ;  } } } return false ;  }
String function (  )  { String loc0 = "" ;  try { loc0 = mAlluxioMaster . getRPCBindHost (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
String function ( Escaper escaper ,  char c )  { String replacement = escaper . escape ( String . valueOf ( c )  )  ;  if  ( replacement == null )  { return null ;  } char [  ]  escaped = escaper . escape ( c )  ;  if  ( escaped == null )  { return replacement ;  } String result = escaper . stringOrNull ( escaped )  ;  return  ( result == null )  ? replacement : result ;  }
void function (  )  { try { Mockito . when ( mClient . listObjects ( any ( ListObjectsRequest . class )  )  )   . thenThrow ( new ServiceException ( "Exception during listing objects" )  )  ;  Mockito . when ( mOSSUnderFileSystem . rename ( anyString (  )  ,  anyString (  )  )  )   . thenReturn ( true )  ;  boolean loc0 = mOSSUnderFileSystem . rename ( PATH + SRC ,  PATH + DST )  ;  assertFalse ( "Rename returned false" ,  !loc0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  fail ( "Exception was thrown" )  ;  } }
void function ( int opcode )  { chunks . add ( new ScriptChunk ( opcode ,  null )  )  ;  int size = chunks . size (  )  ;  }
public class AllocatorFactoryTest { BlockMetadataManagerView mManagerView ;  TemporaryFolder mTestFolder = new TemporaryFolder (  )  ;  void createRoundRobinAllocator (  )  { /* implementation */ } void createMaxFreeAllocator (  )  { /* implementation */ } void before (  )  { /* implementation */ } void createDefaultAllocator (  )  { /* implementation */ } void after (  )  { /* implementation */ } void function (  )  { Configuration . set ( "fs . volume . block . allocator . class" ,  GreedyAllocator . class . getName (  )  )  ;  BlockMetadataManagerView loc0 = null ;  try { loc0 = mManagerView . getSubManager ( "TestVolume" )  ;  } catch  ( IOException e )  { } Allocator loc1 = Allocator . Factory . create ( loc0 )  ;  Assert . assertTrue ( loc1 instanceof GreedyAllocator )  ;  } }
void function ( String arg0 ,  RabbitMQMessage arg1 )  { arg1 . setContentEncoding ( arg0 )  ;  }
void function ( boolean arg0 )  { if  ( sawReturn || arg0 || line . length (  )   >  0 )  { sawReturn = false ;  boolean loc0 = finishLine ( sawReturn || arg0 )  ;  if  ( line . length (  )   >  0 )  { handleLine ( line . toString (  )  ,  "" )  ;  line = new StringBuilder (  )  ;  } sawReturn = loc0 ;  } }
class Symbol { String _stack_type ,  _name ;  int _index ,  _use_count = 0 ;  boolean is_non_term (  )  { } int index (  )  { } String toString (  )  { } int use_count (  )  { return _use_count ;  } String stack_type (  )  { } String name (  )  { } void function (  )  { _use_count ++  ;  } }
void function ( File arg0 )  { File loc0 = arg0 ;  while  ( true )  { if  ( loc0 . isDirectory (  )  )  { File [  ]  loc1 = loc0 . listFiles ( fileFilter )  ;  i = 0 ;  if  ( loc1 != null && loc1 . length  >  0 )  { loc0 = loc1 [ 0 ]  ;  } else { break ;  } } else { if  ( fileFilter . accept ( loc0 . getParentFile (  )  ,  loc0 . getName (  )  )  )  { String loc2 = loc0 . getName (  )  . replace ( fragmentFileName ,  "" )  ;  Document < O >  loc3 = getDocument ( loc2 ,  loc0 )  ;  if  ( loc3 != null )  { documents [ i ++  ]  = loc0 ;  } } if  ( hasNext (  )  )  { loc0 = getNextFile ( loc0 )  ;  } else { break ;  } } } }
String function ( Intent arg0 ,  String arg1 )  { try { String loc0 = arg1 . trim (  )  ;  arg0 . putExtra ( INTENT_EXTRA_TRANSACTION_HASH_OLD ,  loc0 )  ;  String loc1 = arg0 . getStringExtra ( INTENT_EXTRA_TRANSACTION_HASH )  ;  if  ( loc1 == null )  { loc1 = "" ;  } return loc1 ;  } catch  ( Exception e )  { return "" ;  } }
Iterator < OrderLineTypeFacade >  function ( OrderType arg0 )  { try { Iterator < OrderLineType >  loc0 = arg0 . getOrderLine (  )  . iterator (  )  ;  List < OrderLineTypeFacade >  loc1 = new ArrayList <  >  (  )  ;  while  ( loc0 . hasNext (  )  )  { OrderLineType loc2 = loc0 . next (  )  ;  OrderLineTypeFacade loc3 = new OrderLineTypeFacade (  )  ;  loc3 . setOrderLineType ( loc2 )  ;  loc1 . add ( loc3 )  ;  } return loc1 . iterator (  )  ;  } catch  ( Exception e )  { return null ;  } }
void function ( FolderInfo . CheckedFlag arg0 )  { checkedFlag = arg0 ;  }
Bundle function ( Bundle arg0 )  { Bundle loc0 = new Bundle (  )  ;  if  ( arg0 != null )  { loc0 . putAll ( arg0 )  ;  } if  ( this . mVista != null )  { loc0 . putParcelable ( "mVista" ,  new PresenterParcelable < T >  ( this . mVista )  )  ;  } return loc0 ;  }
String function ( Block arg0 ,  int arg1 )  { SLock sLock = concurMgr . sLock ( arg0 )  ;  Buffer buffer = myBuffers . getBuffer ( arg0 )  ;  String loc0 = buffer . getString ( arg1 )  ;  sLock . release (  )  ;  return loc0 ;  }
public BitcoinPacketHeader function ( ByteBuffer arg0 )  { try { byte [  ]  loc0 = new byte [ BitcoinPacketHeader . MAGIC . length ]  ;  arg0 . get ( loc0 )  ;  byte [  ]  loc1 = new byte [ BitcoinPacketHeader . COMMAND_LENGTH ]  ;  arg0 . get ( loc1 )  ;  int loc2 =  ( int )  BitcoinPacketHeader . readUint32 ( arg0 )  ;  byte [  ]  loc3 = new byte [ BitcoinPacketHeader . CHECKSUM_LENGTH ]  ;  arg0 . get ( loc3 )  ;  return new BitcoinPacketHeader ( loc0 ,  loc1 ,  loc2 ,  loc3 )  ;  } catch  ( BufferUnderflowException e )  { log . error ( "BitcoinSerializer: Error deserializing header" ,  e )  ;  return null ;  } }
void function ( Language arg0 ,  Rule arg1 )  { RuleChainVisitor loc0 = languageToRuleChainVisitor . get ( arg0 )  ;  loc0 . add ( arg1 )  ;  }
class EventInGame { TriggerType triggerType ;  String map ;  Array < EventAction >  actions ;  String layer ;  boolean collidable ;  Character character ;  String sprite ;  int id ;  boolean equals ( Object obj )  ;  void setId ( int id )  ;  Character getCharacter (  )  ;  void setLayer ( String layer )  ;  int getId (  )  ;  void setSprite ( String sprite )  ;  String getMap (  )  ;  String getSprite (  )  ;  void setCollidable ( boolean collidable )  ;  void setTriggerType ( TriggerType triggerType )  ;  void setCharacter ( Character character )  ;  boolean isCollidable (  )  ;  void setMap ( String map )  ;  TriggerType getTriggerType (  )  ;  void write ( Json json )  ;  void read ( Json json ,  JsonValue jsonData )  ;  void setActions ( Array < EventAction >  actions )  ;  String getLayer (  )  ;  Array < EventAction >  getActions (  )  ;  void function (  )  { void function (  )  ;  trigger ( null )  ;  } }
void function ( String arg0 ,  String arg1 )  { ASTElement loc0 = element ( arg0 )  ;  tagList . openTag ( loc0 )  ;  ASTElement loc1 = element ( arg1 )  ;  tagList . openTag ( loc1 )  ;  tagList . closeTag ( loc1 )  ;  assertFalse ( tagList . isOpened ( loc1 )  )  ;  tagList . closeTag ( loc0 )  ;  assertFalse ( tagList . isOpened ( loc0 )  )  ;  assertTrue ( tagList . isEmpty (  )  )  ;  }
