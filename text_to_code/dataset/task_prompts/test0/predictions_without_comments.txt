import java.util.*; public class FunctionMappingGenerator { private static class FunctionMapping { String functionName; List<String> parameterNames; Set<String> variableNames; } public static Map<String, FunctionMapping> generateFunctionMappings(ASTNode root) { Map<String, FunctionMapping> functionMappings = new HashMap<>(); traverseAST(root, functionMappings); return functionMappings; } private static void traverseAST(ASTNode node, Map<String, FunctionMapping> functionMappings) { if (node.getType() == ASTNodeType.FUNCTION) { String functionName = node.getName(); List<String> parameterNames = new ArrayList<>(); for (ASTNode paramNode : node.getParameters()) { parameterNames.add(paramNode.getName()); } Set<String> variableNames = extractVariableNames(node); FunctionMapping functionMapping = new FunctionMapping(); functionMapping.functionName = functionName; functionMapping.parameterNames = parameterNames; functionMapping.variableNames = variableNames; functionMappings.put(functionName, functionMapping); } for (ASTNode childNode : node.getChildren()) { traverseAST(childNode, functionMappings); } } private static Set<String> extractVariableNames(ASTNode node) { Set<String> variableNames = new HashSet<>(); traverseVariables(node, variableNames); return variableNames; } private static void traverseVariables(ASTNode node, Set<String> variableNames) { if (node.getType() == ASTNodeType.VARIABLE) { variableNames.add(node.getName()); } for (ASTNode childNode : node.getChildren()) { traverseVariables(childNode, variableNames); } } }
import java.io.FileInputStream; import java.io.IOException; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; public static byte[] hashFileContents(String filePath) throws NoSuchAlgorithmException, IOException { MessageDigest digest = MessageDigest.getInstance("SHA-256"); FileInputStream inputStream = new FileInputStream(filePath); byte[] buffer = new byte[8192]; int readBytes; while ((readBytes = inputStream.read(buffer)) != -1) { digest.update(buffer, 0, readBytes); } byte[] hash = digest.digest(); inputStream.close(); return hash; }
public String getID(Object object, boolean canCreate) { String id = null; if (object != null) { try { id = object.getID(); } catch (NoSuchMethodError e) { id = null; } if (id == null && canCreate) { id = UUID.randomUUID().toString(); } } return id; }
import org.hamcrest.Description; import org.hamcrest.TypeSafeMatcher; public class GreaterThanMatcher<T extends Comparable<T>> extends TypeSafeMatcher<T> { private final T expected; public GreaterThanMatcher(T expected) { this.expected = expected; } @Override protected boolean matchesSafely(T actual) { return actual.compareTo(expected) > 0; } @Override public void describeTo(Description description) { description.appendText("a value greater than ").appendValue(expected); } public static <T extends Comparable<T>> GreaterThanMatcher<T> greaterThan(T expected) { return new GreaterThanMatcher<>(expected); } }
public int getDenominator(int numerator, int denominator) { return denominator; }
public int addNumbers(int num1, int num2) { int result = num1 + num2; return result; }
import org.osgi.framework.BundleActivator; import org.osgi.framework.BundleContext; public class MyBundleActivator implements BundleActivator { @Override public void start(BundleContext context) throws Exception { } @Override public void stop(BundleContext context) throws Exception { } }
public boolean testSeek(BufferedBlockInStream stream, long position) { try { stream.seek(position); long currentPosition = stream.getPos(); return currentPosition == position; } catch (IOException e) { e.printStackTrace(); return false; } }
public static void fullGcAndWait() { Object obj = new Object(); WeakReference<Object> weakRef = new WeakReference<>(obj); System.gc(); while (weakRef.get() != null) { try { Thread.sleep(10); } catch (InterruptedException e) { } } try { Thread.sleep(100); } catch (InterruptedException e) { } }
import org.junit.Before; import org.junit.Test; public class MyTest { private String propertyOne; private int propertyTwo; @Before public void setUp() { propertyOne = "Hello"; propertyTwo = 123; } @Test public void myTest() { System.out.println(propertyOne + " " + propertyTwo); } }
public static String toCStyleComment(String documentation) { StringBuilder sb = new StringBuilder(); sb.append("/*\n"); sb.append(documentation.trim().replaceAll("(?m)^", " * ")); sb.append("\n */"); return sb.toString(); }
import java.util.logging.Level; public Level getLogLevel(String logLevel) { Level level; switch (logLevel.toUpperCase()) { case "SEVERE": level = Level.SEVERE; break; case "WARNING": level = Level.WARNING; break; case "INFO": level = Level.INFO; break; case "CONFIG": level = Level.CONFIG; break; case "FINE": level = Level.FINE; break; case "FINER": level = Level.FINER; break; case "FINEST": level = Level.FINEST; break; default: level = Level.OFF; break; } return level; }
public static boolean searchWord(String[] words, String search) { for (String word : words) { if (word.equals(search)) { return true; } } return false; }
I'm sorry, but I'm not sure what you mean by "current scans". Can you please provide more context or information about what you are trying to accomplish?
import java.util.HashMap; import java.util.Map; public class StringToMapConverter { public static Map<String, String> convertToMap(String[] arr) { Map<String, String> map = new HashMap<>(); for (String str : arr) { String[] splitStr = str.split("#"); if (splitStr.length == 2) { map.put(splitStr[0], splitStr[1]); } } return map; } }
import org.w3c.dom.*; public static void findAttributesAndTextNodes(Element element) { NamedNodeMap attributes = element.getAttributes(); for (int i = 0; i < attributes.getLength(); i++) { Node attribute = attributes.item(i); if (attribute.getNodeType() == Node.ATTRIBUTE_NODE) { System.out.println("Attribute: " + attribute.getNodeName() + " = " + attribute.getNodeValue()); } } NodeList childNodes = element.getChildNodes(); for (int i = 0; i < childNodes.getLength(); i++) { Node node = childNodes.item(i); if (node.getNodeType() == Node.TEXT_NODE) { System.out.println("Text Node: " + node.getNodeValue()); } } }
public boolean validateFiles(Set<String> source, ValidationGoal validationGoal) { boolean success = true; switch (validationGoal) { case SYNTAX_CHECK: for (String file : source) { if (!performSyntaxCheck(file)) { success = false; } } break; case TYPE_CHECK: for (String file : source) { if (!performTypeCheck(file)) { success = false; } } break; case SECURITY_CHECK: for (String file : source) { if (!performSecurityCheck(file)) { success = false; } } break; default: throw new IllegalArgumentException("Invalid validation goal."); } return success; } private boolean performSyntaxCheck(String file) { } private boolean performTypeCheck(String file) { } private boolean performSecurityCheck(String file) { } public enum ValidationGoal { SYNTAX_CHECK, TYPE_CHECK, SECURITY_CHECK }
import android.content.Context; import android.location.LocationManager; public class GPSUtils { /** * Method to enable or disable GPS on an Android device. * * @param context the context of the application or activity * @param enabled true to enable GPS, false to disable GPS */ public static void setGPS(Context context, boolean enabled) { LocationManager locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE); if (locationManager != null) { if (enabled) { locationManager.setProviderEnabled(LocationManager.GPS_PROVIDER, true); } else { locationManager.setProviderEnabled(LocationManager.GPS_PROVIDER, false); } } } }
public static boolean isRightToLeft(View view) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) { int layoutDirection = view.getLayoutDirection(); return layoutDirection == View.LAYOUT_DIRECTION_RTL; } else { return false; } }
public List<String> getChecklistForElement(String elementName) { List<String> checklist = new ArrayList<String>(); String query = "SELECT checklist_items FROM checklists WHERE element_name = ?"; try (Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydatabase", "username", "password"); PreparedStatement ps = conn.prepareStatement(query)) { ps.setString(1, elementName); ResultSet rs = ps.executeQuery(); while (rs.next()) { String checklistItem = rs.getString("checklist_items"); checklist.add(checklistItem); } rs.close(); } catch (SQLException ex) { ex.printStackTrace(); } return checklist; }
public void setDay(int day);
public int getNextAvailableTile(int lane) { int[] cardsInLane = getCardsInLane(lane); // get an array of cards in the lane int numTiles = cardsInLane.length; int closestTileToBase = numTiles - 1; // the last tile is the closest to the base for (int i = numTiles - 1; i >= 0; i--) { if (cardsInLane[i] == 0) { // an empty tile is found return i; } } return closestTileToBase; } private int[] getCardsInLane(int lane) { }
public static double[][] matrixInverse(double[][] matrix) throws IllegalArgumentException { int numRows = matrix.length; int numCols = matrix[0].length; if (numRows != numCols) { throw new IllegalArgumentException("Matrix is not square."); } double[][] identity = new double[numRows][numCols]; for (int i = 0; i < numRows; i++) { identity[i][i] = 1; } double[][] matrixCopy = new double[numRows][numCols]; for (int i = 0; i < numRows; i++) { for (int j = 0; j < numCols; j++) { matrixCopy[i][j] = matrix[i][j]; } } for (int i = 0; i < numRows; i++) { int pivotRow = i; double maxElement = Math.abs(matrixCopy[i][i]); for (int j = i + 1; j < numRows; j++) { double absElement = Math.abs(matrixCopy[j][i]); if (absElement > maxElement) { pivotRow = j; maxElement = absElement; } } if (pivotRow != i) { double[] temp = matrixCopy[i]; matrixCopy[i] = matrixCopy[pivotRow]; matrixCopy[pivotRow] = temp; temp = identity[i]; identity[i] = identity[pivotRow]; identity[pivotRow] = temp; } double pivotElement = matrixCopy[i][i]; if (pivotElement == 0) { throw new IllegalArgumentException("Matrix is singular."); } for (int j = i; j < numCols; j++) { matrixCopy[i][j] /= pivotElement; } for (int j = 0; j < numCols; j++) { identity[i][j] /= pivotElement; } for (int j = i + 1; j < numRows; j++) { double factor = matrixCopy[j][i]; for (int k = i; k < numCols; k++) { matrixCopy[j][k] -= factor * matrixCopy[i][k]; } for (int k = 0; k < numCols; k++) { identity[j][k] -= factor * identity[i][k]; } } } for (int i = numRows - 1; i > 0; i--) { for (int j = i - 1; j >= 0; j--) { double factor = matrixCopy[j][i]; for (int k = 0; k < numCols; k++) { identity[j][k] -= factor * identity[i][k]; } } } return identity; }
public class ExitCodeGetter { private int exitCode; public ExitCodeGetter() { this.exitCode = 0; // default exit code is 0 } public int getExitCode() { return this.exitCode; } public void setExitCode(int exitCode) { this.exitCode = exitCode; } }
public String getHoverAttribute(StandardAttributeResolver resolver) { return resolver.getHoverAttribute(); }
public List<AttributeStatementProvider> getAttributeStatementProviders() { List<AttributeStatementProvider> providers = new ArrayList<>(); providers.add(new ExampleAttributeStatementProvider1()); providers.add(new ExampleAttributeStatementProvider2()); providers.add(new ExampleAttributeStatementProvider3()); return providers; }
public void unloadSound(Clip clip) { clip.stop(); // Stop the clip before unloading it clip.flush(); // Flush any queued audio data clip.close(); // Release any system resources held by the clip }
public ProjectModel getProjectModelForUser(String userId) { ProjectModel projectModel = new ProjectModel(); projectModel.setUserId(userId); projectModel.setProjects(getProjectsForUser(userId)); return projectModel; } private List<Project> getProjectsForUser(String userId) { List<Project> projects = new ArrayList<>(); if (userId.equals("123")) { projects.add(new Project("Project 1", "A description of project 1")); projects.add(new Project("Project 2", "A description of project 2")); } return projects; }
import java.awt.Color; public class ColorNameFinder { public static String getClosestColorName(String hexColor) { Color inputColor = Color.decode("#" + hexColor); Color[] colorTable = {Color.BLACK, Color.BLUE, Color.CYAN, Color.DARK_GRAY, Color.GRAY, Color.GREEN, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE, Color.PINK, Color.RED, Color.WHITE, Color.YELLOW}; String[] colorNames = {"Black", "Blue", "Cyan", "Dark Gray", "Gray", "Green", "Light Gray", "Magenta", "Orange", "Pink", "Red", "White", "Yellow"}; int minDistance = Integer.MAX_VALUE; int closestColorIndex = -1; for (int i = 0; i < colorTable.length; i++) { int redDiff = inputColor.getRed() - colorTable[i].getRed(); int greenDiff = inputColor.getGreen() - colorTable[i].getGreen(); int blueDiff = inputColor.getBlue() - colorTable[i].getBlue(); int distance = redDiff * redDiff + greenDiff * greenDiff + blueDiff * blueDiff; if (distance < minDistance) { minDistance = distance; closestColorIndex = i; } } return colorNames[closestColorIndex]; } }
public String getDataSourceFileName(String dataSource, String objectType) { String suffix = ""; switch (objectType) { case "csv": suffix = ".csv"; break; case "json": suffix = ".json"; break; case "xml": suffix = ".xml"; break; default: break; } return dataSource + suffix; }
public static int getDefaultPort() { return 8080; // Change this to the desired default port number }
import java.util.HashMap; import java.util.Set; public class TestClass { private HashMap<String, Set<String>> urlSet; public Set<String> getIndexedTerms() { return urlSet.keySet(); } }
public void clearBlockMarks(boolean[][] blockGrid) { for (int i = 0; i < blockGrid.length; i++) { for (int j = 0; j < blockGrid[i].length; j++) { blockGrid[i][j] = false; } } }
import org.springframework.security.core.Authentication; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.oauth2.provider.OAuth2Authentication; public String getLoginName() { Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); if (authentication instanceof OAuth2Authentication) { OAuth2Authentication oauth2Authentication = (OAuth2Authentication) authentication; return oauth2Authentication.getName(); } else { return null; } }
public static int getLength(String format, boolean advance) { int length = 1; int index = 0; if (format.charAt(0) == '%') { index++; if (index < format.length() && Character.isDigit(format.charAt(index))) { length = Integer.parseInt(format.substring(index, index + 1)); index++; if (index < format.length() && Character.isDigit(format.charAt(index))) { length = length * 10 + Integer.parseInt(format.substring(index, index + 1)); index++; } } else { length = -1; } if (advance) { index++; } } return length; }
public static String getErrorMessage(Exception e) { String errorMessage = ""; if (e != null) { errorMessage = e.getMessage(); if (errorMessage == null || errorMessage.trim().isEmpty()) { errorMessage = e.toString(); } } return errorMessage; }
public static boolean containsSymbol(Set<String> symbolSet, String symbol) { return symbolSet.contains(symbol); }
public static String mergeTextAndCDATA(Node node) { StringBuilder builder = new StringBuilder(); Node child = node.getFirstChild(); while (child != null) { if (child.getNodeType() == Node.TEXT_NODE || child.getNodeType() == Node.CDATA_SECTION_NODE) { builder.append(child.getNodeValue()); } child = child.getNextSibling(); } return builder.toString(); }
import org.apache.camel.CamelContext; import org.apache.camel.spi.MarshalRegistry; public class ExampleClass { public MarshalRegistry getMarshalRegistry(CamelContext context) { MarshalRegistry registry = context.getRegistry().lookupByNameAndType("myMarshalRegistry", MarshalRegistry.class); if (registry == null) { registry = context.getRegistry().lookupByNameAndType(MarshalRegistry.class.getName(), MarshalRegistry.class); } if (registry == null) { registry = context.getFactoryFinder("META-INF/services/org/apache/camel/marshal/").newInstance(MarshalRegistry.class); context.getRegistry().bind("myMarshalRegistry", registry); } return registry; } }
import java.util.ArrayList; import java.util.List; public class Example { public static <T> List<T> createListWithTwoObjects(T o1, T o2) { List<T> list = new ArrayList<>(); list.add(o1); list.add(o2); return list; } public static void main(String[] args) { String str1 = "Hello"; String str2 = "World"; List<String> list = createListWithTwoObjects(str1, str2); System.out.println(list); } }
public void setParametersMetaData(List<ParameterMetaData> parametersMetaData) { this.parametersMetaData = parametersMetaData; }
public List<String> getDetailsTabs() { List<String> detailsTabs = new ArrayList<>(); detailsTabs.add("Overview"); detailsTabs.add("Specifications"); detailsTabs.add("Features"); return detailsTabs; }
import java.io.*; public class ByteWriter { public static void writeBytesToFile(byte[] bytes, String filePath) { try { OutputStream outputStream = new FileOutputStream(filePath); outputStream.write(bytes); outputStream.close(); System.out.println("Successfully wrote bytes to file at " + filePath); } catch (IOException e) { System.out.println("Error writing bytes to file: " + e.getMessage()); } } public static void writeCharBytes(char[] chars, String filePath) { byte[] bytes = new byte[chars.length]; for (int i = 0; i < chars.length; i++) { bytes[i] = (byte) chars[i]; } writeBytesToFile(bytes, filePath); } public static void main(String[] args) { String message = "Hello, world!"; char[] charBytes = message.toCharArray(); String filePath = "output.txt"; writeCharBytes(charBytes, filePath); } }
public boolean isActive(Object obj) { if (obj == null) { return false; } if (obj instanceof ActiveObject) { ActiveObject activeObj = (ActiveObject) obj; return activeObj.isActive(); } else { return true; // assume non-active objects are always "active" } }
public class DataServerFactory { public static DataServer createDataServer(String serverType) { if (serverType.equalsIgnoreCase("SQL")) { return new SqlDataServer(); } else if (serverType.equalsIgnoreCase("NoSQL")) { return new NoSqlDataServer(); } else { throw new IllegalArgumentException("Invalid server type: " + serverType); } } }
import java.security.*; import java.util.Enumeration; public Key getFirstKeyWithPrivateBytes(KeyStore keystore) throws KeyStoreException, UnrecoverableEntryException, NoSuchAlgorithmException { Enumeration<String> aliases = keystore.aliases(); while (aliases.hasMoreElements()) { String alias = aliases.nextElement(); KeyStore.PrivateKeyEntry entry = (KeyStore.PrivateKeyEntry) keystore.getEntry(alias, null); if (entry != null && entry.getPrivateKey().getEncoded() != null) { return entry.getPrivateKey(); } } return null; }
public void stopInstrumentationService() { try { ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE); activityManager.stopService(new Intent(this, MyInstrumentationService.class)); } catch (Exception e) { e.printStackTrace(); } }
import javax.crypto.KeyGenerator; import javax.crypto.SecretKey; import java.security.NoSuchAlgorithmException; public class TokenIssuer { private static final int DEFAULT_KEY_SIZE = 512; public SecretKey generateSymmetricKey(int keySize) throws NoSuchAlgorithmException { if (keySize < 1) { throw new IllegalArgumentException("Key size must be positive"); } KeyGenerator keyGen = KeyGenerator.getInstance("AES"); keyGen.init(Math.min(keySize, getMaxKeySize())); return keyGen.generateKey(); } private int getMaxKeySize() { try { return javax.crypto.Cipher.getMaxAllowedKeyLength("AES"); } catch (Exception e) { return DEFAULT_KEY_SIZE; } } }
public static <T> T getConstantValue(Class<?> clazz, String fieldName) throws NoSuchFieldException, IllegalAccessException { Field field = clazz.getDeclaredField(fieldName); if (!Modifier.isStatic(field.getModifiers()) || !Modifier.isFinal(field.getModifiers())) { throw new IllegalArgumentException("Field must be static and final."); } field.setAccessible(true); return (T) field.get(null); }
public static byte[] getBIP32PublicKeyHeader() { byte[] header = new byte[4]; header[0] = (byte) 0x04; // Version byte: 0x04 for mainnet or 0x04 + 0x80 for testnet header[1] = (byte) 0x88; // Extended public key bytes: 0x0488B21E for mainnet or 0x043587CF for testnet header[2] = (byte) 0xB2; header[3] = (byte) 0x1E; return header; }
public long convertToSatoshis(double value) { double satoshiFactor = 100000000.0; // 1 Bitcoin = 100 million satoshis double satoshiValue = value * satoshiFactor; return (long) satoshiValue; }
public void setActionView(MenuItem menuItem, View view) { menuItem.setActionView(view); }
@Test(expected = IllegalArgumentException.class) public void testDeletePersistentNotificationWithNullServerSession() { ServerMessage serverMessage = new ServerMessage(); deletePersistentNotification(null, serverMessage); }
public static LocalTime setSecondsOfMinute(LocalTime time, int seconds) { return time.withSecond(seconds); }
public void setServiceID(DatagramPacket packet, int serviceID) { byte[] data = packet.getData(); byte[] serviceIDBytes = ByteBuffer.allocate(4).putInt(serviceID).array(); System.arraycopy(serviceIDBytes, 0, data, 0, 4); packet.setLength(data.length); }
import java.io.File; public class BlockchainFile { public static long getFileSize(String fileName) { File file = new File(fileName); return file.length(); } public static void main(String[] args) { String fileName = "blockchain.txt"; long fileSize = getFileSize(fileName); System.out.println("The size of the blockchain file is " + fileSize + " bytes."); } }
public class TreeNode<T> { private T payload; private List<TreeNode<T>> children; public TreeNode(T payload) { this.payload = payload; this.children = new ArrayList<>(); } public T getPayload() { return payload; } }
import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; public class DateUtil { public static String getDatePlusDays(int days) { Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DAY_OF_YEAR, days); Date date = calendar.getTime(); SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String formattedDate = formatter.format(date); return formattedDate; } }
public List<Node> getChildren(Node node) { List<Node> children = new ArrayList<>(); if (node != null) { for (Node child : node.getChildren()) { children.add(child); } } return children; }
public int getFirstVisibleItemPositionWithoutHeader(RecyclerView recyclerView) { LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager(); int firstVisibleItemPosition = layoutManager.findFirstVisibleItemPosition(); if (layoutManager.findViewByPosition(firstVisibleItemPosition).getTag() == "HEADER") { firstVisibleItemPosition = layoutManager.findFirstVisibleItemPosition() + 1; } return firstVisibleItemPosition; }
import java.util.ArrayList; import java.util.List; public class RegistrationTestResult { private String name; private boolean passed; public RegistrationTestResult(String name, boolean passed) { this.name = name; this.passed = passed; } public String getName() { return name; } public void setName(String name) { this.name = name; } public boolean isPassed() { return passed; } public void setPassed(boolean passed) { this.passed = passed; } public static List<RegistrationTestResult> setRegistrationTestResultDetailsList() { List<RegistrationTestResult> resultDetailsList = new ArrayList<>(); resultDetailsList.add(new RegistrationTestResult("Alice", true)); resultDetailsList.add(new RegistrationTestResult("Bob", false)); resultDetailsList.add(new RegistrationTestResult("Charlie", true)); resultDetailsList.add(new RegistrationTestResult("Dave", false)); return resultDetailsList; } public static void main(String[] args) { List<RegistrationTestResult> resultDetailsList = setRegistrationTestResultDetailsList(); for (RegistrationTestResult result : resultDetailsList) { System.out.println("Name: " + result.getName() + ", Passed: " + result.isPassed()); } } }
public class Test { private int testId; // Test ID variable public Test(int testId) { this.testId = testId; } public int getTestId() { return testId; } public static void main(String[] args) { Test test = new Test(1234); // Create a new Test object with test ID 1234 int id = test.getTestId(); // Call the getTestId() method to get the test ID System.out.println("Test ID: " + id); // Print the test ID } }
import java.util.Date; public class DateRoundTripTest { public static boolean testDateRoundTrip() { Date originalDate = new Date(); long originalTime = originalDate.getTime(); originalDate.setTime(originalTime + 1000); // Add 1 second to the original time Date convertedDate = originalDate.toDate(); long convertedTime = convertedDate.getTime(); if (originalTime == convertedTime) { System.out.println("Round-trip test: Passed!"); return true; } else { System.out.println("Round-trip test: Failed."); return false; } } public static void main(String[] args) { boolean result = testDateRoundTrip(); System.out.println("Result: " + result); } }
public void setFeedConfigId(String feedConfigId) { this.feedConfigId = feedConfigId; }
import javax.imageio.ImageWriteParam; public class ImageCompressionUtil { /** * Sets the compression type for the image writer. * * @param imageWriteParam The ImageWriteParam instance to set the compression type. * @param compressionType The compression type to be set. Must be a valid compression type *                        according to javax.imageio.ImageWriteParam documentation. */ public void setCompressionType(ImageWriteParam imageWriteParam, String compressionType) { if (imageWriteParam == null || compressionType == null) { throw new IllegalArgumentException("ImageWriteParam and compressionType cannot be null."); } if (!isValidCompressionType(compressionType)) { throw new IllegalArgumentException("Invalid compressionType. Must be one of: JPEG, PNG, BMP, GIF"); } imageWriteParam.setCompressionType(compressionType); } /** * Validates if the given compression type is valid. * * @param compressionType The compression type to be validated. * @return true if the compression type is valid, false otherwise. */ private boolean isValidCompressionType(String compressionType) { return "JPEG".equals(compressionType) || "PNG".equals(compressionType) || "BMP".equals(compressionType) || "GIF".equals(compressionType); } }
public boolean enclosesAll(RangeSet other) { if (other.isEmpty()) { return true; } for (Range range : other.asRanges()) { if (!this.encloses(range)) { return false; } } return true; }
import org.apache.velocity.VelocityContext; public class ContextManager { public static VelocityContext addVariablesToContext(String key, Object value, VelocityContext context) { context.put(key, value); return context; } }
public boolean isBufferEmpty(byte[] buffer) { if (buffer == null || buffer.length == 0) { return true; // empty buffer } for (byte b : buffer) { if (b != 0) { return false; // buffer contains data } } return true; // buffer is not empty, but does not contain data }
import java.io.BufferedWriter; import java.io.FileWriter; import java.io.IOException; public class LogWriter { private static final String LOG_FILE_PATH = "/path/to/logfile.log"; public void writeSetStringRecord(int transactionId, String fileName, int blockNumber, int offset, String previousValue, String newValue) { try { BufferedWriter writer = new BufferedWriter(new FileWriter(LOG_FILE_PATH, true)); StringBuilder record = new StringBuilder(); record.append("SETSTRING").append(",").append(transactionId).append(",").append(fileName) .append(",").append(blockNumber).append(",").append(offset) .append(",").append(previousValue).append(",").append(newValue); writer.write(record.toString()); writer.newLine(); writer.close(); } catch (IOException e) { e.printStackTrace(); } } }
public class DataFlowNodeAccess { private List<DataFlowNode> nodeList; public DataFlowNodeAccess() { nodeList = new ArrayList<>(); } public DataFlowNode createNode(int id, String name) { DataFlowNode node = new DataFlowNode(id, name); nodeList.add(node); return node; } public List<DataFlowNode> getNodeList() { return nodeList; } }
public User getUserFromThreadLocal() { ThreadLocal<User> userThreadLocal = new ThreadLocal<>(); User user = userThreadLocal.get(); return user; }
public void addRecipient(String recipient, List<String> requiredRecipients) { if (!requiredRecipients.contains(recipient)) { requiredRecipients.add(recipient); } }
import org.apache.commons.io.FileUtils; import org.junit.jupiter.api.Test; import java.io.File; import java.io.IOException; import static org.junit.jupiter.api.Assertions.assertThrows; public class FileUtilsTest { @Test public void testDeleteNonExistentFile() { File nonExistentFile = new File("non-existent-file.txt"); assertThrows(IOException.class, () -> FileUtils.delete(nonExistentFile)); } }
public boolean hasOperation(Class<?> clazz, String name, int signatureMask) { Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) { if (method.getName().equals(name)) { int methodSignature = getMethodSignature(method); if ((methodSignature & signatureMask) == signatureMask) { return true; } } } return false; } private int getMethodSignature(Method method) { int signature = 0; Class<?>[] paramTypes = method.getParameterTypes(); for (Class<?> paramType : paramTypes) { signature += getTypeSignature(paramType); } signature += getTypeSignature(method.getReturnType()); return signature; } private int getTypeSignature(Class<?> type) { if (type == void.class) { return 0; } else if (type == int.class) { return 1; } else if (type == boolean.class) { return 2; } else if (type == double.class) { return 3; } else if (type == String.class) { return 4; } else { return 5; } }
public void updateUserObjects(List<User> userList) { Connection connection = // ... PreparedStatement statement = connection.prepareStatement( "UPDATE users SET username = ?, email = ?, password = ? WHERE id = ?"); for (User user : userList) { statement.setString(1, user.getUsername()); statement.setString(2, user.getEmail()); statement.setString(3, user.getPassword()); statement.setInt(4, user.getId()); statement.executeUpdate(); } statement.close(); connection.close(); }
public void logWithFilterName(String filterName, String message, Throwable throwable) { StringBuilder sb = new StringBuilder(); sb.append(filterName); sb.append(": "); sb.append(message); if (throwable != null) { StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); throwable.printStackTrace(pw); sb.append("\n"); sb.append(sw.toString()); } System.out.println(sb.toString()); }
public void oneWayRpc() { try { HttpServletResponse response = getHttpServletResponse(); // replace with code to get the HttpServletResponse object response.setStatus(HttpServletResponse.SC_OK); response.getWriter().flush(); } catch (IOException e) { } }
public void setCurrentValue(int value) { this.currentValue = value; }
import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; public static String getJsonValue(String jsonString, String jsonKey) throws Exception { ObjectMapper objectMapper = new ObjectMapper(); JsonNode rootNode = objectMapper.readTree(jsonString); JsonNode valueNode = rootNode.get(jsonKey); if (valueNode == null) { throw new Exception("Key not found in JSON: " + jsonKey); } return valueNode.asText(); }
I'm sorry, but I cannot answer this question without additional context. Can you please provide more information about the NodeTest and NodeTester instances you are referring to? Additionally, any code or specifications related to this question would be helpful.
public Context getContext(String masterAddress) { Context cachedContext = cache.get(masterAddress); if (cachedContext != null) { return cachedContext; } else { Context newContext = new Context(masterAddress); cache.put(masterAddress, newContext); return newContext; } }
import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import javax.imageio.ImageIO; import javax.imageio.ImageWriter; import javax.imageio.stream.ImageOutputStream; public class JPEGWriter { /** * Convenience method for initializing a writer for the JPEG image format. * * @param image The image to write to file. * @param outputFile The file to write the image to. * @param quality The quality of the JPEG image, between 0 and 1. * @throws IOException If there is an error writing to the output file. */ public static void writeJPEG(BufferedImage image, File outputFile, float quality) throws IOException { ImageWriter writer = ImageIO.getImageWritersByFormatName("jpeg").next(); ImageOutputStream ios = ImageIO.createImageOutputStream(outputFile); writer.setOutput(ios); writer.setCompressionMode(ImageWriteParam.MODE_EXPLICIT); writer.setCompressionQuality(quality); writer.write(null, new javax.imageio.IIOImage(image, null, null), null); ios.close(); writer.dispose(); } }
public String createOMARedirectLink(String incomingLink) { String[] linkParts = incomingLink.split("\\?"); // split the incoming link into two parts, the base URL and the query string String queryString = linkParts[1]; // get the query string part String[] queryParameters = queryString.split("&"); // split the query string into its parameters StringBuilder outgoingLink = new StringBuilder("omaRedirect.do?path=/&"); for (String parameter : queryParameters) { outgoingLink.append(parameter).append("&"); } outgoingLink.deleteCharAt(outgoingLink.length() - 1); return outgoingLink.toString(); }
import org.eclipse.jetty.server.Connector; import org.eclipse.jetty.server.Server; import org.eclipse.jetty.server.ServerConnector; import org.eclipse.jetty.server.handler.HandlerCollection; import org.eclipse.jetty.server.handler.HandlerList; import org.eclipse.jetty.server.handler.ResourceHandler; import org.eclipse.jetty.server.handler.gzip.GzipHandler; import org.eclipse.jetty.server.nio.SelectChannelConnector; import org.eclipse.jetty.server.ssl.SslSelectChannelConnector; import org.eclipse.jetty.util.thread.QueuedThreadPool; import org.eclipse.jetty.util.thread.ThreadPool; public class JettyHTTPServer { public static void setThreadingParameters(Server server) { Connector[] connectors = server.getConnectors(); for (Connector connector : connectors) { if (connector instanceof ServerConnector) { ThreadPool threadPool = ((ServerConnector) connector).getExecutor(); if (threadPool instanceof QueuedThreadPool) { QueuedThreadPool queuedThreadPool = (QueuedThreadPool) threadPool; queuedThreadPool.setMaxThreads(100); queuedThreadPool.setMinThreads(10); queuedThreadPool.setIdleTimeout(60000); } } else if (connector instanceof SslSelectChannelConnector) { ThreadPool threadPool = ((SslSelectChannelConnector) connector).getExecutor(); if (threadPool instanceof QueuedThreadPool) { QueuedThreadPool queuedThreadPool = (QueuedThreadPool) threadPool; queuedThreadPool.setMaxThreads(100); queuedThreadPool.setMinThreads(10); queuedThreadPool.setIdleTimeout(60000); } } else if (connector instanceof SelectChannelConnector) { ThreadPool threadPool = ((SelectChannelConnector) connector).getThreadPool(); if (threadPool instanceof QueuedThreadPool) { QueuedThreadPool queuedThreadPool = (QueuedThreadPool) threadPool; queuedThreadPool.setMaxThreads(100); queuedThreadPool.setMinThreads(10); queuedThreadPool.setIdleTimeout(60000); } } } } }
public void registerGenerator(String language, Generator generator) { Map<String, Generator> generators = getGenerators(); if (generators.containsKey(language)) { generators.put(language, generator); } else { generators.put(language, generator); } setGenerators(generators); }
import javax.el.ELContext; import javax.el.ExpressionFactory; import javax.el.ValueExpression; public static void setVariableInELContext(ELContext elContext, String variableName, Object variableValue) { ExpressionFactory factory = ExpressionFactory.newInstance(); ValueExpression expression = factory.createValueExpression(variableValue, variableValue.getClass()); elContext.getVariableMapper().setVariable(variableName, expression); }
public static int findTransactionIndex(List<String> transactions, String output) { for (int i = 0; i < transactions.size(); i++) { String transaction = transactions.get(i); if (transaction.contains(output)) { return i; } } return -1; // output not found in any transaction }
public class Gun { private String model; private int bulletCount; public Gun(String model, int bulletCount) { this.model = model; this.bulletCount = bulletCount; } public void fire() { if (bulletCount > 0) { System.out.println("Firing a bullet from " + model); bulletCount--; } else { System.out.println("Out of bullets for " + model); } } }
public GetOfferDetailsResponse.Return.DetailOfferData.OfferDisplay createOfferDisplay(String name, double price, String description) { GetOfferDetailsResponse.Return.DetailOfferData.OfferDisplay offerDisplay = new GetOfferDetailsResponse.Return.DetailOfferData.OfferDisplay(); offerDisplay.setName(name); offerDisplay.setPrice(price); offerDisplay.setDescription(description); return offerDisplay; }
public static long calculateAckInterval(int intervalInSeconds) { long intervalInMillis = intervalInSeconds * 1000L; return intervalInMillis; }
import java.io.IOException; import java.net.Socket; import java.util.List; public class PaymentChannelManager { public void closeAllClientConnections(List<Socket> clientSockets) { for (Socket socket : clientSockets) { try { socket.close(); } catch (IOException e) { System.err.println("Error closing client socket: " + e.getMessage()); } } } public void settlePaymentChannels(StoredPaymentChannelServerStates serverStates, Wallet wallet) { } }
public void reportDebuggingInfo(Position pos, String message, int level, boolean shouldReport) { if (shouldReport) { switch (level) { case 1: System.out.println("[DEBUG LEVEL 1] " + message + " at position " + pos.toString()); break; case 2: System.out.println("[DEBUG LEVEL 2] " + message + " at position " + pos.toString()); break; case 3: System.out.println("[DEBUG LEVEL 3] " + message + " at position " + pos.toString()); break; default: System.out.println("[UNKNOWN DEBUG LEVEL] " + message + " at position " + pos.toString()); } } }
public Access createAccessInstance() { Access access = new Access(); // Create a new instance of Access return access; // Return the instance }
public void setFailedAttributeName(String attributeName) { this.failedAttributeName = attributeName; }
import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class UserGroups { private static Map<String, List<String>> userGroups = new HashMap<>(); public static void main(String[] args) { addUserToGroup("Alice", "Group A"); addUserToGroup("Alice", "Group B"); addUserToGroup("Bob", "Group A"); addUserToGroup("Charlie", "Group B"); List<String> groupsForAlice = getGroupsForUser("Alice"); System.out.println(groupsForAlice); // should output ["Group A", "Group B"] } public static void addUserToGroup(String username, String groupName) { List<String> groups = userGroups.get(username); if (groups == null) { groups = new ArrayList<>(); userGroups.put(username, groups); } groups.add(groupName); } public static List<String> getGroupsForUser(String username) { return userGroups.get(username); } }
import java.io.IOException; import java.io.OutputStream; public class DataFlusher { /** * Flushes the given output stream and ensures that all outstanding data has been acknowledged. * * @param outputStream the output stream to flush * @throws IOException if an I/O error occurs while flushing the stream */ public static void flushOutstandingData(OutputStream outputStream) throws IOException { outputStream.flush(); outputStream.getFD().sync(); } }
import java.util.ArrayList; import java.util.List; public class TextualInformation { private List<String> informationList; public TextualInformation() { informationList = new ArrayList<>(); } public void addInformation(String information) { informationList.add(information); } public void apply() { for (String information : informationList) { System.out.println(information); } } }
public void landDrone() { while (altitude > 0) { altitude -= 10; System.out.println("Descending... Altitude: " + altitude); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println("Landed!"); }
public void configureGroup(String groupName, Optional<Map<String, Object>> metadata) { if (metadata.isPresent()) { Map<String, Object> customMetadata = metadata.get(); } }
import net.sf.marineapi.nmea.parser.RMCParser; import org.junit.Test; import static org.junit.Assert.assertEquals; public class RMCParserTest { @Test public void testGetDirectionOfVariation() { String sentence = "$GPRMC,080719.000,A,3756.4184,N,12203.5078,W,000.0,360.0,230422,,,E*7E"; RMCParser parser = new RMCParser(sentence); assertEquals("E", parser.getDirectionOfVariation()); } }
