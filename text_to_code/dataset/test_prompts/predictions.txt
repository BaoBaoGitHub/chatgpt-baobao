void function(ScriptOrFnNode arg0, int arg1, ScriptOrFnNode parent) { int loc0 = arg1; ObjArray loc1 = new ObjArray(); ScriptOrFnNode current = arg0; while (current != null) { if (current.getType() == Token.FUNCTION) { TokenMapper.this.functionNum++; TokenMapper.this.lastTokenCount = 0; TokenMapper.this.functionVarMappings.add(new HashMap<String, Integer>()); TokenMapper.this.replacedTokens.add(new ArrayList<Integer>()); TokenMapper.this.functionBracePositions.add(current.getLp()); loc1.add(current); TokenMapper.this.funcObjects.set(TokenMapper.this.functionNum, loc1); ScriptNode functionNode = (ScriptNode) current; if (functionNode.getParamCount() > 0) { generateParamNameMappings(functionNode.getParamCount(), functionNode.getParamAndVarNames()); } if (functionNode.getParamAndVarCount() > functionNode.getParamCount()) { generateLocalVarNameMappings(functionNode.getParamAndVarCount() - functionNode.getParamCount(), functionNode.getParamAndVarNames(), functionNode.getParamCount()); } } current = current.getNext(); } for (int i = 0; i < loc1.size(); i++) { current = (ScriptOrFnNode) loc1.get(i); collectFuncNodes(current, loc0, parent); } }
public static Sha256Hash function(File arg0) throws IOException { InputStream loc0 = null; try { loc0 = new FileInputStream(arg0); byte[] loc1 = ByteStreams.toByteArray(loc0); return create(loc1); } finally { if (loc0 != null) { loc0.close(); } } }
public String function(Object obj, boolean canCreate) { String loc0 = readObjectID(obj); if (loc0 == null && canCreate) { loc0 = createObjectID(obj); } return loc0; }
public <T extends Comparable<T>> Matcher<T> function(T value) { return new TypeSafeMatcher<T>() { public void describeTo(Description description) { description.appendText("a value greater than ").appendValue(value); } protected boolean matchesSafely(T item) { return item.compareTo(value) > 0; } }; }
public int function() { return denom; }
void function(String arg0, String arg1) { id_str = arg0; screen_name = "unknown"; user_name = "unknown@unknown"; loc_radius = 0; user_id = "unknown"; text = ""; lat = 0.0; place_name = "unknown"; image = null; lng = 0.0; created_at = null; extras = new ArrayList<String>(); }
void function(BundleContext arg0) { }
void function() { mTestStream = new TestBufferedBlockInStream(mBlockSize, mBufferSize); mTestStream.seek(0); assertEquals(0, mTestStream.getPosition()); mTestStream.seek(mBlockSize * TestBufferedBlockInStream.NUM_BLOCKS - 1); assertEquals(mBlockSize * TestBufferedBlockInStream.NUM_BLOCKS - 1, mTestStream.getPosition()); mTestStream.seek(mBlockSize * TestBufferedBlockInStream.NUM_BLOCKS / 2); assertEquals(mBlockSize * TestBufferedBlockInStream.NUM_BLOCKS / 2, mTestStream.getPosition()); }
void function() { Object obj = new Object(); WeakReference<Object> ref = new WeakReference<>(obj); obj = null; System.gc(); try { Thread.sleep(timeoutSeconds() * 1000); } catch (InterruptedException e) { throw formatRuntimeException("Unexpectedly interrupted: %s", e); } awaitClear(ref); final CountDownLatch latch = new CountDownLatch(1); Object finalizable = new Object() { protected void finalize() throws Throwable { createUnreachableLatchFinalizer(latch); } }; finalizable = null; System.gc(); try { Thread.sleep(timeoutSeconds() * 1000); } catch (InterruptedException e) { throw formatRuntimeException("Unexpectedly interrupted: %s", e); } await(latch); }
function() { mManager = TransferManagerBuilder.standard().withS3Client(Mockito.mock(AmazonS3.class)).build(); mStream = new S3ADirectOutputStream(mManager, new PutObjectRequest(BUCKET_NAME, KEY, new ByteArrayInputStream(new byte[] {})), null); }
String function(Object arg0, String arg1, String arg2, String arg3) { String loc0 = System.getProperty("line.separator"); setDocs(arg0, arg1); int loc1 = appendComment(new StringBuffer(), arg2, arg3, 0); boolean loc2 = hasDocs(arg0); String loc3 = getComments(arg0); String loc4 = getComments(arg0, arg1, arg2, arg3); String loc5 = defaultFor(arg0, arg2); return loc5; }
public LogLevel function(String arg0, String arg1) { LogLevel loc0 = LOG.getLogLevel(); LogLevel loc1 = LOG.getLogLevel(); if (arg0 != null && arg1 != null) { List<String> loc2 = getAlternateAddresses(null); List<Endpoint> loc3 = getAlternateEndpoints(null); if (loc2.contains(arg0) && loc3 != null && !loc3.isEmpty()) { Endpoint loc4 = selectAlternateEndpoint(loc3); String loc5 = selectAlternateAddress(loc2); LOG.log(loc0, "Selected alternate endpoint: {}", loc4); LOG.log(loc1, "Selected alternate address: {}", loc5); } } return loc0; }
public boolean function(String arg0) { TSTNode loc0 = root; int loc1 = 0; while (loc0 != null) { if (arg0.charAt(loc1) < loc0.data) { loc0 = loc0.left; } else if (arg0.charAt(loc1) > loc0.data) { loc0 = loc0.right; } else { loc1++; if (loc1 == arg0.length()) { return loc0.is_End_Of_String; } loc0 = loc0.middle; } } return false; }
public void function() { if (prodscan != null) { prodscan.close(); prodscan = null; } if (rhsscan != null) { rhsscan.close(); rhsscan = null; } if (lhsscan != null) { lhsscan.close(); lhsscan = null; } }
public Map<String, String> function(String[] arg0) { Map<String, String> loc0 = new HashMap<>(); for (String property : arg0) { String[] parts = property.split("#"); if (parts.length == 2) { String propertyName = parts[0]; String propertyValue = parts[1]; loc0.put(propertyName, propertyValue); } } return loc0; }
Object function(String arg0, Map<String,String> arg1) { XPath xpath = XPathFactory.newInstance().newXPath(); xpath.setNamespaceContext(new SimpleNamespaceContext(namespaces)); try { XPathExpression expr = xpath.compile(arg0); NodeList nodes = (NodeList) expr.evaluate(doc, XPathConstants.NODESET); List<Node> result = new ArrayList<Node>(); for (int i = 0; i < nodes.getLength(); i++) { Node node = nodes.item(i); if (node.getNodeType() == Node.ELEMENT_NODE) { NamedNodeMap attrs = node.getAttributes(); for (int j = 0; j < attrs.getLength(); j++) { Node attr = attrs.item(j); if (attr.getNodeType() == Node.ATTRIBUTE_NODE) { result.add(attr); } } } else if (node.getNodeType() == Node.TEXT_NODE || node.getNodeType() == Node.CDATA_SECTION_NODE) { result.add(node); } } return result; } catch (XPathExpressionException e) { throw new RuntimeException(e); } }
boolean function(Collection<? extends Source> arg0, GoalFactory arg1) { Job job = new Job(); job.addInputFiles(arg0); Goal goal = arg1.createGoal(); if (!goal.shouldRun(job)) { return true; } Goal validateGoal = new CompileValidate(); List<Goal> prereqs = validateGoal.getPrerequisiteGoals(); for (Goal prereq : prereqs) { if (!prereq.runToCompletion(job)) { return false; } } return goal.runToCompletion(job); }
void function(boolean arg0) { if (arg0) { context.enableGPS(); } else { context.disableGPS(); } }
boolean function(View arg0) { return arg0.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL; }
public Checklist getChecklistForElement(Object element) { Checklist checklist = null; if (element != null) { Class elementClass = element.getClass(); if (elementClass != null) { checklist = lookupChecklist(elementClass); } } return checklist; }
Here is the updated code with the requested changes: ``` class DateTest { Date instance; GregorianCalendar cal; void setUp() { instance = new Date(); cal = new GregorianCalendar(); } void testEqualsItself() { assertEquals(instance, instance); } void testToISO8601WithTimeAndNegativeOffset() { instance.setHour(12); instance.setMinute(0); instance.setSecond(0); instance.setMillisecond(0); instance.setTimeZone(TimeZone.getTimeZone("GMT-5")); String expected = "19700101T12:00:00-0500"; assertEquals(expected, instance.toISO8601()); } void testSetMonth() { instance.setMonth(2); cal.setTime(instance); int loc0 = cal.get(Calendar.MONTH); assertEquals(2, loc0); } void testToISO8601TwoDigitYear() { instance.setYear(69); instance.setMonth(0); instance.setDay(1); instance.setHour(0); instance.setMinute(0); instance.setSecond(0); instance.setMillisecond(0); String expected = "690101T000000Z"; assertEquals(expected, instance.toISO8601()); } void testSetYearThreeDigits() { instance.setYear(999); cal.setTime(instance); int loc0 = cal.get(Calendar.YEAR); assertEquals(999, loc0); } void testEqualsWrongType() { Object obj = new Object(); assertFalse(instance.equals(obj)); } void testToISO8601WithTime() { instance.setYear(2000); instance.setMonth(0); instance.setDay(1); instance.setHour(12); instance.setMinute(0); instance.setSecond(0); instance.setMillisecond(0); String expected = "20000101T120000Z"; assertEquals(expected, instance.toISO8601()); } void testToISO8601FourDigitYear() { instance.setYear(2010); instance.setMonth(11); instance.setDay(31); instance.setHour(23); instance.setMinute(59); instance.setSecond(59); instance.setMillisecond(999); String expected = "20101231T235959.999Z"; assertEquals(expected, instance.toISO8601()); } void testEqualsWhenChanged() { Date another = new Date(); assertFalse(instance.equals(another)); instance.setYear(2000); instance.setMonth(0); instance.setDay(1); instance.setHour(0); instance.setMinute(0); instance.setSecond(0); instance.setMillisecond(0); another.setYear(2000); another.setMonth(0); another.setDay(1); another.setHour(0); another.setMinute(0); another.setSecond(0); another.setMillisecond(0); assertTrue(instance.equals(another)); } void testSetYearNegative() { instance.setYear(-2000); cal.setTime(instance); int loc0 = cal.get(Calendar.YEAR); assertEquals(-2000, loc0); } void testConstructorWithValues() { Date d = new Date(2000, 0, 1); instance = d; cal.setTime(instance); int loc0 = cal.get(Calendar.YEAR); int loc1 = cal.get(Calendar.MONTH); int loc2 = cal.get(Calendar.DAY_OF_MONTH); assertEquals(2000, loc0); assertEquals(0
public int function(int lane, int player) { int closestTile = -1; int furthestTile = tileFurthestFromBase(lane, player); if (player == HUMAN_PLAYER) { for (int i = 0; i < tiles[lane].length; i++) { if (tiles[lane][i][player] == null) { closestTile = i; break; } } } else { for (int i = tiles[lane].length - 1; i >= 0; i--) { if (tiles[lane][i][player] == null) { closestTile = i; break; } } } if (closestTile == -1) { return -1; } else { return closestTile > furthestTile ? -1 : closestTile; } }
public Matrix function(Matrix matrix) { int n = matrix.getRowCount(); Matrix identityMatrix = new Matrix(n, n); if (n != matrix.getColumnCount()) { throw new RuntimeException("Matrix is not square"); } for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (i == j) { identityMatrix.setValueAt(i, j, 1); } else { identityMatrix.setValueAt(i, j, 0); } } } Matrix matrixOfMinors = new Matrix(n, n); Matrix matrixOfCofactors = new Matrix(n, n); for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { matrixOfMinors.setValueAt(i, j, determinant(createSubMatrix(matrix, i, j))); matrixOfCofactors.setValueAt(i, j, changeSign(i + j) * matrixOfMinors.getValueAt(i, j)); } } Matrix adjugateMatrix = transpose(matrixOfCofactors); double determinant = determinant(matrix); if (determinant == 0.0) { throw new RuntimeException("Matrix is not invertible"); } Matrix inverseMatrix = new Matrix(n, n); for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { inverseMatrix.setValueAt(i, j, adjugateMatrix.getValueAt(i, j) / determinant); } } return inverseMatrix; }
public String function() { return thisExitStatus.getExitCode(); }
public String function(Object e) { return getAttributeValue(e, "hover"); }
List<AttributeStatementProvider> function() { return attributeStatementProviders; }
void function() { unloadSounds(sounds); }
ProjectModel function(UserModel user) { String projectId = user.getProjectId(); if (projectId == null) { return null; } return projectCache.get(projectId); }
public String function(String hexString) { int hexValue = Integer.parseInt(hexString, 16); int r = (hexValue >> 16) & 0xFF; int g = (hexValue >> 8) & 0xFF; int b = hexValue & 0xFF; double minDistSq = Double.MAX_VALUE; String closestName = null; for (RGB rgb : namedColors.keySet()) { double distSq = calculateColorDistSq(new Color(r, g, b), new Color(rgb.r, rgb.g, rgb.b)); if (distSq < minDistSq) { minDistSq = distSq; closestName = namedColors.get(rgb); } } return closestName; }
function getPseudoFileName() { String suffix = getSuffixFromType(); return name.replaceAll("[^a-zA-Z0-9\\.\\-]", "_") + "_" + revision.replaceAll("[^a-zA-Z0-9\\.\\-]", "_") + "." + suffix; }
public int function() { int loc0 = 8333; return loc0; } Note: The default TCP port on which to connect to nodes in the Bitcoin network is 8333. This method simply returns that value.
public Set<String> function() { Set<String> loc0 = jedis.keys("URLSet:*"); return loc0; } Note: This method uses the Jedis library to retrieve all the keys that start with "URLSet:" from Redis, which correspond to the URLSet keys for the terms that have been indexed. It returns a Set of Strings containing these keys. This method is intended for development and testing purposes only and should not be used in production.
void function() { mBlocksToMoveIn.clear(); mBlocksToMoveOut.clear(); mBlocksToMoveInSize = 0L; mBlocksToMoveOutSize = 0L; }
UserSubject function() { if (subject != null) { return subject; } else if (client != null && preAuthorized) { return client.getPrincipal(); } else { return null; } }
public int function(boolean advance) { char type = getType(); checkType('i', false); int length = getIntFromFormat(false); if (length == 0) { return 1; } if (type == 's') { length--; } if (advance) { consume(); } return length; }
public class TestResultDetailsDTO { String actualValue; Long expectedDataSetId; String errorMsg; Long dataUnitId; Long seqNo; Long dataSetId; String expectedValue; String errorCode; Long testId; String failedAttributeName; String srcFileName; Long expectedDataUnitId; public void setExpectedDataUnitId(Long expectedDataUnitId) { this.expectedDataUnitId = expectedDataUnitId; } public Long getDataUnitId() { return dataUnitId; } public String getErrorCode() { return errorCode; } public void setExpectedDataSetId(Long expectedDataSetId) { this.expectedDataSetId = expectedDataSetId; } public void setActualValue(String actualValue) { this.actualValue = actualValue; } public void setErrorCode(String errorCode) { this.errorCode = errorCode; } public void setDataUnitId(Long dataUnitId) { this.dataUnitId = dataUnitId; } public void setDataSetId(Long dataSetId) { this.dataSetId = dataSetId; } public void setSeqNo(Long seqNo) { this.seqNo = seqNo; } public void setErrorMsg(String errorMsg) { this.errorMsg = errorMsg; } public String toString() { return "TestResultDetailsDTO [actualValue=" + actualValue + ", expectedDataSetId=" + expectedDataSetId + ", errorMsg=" + errorMsg + ", dataUnitId=" + dataUnitId + ", seqNo=" + seqNo + ", dataSetId=" + dataSetId + ", expectedValue=" + expectedValue + ", errorCode=" + errorCode + ", testId=" + testId + ", failedAttributeName=" + failedAttributeName + ", srcFileName=" + srcFileName + ", expectedDataUnitId=" + expectedDataUnitId + "]"; } public Long getExpectedDataSetId() { return expectedDataSetId; } public Long getDataSetId() { return dataSetId; } public void setTestId(Long testId) { this.testId = testId; } public void setFailedAttributeName(String failedAttributeName) { this.failedAttributeName = failedAttributeName; } public Long getTestId() { return testId; } public Long getSeqNo() { return seqNo; } public String getFailedAttributeName() { return failedAttributeName; } public String getActualValue() { return actualValue; } public void setExpectedValue(String expectedValue) { this.expectedValue = expectedValue; } public String getExpectedValue() { return expectedValue; } public void setSrcFileName(String srcFileName) { this.srcFileName = srcFileName; } public Long getExpectedDataUnitId() { return expectedDataUnitId; } public String getSrcFileName() { return srcFileName; } public String function() { String loc0 = errorMsg; return loc0; } }
boolean function(symbol arg0) { not_null(arg0); return _all.containsKey(arg0.get_name()); }
String function(Node arg0) { StringBuilder sb = new StringBuilder(); NodeList childNodes = arg0.getChildNodes(); for (int i = 0; i < childNodes.getLength(); i++) { Node child = childNodes.item(i); if (child.getNodeType() == Node.TEXT_NODE || child.getNodeType() == Node.CDATA_SECTION_NODE) { sb.append(child.getNodeValue()); } } return sb.toString(); }
static MarshalRegistry function() { Context ctx = Context.current(); MarshalRegistry registry = (MarshalRegistry) ctx.get(MarshalRegistry.class); if (registry == null) { registry = new MarshalRegistry(); ctx = ctx.withValue(MarshalRegistry.class, registry); } return registry; }
static <T> List<T> function(T o1, T o2) { List<T> list = new ArrayList<>(); list.add(o1); list.add(o2); return list; }
class MetaData { ParametersMetaData parametersMetaData; String templateName; String workflowImplName; String workflowImplDescription; String templateId; Template template; WorkflowImpl workflowImpl; String workflowImplId; String templateDescription; void function(ParametersMetaData arg0) { ParametersMetaData loc0 = arg0; this.parametersMetaData = loc0; } void setTemplateDescription(String value) { this.templateDescription = value; } void setTemplateName(String value) { this.templateName = value; } String getTemplateId() { return this.templateId; } String getTemplateName() { return this.templateName; } void setWorkflowImplDescription(String value) { this.workflowImplDescription = value; } Template getTemplate() { return this.template; } String getTemplateDescription() { return this.templateDescription; } void setWorkflowImplName(String value) { this.workflowImplName = value; } String getWorkflowImplName() { return this.workflowImplName; } String getWorkflowImplId() { return this.workflowImplId; } WorkflowImpl getWorkflowImpl() { return this.workflowImpl; } ParametersMetaData getParametersMetaData() { return this.parametersMetaData; } void setWorkflowImpl(WorkflowImpl value) { this.workflowImpl = value; } void setWorkflowImplId(String value) { this.workflowImplId = value; } void setTemplate(Template value) { this.template = value; } void setTemplateId(String value) { this.templateId = value; } String getWorkflowImplDescription() { return this.workflowImplDescription; } }
class DeveloperModule { long serialVersionUID = -2570516012301142091L; String aboutName = "Dev module"; Logger LOG = Logger.getLogger(DeveloperModule.class); String function(int arg0) { int loc0 = arg0; if (loc0 == 0) { return "This is the first details tab of our dev module."; } else if (loc0 == 1) { return "This is the second details tab of our dev module."; } else { return "Invalid tab type requested."; } } boolean disable() { } String getName() { } String getInfo(int type) { } boolean enable() { } }
class RtfDumpListener { XMLStreamWriter writer; void function(byte[] arg0, int arg1, int arg2) { String str = new String(arg0); try { writer.writeCharacters(str); } catch (XMLStreamException e) { } } void processGroupEnd() { } void processCommand(Command command, int parameter, boolean hasParameter, boolean optional) { } void processString(String string) { } void processDocumentStart() { } void processBinaryBytes(byte[] data) { } void processGroupStart() { } void processDocumentEnd() { } }
public String function() { return isActive; }
public static function createDataServer(int port, String bindHost) { DataServer dataServer = new DataServer(); return dataServer; }
public ECKey function() { ECKey result = null; for (ECKey loc0 : keys) { if (loc0.getPrivKeyBytes() != null) { result = loc0; break; } } return result; }
public void function() { log.debug("Destroying InstrumentationService"); if (instrumentation != null) { instrumentation.removeJvmMetrics(); instrumentation = null; } }
public void function(long requestedKeySize) { long maxKeySize = requestedKeySize > 0 ? requestedKeySize : maximumKeySize; setKeySize(maxKeySize); }
public Constant function(String fieldName) { if (hasField(fieldName)) { int index = ts.getFieldIndex(fieldName); if (index >= 0) { return ts.getSchema().getField(index).getConstant(); } } return null; }
public int getBip32HeaderPub() { return bip32HeaderPub; }
public long function() { long satoshis = this.value; return satoshis; }
public void function(View actionView) { mMenuItem.setActionView(actionView); }
public void function() { try { notificationController.deletePersistentNotification(null, mockServerMessage); fail("Expected IllegalArgumentException to be thrown."); } catch (IllegalArgumentException e) { } }
public void function(double seconds) { this.seconds = seconds; }
public void function(ServiceID serviceID) { this.serviceID = serviceID; }
int function() { int loc0 = FILE_PROLOGUE_BYTES + (numHeaders * RECORD_SIZE); return loc0; }
T function() { return mPayload; }
String function() { SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); return dateFormat.format(addedDate); }
List<DirectedAcyclicGraphNode<T>> getChildren() { return mChildren; }
View function(RecyclerView arg0) { int childCount = arg0.getChildCount(); for (int i = 0; i < childCount; i++) { View child = arg0.getChildAt(i); RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); int adapterPosition = params.getViewAdapterPosition(); if (!indexOutOfBounds(adapterPosition) && !mAdapter.isHeader(adapterPosition)) { return child; } } return null; }
public void function(List<TestResultDetailsDTO> arg0) { regTestResultDetailsLst = arg0; }
public long function() { return testId; }
void function() { Time time1 = new Time(12, 34, 56); Time time2 = new Time(); time2.setTime(time1.getMilliseconds()); Date date = time2.toDate(); Time time3 = Time.fromDate(date); assertEquals(time2.getMilliseconds(), time3.getMilliseconds()); }
function setFeedConfigId(BigDecimal arg0) { this.feedConfigId = arg0; }
/** * Compression type for images to be generated from this writer. See * {@link javax.imageio.ImageWriteParam#setCompressionType(String)} for a description of what * this means and valid range of values. * * @param compressionType the compression type to set */ void function(String compressionType) { this.writeCompressionType = compressionType; }
public boolean function(RangeSet<C> arg0) { if (arg0.isEmpty()) { return true; } for (Range<C> loc0 : arg0.asRanges()) { boolean found = false; for (Range<C> loc1 : asRanges()) { if (loc1.encloses(loc0)) { found = true; break; } } if (!found) { return false; } } return true; }
public void function(Map<String, Object> arg0) { context.getVariables().putAll(arg0); }
public boolean function() { return buffer != null && buffer.position() > 0; }
public void function(int txnum) { LogMgr logMgr = new LogMgr(txnum); String logRecord = "SETSTRING " + txnum + " " + blk.fileName() + " " + blk.number() + " " + offset + " " + oldval; logMgr.logString(logRecord); }
void function(int type, DataFlowNode node) { DataFlowNode newNode = createDataFlowNode(type, node); dataFlow.add(newNode); } private DataFlowNode createDataFlowNode(int type, DataFlowNode node) { DataFlowNode newNode; if (type == NodeType.START) { newNode = createStartNode(node.line()); } else if (type == NodeType.END) { newNode = createEndNode(node.line()); } else { newNode = null; } return newNode; }
User function() { ThreadLocal<User> sUserThreadLocal = new ThreadLocal<>(); User loc0 = sUserThreadLocal.get(); return loc0; }
void function(String recipient) { if (selectedRecipients == null) { selectedRecipients = new ArrayList<String>(); } if (!selectedRecipients.contains(recipient)) { selectedRecipients.add(recipient); } } The function takes a string argument "recipient" and adds it to the list of required recipients ("selectedRecipients") if it is not already in the list. If the list is null, it creates a new instance of ArrayList<String> and assigns it to "selectedRecipients".
void function() { mException.expect(IllegalArgumentException.class); mException.expectMessage("The file to delete does not exist"); File nonExistentFile = new File(mTestFolder.getRoot(), "non-existent-file.txt"); FileUtils.delete(nonExistentFile.getPath()); } The function tests the FileUtils.delete(String) method by attempting to delete a non-existent file. It uses the ExpectedException rule to expect an IllegalArgumentException with the message "The file to delete does not exist". It creates a File object for a file that does not exist and attempts to delete it using FileUtils.delete().
boolean function(String operationName, OperationSignature signatureMask) { Map<String, OperationStats> operationsByName = operations.get(signatureMask); if (operationsByName == null) { return false; } OperationStats operationStats = operationsByName.get(operationName); if (operationStats == null) { return false; } return operationStats.isCovered(); } The function takes two arguments, a string "operationName" and an OperationSignature "signatureMask". It checks whether the class has an operation with the given name and signature mask that is covered. It retrieves the operations map for the given signature mask from the "operations" member variable. If the map is null, it returns false. If the map is not null, it retrieves the OperationStats object for the given operation name from the map. If the OperationStats object is null, it returns false. If the OperationStats object is not null, it returns the value of its "isCovered" method.
void function(Collection<UserModel> userModels) { for (UserModel userModel : userModels) { if (!updateUserModel(userModel)) { logger.error("Failed to update user model for user " + userModel.getUsername()); } } }
void function(String arg0, Throwable arg1) { String filterName = config.getFilterName(); String message = filterName + ": " + arg0; GenericServlet servlet = new GenericServlet() {}; servlet.log(message, arg1); }
private void function(Object arg0, Object arg1) { Object loc0 = null; Object loc1 = null; try { } catch (Exception e) { LOG.error("Error occurred in JsonControllerUtils.function", e); } }
void function(int arg0) { progressMonitor.curValue = arg0; } This method takes an integer argument "arg0" and sets the current value of the progress monitor to it. The current value is stored in the member variable "curValue".
String function() { return m_escapedJson; } This method returns the JSON string stored in the member variable "m_escapedJson". It takes no arguments and returns a String.
boolean function(NodeTester arg0) { NodeIterator nodeIterator = documentTraversal.createNodeIterator(rootNode, NodeFilter.SHOW_ALL, null, true); Node currentNode; while ((currentNode = nodeIterator.nextNode()) != null) { if (acceptNodeType(currentNode.getNodeType()) && arg0.test(currentNode)) { return true; } } return false; } This method takes a NodeTester instance as an argument and returns a boolean. It uses the DocumentTraversal API to iterate over all the nodes in the document starting from the root node. For each node, it checks if the node type is accepted by calling the acceptNodeType method, and if the node passes the NodeTester test by calling arg0.test(currentNode). If a node passes both tests, the method returns true. If no nodes pass the tests, the method returns false.
public BlockStoreContext function(InetSocketAddress arg0) { BlockStoreContext loc0 = CACHED_CONTEXTS.get(arg0); if (loc0 == null) { synchronized (CACHED_CONTEXTS) { loc0 = CACHED_CONTEXTS.get(arg0); if (loc0 == null) { loc0 = new BlockStoreContext(arg0, mBlockMasterClientPool, BLOCK_WORKER_THRIFT_CLIENT_POOL, BLOCK_WORKER_THRIFT_CLIENT_HEARTBEAT_POOL, NETTY_CHANNEL_POOL_MAP, mHasLocalWorker); CACHED_CONTEXTS.put(arg0, loc0); } } } return loc0; }
public void function() { setWriteCompressionMode(ImageWriteParam.MODE_EXPLICIT); setWriteCompressionType("JPEG"); setWriteCompressionQuality(writeCompressionQuality); setImageFormat("JPEG"); }
public String function(String omaQueryString) { String path = "/"; String params = removePath(omaQueryString); if (params != null) { path = createOmaLink(params); } return OMA_REDIRECT_LINK + "path=" + path; }
public void function(int port, ThreadingParameters threadingParameters) { if (threadingParameters == null) { LOG.warning("Null threading parameters are not allowed. Ignoring the call."); return; } JettyHTTPServerEngine engine = retrieveJettyHTTPServerEngine(port); if (engine == null) { LOG.warning("JettyHTTPServerEngine not found for port " + port + ". Ignoring the call."); return; } engine.setThreadingParameters(threadingParameters); LOG.fine("Threading parameters set for JettyHTTPServerEngine on port " + port); }
function(Language lang, CodeGenerator generator) { if (generators.containsKey(lang)) { LOG.info("Replacing generator for language " + lang); } generators.put(lang, generator); }
void function(String arg0, Object arg1) { context.setVariable(arg0, arg1); }
int function() { return index; }
void function() { if (bullets.size() < MAX_BULLETS && bulletTime <= 0) { bullets.add(new Bullet(xPos, yPos+0.2f, zPos, heading)); bulletTime = BULLET_INTERVAL; } }
public GetOfferDetailsResponse.Return.DetailOfferData.OfferDisplay function() { GetOfferDetailsResponse.Return.DetailOfferData.OfferDisplay loc0 = new GetOfferDetailsResponse.Return.DetailOfferData.OfferDisplay(); return loc0; }
public class RMConfiguration { private boolean sequenceSTRRequired; private Long acknowledgementInterval; private String rmNamespace; private String rm10AddressingNamespace; private boolean inOrder; private boolean exponentialBackoff; private DeliveryAssurance deliveryAssurance; private Long inactivityTimeout; private boolean sequenceTransportSecurityRequired; private Long baseRetransmissionInterval; public boolean isSequenceSTRRequired() { return sequenceSTRRequired; } public void setSequenceSTRRequired(boolean sequenceSTRRequired) { this.sequenceSTRRequired = sequenceSTRRequired; } public Long getAcknowledgementInterval() { return acknowledgementInterval; } public void setAcknowledgementInterval(Long acknowledgementInterval) { this.acknowledgementInterval = acknowledgementInterval; } public String getRMNamespace() { return rmNamespace; } public void setRMNamespace(String rmNamespace) { this.rmNamespace = rmNamespace; } public String getRM10AddressingNamespace() { return rm10AddressingNamespace; } public void setRM10AddressingNamespace(String rm10AddressingNamespace) { this.rm10AddressingNamespace = rm10AddressingNamespace; } public boolean isInOrder() { return inOrder; } public void setInOrder(boolean inOrder) { this.inOrder = inOrder; } public boolean isExponentialBackoff() { return exponentialBackoff; } public void setExponentialBackoff(boolean exponentialBackoff) { this.exponentialBackoff = exponentialBackoff; } public DeliveryAssurance getDeliveryAssurance() { return deliveryAssurance; } public void setDeliveryAssurance(DeliveryAssurance deliveryAssurance) { this.deliveryAssurance = deliveryAssurance; } public Long getInactivityTimeout() { return inactivityTimeout; } public void setInactivityTimeout(Long inactivityTimeout) { this.inactivityTimeout = inactivityTimeout; } public boolean isSequenceTransportSecurityRequired() { return sequenceTransportSecurityRequired; } public void setSequenceTransportSecurityRequired(boolean sequenceTransportSecurityRequired) { this.sequenceTransportSecurityRequired = sequenceTransportSecurityRequired; } public Long getBaseRetransmissionInterval() { return baseRetransmissionInterval; } public void setBaseRetransmissionInterval(Long baseRetransmissionInterval) { this.baseRetransmissionInterval = baseRetransmissionInterval; } /** * Get the number of milliseconds for the acknowledgment interval. */ public long function() { Long interval = getAcknowledgementInterval(); if (interval == null) { return 0; } else { return interval.longValue(); } } public long getInactivityTimeoutTime() { if (inactivityTimeout == null) { return 0; } else { return inactivityTimeout.longValue(); } } public String getAddressingNamespace() { return rm10AddressingNamespace; } public ProtocolVariation getProtocolVariation() { return ProtocolVariation.RM10WSA200408; } }
void function() { Iterator<ServerConnectionEventHandler.ClientConnection> iterator = server.getClientConnections().iterator(); while (iterator.hasNext()) { ServerConnectionEventHandler.ClientConnection client = iterator.next(); try { client.close(); } catch (IOException e) { } iterator.remove(); } }
public class Report { private Stack<String> should_report = new Stack<>(); private ErrorQueue eq; private String loader = "loader"; private Collection<String> topics = new LinkedHashSet<>(); private String errors = "errors"; private String types = "types"; private String dataflow = "dataflow"; private String debug = "debug"; private String context = "context"; private String serialize = "serialize"; private String verbose = "verbose"; private String imports = "imports"; private String visit = "visit"; private String resolver = "resolver"; private Map<String,Integer> reportTopics = new HashMap<>(); private String cfg = "cfg"; private boolean noReporting = true; private String frontend = "frontend"; private String time = "time"; public int level(String name) { } public void pushTopic(String topic) { } public void popTopic() { } public void addTopic(String topic, int level) { } public ErrorQueue getQueue() { } public void setTopic(String topic, int level) { } public boolean should_report(String topic, int level) { } public boolean should_report(String[] topics, int level) { } public boolean should_report(Collection<String> topics, int level) { } public void setQueue(ErrorQueue eq) { } public void function(Position pos, int level, String message) { if (should_report(debug, level)) { ErrorInfo err = new ErrorInfo(message, level, pos); eq.enqueue(err); } } }
public Access function() { return new Access(); }
public class TestResultDetailsDTO { private Long expectedDataSetId; private String errorCode; private String errorMsg; private Long dataSetId; private Long dataUnitId; private String actualValue; private Long testId; private String failedAttributeName; private String srcFileName; private Long expectedDataUnitId; private Long seqNo; private String expectedValue; public String getFailedAttributeName() { return this.failedAttributeName; } public void setTestId(Long testId) { this.testId = testId; } public String getActualValue() { return this.actualValue; } public void setDataSetId(Long dataSetId) { this.dataSetId = dataSetId; } public String getErrorMsg() { return this.errorMsg; } public Long getExpectedDataSetId() { return this.expectedDataSetId; } public String getSrcFileName() { return this.srcFileName; } public Long getDataSetId() { return this.dataSetId; } public void setExpectedDataUnitId(Long expectedDataUnitId) { this.expectedDataUnitId = expectedDataUnitId; } public void setExpectedValue(String expectedValue) { this.expectedValue = expectedValue; } public void setActualValue(String actualValue) { this.actualValue = actualValue; } public Long getExpectedDataUnitId() { return this.expectedDataUnitId; } public Long getSeqNo() { return this.seqNo; } public Long getTestId() { return this.testId; } public Long getDataUnitId() { return this.dataUnitId; } public void setSeqNo(Long seqNo) { this.seqNo = seqNo; } public void setErrorMsg(String errorMsg) { this.errorMsg = errorMsg; } public String getExpectedValue() { return this.expectedValue; } public void setSrcFileName(String srcFileName) { this.srcFileName = srcFileName; } public String getErrorCode() { return this.errorCode; } public void setDataUnitId(Long dataUnitId) { this.dataUnitId = dataUnitId; } public void setExpectedDataSetId(Long expectedDataSetId) { this.expectedDataSetId = expectedDataSetId; } public void setErrorCode(String errorCode) { this.errorCode = errorCode; } public void setFailedAttributeName(String failedAttributeName) { this.failedAttributeName = failedAttributeName; } }
public class ShellBasedUnixGroupsMapping { public List<String> function(String username) { List<String> groups = new ArrayList<>(); return groups; } }
void function() { try { byte[] loc0 = new byte[0]; while (true) { int loc1 = clientSession.pollAck(); if (loc1 == -1) { break; } } clientSession.acknowledge(); while (clientSession.hasOutstanding()) { int loc2 = clientSession.getAvailable(); byte[] loc3 = new byte[loc2]; int loc4 = clientSession.receive(loc3); if (loc4 == -1) { break; } loc0 = ArrayUtils.addAll(loc0, loc3); } if (loc0.length > 0) { sendBlocking(loc0); } } catch (Exception e) { logger.warn("Failed to flush outstanding data", e); } }
void function(String text) { if (HAS_REMOTE_CONTROL_APIS) { try { MetadataEditorCompat loc0 = editMetadata(false); loc0.putString(METADATA_KEY_DISPLAY_TITLE, text); loc0.apply(); } catch (Exception e) { } } else { } }
void function() { cmd.landing(); waitFor(spinTime); onStop(); batLvl = 0; }
void function(Map<String, String> metadata) { this.metadata = metadata; }
public class RMCTest { RMCParser empty; String EXAMPLE = "$GPRMC,120044.567,A,6011.552,N,02501.941,E,000.0,360.0,160705,006.1,E,A*0B"; RMCParser rmc; void function() { } }
