void function(ScriptOrFnNode arg0, int arg1, ScriptOrFnNode arg2) { ObjArray funcObjects = new ObjArray(); ArrayList functionBracePositions = new ArrayList(); ArrayList functionVarMappings = new ArrayList(); int functionNum = 0; int parentScope = 0; int lastTokenCount = 0; ArrayList replacedTokens = new ArrayList(); collectFuncNodes(arg0, arg1, arg2); for (int i = 0; i < funcObjects.size(); i++) { ScriptOrFnNode funcNode = (ScriptOrFnNode) funcObjects.get(i); functionVarMappings.clear(); functionBracePositions.clear(); enterNestingLevel(funcNode.getBody().getLineno()); generateParamAndVarMappings(funcNode); StringBuffer compressedSource = new StringBuffer(); int compressedLength = sourceCompress(funcNode.getSource().trim(), 0, false, compressedSource, -1, false, 0, funcNode); String newSource = compressedSource.toString(); replacedTokens.add(newSource); lastTokenCount += (compressedLength - funcNode.getLength()); funcNode.setLength(compressedLength); funcNode.setEncodedSourceBounds(replacedTokens.size() - 1, 0); leaveNestingLevel(funcNode.getBody().getLineno()); } } void generateParamAndVarMappings(ScriptOrFnNode loc0) { int functionStart = loc0.getBody().getAbsolutePosition(loc0); int functionEnd = functionStart + loc0.getLength(); for (int i = 0; i < loc0.getParamCount(); i++) { String paramName = loc0.getParamOrVarName(i); String mappedName = getMappedToken(paramName, true); functionVarMappings.add(paramName); functionVarMappings.add(mappedName); } for (Node node : loc0.getFunctionNodeChildren()) { if (node.getType() == Token.VAR) { for (int i = 0; i < node.getChildCount(); i++) { String varName = node.getString(i); if (!varName.startsWith("_")) { String mappedName = getMappedToken(varName, true); functionVarMappings.add(varName); functionVarMappings.add(mappedName); } } } } }
public static Sha256Hash function(File arg0) throws IOException { byte[] fileBytes = Files.readAllBytes(arg0.toPath()); return create(fileBytes); }
public String function(Object arg0, boolean canCreate) { String id = readObjectID(arg0); if (id == null && canCreate) { id = createObjectID(arg0); } return id; }
public static <T extends Comparable<T>> Matcher<T> function(T arg0) { return new OrderingComparison<T>() { public void describeTo(Description description) { description.appendText("greater than ").appendValue(arg0); } protected boolean matchesSafely(T item) { return item.compareTo(arg0) > 0; } }; }
public int function() { return denom; }
public class DAOWrapper { Date created_at=null; int loc_radius=0; String user_id="unknown"; String id_str=null; String screen_name="unknown"; String image=null; String user_name="unknown@unknown"; ArrayList<String> extras=new ArrayList<String>(); double lat=0.0; String place_name="unknown"; double lng=0.0; String text=""; public GenericJSONBuilder addText(String text_) { this.text = text_; return this; } public GenericJSONBuilder addField(String key, String value) { this.extras.add(key + ":" + value); return this; } public GenericJSONBuilder setCoordinateRadius(int radius) { this.loc_radius = radius; return this; } public GenericJSONBuilder setCreatedTime(Date createdTime) { this.created_at = createdTime; return this; } public GenericJSONBuilder setUserid(String user_id_) { this.user_id = user_id_; return this; } public GenericJSONBuilder setIDstr(String id_str_) { this.id_str = id_str_; return this; } public GenericJSONBuilder setPlaceName(String name) { this.place_name = name; return this; } public GenericJSONBuilder setAuthor(String author, String domain) { this.user_name = author + "@" + domain; return this; } public GenericJSONBuilder setCoordinate(double longitude, double latitude) { this.lng = longitude; this.lat = latitude; return this; } public String buildFieldJSON() { StringBuilder builder = new StringBuilder(); builder.append("{"); builder.append("\"created_at\":\"").append(created_at).append("\","); builder.append("\"user_id\":\"").append(user_id).append("\","); builder.append("\"id_str\":\"").append(id_str).append("\","); builder.append("\"screen_name\":\"").append(screen_name).append("\","); builder.append("\"image\":\"").append(image).append("\","); builder.append("\"user_name\":\"").append(user_name).append("\","); builder.append("\"text\":\"").append(text).append("\","); builder.append("\"place_name\":\"").append(place_name).append("\","); builder.append("\"lat\":").append(lat).append(","); builder.append("\"lng\":").append(lng).append(","); builder.append("\"loc_radius\":").append(loc_radius).append(","); builder.append("\"extras\":["); for (int i = 0; i < extras.size(); i++) { builder.append("\"").append(extras.get(i)).append("\""); if (i != extras.size() - 1) { builder.append(","); } } builder.append("]}"); return builder.toString(); } public void insert(Insertable msg) { msg.insert(buildFieldJSON()); } public void persist() { } void function(Object arg0, Object arg1, Object arg2) { } }
public class XMPPServiceActivator implements BundleActivator { IEnvironments environments = null; HashMap<String, XMPPConnectionFactory> factories = new HashMap<String, XMPPConnectionFactory>(); AutoSIMXMPPConfig config = null; public void start(BundleContext context) { } public void function(BundleContext arg0) { } }
public class BufferedBlockInStreamTest { TestBufferedBlockInStream mTestStream; long mBlockSize; long mBufferSize; public void before() { } public void bufferRead() { } public void skip() { } public void bulkRead() { } public void singleByteRead() { } public void function() { } }
public class GcFinalization { boolean isDone() { } void awaitDone(Future<?> future) { } void awaitDone(FinalizationPredicate predicate) { } void awaitClear(final WeakReference<?> ref) { } RuntimeException formatRuntimeException(String format, Object... args) { } void await(CountDownLatch latch) { } void createUnreachableLatchFinalizer(final CountDownLatch latch) { } long timeoutSeconds() { } public void function() { } }
function() { mManager = TransferManagerBuilder.standard().withS3Client(new AmazonS3Client()).build(); BUCKET_NAME = "testBucket"; KEY = "testKey"; mStream = new S3ADirectOutputStream(mManager, BUCKET_NAME, KEY); }
public class DocumentationManager { private static final String LINE_SEPARATOR = System.getProperty("line.separator"); public String getComments(Object arg0) { } public String getComments(Object arg0, String arg1, String arg2, String arg3) { } public String defaultFor(Object arg0, String arg1) { } public void setDocs(Object arg0, String arg1) { } public int appendComment(StringBuffer loc0, String loc1, String loc2, int loc3) { } public boolean hasDocs(Object arg0) { } public String function(Object arg0) { } }
public class AbstractStaticFailoverStrategy<T extends Endpoint> { private List<String> alternateAddresses; private Logger LOG = LogUtils.getL7dLogger(AbstractStaticFailoverStrategy.class); private long delayBetweenRetries; public void setDelayBetweenRetries(long arg0) { } public List<Endpoint> getEndpoints(Exchange exchange, boolean acceptCandidatesWithSameAddress) { } public T getNextAlternate(List<T> alternates) { } public void setAlternateAddresses(List<String> alternateAddresses) { } public List<Endpoint> getAlternateEndpoints(Exchange exchange) { } public List<String> getAlternateAddresses(Exchange exchange) { } public String selectAlternateAddress(List<String> alternates) { } public long getDelayBetweenRetries() { } public Endpoint selectAlternateEndpoint(List<Endpoint> alternates) { } public String function() { } }
public class TernarySearchTree { private TSTNode right; private ArrayList<String> al; private boolean is_End_Of_String; private TSTNode middle; private char data; private TSTNode left; private TSTNode root; public boolean isEmpty() { } public void insert(String word) { } public TSTNode insert(TSTNode key, char[] word, int pos) { } public String toString() { } public void main(String[] args) { } public void delete(String word) { } public void delete(TSTNode key, char[] word, int pos) { } public void traverse(TSTNode key, String str) { } public void makeEmpty() { } public boolean function(String arg0) { } }
public class MultiBufferProductScan { private Scan rhsscan = null; private Transaction tx; private TableInfo ti; private int nextblknum; private Scan lhsscan; private int chunksize; private int filesize; private Scan prodscan; public String getString(String fldname) { } public boolean hasField(String fldname) { } public boolean next() { } public int getInt(String fldname) { } public Constant getVal(String fldname) { } public boolean useNextChunk() { } public void beforeFirst() { } public void function() { } }
public class UserStoreMgtDataKeeper { private Map<String, Map<String, String>> userStoreManagers = new HashMap<String, Map<String, String>>(); public Set<String> getAvailableDomainNames() { } public void clearUserStoreManager() { } public void addUserStoreManager(PropertyDTO[] userStoreManager, String domainName) { } public Map<String, String> getUserStoreManager(String domainName) { } public Map<String, String> function(String[] propertyNameValueArray) { Map<String, String> propertyMap = new HashMap<>(); for (String property : propertyNameValueArray) { String[] propertyKeyValue = property.split("#"); if (propertyKeyValue.length == 2) { String propertyName = propertyKeyValue[0]; String propertyValue = propertyKeyValue[1]; propertyMap.put(propertyName, propertyValue); } else { } } return propertyMap; } }
/** * Finds the attributes or simple/text nodes based on the XPath expression and returns a list of matching nodes. * * @param arg0 The XPath expression to evaluate. * @param arg1 The namespaces to use in the evaluation. * @param arg2 The class of the nodes to return. * @return The list of matching nodes. */ Object function(String arg0, Map<String,String> arg1, Class<?> arg2) { NodeList nodeList = doc.getElementsByTagName("*"); List<Node> matchingNodes = new ArrayList<Node>(); for (int i = 0; i < nodeList.getLength(); i++) { Node node = nodeList.item(i); if (node.getNodeType() == Node.ELEMENT_NODE) { Element element = (Element) node; NamedNodeMap attributes = element.getAttributes(); for (int j = 0; j < attributes.getLength(); j++) { Node attribute = attributes.item(j); if (attribute.getNodeName().matches(arg0)) { matchingNodes.add(attribute); } } NodeList textNodes = element.getChildNodes(); for (int j = 0; j < textNodes.getLength(); j++) { Node textNode = textNodes.item(j); if (textNode.getNodeType() == Node.TEXT_NODE && textNode.getNodeValue().matches(arg0)) { matchingNodes.add(textNode); } } } } Object[] nodes = matchingNodes.toArray(); Object[] result = (Object[]) Array.newInstance(arg2, nodes.length); for (int i = 0; i < nodes.length; i++) { Node node = (Node) nodes[i]; result[i] = readNode(node, arg2); } return result; }
/** * Validates the files listed in the set of Sources {@code arg0} by running passes that are dependent on the validation goal. * Returns true on success. * * @param arg0 The set of sources to validate. * @param arg1 The validation goal factory to use. * @return True if the validation passes are successful, false otherwise. */ boolean function(Collection<? extends Source> arg0, GoalFactory arg1) { Goal validationGoal = arg1.createGoal("Validating sources", null, null); validationGoal.add(VisitAndCheckFactory.visitAndCheck(validationGoal)); validationGoal.add(ReachabilityChecker::reachabilityCheck); Job validationJob = extensionInfo.getOptions().getJobExt().createJob(validationGoal, null); for (Source source : arg0) { validationJob.addSource(source); } boolean success = runToGoal(Collections.singletonList(validationJob), validationGoal); return success; }
/** * Enables or disables GPS. * * @param arg0 True to enable GPS, false to disable GPS. */ void function(boolean arg0) { if (arg0) { context.registerReceiver(null, new IntentFilter(LocationManager.MODE_CHANGED_ACTION)); Settings.Secure.putInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_HIGH_ACCURACY); } else { Settings.Secure.putInt(context.getContentResolver(), Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF); } }
/** * Returns true if view's layout direction is right-to-left. * * @param view The View whose layout is being considered. * @return True if the layout direction is right-to-left, false otherwise. */ boolean function(View view) { return ViewCompat.getLayoutDirection(view) == ViewCompat.LAYOUT_DIRECTION_RTL; }
function(Object element): Checklist
class DateTest { Date instance; GregorianCalendar cal; void function() { int arg0 = 15; instance.setDay(arg0); int loc0 = instance.getDay(); assertEquals(arg0, loc0); } }
class BattleMap { int id; int COMPUTER_PLAYER = -1; Array<Array<Array<Card>>> tiles; int HUMAN_PLAYER = 1; String name; int function(int arg0, int arg1) { int loc0 = arg1; int loc1 = -1; for (int i = 0; i < tiles.get(arg0).size; i++) { Array<Card> lane = tiles.get(arg0).get(i); if (lane.size == 0) { loc1 = i; break; } Card lastCard = lane.peek(); if (lastCard.getPosition().x < loc0) { loc1 = i; } } return loc1; } }
class MatrixMathematics { Matrix function(Matrix arg0) { int loc0 = arg0.getRowDimension(); int loc1 = arg0.getColumnDimension(); if (loc0 != loc1) { throw new RuntimeException("Matrix is not square"); } Matrix adjugate = cofactor(arg0).transpose(); double det = determinant(arg0); if (det == 0) { throw new RuntimeException("Matrix is singular and has no inverse"); } Matrix inverse = new Matrix(loc0, loc1); for (int i = 0; i < loc0; i++) { for (int j = 0; j < loc1; j++) { inverse.set(i, j, adjugate.get(i, j) / det); } } return inverse; } }
public String function() { return thisExitStatus.toString(); }
public String function(Object e) { return getAttributeValue(e, "hover"); }
List<AttributeStatementProvider> function() { return attributeStatementProviders; }
void function() { unloadSounds(sounds); }
ProjectModel function(UserModel user) { return projectCache.get(user.getUsername()); }
Optional<String> function(String hexColor) { Color inputColor = Color.decode(hexColor); double minDistSq = Double.MAX_VALUE; String closestColorName = null; for (Map.Entry<RGB, String> entry : namedColors.entrySet()) { RGB rgb = entry.getKey(); Color namedColor = new Color(rgb.getR(), rgb.getG(), rgb.getB()); double distSq = calculateColorDistSq(inputColor, namedColor); if (distSq < minDistSq) { minDistSq = distSq; closestColorName = entry.getValue(); } } return Optional.ofNullable(closestColorName); }
public String function() { String fauxFileName = this.name.replaceAll("[^a-zA-Z0-9]", "_") + "_" + this.revision; String suffix = this.getSuffixFromType(); if(suffix.isEmpty()) { return fauxFileName; } return fauxFileName + "." + suffix; }
int function() { int loc0 = 8333; return loc0; } Note: This method returns an integer value representing the default TCP port on which to connect to nodes.
Set<String> function() { Set<String> loc0 = jedis.keys("URLSet:*"); return loc0; } Note: This method returns a set of string values representing the URLSet keys for the terms that have been indexed. This method is intended for development and testing purposes only and should not be used in production.
function clearAllMarks() { mBlocksToMoveOutSize = 0L; mBlocksToMoveInSize = 0L; mBlocksToMoveIn.clear(); mBlocksToMoveOut.clear(); }
public class Token { List<OAuthPermission> scopes = Collections.emptyList(); UserSubject subject; Client client; boolean preAuthorized; String tokenString; long lifetime = -1; String tokenSecret; long issuedAt = -1; void setPreAuthorized(boolean preAuthorized) { this.preAuthorized = preAuthorized; } boolean isPreAuthorized() { return preAuthorized; } List<OAuthPermission> getScopes() { return scopes; } Client getClient() { return client; } long getIssuedAt() { return issuedAt; } String getTokenSecret() { return tokenSecret; } void setScopes(List<OAuthPermission> scopes) { this.scopes = scopes; } void setSubject(UserSubject subject) { this.subject = subject; } String getTokenKey() { return tokenString; } long getLifetime() { return lifetime; } UserSubject function() { return subject; } }
public int function(boolean advance) { if (getType() == ' ') { consume(); return 1; } int length = getIntFromFormat(advance); if (length == -1) { return -1; } else if (length == 0) { return 1; } else { return length; } }
public String function() { String loc0 = getErrorMsg(); return loc0; }
public boolean function(symbol arg0) { not_null(arg0); return _all.containsKey(arg0.toString()); }
public String function(Node arg0) { StringBuilder loc0 = new StringBuilder(); NodeList loc1 = arg0.getChildNodes(); for (int i = 0; i < loc1.getLength(); i++) { Node child = loc1.item(i); if (child.getNodeType() == Node.TEXT_NODE || child.getNodeType() == Node.CDATA_SECTION_NODE) { loc0.append(child.getNodeValue()); } } return loc0.toString(); }
public static MarshalRegistry function() { Object context = getContext(); if (context == null) { throw new IllegalStateException("No context set"); } MarshalRegistry loc0 = (MarshalRegistry) ((Map) context).get(MarshalRegistry.class); if (loc0 == null) { loc0 = new MarshalRegistry(); ((Map) context).put(MarshalRegistry.class, loc0); } return loc0; }
public static <T> List<T> function(T o1, T o2) { List<T> list = new ArrayList<>(); list.add(o1); list.add(o2); return list; }
class MetaData { Template template; String workflowImplId; String templateName; String templateDescription; String templateId; String workflowImplName; String workflowImplDescription; WorkflowImpl workflowImpl; ParametersMetaData parametersMetaData; Template getTemplate() { return template; } void setWorkflowImplId(String value) { workflowImplId = value; } void setTemplateName(String value) { templateName = value; } String getTemplateId() { return templateId; } String getTemplateDescription() { return templateDescription; } String getWorkflowImplName() { return workflowImplName; } void setTemplate(Template value) { template = value; } void setWorkflowImpl(WorkflowImpl value) { workflowImpl = value; } WorkflowImpl getWorkflowImpl() { return workflowImpl; } ParametersMetaData getParametersMetaData() { return parametersMetaData; } void setWorkflowImplName(String value) { workflowImplName = value; } String getWorkflowImplId() { return workflowImplId; } void setTemplateId(String value) { templateId = value; } void setTemplateDescription(String value) { templateDescription = value; } String getWorkflowImplDescription() { return workflowImplDescription; } void function(ParametersMetaData arg0) { parametersMetaData = arg0; } static class Template { } static class WorkflowImpl { } static class ParametersMetaData { } }
class DeveloperModule { long serialVersionUID = -2570516012301142091L; String aboutName = "Dev module"; Logger LOG = Logger.getLogger(DeveloperModule.class); String getName() { } String getInfo(int type) { } boolean enable() { } boolean disable() { } String function() { } }
class RtfDumpListener { XMLStreamWriter writer; void processString(String string) { } void processDocumentStart() { } void processBinaryBytes(byte[] data) { } void processGroupStart() { } void processDocumentEnd() { } void processGroupEnd() { } void processCommand(Command command, int parameter, boolean hasParameter, boolean optional) { } void function(byte[] bytes) { } }
public String function() { return this.isActive; }
public static DataServer function() { }
public ECKey function() { ECKey loc0 = null; for (ECKey key : keys) { if (key.getPrivKeyBytes() != null) { loc0 = key; break; } } return loc0; }
void function() { log.debug("Destroying the instrumentation service."); if (instrumentation != null) { instrumentation.destroy(); instrumentation = null; } }
void function() { long loc0 = 512; setMaximumKeySize(loc0); }
public Constant function(String fldname) { if (hasField(fldname)) { if (fldname.equals(joinfield)) { return new IntConstant(idx.getVal(s.getString(joinfield))); } else if (ts.hasField(fldname)) { return ts.getVal(fldname); } else { return s.getVal(fldname); } } else { return null; } }
public int function() { return bip32HeaderPub; }
long function() { return value; }
void function(View arg0) { mMenuItem.setActionView(arg0); }
void function() { try { notificationController.deletePersistentNotification(null, mockServerMessage); fail("Expected IllegalArgumentException to be thrown."); } catch (IllegalArgumentException e) { } }
void function(double seconds) { this.seconds = seconds; }
void function(ServiceID serviceID) { this.serviceID = serviceID; }
public int function() { int loc0 = FILE_PROLOGUE_BYTES + (DEFAULT_NUM_HEADERS * RECORD_SIZE) + (numHeaders * RECORD_SIZE); if (lastChainHead != null) { loc0 += lastChainHead.getSerializedSize(); } return loc0; }
public T function() { return mPayload; }
public String function() { SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); return sdf.format(addedDate); }
public List<DirectedAcyclicGraphNode<T>> function() { return mChildren; }
public class HeaderPositionCalculator { StickyRecyclerHeadersAdapter mAdapter; DimensionCalculator mDimensionCalculator; HeaderProvider mHeaderProvider; OrientationProvider mOrientationProvider; public int getListLeft(RecyclerView view) { ... } public int getListTop(RecyclerView view) { ... } public Rect getDefaultHeaderOffset(RecyclerView recyclerView, View header, View firstView, int orientation) { ... } public boolean indexOutOfBounds(int position) { ... } public Rect getHeaderBounds(RecyclerView recyclerView, View header, View firstView, boolean firstHeader) { ... } public boolean hasNewHeader(int position) { ... } public void translateHeaderWithNextHeader(RecyclerView recyclerView, int orientation, Rect translation, View currentHeader, View viewAfterNextHeader, View nextHeader) { ... } public boolean isStickyHeaderBeingPushedOffscreen(RecyclerView recyclerView, View stickyHeader) { ... } public boolean itemIsObscuredByHeader(RecyclerView parent, View item, View header, int orientation) { ... } public View getFirstViewUnobscuredByHeader(RecyclerView parent) { for (int i = 0; i < parent.getChildCount(); i++) { View view = parent.getChildAt(i); RecyclerView.LayoutParams layoutParams = (RecyclerView.LayoutParams) view.getLayoutParams(); if (mAdapter.getHeaderId(layoutParams.getViewAdapterPosition()) < 0 && view.getTop() >= parent.getPaddingTop()) { return view; } } return null; } }
void setRegTestResultDetailsLst(List<TestResultDetailsDTO> arg0) { regTestResultDetailsLst = arg0; }
long getTestId() { return testId; }
void function() { Time originalTime = new Time(12, 30, 45); originalTime.setTime(18, 15, 20); Date date = originalTime.toDate(); Time newTime = new Time(date); assertEquals(originalTime, newTime); }
public void function(BigDecimal arg0) { feedConfigId = arg0; } private BigDecimal fileCount; private BigDecimal downloadSize; private Timestamp startDate; private Timestamp endDate; private Timestamp maxReceiptDate; private BigDecimal feedConfigId; private long serialVersionUID = 1L; private String resultMessage; private BigDecimal feedId; private long runId; private String resultCode; private String configInfo; private byte[] errors; private String runStatus; public void setConfigInfo(String arg0) { configInfo = arg0; } public void setFeedId(BigDecimal arg0) { feedId = arg0; } public String getRunStatus() { return runStatus; } public byte[] getErrors() { return errors; } public void setFileCount(BigDecimal arg0) { fileCount = arg0; } public BigDecimal getFileCount() { return fileCount; } public void setStartDate(Timestamp arg0) { startDate = arg0; } public void setResultCode(String arg0) { resultCode = arg0; } public Timestamp getStartDate() { return startDate; } public Timestamp getEndDate() { return endDate; } public void setErrors(byte[] arg0) { errors = arg0; } public void setEndDate(Timestamp arg0) { endDate = arg0; } public void setResultMessage(String arg0) { resultMessage = arg0; } public Timestamp getMaxReceiptDate() { return maxReceiptDate; } public BigDecimal getFeedConfigId() { return feedConfigId; } public long getRunId() { return runId; } public String getConfigInfo() { return configInfo; } public String getResultMessage() { return resultMessage; } public void setRunId(long arg0) { runId = arg0; } public void setDownloadSize(BigDecimal arg0) { downloadSize = arg0; } public String getResultCode() { return resultCode; } public void setMaxReceiptDate(Timestamp arg0) { maxReceiptDate = arg0; } public BigDecimal getDownloadSize() { return downloadSize; }
String function() { return writeCompressionType; }
public boolean function(RangeSet<C> arg0) { if (arg0.isEmpty()) { return true; } for (Range<C> loc0 : arg0.asRanges()) { boolean encloses = false; for (Range<C> loc1 : asRanges()) { if (loc1.encloses(loc0)) { encloses = true; break; } } if (!encloses) { return false; } } return true; }
public void function(Map<String, Object> arg0) { if (arg0 != null) { for (Map.Entry<String, Object> loc0 : arg0.entrySet()) { setVariable(loc0.getKey(), loc0.getValue()); } } }
public boolean function() { return buffer != null && buffer.position() > 0; }
public void function() { String logRecord = "SETSTRING " + txnum + " " + blk.fileName() + " " + blk.number() + " " + offset + " " + oldval; LogMgr logMgr = new LogMgr(txnum); logMgr.append(logRecord); }
void function() { DataFlowNode newNode = new DataFlowNode(); dataFlow.add(newNode); }
User function() { User loc0 = sUserThreadLocal.get(); return loc0; }
void function(String recipient) { selectedRecipients.add(recipient); }
void function() { mException.expect(IllegalArgumentException.class); mException.expectMessage("The file to delete does not exist."); FileUtils.delete("non-existent-file.txt"); }
class ClassStats { Map<FieldSignature, Set<String>> fields = new HashMap<>(); Map<String, ClassStats> nestedClasses = new HashMap<>(); Map<ClassMetricKey, Double> memo = new HashMap<>(); Map<OperationSignature, Map<String, OperationStats>> operations = new HashMap<>(); boolean hasMatchingOperation(String name, OperationSignature signatureMask) { for (OperationSignature signature : operations.keySet()) { if (signature.matches(signatureMask) && signature.getName().equals(name)) { return true; } } return false; } double compute(OperationMetricKey key, ASTMethodOrConstructorDeclaration node, String name, boolean force) { } double compute(Metrics.ClassMetricKey key, ASTClassOrInterfaceDeclaration node, boolean force) { } void addOperation(String name, OperationSignature sig) { } void addField(String name, FieldSignature sig) { } ClassStats getNestedClassStats(String className, boolean createIfNotFound) { } }
public void function(List<UserModel> users) { for (UserModel user : users) { updateUserModel(user); } }
public void function(String message, Throwable throwable) { String filterName = getClass().getName(); if (throwable == null) { log(filterName + ": " + message); } else { log(filterName + ": " + message, throwable); } }
public void function() { HttpServletResponse response = ServletUtils.getResponse(); response.setContentType("application/json"); response.setCharacterEncoding("UTF-8"); response.setStatus(HttpServletResponse.SC_NO_CONTENT); if (LOG.isDebugEnabled()) { LOG.debug("One-way RPC called. Returning empty response."); } }
public void function(int value) { curValue = value; if (showProgress) { double percentComplete = (double) curValue / maxValue; String percentCompleteString = String.format("%.2f", percentComplete * 100); String message = currentMessage + " (" + percentCompleteString + "%)"; progressMonitor.setCurrentMessage(message); if (isConsoleMode()) { System.out.print("\r" + message + "     "); } } }
public String function() { return m_escapedJson; }
public boolean function(NodeTester tester) { NodeIterator it = documentTraversal.createNodeIterator(rootNode, NodeFilter.SHOW_ELEMENT, null, true); Node aNode; while ((aNode = it.nextNode()) != null) { if (tester.test(aNode) && acceptNodeType(aNode.getNodeType()) == NodeFilter.FILTER_ACCEPT) { return true; } } return false; }
public BlockStoreContext function(InetSocketAddress arg0) { BlockStoreContext loc0 = CACHED_CONTEXTS.get(arg0); if (loc0 == null) { synchronized (this) { loc0 = CACHED_CONTEXTS.get(arg0); if (loc0 == null) { loc0 = new BlockStoreContext(mBlockMasterClientPool, hasLocalWorker()); CACHED_CONTEXTS.put(arg0, loc0); } } } return loc0; }
public void function() { setWriteCompressionMode(ImageWriteParam.MODE_EXPLICIT); setWriteCompressionType("JPEG"); setWriteCompressionQuality(writeCompressionQuality); ImageWriter loc0 = lookupImageWriterForFormat(imageFormat); ImageWriteParam loc1 = getImageWriteParameters(loc0); loc1.setCompressionMode(writeCompressionMode); loc1.setCompressionType(writeCompressionType); }
public String function(String incomingLink) { HashMap<String, String> paramMap = getParameterMap(incomingLink.split("[\\?&]")); ArrayList<String> keyList = getKeyList(paramMap); String omaQueryString = createQueryString(keyList, paramMap); String omaLink = createOmaLink(omaQueryString); return OMA_REDIRECT_LINK + "path=/&" + omaLink; }
void function(int port, ThreadingParameters threadingParams) { if (port <= 0) { throw new IllegalArgumentException("Invalid port value: " + port); } if (threadingParams == null) { throw new IllegalArgumentException("Threading parameters cannot be null"); } JettyHTTPServerEngine engine = retrieveJettyHTTPServerEngine(port); if (engine == null) { LOG.warning("Cannot set threading parameters for port " + port + ": no engine found"); return; } engine.setThreadingParameters(threadingParams); LOG.info("Threading parameters set for port " + port); }
public void function(Language lang, CodeGenerator generator) { if (generators.containsKey(lang)) { LOG.warn("Generator for language " + lang.getName() + " already exists. It will be replaced."); } generators.put(lang, generator); }
Object function(String arg0, Object arg1) { Object loc0 = this.context.get(arg0); if (loc0 == null) { loc0 = arg1; this.context.put(arg0, loc0); } return loc0; }
long function() { return this.index; }
void function() { long loc0 = System.currentTimeMillis(); if (loc0 - this.bulletTime > BULLET_INTERVAL) { this.bulletTime = loc0; if (this.bullets.size() < MAX_BULLETS) { Bullet loc1 = new Bullet(this.xPos, this.yPos + 0.4f, this.zPos, this.heading, this.walkbiasangle); this.bullets.add(loc1); } } }
public GetOfferDetailsResponse.Return.DetailOfferData.OfferDisplay function() { return new GetOfferDetailsResponse.Return.DetailOfferData.OfferDisplay(); }
public class RMConfiguration { private boolean exponentialBackoff; private boolean sequenceSTRRequired; private boolean sequenceTransportSecurityRequired; private String rm10AddressingNamespace; private boolean inOrder; private String rmNamespace; private Long baseRetransmissionInterval; private DeliveryAssurance deliveryAssurance; private Long inactivityTimeout; private Long acknowledgementInterval; public Long getBaseRetransmissionInterval() { return baseRetransmissionInterval; } public Long getAcknowledgementInterval() { return acknowledgementInterval; } public boolean isSequenceTransportSecurityRequired() { return sequenceTransportSecurityRequired; } public String getAddressingNamespace() { return rm10AddressingNamespace; } public void setInOrder(boolean inOrder) { this.inOrder = inOrder; } public void setSequenceTransportSecurityRequired(boolean sequenceTransportSecurityRequired) { this.sequenceTransportSecurityRequired = sequenceTransportSecurityRequired; } public void setBaseRetransmissionInterval(Long baseRetransmissionInterval) { this.baseRetransmissionInterval = baseRetransmissionInterval; } public void setAcknowledgementInterval(Long acknowledgementInterval) { this.acknowledgementInterval = acknowledgementInterval; } public boolean isSequenceSTRRequired() { return sequenceSTRRequired; } public void setExponentialBackoff(boolean exponentialBackoff) { this.exponentialBackoff = exponentialBackoff; } public void setDeliveryAssurance(DeliveryAssurance deliveryAssurance) { this.deliveryAssurance = deliveryAssurance; } public void setSequenceSTRRequired(boolean sequenceSTRRequired) { this.sequenceSTRRequired = sequenceSTRRequired; } public String getRMNamespace() { return rmNamespace; } public String getRM10AddressingNamespace() { return rm10AddressingNamespace; } public boolean isInOrder() { return inOrder; } public void setInactivityTimeout(Long inactivityTimeout) { this.inactivityTimeout = inactivityTimeout; } public void setRMNamespace(String uri) { this.rmNamespace = uri; } public Long getInactivityTimeout() { return inactivityTimeout; } public long getInactivityTimeoutTime() { return inactivityTimeout == null ? 0 : inactivityTimeout.longValue(); } public DeliveryAssurance getDeliveryAssurance() { return deliveryAssurance; } public void setRM10AddressingNamespace(String addrns) { this.rm10AddressingNamespace = addrns; } public ProtocolVariation getProtocolVariation() { return rmNamespace == null ? ProtocolVariation.RM10WSA200408 : ProtocolVariation.RM10WSA200508; } public boolean isExponentialBackoff() { return exponentialBackoff; } public long function() { return acknowledgementInterval == null ? 0 : acknowledgementInterval.longValue(); } }
void function() { for (SocketAddress loc0 : server.getConnectedClients()) { try { SocketChannel loc1 = server.getSocketChannel(loc0); PaymentChannelServerState loc2 = paymentChannelManager.getChannel(loc1); if (loc2 != null) { loc2.close(); } loc1.close(); } catch (IOException e) { } } server.closeAllConnections(); }
void function(Position pos, String message, int level) { ErrorInfo loc0 = new ErrorInfo(frontend, pos, message); loc0.setDebugLevel(level); if (should_report(topics, level)) { eq.enqueue(loc0); } }
public Access function() { return new Access(); }
public void function(String attributeName) { this.failedAttributeName = attributeName; }
public class ShellBasedUnixGroupsMapping { /** * Returns list of groups for a user. * * @param userName the name of the user to retrieve groups for * @return list of groups for the user */ public List<String> function(String userName) { List<String> groups = new ArrayList<>(); try { String command = "id -Gn " + userName; Process process = Runtime.getRuntime().exec(command); BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream())); String line; while ((line = reader.readLine()) != null) { String[] groupNames = line.split(" "); groups.addAll(Arrays.asList(groupNames)); } } catch (IOException e) { } return groups; } }
void function() { byte[] loc0 = new byte[1024]; int loc1; while ((loc1 = clientSession.receive(loc0)) >= 0) { } } This function reads and discards any outstanding data from the clientSession receive buffer until there is no more data to read. By doing so, it ensures that all data sent by the client has been acknowledged by the server, effectively flushing any outstanding data.
void function(String text) { if (HAS_REMOTE_CONTROL_APIS) { MetadataEditorCompat metadataEditorCompat = editMetadata(false); metadataEditorCompat.putString(METADATA_KEY_ARTWORK, text); metadataEditorCompat.apply(); } } This function adds textual information to the metadata editor that will be displayed on the remote control client. However, it is important to note that any information added after the apply() method has been called will not be displayed. The function checks if the device has remote control APIs and, if so, retrieves the metadata editor and adds the provided text to the metadata with the key METADATA_KEY_ARTWORK. Finally, it applies the changes to the metadata editor.
void function() { cmd.landing(); } This function instructs the drone to land. It does so by calling the landing method of the CommandManager object cmd.
void function(Map<String,String> metadata) { this.metadata = metadata; } This function sets the metadata of the GroupConfiguration object to the provided map of strings. The metadata is an optional parameter that can be used for customer automation, but it does not affect any functionality in Auto Scale. There is currently no depth limitation for the metadata. The function simply assigns the provided metadata map to the metadata member variable of the object.
class RMCTest { String EXAMPLE = "$GPRMC,120044.567,A,6011.552,N,02501.941,E,000.0,360.0,160705,006.1,E,A*0B"; RMCParser rmc; RMCParser empty; void setUp() {} void testConstructor() {} void testSetTime() {} void testSetDate() {} void testSetDataStatus() {} void testSetPosition() {} void testSetCourse() {} void testSetSpeed() {} void testSetVariation() {} void testSetDirectionOfVariation() {} void testSetDirectionOfVariationWithInvalidDirection() {} void testSetFaaMode() {} void testSetFaaModeWhenOmitted() {} void testGetPosition() {} void testGetTime() {} void testGetDate() {} void testGetDataStatus() {} void testGetCourse() {} void testGetCorrectedCourse() {} void testGetSpeed() {} void testGetMagneticVariation() {} void testGetDirectionOfVariation() {} void testGetFaaMode() {} void testGetDay() {} void testGetMonth() {} void testGetYear() {} void function() {} }
