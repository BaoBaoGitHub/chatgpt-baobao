void function ( ScriptOrFnNode arg0 ,  int arg1 ,  ScriptOrFnNode arg2 )  { ObjArray loc0 = new ObjArray (  )  ;  ArrayList loc1 = new ArrayList (  )  ;  int loc2 = 0 ;  ArrayList loc3 = new ArrayList (  )  ;  ArrayList loc4 = new ArrayList (  )  ;  ArrayList loc5 = new ArrayList (  )  ;  collectFuncNodes ( arg0 ,  arg1 ,  arg2 )  ;  for  ( int i = 0 ;  i  <  loc0 . length (  )  ;  i ++  )  { FunctionNode fnNode =  ( FunctionNode )  loc0 . get ( i )  ;  String fnName = fnNode . getName (  )  ;  String mappedName = getMappedToken ( fnName ,  true )  ;  if  ( !fnName . equals ( mappedName )  )  { functionVarMappings . add ( new Object [  ] {fnName ,  mappedName} )  ;  } for  ( int j = 0 ;  j  <  fnNode . getParamCount (  )  ;  j ++  )  { String paramName = fnNode . getParamOrVarName ( j )  ;  String mappedParamName = getMappedToken ( paramName ,  true )  ;  if  ( !paramName . equals ( mappedParamName )  )  { functionVarMappings . add ( new Object [  ] {paramName ,  mappedParamName} )  ;  } } Node body = fnNode . getBody (  )  ;  if  ( body != null )  { int start = body . getLineno (  )  ;  int end = body . getLastLineno (  )  ;  if  ( start  > = 0 && end  > = 0 )  { loc2 = start ;  for  ( int j = start ;  j  < = end ;  j ++  )  { TokenStream ts = currentScriptOrFn . getTokenStream (  )  ;  ts . setLineno ( j )  ;  int tt = ts . getToken (  )  ;  while  ( tt  >  0 )  { String ttt = ts . getString (  )  ;  String mappedToken = getMappedToken ( ttt ,  true )  ;  if  ( !ttt . equals ( mappedToken )  )  { if  ( !isInScopeChain ( ttt )  )  { if  ( tt == Token . NAME )  { functionVarMappings . add ( new Object [  ] {ttt ,  mappedToken} )  ;  } else { replacedTokens . add ( new Object [  ] {tt ,  ttt ,  mappedToken} )  ;  } } } tt = ts . getToken (  )  ;  } } } } } }
Sha256Hash function ( File arg0 )  throws IOException { InputStream loc0 = new BufferedInputStream ( new FileInputStream ( arg0 )  )  ;  byte [  ]  loc1 = new byte [ arg0 . length (  )  ]  ;  int loc2 = 0 ;  while  ( loc2  <  loc1 . length )  { int loc3 = loc0 . read ( loc1 ,  loc2 ,  loc1 . length - loc2 )  ;  if  ( loc3  <  0 )  { throw new EOFException (  )  ;  } loc2 += loc3 ;  } loc0 . close (  )  ;  return Sha256Hash . create ( loc1 )  ;  }
String function ( boolean canCreate ,  Object arg0 )  { String loc0 = readObjectID ( arg0 )  ;  if  ( loc0 == null && canCreate )  { loc0 = createObjectID ( arg0 )  ;  } return loc0 ;  }
import java . util . Comparator ;  public class OrderingComparison { public static  < T extends Comparable < T >  >  Matcher < T >  function ( T arg0 )  { return greaterThan ( arg0 )  ;  } public static  < T extends Comparable < T >  >  Matcher < T >  comparesEqualTo ( T arg0 )  { return new CompareEqualToMatcher <  >  ( arg0 )  ;  } public static  < T extends Comparable < T >  >  Matcher < T >  greaterThanOrEqualTo ( T arg0 )  { return new CompareToMatcher <  >  ( arg0 ,  Comparator . reverseOrder (  )  ,  "greater than or equal to" )  ;  } public static  < T extends Comparable < T >  >  Matcher < T >  lessThanOrEqualTo ( T arg0 )  { return new CompareToMatcher <  >  ( arg0 ,  "less than or equal to" )  ;  } public static  < T extends Comparable < T >  >  Matcher < T >  lessThan ( T arg0 )  { return new CompareToMatcher <  >  ( arg0 ,  Comparator . reverseOrder (  )  ,  "less than" )  ;  } private static class CompareEqualToMatcher < T extends Comparable < T >  >  extends BaseMatcher < T >  { private final T expectedValue ;  public CompareEqualToMatcher ( T expectedValue )  { this . expectedValue = expectedValue ;  }  @ Override public boolean matches ( Object item )  { if  ( item == null )  { return false ;  } T actualValue =  ( T )  item ;  return actualValue . compareTo ( expectedValue )  == 0 ;  }  @ Override public void describeTo ( Description description )  { description . appendText ( "equal to " )  . appendValue ( expectedValue )  ;  } } private static class CompareToMatcher < T extends Comparable < T >  >  extends BaseMatcher < T >  { private final T expectedValue ;  private final Comparator < T >  comparator ;  private final String comparisonType ;  public CompareToMatcher ( T expectedValue ,  String comparisonType )  { this . expectedValue = expectedValue ;  this . comparator = Comparator . naturalOrder (  )  ;  this . comparisonType = comparisonType ;  } public CompareToMatcher ( T expectedValue ,  Comparator < T >  comparator ,  String comparisonType )  { this . expectedValue = expectedValue ;  this . comparator = comparator ;  this . comparisonType = comparisonType ;  }  @ Override public boolean matches ( Object item )  { if  ( item == null )  { return false ;  } T actualValue =  ( T )  item ;  return comparator . compare ( actualValue ,  expectedValue )   <  0 ;  }  @ Override public void describeTo ( Description description )  { description . appendText ( comparisonType + " " )  . appendValue ( expectedValue )  ;  } } }
int function ( int arg0 )  { int loc0 = denom * arg0 ;  int loc1 = loc0 / num ;  return loc1 ;  }
class DAOWrapper { String screen_name = "unknown" ;  String image = null ;  String user_name = "unknown @ unknown" ;  Date created_at = null ;  String user_id = "unknown" ;  String id_str = null ;  String place_name = "unknown" ;  double lng = 0 . 0 ;  int loc_radius = 0 ;  String text = "" ;  ArrayList < String >  extras = new ArrayList < String >  (  )  ;  double lat = 0 . 0 ;  GenericJSONBuilder setPlaceName ( String name )  { place_name = name ;  return this ;  } GenericJSONBuilder setCoordinateRadius ( int radius )  { loc_radius = radius ;  return this ;  } GenericJSONBuilder setCoordinate ( double longtitude ,  double latitude )  { lng = longtitude ;  lat = latitude ;  return this ;  } void persist (  )  { } GenericJSONBuilder setUserid ( String user_id_ )  { user_id = user_id_ ;  return this ;  } GenericJSONBuilder setCreatedTime ( Date createdTime )  { created_at = createdTime ;  return this ;  } String buildFieldJSON (  )  { return "" ;  } GenericJSONBuilder setIDstr ( String id_str_ )  { id_str = id_str_ ;  return this ;  } GenericJSONBuilder addText ( String text_ )  { text = text_ ;  return this ;  } GenericJSONBuilder addField ( String key ,  String value )  { return this ;  } void insert ( Insertable msg )  { } GenericJSONBuilder setAuthor ( String author ,  String domain )  { return this ;  } GenericJSONBuilder builder (  )  { return this ;  } void function ( String arg0 ,  String arg1 ,  Date arg2 ,  String arg3 ,  String arg4 ,  String arg5 ,  String arg6 ,  double arg7 ,  int arg8 ,  String arg9 ,  ArrayList < String >  arg10 ,  double arg11 )  { screen_name = arg0 ;  image = arg1 ;  created_at = arg2 ;  user_id = arg3 ;  id_str = arg4 ;  place_name = arg5 ;  lng = arg6 ;  loc_radius = arg7 ;  text = arg8 ;  extras = arg9 ;  lat = arg10 ;  } }
public void function ( BundleContext arg0 )  { }
public void function (  )  { long arg0 = 10 ;  long arg1 = 5 ;  long loc0 ,  loc1 ;  mTestStream . seek ( arg0 )  ;  loc0 = mTestStream . getPosition (  )  ;  mTestStream . seek ( arg1 )  ;  loc1 = mTestStream . getPosition (  )  ;  if  ( loc0 != arg0 || loc1 != arg1 )  { System . out . println ( "seek (  )  failed to set the correct position" )  ;  } }
public static void function (  )  { CountDownLatch unreachableLatch = new CountDownLatch ( 1 )  ;  createUnreachableLatchFinalizer ( unreachableLatch )  ;  WeakReference < Object >  weakRef = new WeakReference < Object >  ( new Object (  )  )  ;  long startTime = System . nanoTime (  )  ;  while  ( true )  { System . gc (  )  ;  try { await ( unreachableLatch )  ;  if  ( weakRef . get (  )  == null )  { break ;  } } catch  ( InterruptedException e )  { Thread . currentThread (  )  . interrupt (  )  ;  throw formatRuntimeException ( "Interrupted while waiting for GC to complete: %s" ,  e . getMessage (  )  )  ;  } if  ( timeoutSeconds (  )   >  0 &&  ( System . nanoTime (  )  - startTime )   >  timeoutSeconds (  )  * 1_000_000_000L )  { throw formatRuntimeException ( "Timeout waiting for GC to complete" )  ;  } } if  ( isDone (  )  )  { return ;  } awaitDone (  (  )  - >  true )  ;  }
private void function (  )  { TransferManager loc0 = TransferManagerBuilder . standard (  )  . withS3Client ( new AmazonS3ClientBuilder (  )  . withRegion ( Regions . DEFAULT_REGION )  . build (  )  )  . build (  )  ;  String loc1 = "testBucket" ;  String loc2 = "testKey" ;  S3ADirectOutputStream loc3 = new S3ADirectOutputStream ( loc1 ,  loc2 ,  loc0 )  ;  mManager = loc0 ;  BUCKET_NAME = loc1 ;  KEY = loc2 ;  mStream = loc3 ;  }
public class DocumentationManager { private static final String LINE_SEPARATOR = System . getProperty ( "line . separator" )  ;  public void setDocs ( Object o ,  String s )  { } public int appendComment ( StringBuffer sb ,  String prefix ,  String comment ,  int nlprefix )  { return 0 ;  } public boolean hasDocs ( Object o )  { return false ;  } public String getComments ( Object o )  { return null ;  } public String getComments ( Object o ,  String header ,  String prefix ,  String footer )  { return null ;  } public String defaultFor ( Object o ,  String indent )  { return null ;  } public String function ( Object arg0 ,  Object arg1 )  { String loc0 = "/*" + LINE_SEPARATOR ;  String loc1 = "*/" + LINE_SEPARATOR ;  String loc2 = "    " ;  String loc3 = "arg0: " + arg0 + LINE_SEPARATOR ;  String loc4 = "arg1: " + arg1 + LINE_SEPARATOR ;  String loc5 = "*/" ;  StringBuffer sb = new StringBuffer ( loc0 )  ;  sb . append ( loc2 )  . append ( loc3 )  ;  sb . append ( loc2 )  . append ( loc4 )  ;  sb . append ( loc1 )  ;  return sb . toString (  )  ;  } }
public static String function ( Exchange arg0 ,  boolean arg1 )  { List < String >  loc0 = getAlternateAddresses ( arg0 )  ;  List < Endpoint >  loc1 = getAlternateEndpoints ( arg0 )  ;  String loc2 = selectAlternateAddress ( loc0 )  ;  Endpoint loc3 = selectAlternateEndpoint ( loc1 )  ;  if  ( arg1 )  { LOG . debug ( "Selecting alternate endpoint: {}" ,  loc3 )  ;  return loc3 . toString (  )  ;  } else { LOG . debug ( "Selecting alternate address: {}" ,  loc2 )  ;  return loc2 ;  } }
String function ( String arg0 )  { TSTNode loc0 = root ;  int loc1 = 0 ;  while  ( loc0 != null )  { if  ( loc0 . data == arg0 . charAt ( loc1 )  )  { if  ( loc1 == arg0 . length (  )  - 1 )  { if  ( loc0 . is_End_Of_String )  { return arg0 ;  } else { return null ;  } } loc1 ++  ;  loc0 = loc0 . middle ;  } else if  ( arg0 . charAt ( loc1 )   <  loc0 . data )  { loc0 = loc0 . left ;  } else { loc0 = loc0 . right ;  } } return null ;  }
void function (  )  { lhsscan . close (  )  ;  prodscan . close (  )  ;  if  ( rhsscan != null )  { rhsscan . close (  )  ;  } }
Map < String ,  String >  function ( String [  ]  arg0 )  { Map < String ,  String >  resultMap = new HashMap <  >  (  )  ;  for  ( String loc0 : arg0 )  { String [  ]  loc1 = loc0 . split ( "#" )  ;  if  ( loc1 . length == 2 )  { resultMap . put ( loc1 [ 0 ]  ,  loc1 [ 1 ]  )  ;  } } return resultMap ;  }
public NodeList function ( String arg0 )  { try { XPathFactory xPathfactory = XPathFactory . newInstance (  )  ;  XPath xpath = xPathfactory . newXPath (  )  ;  xpath . setNamespaceContext ( new NamespaceContext (  )  {  @ Override public String getNamespaceURI ( String prefix )  { if  ( prefix . equals ( "xml" )  )  { return XML_NAMESPACE ;  } else { return namespaces . get ( prefix )  ;  } }  @ Override public String getPrefix ( String namespaceURI )  { for  ( Map . Entry < String ,  String >  entry : namespaces . entrySet (  )  )  { if  ( entry . getValue (  )  . equals ( namespaceURI )  )  { return entry . getKey (  )  ;  } } return null ;  }  @ Override public Iterator < String >  getPrefixes ( String namespaceURI )  { List < String >  prefixes = new ArrayList <  >  (  )  ;  for  ( Map . Entry < String ,  String >  entry : namespaces . entrySet (  )  )  { if  ( entry . getValue (  )  . equals ( namespaceURI )  )  { prefixes . add ( entry . getKey (  )  )  ;  } } return prefixes . iterator (  )  ;  } } )  ;  XPathExpression expr = xpath . compile ( arg0 )  ;  NodeList loc0 =  ( NodeList )  expr . evaluate ( doc ,  XPathConstants . NODESET )  ;  for  ( int i = 0 ;  i  <  loc0 . getLength (  )  ;  i ++  )  { Node node = loc0 . item ( i )  ;  if  ( node . getNodeType (  )  == Node . COMMENT_NODE )  { loc0 . item ( i )  . getParentNode (  )  . removeChild ( loc0 . item ( i )  )  ;  } else if  ( node . getNodeType (  )  == Node . ELEMENT_NODE )  { NamedNodeMap attributes = node . getAttributes (  )  ;  for  ( int j = 0 ;  j  <  attributes . getLength (  )  ;  j ++  )  { Node attribute = attributes . item ( j )  ;  if  ( attribute . getNodeName (  )  . startsWith ( "xmlns" )  )  { node . getAttributes (  )  . removeNamedItem ( attribute . getNodeName (  )  )  ;  } } } } return loc0 ;  } catch  ( XPathExpressionException e )  { e . printStackTrace (  )  ;  return null ;  } }
boolean function ( Collection < ? extends Source >  arg0 ,  GoalFactory arg1 )  { for  ( Source loc0 : arg0 )  { String loc1 = loc0 . getPath (  )  . getAbsolutePath (  )  ;  try { CompilerJob loc2 = makeJob ( loc0 )  ;  Goal loc3 = getGoal ( loc2 )  ;  if  ( loc3 instanceof CompileGoal )  { compileFiles ( loc2 )  ;  } else if  ( loc3 instanceof CheckGoal )  { CheckGoal loc4 =  ( CheckGoal )  loc3 ;  loc4 . check ( loc2 )  ;  } else if  ( loc3 instanceof TranslateGoal )  { TranslateGoal loc5 =  ( TranslateGoal )  loc3 ;  loc5 . translate ( loc2 )  ;  } else if  ( loc3 instanceof SerializedFormGoal )  { SerializedFormGoal loc6 =  ( SerializedFormGoal )  loc3 ;  loc6 . serialize ( loc2 )  ;  } else { throw new AssertionError ( "Unknown goal type: " + loc3 )  ;  } } catch  ( IOException loc7 )  { errorQueue (  )  . enqueue ( ErrorKind . IO_ERROR ,  loc1 ,  loc7 )  ;  } catch  ( TaskAbortException loc8 )  { errorQueue (  )  . enqueue ( ErrorKind . TASK_ABORTED ,  loc1 ,  loc8 )  ;  } catch  ( AbortCompilation loc9 )  { return false ;  } catch  ( RuntimeException loc10 )  { errorQueue (  )  . enqueue ( ErrorKind . INTERNAL_ERROR ,  loc1 ,  loc10 )  ;  } catch  ( OutOfMemoryError loc11 )  { errorQueue (  )  . enqueue ( ErrorKind . OUT_OF_MEMORY ,  loc1 ,  loc11 )  ;  } } return true ;  }
public class SystemCommands { Context context ;  void reboot (  )  { } boolean getGPS (  )  { return false ;  } void function ( boolean arg0 )  { boolean loc0 = arg0 ;  } }
boolean function ( View arg0 )  { int loc0 = ViewCompat . getLayoutDirection ( arg0 )  ;  return loc0 == ViewCompat . LAYOUT_DIRECTION_RTL ;  }
Checklist function ( Class arg0 ,  Object arg1 )  { Checklist loc0 = lookupChecklist ( arg0 )  ;  if  ( loc0 != null )  { register ( arg1 ,  loc0 )  ;  ChecklistStatus loc1 = getStatusFor ( arg1 )  ;  if  ( loc1 != null )  { return loc1 . getChecklist (  )  ;  } } return null ;  }
void function ( int arg0 )  { setUp (  )  ;  instance . setDay ( arg0 )  ;  int loc0 = instance . getDay (  )  ;  assertEquals ( arg0 ,  loc0 )  ;  }
int function ( int arg0 ,  int arg1 )  { int loc0 = -1 ;  int loc1 = -1 ;  int lane = arg0 ;  int player = arg1 ;  Array < Array < Array < Card >  >  >  tiles = getTiles (  )  ;  int tileIndex = -1 ;  int distance = Integer . MAX_VALUE ;  int baseIndex = -1 ;  if  ( player == HUMAN_PLAYER )  { baseIndex = 0 ;  } else { baseIndex = tiles . get ( 0 )  . get ( lane )  . size - 1 ;  } for  ( int i = 0 ;  i  <  tiles . get ( 0 )  . get ( lane )  . size ;  i ++  )  { Card card = tiles . get ( baseIndex )  . get ( lane )  . get ( i )  ;  if  ( card == null )  { int cardDistance = Math . abs ( baseIndex - i )  ;  if  ( cardDistance  <  distance )  { tileIndex = i ;  distance = cardDistance ;  } } } if  ( tileIndex != -1 )  { if  ( player == HUMAN_PLAYER )  { loc0 = tileIndex ;  loc1 = baseIndex ;  } else { loc0 = baseIndex ;  loc1 = tileIndex ;  } } return loc0 ;  }
Matrix function ( Matrix arg0 )  { int n = arg0 . getRowDimension (  )  ;  Matrix loc0 = MatrixMathematics . cofactor ( arg0 )  ;  double loc1 = MatrixMathematics . determinant ( arg0 )  ;  if  ( loc1 == 0 )  { throw new IllegalArgumentException ( "Matrix is singular and cannot be inverted . " )  ;  } loc0 = MatrixMathematics . transpose ( loc0 )  ;  Matrix loc2 = new Matrix ( n ,  n )  ;  double loc3 = 1 . 0 / loc1 ;  for  ( int i = 0 ;  i  <  n ;  i ++  )  { for  ( int j = 0 ;  j  <  n ;  j ++  )  { loc2 . set ( i ,  j ,  loc3 * loc0 . get ( i ,  j )  )  ;  } } return loc2 ;  }
public String function (  )  { String loc0 = "" ;  if  ( thisExitStatus != null )  { loc0 = thisExitStatus . getExitDescription (  )  ;  } if  ( partialExitCodes != null && !partialExitCodes . isEmpty (  )  )  { StringBuilder loc1 = new StringBuilder ( loc0 )  ;  for  ( JobExitStatus loc2 : partialExitCodes )  { if  ( loc2 != null && loc2 . getExitDescription (  )  != null )  { if  ( loc1 . length (  )   >  0 )  { loc1 . append ( " ;  " )  ;  } loc1 . append ( loc2 . getExitDescription (  )  )  ;  } } loc0 = loc1 . toString (  )  ;  } return loc0 ;  }
public boolean function ( Object arg0 )  { Object loc0 = arg0 ;  String loc1 = getAttributeValue ( loc0 ,  "hover" )  ;  return loc1 != null && !loc1 . isEmpty (  )  ;  }
List < AttributeStatementProvider >  function ( TokenProviderParameters arg0 ,  byte [  ]  arg1 ,  Document arg2 )  { SamlAssertionWrapper assertion = createSamlToken ( arg0 ,  arg1 ,  arg2 )  ;  List < AttributeStatementProvider >  loc0 = attributeStatementProviders ;  if  ( loc0 == null || loc0 . isEmpty (  )  )  { return Collections . emptyList (  )  ;  } List < AttributeStatement >  loc1 = new ArrayList <  >  ( loc0 . size (  )  )  ;  for  ( AttributeStatementProvider loc2 : loc0 )  { AttributeStatement loc3 = loc2 . getStatement ( assertion )  ;  if  ( loc3 != null )  { loc1 . add ( loc3 )  ;  } } return loc1 ;  }
void function (  )  { unloadSounds ( soundsToLoad )  ;  }
public ProjectModel function ( UserModel arg0 ,  boolean arg1 )  { FileBasedConfig loc0 = projectConfigs ;  Logger loc1 = logger ;  Map < String ,  ProjectModel >  loc2 = projectCache ;  IUserManager loc3 = userManager ;  ObjectCache < String >  loc4 = projectMarkdownCache ;  ObjectCache < String >  loc5 = projectRepositoriesMarkdownCache ;  IStoredSettings loc6 = settings ;  IRuntimeManager loc7 = runtimeManager ;  IRepositoryManager loc8 = repositoryManager ;  return null ;  // Return the project model for the specified user }
public Optional < String >  function ( String arg0 )  { if  ( arg0 == null || arg0 . length (  )  != 6 )  { return Optional . empty (  )  ;  } int loc0 = Integer . parseInt ( arg0 . substring ( 0 ,  2 )  ,  16 )  ;  int loc1 = Integer . parseInt ( arg0 . substring ( 2 ,  4 )  ,  16 )  ;  int loc2 = Integer . parseInt ( arg0 . substring ( 4 ,  6 )  ,  16 )  ;  Color color = new Color ( loc0 ,  loc1 ,  loc2 )  ;  String closestColorName = null ;  double minDistance = Double . MAX_VALUE ;  for  ( Map . Entry < RGB ,  String >  entry : namedColors . entrySet (  )  )  { RGB rgb = entry . getKey (  )  ;  Color namedColor = new Color ( rgb . getR (  )  ,  rgb . getG (  )  ,  rgb . getB (  )  )  ;  double distance = calculateColorDistSq ( color ,  namedColor )  ;  if  ( distance  <  minDistance )  { minDistance = distance ;  closestColorName = entry . getValue (  )  ;  } } return Optional . ofNullable ( closestColorName )  ;  }
String function ( String arg0 ,  String arg1 )  { String loc0 = arg0 . toLowerCase (  )  ;  String loc1 = arg1 . toLowerCase (  )  ;  StringBuilder fauxFileName = new StringBuilder (  )  ;  fauxFileName . append ( loc0 )  . append ( " . " )  . append ( getSuffixFromType ( loc1 )  )  ;  return fauxFileName . toString (  )  ;  }
int function ( int arg0 ,  int arg1 )  { int loc0 = 8333 ;  int loc1 = 18333 ;  if  ( arg0 == 0 )  { return loc0 ;  } else if  ( arg1 == 0 )  { return loc1 ;  } else { return arg0 ;  } }
String [  ]  function (  )  { Jedis loc0 = jedis ;  Set < String >  loc1 = loc0 . smembers ( termSetKey (  )  )  ;  return loc1 . toArray ( new String [ 0 ]  )  ;  } Note: This method returns an array of String objects containing URLSet keys for the terms that have been indexed .  It uses the Jedis SMEMBERS command to retrieve the members of the set associated with the termSetKey .  The method converts the resulting Set to an array of Strings and returns it . 
void function (  )  { mBlocksToMoveIn . clear (  )  ;  mBlocksToMoveOut . clear (  )  ;  mBlocksToMoveInSize = 0L ;  mBlocksToMoveOutSize = 0L ;  }
public UserSubject function ( Token arg0 ,  HttpServletRequest arg1 )  { if  ( arg0 != null && arg1 != null )  { List < OAuthPermission >  loc0 = arg0 . getScopes (  )  ;  if  ( loc0 != null && !loc0 . isEmpty (  )  )  { for  ( OAuthPermission loc1 : loc0 )  { if  ( loc1 . getPermission (  )  . equals ( "openid" )  )  { String loc2 = arg1 . getParameter ( "sub" )  ;  if  ( loc2 != null )  { UserSubject loc3 = arg0 . getSubject (  )  ;  if  ( loc3 == null )  { loc3 = new UserSubject ( loc2 )  ;  arg0 . setSubject ( loc3 )  ;  } else { loc3 . setLoginName ( loc2 )  ;  } return loc3 ;  } } } } } return null ;  }
int function ( boolean arg0 )  { char type = getType (  )  ;  if  ( type == 'x' || type == 'a' || type == 'c' )  { checkType ( 'i' ,  arg0 )  ;  return 1 ;  } else if  ( type == 'h' || type == 'H' || type == 'b' || type == 'B' )  { checkType ( 'i' ,  arg0 )  ;  int len = getIntFromFormat ( true )  ;  if  ( len == -1 )  { return 1 ;  } else { return len ;  } } else if  ( type == 's' || type == 'S' )  { checkType ( 'i' ,  arg0 )  ;  int len = getIntFromFormat ( true )  ;  if  ( len == -1 )  { return 1 ;  } else { return len * 2 ;  } } else if  ( type == 'f' || type == 'd' )  { checkType ( 'i' ,  arg0 )  ;  return 4 ;  } else if  ( type == 'l' )  { checkType ( 'i' ,  arg0 )  ;  return 8 ;  } else { throw new RuntimeException ( "Unknown type: " + type )  ;  } }
String function ( TestResultDetailsDTO arg0 )  { String loc0 = arg0 . getErrorMsg (  )  ;  return loc0 ;  }
public boolean function ( symbol arg0 )  { Iterator < symbol >  loc0 = _all . values (  )  . iterator (  )  ;  while  ( loc0 . hasNext (  )  )  { symbol loc1 = loc0 . next (  )  ;  if  ( loc1 . equals ( arg0 )  )  { return true ;  } } return false ;  }
Node function ( Node arg0 )  { if  ( arg0 == null )  { return null ;  } Node loc0 = arg0 . getFirstChild (  )  ;  if  ( loc0 == null )  { return null ;  } StringBuilder loc1 = null ;  while  ( loc0 != null )  { if  ( loc0 . getNodeType (  )  == Node . TEXT_NODE || loc0 . getNodeType (  )  == Node . CDATA_SECTION_NODE )  { if  ( loc1 == null )  { loc1 = new StringBuilder (  )  ;  } loc1 . append ( loc0 . getNodeValue (  )  )  ;  } loc0 = loc0 . getNextSibling (  )  ;  } if  ( loc1 != null )  { Node loc2 = arg0 . getOwnerDocument (  )  . createTextNode ( loc1 . toString (  )  )  ;  arg0 . appendChild ( loc2 )  ;  loc0 = arg0 . getFirstChild (  )  ;  while  ( loc0 != null )  { Node loc3 = loc0 . getNextSibling (  )  ;  if  ( loc0 . getNodeType (  )  == Node . TEXT_NODE || loc0 . getNodeType (  )  == Node . CDATA_SECTION_NODE )  { arg0 . removeChild ( loc0 )  ;  } loc0 = loc3 ;  } } return arg0 ;  }
public static MarshalRegistry function ( Object arg0 ,  Object arg1 )  { Context context =  ( Context )  arg0 ;  String registryKey =  ( String )  arg1 ;  MarshalRegistry loc0 =  ( MarshalRegistry )  context . get ( registryKey )  ;  if  ( loc0 == null )  { loc0 = new MarshalRegistry (  )  ;  context . put ( registryKey ,  loc0 )  ;  } return loc0 ;  }
List < Object >  function ( Object arg0 ,  Object arg1 )  { List < Object >  loc0 = new ArrayList <  >  (  )  ;  loc0 . add ( arg0 )  ;  loc0 . add ( arg1 )  ;  return loc0 ;  }
public void function ( ParametersMetaData arg0 )  { ParametersMetaData loc0 = arg0 ;  this . parametersMetaData = loc0 ;  }
public String function ( int arg0 ,  String arg1 )  { String loc0 = "Details tab content for " + aboutName ;  String loc1 = "Type " + arg0 + " requested" ;  String loc2 = "Argument passed: " + arg1 ;  String loc3 = "DeveloperModule enabled? " + enable (  )  ;  LOG . info ( loc1 )  ;  LOG . info ( loc2 )  ;  LOG . info ( loc3 )  ;  return loc0 + "\n" + loc1 + "\n" + loc2 + "\n" + loc3 ;  }
void function ( byte [  ]  arg0 )  { try { writer . writeCharacters ( new String ( arg0 )  )  ;  } catch  ( Exception e )  { } }
public String function (  )  { String loc0 = isActive ;  return loc0 ;  }
public class DataServerFactory { public static DataServer function ( int arg0 ,  String arg1 ,  boolean arg2 )  { int loc0 = arg0 ;  // port String loc1 = arg1 ;  // bindHost boolean loc2 = arg2 ;  // isClosed return new DataServer ( loc0 ,  loc1 ,  loc2 )  ;  } }
public ECKey function ( List < ECKey >  arg0 ,  Script arg1 )  { ECKey loc0 = null ;  for  ( ECKey key : arg0 )  { if  ( key . getPrivKeyBytes (  )  != null )  { loc0 = key ;  break ;  } } return loc0 ;  }
public void function ( Object arg0 ,  Object arg1 )  { Instrumentation loc0 = instrumentation ;  instrumentation = null ;  Services . get (  )  . unregister ( getInterface (  )  )  ;  XLog loc1 = log ;  if  ( loc1 != null )  { loc1 . info ( "Destroying instrumentation service" )  ;  } log = null ;  JVM_INSTRUMENTATION_GROUP = null ;  }
void function ( long arg0 )  { long loc0 = 512 ;  if  ( arg0  >  0 && arg0  < = loc0 )  { keySize = arg0 ;  } else { keySize = loc0 ;  } }
public String function ( String arg0 )  { String loc0 = null ;  if  ( arg0 . equals ( joinfield )  )  { loc0 = ts . getString ( joinfield )  ;  } else if  ( hasField ( arg0 )  )  { loc0 = s . getString ( arg0 )  ;  } else { loc0 = idx . getString ( arg0 )  ;  } return loc0 ;  }
int function ( int arg0 ,  int arg1 ,  int arg2 )  { int loc0 = 0x0488B21E ;  loc0 |= arg0  <  <  16 ;  loc0 |= arg1  <  <  8 ;  loc0 |= arg2 ;  return loc0 ;  }
public long function (  )  { long loc0 = value ;  return loc0 ;  }
public View function ( MenuItem arg0 ,  View arg1 )  { View loc0 = arg0 . getActionView (  )  ;  arg0 . setActionView ( arg1 )  ;  return loc0 ;  }
public void function ( ServerSession arg0 ,  ServerMessage arg1 )  { NotificationController notificationController = new NotificationController (  )  ;  try { notificationController . deletePersistentNotification ( null ,  arg0 ,  arg1 )  ;  fail ( "Expected an IllegalArgumentException to be thrown" )  ;  } catch  ( IllegalArgumentException loc0 )  { } }
public void function ( double seconds )  { double loc0 = seconds ;  if  ( loc0  <  0 || loc0  > = 60 )  { throw new IllegalArgumentException ( "Seconds must be between 0 and 59" )  ;  } this . seconds = loc0 ;  }
void function ( ServiceID arg0 )  { loc0 = arg0 ;  capacity = data . length + loc0 . toByteArray (  )  . length ;  }
int function (  )  { int loc0 = RECORD_SIZE * numHeaders + FILE_PROLOGUE_BYTES ;  return loc0 ;  }
T function (  )  { return mPayload ;  }
String function ( Date arg0 )  { DateFormat loc0 = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" )  ;  return loc0 . format ( arg0 )  ;  }
public List < DirectedAcyclicGraphNode < T >  >  function (  )  { List < DirectedAcyclicGraphNode < T >  >  loc0 = new ArrayList <  >  (  )  ;  loc0 . addAll ( mChildren )  ;  return loc0 ;  }
int function ( RecyclerView arg0 )  { View loc0 = arg0 . getChildAt ( 0 )  ;  if  ( loc0 == null )  { return RecyclerView . NO_POSITION ;  } int loc1 = arg0 . getChildAdapterPosition ( loc0 )  ;  if  ( loc1 == RecyclerView . NO_POSITION )  { return RecyclerView . NO_POSITION ;  } if  ( mAdapter . getHeaderId ( loc1 )   > = 0 )  { View loc2 = mHeaderProvider . getHeader ( arg0 ,  loc1 )  ;  if  ( itemIsObscuredByHeader ( arg0 ,  loc0 ,  loc2 ,  mOrientationProvider . getOrientation ( arg0 )  )  )  { return findNextVisibleItemPosition ( loc1 ,  arg0 )  ;  } } return loc1 ;  } boolean itemIsObscuredByHeader ( RecyclerView arg0 ,  View arg1 ,  View arg2 ,  int arg3 )  { int loc0 ;  int loc1 ;  if  ( arg3 == 1 )  { loc0 = mDimensionCalculator . getDecoratedTop ( arg2 )  - arg0 . getPaddingTop (  )  ;  if  ( loc0  < = arg0 . getLayoutManager (  )  . getDecoratedTop ( arg1 )  )  { return true ;  } } else { loc1 = mDimensionCalculator . getDecoratedLeft ( arg2 )  - arg0 . getPaddingLeft (  )  ;  if  ( loc1  < = arg0 . getLayoutManager (  )  . getDecoratedLeft ( arg1 )  )  { return true ;  } } return false ;  } int findNextVisibleItemPosition ( int arg0 ,  RecyclerView arg1 )  { int loc0 = arg0 + 1 ;  int loc1 = arg1 . getLayoutManager (  )  . getItemCount (  )  ;  while  ( loc0  <  loc1 )  { if  ( mAdapter . getHeaderId ( loc0 )   <  0 )  { View loc2 = arg1 . getLayoutManager (  )  . findViewByPosition ( loc0 )  ;  if  ( loc2 != null )  { if  ( loc2 . getTop (  )  - arg1 . getPaddingTop (  )   > = mHeaderProvider . getHeader ( arg1 ,  loc0 - 1 )  . getHeight (  )  )  { return loc0 ;  } } } loc0 ++  ;  } return RecyclerView . NO_POSITION ;  }
void function ( List < TestResultDetailsDTO >  arg0 )  { List < TestResultDetailsDTO >  loc0 = new ArrayList <  >  ( arg0 )  ;  this . regTestResultDetailsLst = loc0 ;  }
long function (  )  { return this . testId ;  }
void function ( Time arg0 )  { Time loc0 = new Time ( arg0 . getTime (  )  )  ;  loc0 . setTime ( arg0 . getTime (  )  )  ;  Date loc1 = loc0 . toDate (  )  ;  Time loc2 = new Time ( loc1 . getTime (  )  )  ;  assert ( loc0 . equals ( loc2 )  )  ;  }
public void function ( BigDecimal arg0 )  { BigDecimal loc0 = arg0 ;  setFeedConfigId ( loc0 )  ;  }
String function ( String arg0 ,  String arg1 )  { ImageWriteParam loc0 = getImageWriteParameters ( lookupImageWriterForFormat ( arg0 )  )  ;  loc0 . setCompressionType ( arg1 )  ;  return arg1 ;  }
boolean function ( RangeSet < C >  arg0 ,  RangeSet < C >  arg1 )  { for  ( Range < C >  loc0 : arg1 . asRanges (  )  )  { boolean found = false ;  for  ( Range < C >  loc1 : arg0 . asRanges (  )  )  { if  ( loc1 . encloses ( loc0 )  )  { found = true ;  break ;  } } if  ( !found )  { return false ;  } } return true ;  }
void function ( Map < String , Object >  arg0 )  { for  ( Map . Entry < String , Object >  loc0 : arg0 . entrySet (  )  )  { context . setVariable ( loc0 . getKey (  )  ,  loc0 . getValue (  )  )  ;  } }
public boolean function ( int arg0 ,  ByteBuffer arg1 ,  ByteBufferAllocator arg2 ,  int arg3 )  { int loc0 = arg1 . position (  )  ;  arg1 . position ( arg0 )  ;  int loc1 = arg1 . remaining (  )  ;  arg1 . position ( loc0 )  ;  return loc1  >  0 ;  }
public void function ( int txNum ,  String filename ,  int blockNum ,  int offset ,  String oldValue )  { String logRecord = "SETSTRING " + txNum + " " + filename + " " + blockNum + " " + offset + " " + oldValue ;  LogMgr logMgr = new LogMgr (  )  ;  logMgr . append ( logRecord )  ;  }
DataFlowNode function ( int arg0 )  { DataFlowNode loc0 = new DataFlowNode ( arg0 )  ;  dataFlow . add ( loc0 )  ;  return loc0 ;  }
User function (  )  { User loc0 = sUserThreadLocal . get (  )  ;  return loc0 ;  }
void function ( String arg0 )  { List < String >  loc0 = getSelectedRecipients (  )  ;  if  ( !loc0 . contains ( arg0 )  )  { loc0 . add ( arg0 )  ;  setSelectedRecipients ( loc0 )  ;  } }
public void function (  )  { String arg0 = "nonexistent-file . txt" ;  mException . expect ( IllegalArgumentException . class )  ;  mException . expectMessage ( "File not found: " + arg0 )  ;  FileUtils . delete ( arg0 )  ;  }
boolean function ( String arg0 ,  OperationSignature arg1 )  { for  ( Map . Entry < OperationSignature ,  Map < String ,  OperationStats >  >  entry : operations . entrySet (  )  )  { OperationSignature loc0 = entry . getKey (  )  ;  if  ( loc0 . matches ( arg1 )  )  { Map < String ,  OperationStats >  loc1 = entry . getValue (  )  ;  if  ( loc1 . containsKey ( arg0 )  )  { return true ;  } } } return false ;  }
public void function ( List < UserModel >  arg0 )  { for  ( int loc0 = 0 ;  loc0  <  arg0 . size (  )  ;  loc0 ++  )  { UserModel loc1 = arg0 . get ( loc0 )  ;  if  ( loc1 != null )  { String loc2 = loc1 . getUsername (  )  ;  if  ( loc2 != null )  { updateUserModel ( loc2 ,  loc1 )  ;  } else { logger . warn ( "Skipping user model with null username" )  ;  } } else { logger . warn ( "Skipping null user model" )  ;  } } }
void function ( String message ,  Throwable throwable )  { String filterName = getClass (  )  . getName (  )  ;  if  ( throwable == null )  { log ( filterName + ": " + message )  ;  } else { log ( filterName + ": " + message ,  throwable )  ;  } }
void function ( Object arg0 ,  Object arg1 )  { try { HttpServletResponse loc0 =  ( HttpServletResponse )  arg1 ;  loc0 . setStatus ( HttpServletResponse . SC_OK )  ;  loc0 . flushBuffer (  )  ;  } catch  ( IOException loc1 )  { LOG . error ( "Error writing empty response . " ,  loc1 )  ;  } }
void function ( int arg0 )  { curValue = arg0 ;  if  ( isShowProgress (  )  )  { double percentComplete = getPercentComplete (  )  ;  int intPercentComplete =  ( int )   ( percentComplete * 100 )  ;  String progressString = String . format ( "Progress: %d%%" ,  intPercentComplete )  ;  setCurrentMessage ( progressString )  ;  logDebug ( progressString )  ;  } }
String function  ( FileMapper loc0 )  { JSONObject loc1 = new JSONObject (  )  ;  loc0 . forEach (  ( arg0 ,  arg1 )  - >  { JSONArray loc2 = new JSONArray (  )  ;  arg1 . getCompleteFiles (  )  . forEach ( loc2::put )  ;  loc1 . put ( arg0 . toString (  )  ,  loc2 )  ;  } )  ;  return loc1 . toString (  )  ;  }
NodeTest { boolean function ( NodeTester arg0 ,  Node arg1 )  { if  ( arg0 == null || arg1 == null )  { return false ;  } rootNode = arg0 . getRootNode (  )  ;  if  ( rootNode == null )  { return false ;  } documentTraversal = arg0 . getDocumentTraversal (  )  ;  if  ( documentTraversal == null )  { return false ;  } nodeTypes = arg0 . getNodeTypes (  )  ;  if  ( nodeTypes == null )  { return false ;  } if  ( !acceptNodeType ( arg1 . getNodeType (  )  )  )  { return false ;  } short nodeAcceptance = arg0 . acceptNode ( arg1 )  ;  if  ( nodeAcceptance == DocumentFilter . FILTER_REJECT )  { return false ;  } Node loc0 = rootNode ;  while  ( loc0 != null && loc0 != arg1 )  { loc0 = documentTraversal . getParentNode ( loc0 )  ;  } if  ( loc0 == null )  { return false ;  } return true ;  } }
public BlockStoreContext function ( InetSocketAddress arg0 ,  BlockMasterClientPool arg1 )  { BlockStoreContext loc0 = CACHED_CONTEXTS . get ( arg0 )  ;  if  ( loc0 == null )  { synchronized  ( CACHED_CONTEXTS )  { loc0 = CACHED_CONTEXTS . get ( arg0 )  ;  if  ( loc0 == null )  { loc0 = new BlockStoreContext ( arg1 )  ;  CACHED_CONTEXTS . put ( arg0 ,  loc0 )  ;  } } } return loc0 ;  }
ImageWriter function ( String arg0 ,  float arg1 ,  int arg2 )  { String loc0 = "JPEG" ;  ImageWriter loc1 = lookupImageWriterForFormat ( loc0 )  ;  ImageWriteParam loc2 = getImageWriteParameters ( loc1 )  ;  loc2 . setCompressionMode ( arg2 )  ;  loc2 . setCompressionType ( arg0 )  ;  loc2 . setCompressionQuality ( arg1 )  ;  return loc1 ;  }
I'm sorry ,  but it's not clear what you want me to do .  Could you please provide more specific instructions or a question for me to answer?
void function ( JettyHTTPServerEngine arg0 ,  ThreadingParameters arg1 )  { if  ( arg1 == null )  { arg1 = fallbackThreadingParameters ;  } String loc0 = Integer . toString ( arg0 . getPort (  )  )  ;  threadingParametersMap . put ( loc0 ,  arg1 )  ;  arg0 . setThreadPool ( createThreadPool ( arg1 )  )  ;  }
CodeGenerator function ( Language arg0 ,  CodeGenerator arg1 )  { CodeGenerator loc0 = generators . put ( arg0 ,  arg1 )  ;  if  ( loc0 != null )  { LOG . info ( "Replacing existing generator for language: " + arg0 )  ;  } return loc0 ;  }
void function ( String arg0 ,  Object arg1 )  { Context loc0 = this . context ;  Map < String , Object >  loc1 = loc0 . getVars (  )  ;  loc1 . put ( arg0 ,  arg1 )  ;  }
int function ( int arg0 ,  long arg1 ,  BigInteger arg2 ,  byte [  ]  arg3 ,  Sha256Hash arg4 ,  int arg5 )  { int loc0 = arg0 ;  long loc1 = arg1 ;  BigInteger loc2 = arg2 ;  byte [  ]  loc3 = arg3 ;  Sha256Hash loc4 = arg4 ;  int loc5 = arg5 ;  loc0 = loc0 - 1 ;  return loc0 ;  }
void function ( int arg0 ,  int arg1 ,  int arg2 ,  int arg3 ,  float arg4 ,  float arg5 ,  float arg6 )  { if  ( bulletTime  >  0 )  { return ;  } if  ( MAX_BULLETS  < = 0 || bullets . size (  )   > = MAX_BULLETS )  { return ;  } Bullet loc0 = new Bullet ( arg0 ,  arg1 ,  arg2 ,  arg3 ,  arg4 ,  arg5 ,  arg6 )  ;  bullets . add ( loc0 )  ;  bulletTime = BULLET_INTERVAL ;  } Note: This method fires a bullet from the current position with the specified parameters .  The arguments are as follows: arg0 is the x position of the bullet ,  arg1 is the y position of the bullet ,  arg2 is the z position of the bullet ,  arg3 is the direction in which the bullet is fired ,  arg4 is the speed of the bullet ,  arg5 is the angle of the bullet ,  and arg6 is the range of the bullet .  The method checks if there is a cooldown time for firing bullets ,  and if the maximum number of bullets has been reached .  If both conditions are met ,  a new bullet object is created and added to the list of bullets .  The cooldown time is also set . 
public static GetOfferDetailsResponse . Return . DetailOfferData . OfferDisplay function ( String arg0 ,  String arg1 )  { GetOfferDetailsResponse . Return . DetailOfferData . OfferDisplay loc0 = ObjectFactory . createGetOfferDetailsResponseReturnDetailOfferDataOfferDisplay (  )  ;  loc0 . setOfferTitle ( arg0 )  ;  loc0 . setOfferDescription ( arg1 )  ;  return loc0 ;  }
Long function (  )  { Long loc0 = getAcknowledgementInterval (  )  ;  return loc0 ;  }
void function (  )  { for  ( loc0 : eventHandler . getOpenChannels (  )  )  { try { loc0 . close (  )  ;  } catch  ( IOException e )  { } } eventHandlerFactory . close (  )  ;  server . close (  )  ;  }
void function ( Position pos ,  String arg0 ,  int arg1 )  { String loc0 = arg0 ;  // Rename argument name int loc1 = arg1 ;  // Rename argument name if  ( should_report ( loc0 ,  loc1 )  )  { enqueue ( new ErrorInfo ( pos ,  loc0 ,  loc1 )  )  ;  } }
JAXBElement < Access >  function ( String arg0 ,  String arg1 ,  List < String >  arg2 )  { Access loc0 = new Access (  )  ;  loc0 . setDomain ( arg0 )  ;  loc0 . setTarget ( arg1 )  ;  loc0 . getRole (  )  . addAll ( arg2 )  ;  return new JAXBElement <  >  ( _Access_QNAME ,  Access . class ,  null ,  loc0 )  ;  } Note: The above function uses the member variable "_Access_QNAME" to create a new JAXBElement object with the Access object as its value .  The argument names "arg0" ,  "arg1" ,  and "arg2" correspond to the domain ,  target ,  and role list of the Access object ,  respectively . 
void function ( String arg0 )  { String loc0 = arg0 ;  failedAttributeName = loc0 ;  }
public List < String >  function ( String arg0 )  { List < String >  loc0 = new ArrayList < String >  (  )  ;  try { String loc1 = "id -gn " + arg0 ;  Process loc2 = Runtime . getRuntime (  )  . exec ( new String [  ] {"/bin/sh" ,  "-c" ,  loc1} )  ;  BufferedReader loc3 = new BufferedReader ( new InputStreamReader ( loc2 . getInputStream (  )  )  )  ;  String loc4 = loc3 . readLine (  )  ;  StringTokenizer loc5 = new StringTokenizer ( loc4 ,  " " )  ;  loc5 . nextToken (  )  ;  while  ( loc5 . hasMoreTokens (  )  )  { loc0 . add ( loc5 . nextToken (  )  )  ;  } loc3 . close (  )  ;  } catch  ( IOException e )  { } return loc0 ;  }
void function (  )  { byte [  ]  loc0 = new byte [ 0 ]  ;  clientEndpoint . setBlocking ( true )  ;  while  ( clientSession . getPacketCount (  )   >  0 )  { clientEndpoint . receive ( loc0 )  ;  } while  ( clientSession . getOutstandingBytes (  )   >  0 )  { clientEndpoint . receive ( loc0 )  ;  } }
void function ( CharSequence arg0 ,  CharSequence arg1 ,  CharSequence arg2 ,  CharSequence arg3 )  { if  ( mActualMetadataEditor != null )  { try { mActualMetadataEditor . getClass (  )  . getMethod ( "putText" ,  int . class ,  CharSequence . class )   . invoke ( mActualMetadataEditor ,  METADATA_KEY_ARTWORK ,  arg0 )  ;  mActualMetadataEditor . getClass (  )  . getMethod ( "putText" ,  int . class ,  CharSequence . class )   . invoke ( mActualMetadataEditor ,  METADATA_KEY_ALBUM ,  arg1 )  ;  mActualMetadataEditor . getClass (  )  . getMethod ( "putText" ,  int . class ,  CharSequence . class )   . invoke ( mActualMetadataEditor ,  METADATA_KEY_TITLE ,  arg2 )  ;  mActualMetadataEditor . getClass (  )  . getMethod ( "putText" ,  int . class ,  CharSequence . class )   . invoke ( mActualMetadataEditor ,  METADATA_KEY_ARTIST ,  arg3 )  ;  } catch  ( Exception e )  { } } }
void function (  )  { try { ourInstance . setBatLvl ( 50 )  ;  ourInstance . lowerAltitude (  )  ;  ourInstance . waitFor ( 5000 )  ;  ourInstance . spinRight (  )  ;  ourInstance . waitFor ( 2000 )  ;  ourInstance . backward ( 1000 )  ;  ourInstance . waitFor ( 1000 )  ;  ourInstance . spinLeft (  )  ;  ourInstance . waitFor ( 2000 )  ;  ourInstance . forward ( 500 )  ;  ourInstance . waitFor ( 500 )  ;  ourInstance . spinRight (  )  ;  ourInstance . waitFor ( 2000 )  ;  ourInstance . forward ( 1000 )  ;  ourInstance . waitFor ( 2000 )  ;  ourInstance . spinLeft (  )  ;  ourInstance . waitFor ( 2000 )  ;  ourInstance . right (  )  ;  ourInstance . waitFor ( 1000 )  ;  ourInstance . spin90Left (  )  ;  ourInstance . waitFor ( ourInstance . spin90Time )  ;  ourInstance . backward ( 1000 )  ;  ourInstance . waitFor ( 2000 )  ;  ourInstance . land (  )  ;  ourInstance . onStop (  )  ;  } catch  ( Exception loc0 )  { Log . e ( TAG ,  "Error in landing: " + loc0 . getMessage (  )  )  ;  } }
Optional < Map < String ,  String >  >  function ( GroupConfiguration loc0 )  { return Optional . ofNullable ( loc0 . getMetadata (  )  )  ;  }
void function (  )  { setUp (  )  ;  String EXAMPLE = "$GPRMC , 120044 . 567 , A , 6011 . 552 , N , 02501 . 941 , E , 000 . 0 , 360 . 0 , 160705 , 006 . 1 , E , A*0B" ;  rmc . parse ( EXAMPLE )  ;  char loc0 = 'E' ;  rmc . setDirectionOfVariation ( loc0 )  ;  assertEquals ( loc0 ,  rmc . getDirectionOfVariation (  )  )  ;  loc0 = 'W' ;  rmc . setDirectionOfVariation ( loc0 )  ;  assertEquals ( loc0 ,  rmc . getDirectionOfVariation (  )  )  ;  try { loc0 = 'X' ;  rmc . setDirectionOfVariation ( loc0 )  ;  fail ( "Expected IllegalArgumentException" )  ;  } catch  ( IllegalArgumentException e )  { } }
