void function(ScriptOrFnNode arg0) { collectFuncNodes(arg0, loc0, null); }
public Sha256Hash function(File file) throws IOException { FileInputStream input = null; try { input = new FileInputStream(file); byte[] fileBytes = ByteStreams.toByteArray(input); return Sha256Hash.create(fileBytes); } finally { if (input != null) { input.close(); } } }
String function(boolean canCreate, Object arg0) { String loc0 = readObjectID(arg0); if (canCreate && loc0 == null) { loc0 = createObjectID(arg0); } return loc0; }
import org.hamcrest.Matcher; import org.hamcrest.number.ComparatorMatcherBuilder; public class OrderingComparison { public static <T extends Comparable<T>> Matcher<T> function(T arg0) { return ComparatorMatcherBuilder.<T>usingNaturalOrdering().greaterThan(arg0); } }
int function() { return denom; }
public String function(String arg0, String arg1) { DAOWrapper loc0 = new DAOWrapper(); loc0.GenericJSONBuilder() .addText(arg0) .setImage(arg1); return loc0.builder().buildFieldJSON(); } Explanation: This method takes in two arguments, "arg0" and "arg1", and returns a String. It creates an instance of the "DAOWrapper" class, initializes its "GenericJSONBuilder" member function, adds "arg0" and "arg1" as text and image respectively, and then builds and returns the JSON string using the "buildFieldJSON()" function of the builder.
public class XMPPServiceActivator implements BundleActivator { IEnvironments environments = null; HashMap<String, XMPPConnectionFactory> factories = new HashMap<String, XMPPConnectionFactory>(); AutoSIMXMPPConfig config = null; public void start(BundleContext context) { } public void function(BundleContext arg0) { deregisterConnectionFactory(); factories.remove("someKey"); } public void stop(BundleContext arg0) { function(arg0); } private void deregisterConnectionFactory() { } }
void function(long arg0) { mTestStream.seek(arg0); assertEquals(arg0, mTestStream.getPosition()); byte[] loc0 = new byte[1]; mTestStream.read(loc0); assertEquals(arg0 + 1, mTestStream.getPosition()); }
void function(CountDownLatch arg0, WeakReference<?> arg1) { try { System.gc(); System.runFinalization(); arg0.await(); while (arg1.get() != null) { System.gc(); System.runFinalization(); arg0.await(10, TimeUnit.MILLISECONDS); } CountDownLatch loc0 = new CountDownLatch(1); createUnreachableLatchFinalizer(loc0); loc0.await(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw formatRuntimeException("Error waiting for GC and finalization: %s", e.getMessage()); } catch (Exception e) { throw formatRuntimeException("Error during GC and finalization: %s", e.getMessage()); } }
void function() { MockedClass mockedObject = mock(MockedClass.class); when(mockedObject.mockedMethod(any(String.class))).thenReturn("mockedReturnValue"); mManager = mock(TransferManager.class); mStream = mock(S3ADirectOutputStream.class); when(mManager.upload(any(String.class), any(String.class), any(InputStream.class), any(ObjectMetadata.class))) .thenReturn(new UploadResult()); }
String function(Object arg0, String arg1, String arg2, String arg3) { String loc0 = getComments(arg0, arg1, arg2, arg3); String loc1 = loc0.replaceAll("/\\*\\*|\\*/|\\*\\s*", "").trim(); return loc1; }
Level function() { return Level.WARNING; }
String function(String arg0) { TSTNode loc0 = root; char[] loc1 = arg0.toCharArray(); int loc2 = 0; while (loc0 != null) { if (loc1[loc2] < loc0.data) loc0 = loc0.left; else if (loc1[loc2] > loc0.data) loc0 = loc0.right; else { loc2++; if (loc2 == loc1.length) return loc0.is_End_Of_String ? loc0.str : null; loc0 = loc0.middle; } } return null; }
void function(TableInfo arg0, int arg1, int arg2, Scan arg3, Scan arg4, Transaction arg5, int arg6, Scan arg7) { int loc0 = arg1; int loc1 = arg2; Scan loc2 = arg3; Scan loc3 = arg4; Transaction loc4 = arg5; TableInfo loc5 = arg0; int loc6 = arg6; Scan loc7 = arg7; loc2.close(); if (loc3 != null) { loc3.close(); } loc4.commit(); loc5.purgeTx(loc4); loc7.beforeFirst(); }
Map<String, String> function(String[] arg0) { Map<String, String> loc0 = new HashMap<>(); for (String arg : arg0) { String[] loc1 = arg.split("#"); loc0.put(loc1[0], loc1[1]); } return loc0; }
public static String[] function(XMLSource arg0, String arg1) { try { Node[] loc0 = arg0.getNodes(arg1, String.class); List<String> result = new ArrayList<>(); for (Node node : loc0) { if (node.getNodeType() != Node.COMMENT_NODE) { result.add(node.getTextContent()); } } return result.toArray(new String[result.size()]); } catch (Exception e) { e.printStackTrace(); return new String[0]; } }
boolean function(Collection<Source> arg0) { runToGoal(arg0, new GoalFactory() { }); return sourceExtension().getValidationGoal(arg1); } @Override Goal getGoal(Job arg1) { return sourceExtension().getValidationGoal(arg1); }
void function(boolean arg0) { ContentResolver loc0 = context.getContentResolver(); loc0.setLocationProviderEnabled(LocationManager.GPS_PROVIDER, arg0); }
boolean function(View arg0) { if (Build.VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN_MR1) { return arg0.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL; } else { return false; } }
Checklist function(Object arg0) { Class loc0 = arg0.getClass(); Checklist loc1 = lookupChecklist(loc0); if (loc1 == null && loc0.getSuperclass() != null) { loc1 = lookupChecklist(loc0.getSuperclass()); } return loc1; }
void function() { try { int loc0 = 15; // example day value instance.setDay(loc0); } catch (Exception loc1) { fail("Exception thrown: " + loc1.getMessage()); } }
int function(int arg0, int arg1) { int loc0 = 0; for (int loc1 = 0; loc1 < tiles[arg0][arg1].length; loc1++) { if (tiles[arg0][arg1][loc1] == null) { loc0 = loc1; break; } } return loc0; }
public Matrix function(Matrix arg0) { Matrix loc0 = transpose(arg0); Matrix loc1 = cofactor(loc0); double loc2 = determinant(arg0); double loc3 = 1.0 / loc2; Matrix loc4 = multiplyByConstant(loc1, loc3); return loc4; }
String function() { return thisExitStatus.getExitCode(); }
boolean function(Object arg0) { Element loc0 = (Element) arg0; return isHover(loc0); }
public List<AttributeStatementProvider> function() { List<AttributeStatementProvider> attributeStatementProviders = null; try { attributeStatementProviders = getAttributeStatementProviders(); } catch (Exception e) { e.printStackTrace(); } return attributeStatementProviders; }
public void function() { getAssets(); unload(); } private void getAssets() { } private void unload() { Array<Asset> loc0 = new Array<>(); }
ProjectModel function(UserModel arg0) { List<ProjectModel> loc0 = getProjectModels(arg0, true); if (!loc0.isEmpty()) { return loc0.get(0); } else { return null; } }
String function(String arg0) { int loc0 = Integer.parseInt(arg0, 16); int loc1 = (loc0 >> 16) & 0xFF; int loc2 = (loc0 >> 8) & 0xFF; int loc3 = loc0 & 0xFF; String loc4 = getClosestNamedColor(loc1, loc2, loc3); return loc4; }
String function(String arg0, String arg1, String arg2) { String fauxFile = "%s_%s_%s.%s"; return String.format(fauxFile, getSchema(), getType(), getName(), getSuffixFromType()); }
int function() { try { return port; } catch (Exception loc0) { loc0.printStackTrace(); return -1; // or any other default value } }
Set<String> function(Jedis arg0) { Set<String> loc0 = null; try { loc0 = arg0.keys("URLSet:*"); } catch (Exception e) { System.err.println("Error getting URLSet keys from Jedis: " + e.getMessage()); } return loc0; }
void function() { mBlocksToMoveIn.clear(); mBlocksToMoveOut.clear(); }
UserSubject function() { UserSubject subject = null; if (client != null && scopes != null && subject == null) { for (OAuthPermission scope : scopes) { if (scope instanceof SubjectOAuthPermission) { String subjectName = ((SubjectOAuthPermission) scope).getSubject(); if (subjectName != null) { subject = new UserSubject(subjectName); break; } } } } return subject; }
int function(boolean arg0) { try { return getIntFromFormat(arg0); } catch (Exception e) { } return 1; }
String function(TestResultDetailsDTO loc0) { return loc0.getErrorMsg(); }
boolean function(String arg0) { return _all.containsKey(arg0); }
String function(Node arg0) { StringBuilder result = new StringBuilder(); NodeList childNodes = arg0.getChildNodes(); for (int loc0 = 0; loc0 < childNodes.getLength(); loc0++) { Node childNode = childNodes.item(loc0); if (childNode instanceof Text || childNode instanceof CDATASection) { String nodeValue = childNode.getNodeValue(); result.append(nodeValue); } } return result.toString(); }
MarshalRegistry function(Object arg0, Object arg1) { String loc0 = "marshalRegistry"; MarshalRegistry loc1 = (MarshalRegistry) getProperty(loc0); if (loc1 == null) { loc1 = new MarshalRegistry(); setProperty(loc0, loc1); } return loc1; }
import java.util.ArrayList; import java.util.List; public class CollectionUtil { public static <T> List<T> function(T o1, T o2) { List<T> locList = new ArrayList<>(); try { locList.add(o1); locList.add(o2); } catch (Exception e) { e.printStackTrace(); } return locList; } }
void function(ParametersMetaData arg0) { try { setParametersMetaData(arg0); } catch (Exception e) { } }
public static ArrayList function(Object arg0, int arg1, String arg2) { ArrayList loc0 = new ArrayList(); try { loc0.add(new DeveloperModule()); TestPanel loc1 = TestPanel.getInstance(); loc0.add(loc1); return loc0; } catch (Exception loc2) { LOG.error("Failed to retrieve details tab(s): " + loc2.getMessage()); return null; } }
void function(byte[] arg0) { try { writer.writeStartElement("data"); String loc0 = new String(arg0); writer.writeCharacters(loc0); writer.writeEndElement(); } catch (XMLStreamException e) { e.printStackTrace(); } }
String function() { String loc0 = isActive; return loc0; }
private Object function(Object arg0, Object arg1, Object arg2) { Object loc0 = null; try { loc0 = CommonUtils.createNewClassInstance(Configuration.getClass("DataServer")); } catch (Throwable loc1) { Throwables.propagate(loc1); } return loc0; }
ECKey function(List<ECKey> arg0) { try { for (ECKey loc0 : arg0) { ECKey privKey = loc0.getPrivKey(); if (privKey != null) { return privKey; } } } catch (ECKey.MissingPrivateKeyException loc1) { } return null; }

void function(long arg0) { this.maximumKeySize = arg0; }
public String function(String arg0) { if (ts.hasField(arg0)) { return getVal(arg0); } return null; } private String getVal(String field) { String val = null; if (ts.hasField(field)) { val = ts.getString(field); } else if (s.hasField(field)) { val = s.getString(field); } return val; }
public byte[] function(int arg0) { byte[] loc0 = new byte[4]; loc0[0] = (byte) ((arg0 >> 24) & 0xff); loc0[1] = (byte) ((arg0 >> 16) & 0xff); loc0[2] = (byte) ((arg0 >> 8) & 0xff); loc0[3] = (byte) (arg0 & 0xff); return loc0; }
public long function(Coin arg0) { Coin loc0 = arg0.shiftLeft(SMALLEST_UNIT_EXPONENT); if (loc0.compareTo(MAX_SATOSHIS) > 0) { throw new ArithmeticException("Result exceeds maximum number of satoshis"); } return loc0.longValue(); }
public void function(MenuItemWrapper itemWrapper, int resId, Object obj) { itemWrapper.mMenuItem.setActionView(resId); itemWrapper.mMenuItem.setActionView(obj, 0); }
public void function() { notificationController.deletePersistentNotification(null, mockServerMessage); }
void function(double seconds) { try { if (seconds < 0 || seconds >= 60) { throw new IllegalArgumentException("srini_string"); } this.seconds = seconds; } catch (IllegalArgumentException e) { System.err.println("Exception caught: " + e.getMessage()); } }
void function(ServiceID arg0, ServiceID serviceID) { try { this.serviceID = serviceID; } catch (Exception e) { } }
int function() { int loc0 = 32 + StoredBlock.COMPACT_SERIALIZED_SIZE; int loc1 = numHeaders * loc0; int loc2 = FILE_PROLOGUE_BYTES + loc1; return loc2; }
T getPayload() { return mPayload; }
String function() { return DateTime.formatUTCtoSqlUTC(this.addedDate); }
List<DirectedAcyclicGraphNode<T>> function(DirectedAcyclicGraphNode<T> arg0) { List<DirectedAcyclicGraphNode<T>> loc0 = new ArrayList<>(); try { loc0.addAll(arg0.mChildren); } catch (NullPointerException e) { } return loc0; }
View function(RecyclerView arg0, View arg1, int arg2, int arg3) { int itemCount = arg0.getChildCount(); int headerCount = mAdapter.getHeaderCount(); int orientation = mOrientationProvider.getOrientation(); for (int loc0 = 0; loc0 < itemCount; loc0++) { View item = arg0.getChildAt(loc0); if (!itemIsObscuredByHeader(arg0, item, arg1, orientation)) { int position = arg0.getChildAdapterPosition(item) - headerCount; if (position >= 0 && !indexOutOfBounds(position)) { View header = mHeaderProvider.getHeader(arg0, position); Rect headerBounds = mDimensionCalculator.getHeaderBounds(arg0, header, item, position); if (headerBounds.contains(arg2, arg3)) { return item; } } } } return null; }
void function(List<TestResultDetailsDTO> arg0) { regTestResultDetailsLst = arg0; }
public long function(RegPCLTestResultEntity arg0) { try { return arg0.getTestId(); } catch (Exception loc0) { System.err.println("Error getting test ID: " + loc0.getMessage()); return -1L; } }
void function() { Time time = new Time(); TimeZone timeZone = TimeZone.getTimeZone("GMT+2"); Date arg0 = new Date(); arg0.setTime(arg0.getTime() + 5000); // Add 5 seconds to the current time time.setTime(arg0); Date loc0 = time.toDate(timeZone); Date loc1 = new Date(arg0.getTime()); assertEquals(loc0, loc1); long loc2 = loc0.getTime(); long loc3 = loc1.getTime(); assertEquals(loc2, loc3); }
public void function(BigDecimal arg0) { try { this.feedConfigId = arg0; } catch (Exception loc0) { } }
void function(String arg0) { writeCompressionType = arg0; } This function sets the compression type for images generated from the writer to the value provided in the argument "arg0". It does not handle any exceptions that may occur during its execution.
boolean function(RangeSet<C> arg0, Range<C> arg1) { return arg0.encloses(arg1); }
void function(Map<String,Object> arg0) { try { vars.putAll(arg0); } catch(Exception loc0) { System.err.println("Add variables to the context."); } }
public int function(int arg0, ByteBuffer arg1) { buffer = arg1; setOutputMode(); return buffer.hasRemaining() ? 1 : 0; }
void function(int arg0, String arg1, int arg2, int arg3, String arg4, String arg5) { SetStringRecord rec = new SetStringRecord(arg0, arg1, arg2, arg3, arg4, arg5); byte[] byteRec = rec.getBytes(); int lsn = append(byteRec); rec.setLSN(lsn); }
void function(DataFlowHandler dataFlowHandler, int arg0) { try { DataFlowNode node = dataFlowHandler.createDataFlowNode(arg0); List<DataFlowNode> dataFlow = this.dataFlow; dataFlow.add(node); } catch (Exception e) { LOGGER.warning("Error occurred in function: " + e.getMessage()); } }
public User function() { try { if (!SecurityUtils.isAuthenticationEnabled()) { throw new IOException(ExceptionMessage.AUTHENTICATION_IS_NOT_ENABLED.getMessage()); } return sUserThreadLocal.get(); } catch (Exception e) { return null; } }
public void function(String arg0) { try { if (!selectedRecipients.contains(arg0)) { selectedRecipients.add(arg0); } } catch (Exception e) { System.out.println("Failed to add recipient to the required recipients list."); e.printStackTrace(); } }
File function(String arg0) { File loc0 = new File(arg0); String loc1 = loc0.getRoot().getAbsolutePath(); mException.expect(IOException.class); if (!FileUtils.delete(arg0)) { fail("Failed to delete non-existent file: " + arg0); } return loc0; }
boolean function(String arg0, OperationSigMask arg1) { if (arg1.covers(OperationSignature loc0)) { if (operations.containsKey(loc0)) { return true; } else { return false; } } else { return false; } }
boolean function(Collection<UserModel> arg0) { return userService.updateUserModels(arg0); }
public void function(String arg0, Object arg1) { try { this.config.getServletContext().log(this.config.getFilterName() + "srini_string" + arg0, arg1 instanceof Throwable ? (Throwable) arg1 : null); } catch (Exception loc0) { } }
void function(HttpServletRequest arg0, HttpServletResponse arg1) { try { writeResponse(arg0, arg1, ""); } catch (IOException loc0) { LOG.error("Error writing empty response", loc0); } }
void function(int arg0, ProgressMonitor progressMonitor) { progressMonitor.setCurValue(arg0); }
String function(String arg0) { String loc0 = ""; try { loc0 = function(); } catch (Exception e) { m_log.error("Error accessing JSON string: " + e.getMessage()); } return loc0; } String function() throws Exception { String loc0 = m_escapedJson.replaceAll("\\\\", ""); loc0 = loc0.substring(1, loc0.length() - 1); return loc0; }
NodeIterator function(Document arg0, NodeTester arg1) { NodeFilter filter = new NodeFilter() { public short acceptNode(Node loc0) { return acceptNodeType(loc0.getNodeType()) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; } }; return arg0.createNodeIterator(rootNode, NodeFilter.SHOW_ALL, filter, false); }
BlockStoreContext function(InetSocketAddress arg0) { BlockStoreContext loc0 = CACHED_CONTEXTS.get(arg0); if (loc0 == null) { loc0 = new BlockStoreContext(mBlockMasterClientPool, mHasLocalWorker); CACHED_CONTEXTS.put(arg0, loc0); } return loc0; }
void function(ImageWriter arg0) { setWriteCompressionMode(ImageWriteParam.MODE_EXPLICIT); setWriteCompressionType("JPEG"); setWriteCompressionQuality(0.9f); }
String function(String arg0) { String loc0 = conditionallyPrependHttp(arg0); URI uri = URI.create(loc0); String loc1 = getHost(uri) + getPath(uri); String loc2 = getQuery(uri); return OMA_REDIRECT_LINK + "path=" + removePath(loc1) + "&" + loc2; }
void function(int port, ThreadingParameters threadingParams) { try { JettyHTTPServerEngine engine = portMap.get(port); if (engine != null) { Map<String, ThreadingParameters> newMap = new TreeMap<String, ThreadingParameters>(); newMap.put(Integer.toString(port), threadingParams); engine.getThreadingParametersMap().putAll(newMap); } } catch (Exception e) { LOG.log(Level.WARNING, "Exception setting threading parameters for port " + port, e); } }
void function(Language lang, CodeGenerator generator) { if (generators.containsKey(lang)) { LOG.debug("Replacing generator for language " + lang.getName()); } generators.put(lang, generator); fireEvent(new GeneratorAddedEvent(lang)); }
public void function(String name, String value) { try { setVariable(name, value); } catch (Exception e) { } }
public int function() { try { return index; } catch (Exception e) { return -1; } }
void function() { if (System.nanoTime() - bulletTime <= BULLET_INTERVAL && bullets.size() < MAX_BULLETS) { return; } bulletTime = System.nanoTime(); if (bullets.size() < MAX_BULLETS) { bullets.add(new Bullet(xPos, yPos, zPos, heading)); } }
GetOfferDetailsResponse.Return.DetailOfferData.OfferDisplay function() { GetOfferDetailsResponse response = createGetOfferDetailsResponse(); GetOfferDetailsResponse.Return returnValue = response.getReturn(); GetOfferDetailsResponse.Return.DetailOfferData detailOfferData = returnValue.getDetailOfferData(); return detailOfferData.getOfferDisplay(); }
public static long function(RMConfiguration arg0) { Long loc0 = arg0 != null ? arg0.getAcknowledgementInterval() : null; long loc1 = 0; if (loc0 != null) { try { loc1 = loc0.longValue(); } catch (NullPointerException e) { } catch (NumberFormatException e) { } } return loc1; }
void function() { server.stopAsync(); server.awaitTerminated(); }
String function(String message, String topic, int level, Position pos) { StringBuffer buf = new StringBuffer(); buf.append(message); int len = buf.length(); ErrorInfo info = new ErrorInfo(topic, buf.toString(), pos, level); getQueue().enqueue(info, ErrorInfo.DEBUG); return buf.toString(); }
Access function() { return new Access(); }
void function(TestResultDetailsDTO dto, String attributeName) { dto.setFailedAttributeName(attributeName); }
public List<String> function(String user) { List<String> groups = CommonUtils.getUnixGroups(user); ArrayList<String> groupList = new ArrayList<String>(); LinkedHashSet<String> groupSet = new LinkedHashSet<String>(); groupSet.addAll(groups); groupList.addAll(groupSet); return groupList; }
public void function() { try { Socket socket = getSocket(); if (socket != null) { socket.getOutputStream().flush(); } } catch (IOException e) { } }
void function(int key, String value) { MetadataEditorCompat metadataEditor = new MetadataEditorCompat(mActualMetadataEditor); metadataEditor.putString(key, value); }
void function() { GeneralMotorCon.getInstance().appendToConsole("Landing"); GeneralMotorCon.getInstance().landing(); GeneralMotorCon.getInstance().doFor(GeneralMotorCon.getInstance().hoverTime); }
Optional<GroupConfiguration> function(int arg0, int arg1, String arg2, int arg3, Map<String, String> arg4) { try { GroupConfiguration loc0 = new GroupConfiguration.Builder() .maxEntities(arg0) .minEntities(arg1) .name(arg2) .cooldown(arg3) .metadata(arg4) .build(); return Optional.of(loc0); } catch (IllegalArgumentException | NullPointerException e) { return Optional.empty(); } }
void function() { RMCParser rmc = new RMCParser(EXAMPLE); double expectedVariation = 6.1; String expectedDirection = "E"; double loc0 = rmc.getVariation(); String loc1 = rmc.getDirectionOfVariation(); assertEquals(expectedVariation, loc0, 0.1); assertEquals(expectedDirection, loc1); assertTrue(loc0 >= 0.0 && loc0 <= 180.0); assertTrue(loc1.equals("E") || loc1.equals("W")); }
String function(String arg0) { try { String loc0 = StringEscapeUtils.escapeJavaScript(arg0); loc0 = loc0.replaceAll("(?i)javascript", ""); loc0 = loc0.replaceAll("/\\*.*?\\*/", ""); return loc0; } catch (Exception e) { return ""; } }
String function(TokenReference arg0) { String loc0 = arg0.wsseValueType; return loc0; }
String function(Object arg0, Object arg1, Object arg2) { try { DAOWrapper locWrapper = new DAOWrapper(); locWrapper.setCoordinate((double)arg0, (double)arg1); locWrapper.setPlaceName((String)arg2); return locWrapper.buildFieldJSON(); } catch (Exception e) { e.printStackTrace(); return null; } }
public void function() { try { loadProperties(); } catch (IOException e) { LOGGER.error("Error loading properties: {}", e.getMessage()); } }
String function(IStoredSettings settings, String name) { try { return settings.getString(name, null); } catch (Exception e) { return null; } }
public static ResourceTypeHandler function(String arg0) { ResourceTypeHandler loc0 = null; try { loc0 = ResourceTypeHandler.valueOf(arg0); } catch (IllegalArgumentException e) { } return loc0; }
@Override void function(Node arg0, NodeTest arg1) { try { unhandled(arg0); } catch (Exception loc0) { loc0.printStackTrace(); } }
public static long function() { long loc0 = 0; long loc1 = 0; try { loc0 = RpcStatus.getTotal(); loc1 = RpcStatus.getTotalElapsed(); if (loc0 == 0) { return 0; } else { return (loc1 / loc0); } } catch (Exception e) { return 0; } }
void function() { try { setValue(""); setErrorLevel(0); setWarning(false); setKO(false); } catch (Exception e) { } }
public void function() { RMBTest rmbTest = new RMBTest(); double arg0 = 45.0; rmbTest.setUp(); try { rmbTest.rmb.setBearing(arg0); assertTrue("Expected IllegalArgumentException was not thrown.", false); } catch (IllegalArgumentException e) { assertTrue("Exception message does not contain 'bearing'!", e.getMessage().contains("bearing")); } catch (Exception e) { assertTrue("Unexpected exception thrown!", false); } double loc0 = 0.0; double loc1 = 180.0; double loc2 = -1.0; double loc3 = 361.0; try { rmbTest.rmb.setBearing(loc0); assertEquals(loc0, rmbTest.rmb.getBearing(), 0.0); rmbTest.rmb.setBearing(loc1); assertEquals(loc1, rmbTest.rmb.getBearing(), 0.0); rmbTest.rmb.setBearing(loc2); assertTrue("Expected IllegalArgumentException was not thrown.", false); } catch (IllegalArgumentException e) { assertTrue("Exception message does not contain 'bearing'!", e.getMessage().contains("bearing")); } catch (Exception e) { assertTrue("Unexpected exception thrown!", false); } try { rmbTest.rmb.setBearing(loc3); assertTrue("Expected IllegalArgumentException was not thrown.", false); } catch (IllegalArgumentException e) { assertTrue("Exception message does not contain 'bearing'!", e.getMessage().contains("bearing")); } catch (Exception e) { assertTrue("Unexpected exception thrown!", false); } }
public String function(long arg0) { try { AlluxioURI loc0 = mFileSystemMaster.getPath(arg0); return loc0.getPath(); } catch (Exception loc1) { return null; } }
int function(byte[] arg0) { int loc0 = Arrays.hashCode(arg0); int loc1 = ZERO_HASH.hashCode(); int loc2 = (loc1 << 1) | loc1; int loc3 = loc2 & loc0; return loc3; }
byte function() { byte loc0 = tag; return loc0; }
byte[] function(Block arg0) { byte[] loc0 = new byte[COMPACT_SERIALIZED_SIZE]; ByteBuffer loc1 = ByteBuffer.wrap(loc0); loc1.put(arg0.getHeader().getVersion()); loc1.put(arg0.getHeader().getPrevBlockHash().getBytes()); loc1.put(arg0.getHeader().getMerkleRoot().getBytes()); loc1.put(arg0.getHeader().getTime()); loc1.put(arg0.getHeader().getDifficultyTarget()); loc1.put(arg0.getHeader().getNonce()); loc1.put(EMPTY_BYTES); loc1.putInt(arg0.getHeader().getHeight()); return loc0; }
public Map<String, Object> function() { Map<String, Object> loc0 = new HashMap<>(); FCKeditorConfig loc1 = config != null ? config : new FCKeditorConfig(); loc0.putAll(loc1.getAdvancedSettings()); return loc0; }
Difference function() { Difference loc0 = this.additionDifference; return loc0; }
public String function() { String loc0 = ""; try { loc0 = this.version; } catch (Exception e) { LOG.error("Error accessing language version", e); } return loc0; }
Symbol function(int arg0) { Symbol loc0 = real_stack.elementAt(real_next); real_next++; vstack.push(arg0); int loc1 = vstack.size(); parse_state(loc0, arg0); return loc0; }
void function(ListenableFuture<?> arg0, Object arg1, int arg2) { CountDownLatch loc0 = new CountDownLatch(1); MockFutureListener loc1 = new MockFutureListener(arg0, loc0); arg0.addListener(loc1, MoreExecutors.directExecutor()); try { Assert.assertTrue(loc0.await(arg2, TimeUnit.SECONDS)); loc1.assertTimeout(); loc1.assertException(null); Assert.assertEquals(arg1, arg0.get()); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new RuntimeException(e); } catch (ExecutionException e) { loc1.assertException(e.getCause()); throw new RuntimeException(e.getCause()); } }
void function(int arg0) { try { this.gisticID = arg0; } catch (Exception e) { System.out.println("An error occurred while setting the internal ID: " + e.getMessage()); } }
long function(K arg0, long arg1) { try { return map.accumulateAndGet(arg0, arg1, Long::sum); } catch (NullPointerException e) { throw new IllegalArgumentException("key cannot be null"); } }
public static void function(String[] arg0) { try { SshExample loc0 = new SshExample(); loc0.connected(new SshConnectedEvent()); loc0.disconnected(new SshDisconnectedEvent()); loc0.dataReceived(new SshDataReceivedEvent()); } catch (Exception loc1) { System.out.println("Main method for SshExample: " + loc1.getMessage()); } }
void function(Object arg0, Object arg1) { activePlugins.removePluginObserver((PluginObserver) arg0); allPlugins.remove((AbstractPlugin) arg1); }
List<String> function(String arg0) { List<String> loc0 = new ArrayList<>(); try { loc0 = Lists.newArrayList(arg0); } catch (Exception e) { } return loc0; }
void function(ServiceID arg0) { try { bind(arg0); } catch (IOException loc0) { loc0.printStackTrace(); } }
void function() { testGetResponseString(); System.out.println("Test of getResponseStringCsv method, of class LogEntryRequest."); String loc0 = "srini_string"; String loc1 = instance.getResponseStringCsv(); assertEquals(loc0, loc1); }
Label function(Label arg0, float arg1, float arg2, float arg3, float arg4) { arg0.setX(arg1); arg0.setY(arg2); arg0.setWidth(arg3); arg0.setHeight(arg4); arg0.getStyle().set("color", Color.BLACK); arg0.setFont(Font.getDefault()); return arg0; }
public Sha256Hash function() { byte[] concatData = new byte[0]; for (StoredBlock storedBlock : checkpoints.values()) { concatData = Arrays.copyOf(concatData, concatData.length + 80); ByteBuffer buffer = ByteBuffer.wrap(concatData, concatData.length - 80, 80); storedBlock.getHeader().bitcoinSerialize(buffer); } byte[] hashBytes = Sha256Hash.hashTwice(concatData); return Sha256Hash.wrap(hashBytes); }
void function(Object arg0) { checkType(arg0); packLong(((Long)arg0).longValue(), true); } Note: I had to make assumptions about the types of some variables and parameters (e.g. checkType, packLong) since they were not provided in the question.
void function() { HDMTest hdmTest = new HDMTest(); hdmTest.setUp(); hdmTest.hdm.setHeading(90.0); boolean loc0 = hdmTest.hdm.isTrue(); assertTrue(loc0); hdmTest.hdm.setHeadingTooHigh(); boolean loc1 = hdmTest.hdm.isTrue(); assertFalse(loc1); }
void function(Signature.Visibility arg0) { visMask.removeAll(Arrays.asList(arg0)); }
String function(String arg0) { System.out.print(arg0); String loc0 = scanner.nextLine(); return loc0; }
Options function() { Options options = null; try { options = new Options(); options.addOption(Option.builder("R").required(false).hasArg(false).desc("recursive").build()); options.addOption(Option.builder("f").required(false).hasArg(false).desc("force").build()); options.addOption(Option.builder("P").required(false).numberOfArgs(1).desc("properties file name").build()); options.addOption(Option.builder("readonly").required(false).hasArg(false).desc("readonly").build()); options.addOption(Option.builder("shared").required(false).hasArg(false).desc("shared").build()); } catch (Exception e) { } return options; }
void function() { try { double arg0 = 123.45; vhw.setHeading(arg0); double loc0 = vhw.getHeading(); assertEquals(arg0, loc0, 0.001); } catch (Exception e) { } }
List<Variable> function(Constraint arg0, Variable arg1) { List<Variable> scope = arg0.getScope(); int size = scope.size(); List<Variable> result = new ArrayList<>(size - 1); for (int i = 0; i < size; i++) { Variable loc0 = scope.get(i); if (!loc0.equals(arg1)) { result.add(loc0); } } return result; }
public double function() { double loc0 = 0.0; try { loc0 = getOccupancy(); } catch (Exception e) { System.err.println("An exception occurred while getting occupancy: " + e.getMessage()); } return loc0; }
public String function() { String loc0 = null; try { loc0 = this.literalName; if (loc0 == null) { loc0 = this.SK_INSTANCE.equals(this) ? "INSTANCE" : (this.SK_CLASSIFIER.equals(this) ? "CLASSIFIER" : null); } if (loc0 == null) { throw new IllegalStateException("Invalid ScopeKindEnum value: " + this); } } catch (Exception loc1) { loc0 = "UNKNOWN"; } return loc0; }
void function(String arg0) { panel.setDocument(arg0); layout((Graphics2D) panel.getGraphics(), dim); render((Graphics2D) panel.getGraphics()); }
String function() { String loc0 = TodoParser.encode(item.getHeadline()); return "<headline>" + loc0 + "</headline>"; }
public String function() { StringBuilder sb = new StringBuilder(); for (Customer loc0 : customers) { sb.append(loc0.getName()).append(" (") .append(loc0.getNumberOfAccounts()).append(" account") .append(loc0.getNumberOfAccounts() > 1 ? "s" : "").append("): "); double loc1 = loc0.totalInterestEarned(); sb.append(format(loc1, "USD")).append("\n"); } return sb.toString(); }
double function() { StatsAccumulator statsAccumulator = new StatsAccumulator(); statsAccumulator.addAll(this.values); double min = statsAccumulator.min; if (Double.isNaN(min)) { return Double.NaN; } else if (Double.isInfinite(min)) { if (min < 0) { return Double.NEGATIVE_INFINITY; } else { double[] finiteValues = this.values.stream() .filter(d -> Double.isFinite(d)) .mapToDouble(d -> d) .toArray(); if (finiteValues.length == 0) { return Double.POSITIVE_INFINITY; } else { return Arrays.stream(finiteValues).min().getAsDouble(); } } } else { return min; } }
void function() { System.out.println("Test of getDeviceBlock method, of class Device."); String loc0 = dev.getDeviceBlock(); assertEquals(arg0, loc0); fail("The test case is a prototype."); }
void function() { SpaceXGUI.getInstance().appendToConsole(TAG, "srini_string"); cmd.down(speed).doFor(1000); cmd.hover().doFor(hoverTime); }
void function() { try { bufferSize = 0; buffer = new byte[INITIAL_BUFFER_CAPACITY]; } catch (Exception e) { e.printStackTrace(); } }
public byte[] function(byte[] arg0, byte[] arg1, byte[] arg2) { byte[] loc0 = NetworkParameters.SATOSHI_KEY; ECKey loc1 = ECKey.fromPublicOnly(loc0); if (!loc1.verify(arg0, arg1, arg2)) { throw new VerificationException("Signature does not match."); } return loc0; }
String function(Uri arg0) { SQLiteMatcherEntry loc0 = getMatcherEntry(arg0); SQLiteMatcherEntry.Type loc1 = loc0.getBaseType(); String loc2 = getType(); String loc3 = loc0.getSubType(); return loc2 + "/" + loc1 + "." + loc3; }
void function(final OutputStream arg0, final short arg1) { arg0.write(arg1 & 0xff); arg0.write((arg1 >> 8) & 0xff); }
double function(DenseMatrix64F arg0, DenseMatrix64F arg1, DenseMatrix64F arg2, double gamma, DenseMatrix64F u) { int n = arg0.getNumElements(); DenseMatrix64F x = new DenseMatrix64F(n, 1); DenseMatrix64F y = new DenseMatrix64F(n, 1); for (int i = 0; i < n; i++) { x.set(i, arg0.get(i)); } for (int i = 0; i < n; i++) { y.set(i, x.get(i)); } DenseMatrix64F uuT = new DenseMatrix64F(n, n); CommonOps.multTransB(u, u, uuT); CommonOps.scale(gamma, uuT); CommonOps.add(CommonOps.identity(n), uuT, arg2); CommonOps.mult(arg2, x, y); for (int i = 0; i < n; i++) { arg1.set(i, y.get(i)); } return 0.0; }
public static void function(Repository arg0, String arg1, String arg2, OutputStream arg3) { CompressionUtils compressionUtils = new CompressionUtils(); compressionUtils.tar(CompressorStreamFactory.XZ, arg0, arg1, arg2, arg3); }
import java.util.Collections; import java.util.Map; public class SearchConditionBuilder { private static final String DEFAULT_LANGUAGE = "FIQL"; private static final String FIQL = DEFAULT_LANGUAGE; public String query() { return ""; } private Map<String, String> createBuilderInstance(String language) { try { return Collections.emptyMap(); } catch (Exception e) { return null; } } }
void function(AbstractJspNodesTst obj, Object arg0) { if (arg0 instanceof JspNode) { obj.add((JspNode) arg0); for (int i = 0, len = ((JspNode) arg0).jjtGetNumChildren(); i < len; i++) { function(obj, ((JspNode) arg0).jjtGetChild(i)); } if (arg0.getClass().equals(clazz)) { obj.getNodes().add((T) arg0); } } }
boolean function(MotionEvent arg0, HandwriterView view) { boolean loc0 = view.getOnlyPenInput(); // Whether to use the MotionEvent as finger touch Hardware hardware = Hardware.getInstance(view.getContext()); boolean loc1 = hardware.isPenEvent(arg0); // Check if MotionEvent is a pen event return loc0 && loc1; }
SecurityContext function() { try { SecurityContext loc0 = getMessageContext().getSecurityContext(); if (!isSecure()) { warning("Insecure transport detected, OAuth access token security is compromised"); if (blockUnsecureRequests) { throw new BadRequestException("HTTPS is required to access this resource"); } } return loc0; } catch (RuntimeException loc1) { throw toBadRequestException(loc1); } }
void function(XMPPListener loc0) { try { if (loc0 != null && loc0.xmppConnection != null && loc0.xmppConnection.isConnected()) { loc0.xmppConnection.disconnect(); } } catch (Exception e) { loc0.log.error("Error disconnecting XMPP connection: " + e.getMessage(), e); } try { if (loc0 != null && loc0.workerPool != null) { loc0.workerPool.shutdown(); } } catch (Exception e) { loc0.log.error("Error shutting down worker pool: " + e.getMessage(), e); } }
String function(JSONObject arg0, String arg1) { String loc0 = ""; if (arg0.contains(arg1)) { loc0 = arg0.get(arg1).toString(); } return loc0; }
void function(byte[] arg0, int arg1) { byte[] loc0 = decoder.decodeBytes(arg0, arg1); byte[] loc1 = fmt.isBigEndian() ? loc0 : ByteData.reverseBytes(loc0); line.write(loc1, 0, loc1.length); }
int function() { int loc0 = 0; try { if (value <= Integer.MAX_VALUE) { loc0 = sizeOf((int)value); } else { loc0 = sizeOf(value); } } catch (Exception e) { e.printStackTrace(); } return loc0; }
boolean function(BitcoinSerializer loc0) { return loc0.isParseLazyMode(); }
public void function(String arg0) { runStatus = arg0; } This method sets the "runStatus" member variable of the "PCLFetcherRunRecorderEntity" class to the value of the argument passed in as "arg0".
void function() { SpaceXGUI.getInstance().appendToConsole(TAG, "srini_string"); cmd.setLedsAnimation(LEDAnimation.BLINK_RED, 3, (spinTime/1000)); cmd.spinRight(spin90Speed).doFor(spin90Time); cmd.hover().doFor(hoverTime); }
Map<Long, Integer> function() { Map<Long, Integer> loc0 = new HashMap<>(); try { List<ClientDetailsEntity> loc1 = clientService.getAllClients(); for (ClientDetailsEntity loc2 : loc1) { loc0.put(loc2.getId(), 0); } } catch (Exception loc3) { } return loc0; }
XPathContext function() { try { XPathContext loc0 = (XPathContext) super.clone(); loc0.path = new LinkedList<>(); for (Level loc1 : path) { loc0.path.addLast(loc1.clone()); } loc0.attributes = new HashMap<>(); for (Map.Entry<QName, Level> loc2 : attributes.entrySet()) { loc0.attributes.put(loc2.getKey(), loc2.getValue().clone()); } loc0.children = new ArrayList<>(); loc0.appendChildren(children); return loc0; } catch (CloneNotSupportedException loc3) { return null; } }
public int function(byte[] key) { HashFunction hasher = Hashing.murmur3_32(); HashCode hash = hasher.hashBytes(key); return Math.abs(hash.asInt()) % mNumBuckets; }
void function() { String validType = "$GP"; String invalidType = "$ABC"; assertTrue(instance.hasParser(validType + "GGA")); assertTrue(instance.hasParser(validType + "GLL")); assertTrue(instance.hasParser(validType + "RMC")); assertFalse(instance.hasParser(invalidType + "XXX")); }
I'm sorry, but your request seems incomplete or unclear. Could you please provide more information or context?
String function() { StringBuilder sb = new StringBuilder(); Iterator<Level> it = path.descendingIterator(); while (it.hasNext()) { sb.append(SEP); sb.append(it.next().asString()); } return sb.toString(); }
void function(BigDecimal arg0) { setRunId(arg0); }
void function() { assert _dot_pos == _the_production.rhs_length() : "Dot is not at the end of the production"; }
public void function() { try { CompleteFileOptions options = CompleteFileOptions.defaults(); long expectedLength = options.getUfsLength(); assertEquals(expectedLength, options.getUfsLength()); } catch (Exception e) { e.printStackTrace(); } }
public static Permission function(int permissionId) { return Permission.PERMISSIONS.get(Integer.valueOf(permissionId)); }
void function() { cancelled = true; }
public static JsonArray function(Set<String> items) { try { if (items == null || items.isEmpty()) { return null; } JsonArray array = new JsonArray(); for (String item : items) { array.add(item); } return array; } catch (Exception e) { logger.error("Error converting set to JSON array", e); return null; } }
public void function() { try { double expected = 1.852; double delta = 0.01; vhw.parse(EXAMPLE); assertEquals(expected, vhw.getSpeedKmh(), delta); } catch (Exception e) { } }
public void function() throws Exception { if (getType() == null) { throw new Exception("Invalid message: type is null"); } if (getEncodedLength() < 0) { throw new Exception("Invalid message: encoded length is negative"); } }
public boolean function(String fieldName) { return s1.hasField(fieldName) || s2.hasField(fieldName); }
void function(HttpServletRequest request) { HttpSession session = request.getSession(); session.setAttribute("authenticated", true); }
public FullyQualifiedClassType function() { return this.handlerClass; }
void function() { String oldRevisionInfo = RevisionManagement.getRevisionInformation(); oldRevisionGraphMap.put(revisionInformation, oldRevisionInfo); }
public int function() { try { return under_term.length; } catch (Exception e) { return 0; } }
public Spring function() { return mSprings.get(mControlSpringIndex); }
String getExtensionInfo() { return extensionInfo.toString(); }
void function() { try { rmb = new RMBSentence(EXAMPLE); empty = new RMBSentence(); } catch (Exception e) { System.out.println("Error in setUp: " + e.getMessage()); } }
void function(List<OAuthPermission> arg0) { this.scopes = arg0; }
Pageable pageable = PageRequest.of(0, max_suggest); log.debug("Getting all ingredients with pageable: {}", pageable); return ingredientRepository.findAll(pageable).getContent();
public String function(int index, String[] parts, int headerCount) { try { String data = parts[index]; if (data == null || data.trim().isEmpty() || data.equals(NA_STRING)) { return ""; } return data.trim(); } catch (ArrayIndexOutOfBoundsException e) { throw new RuntimeException("Column not found before end of data line", e); } }
void function(int arg0) { try { this.timeoutMillis = arg0; resetTimeout(); } catch (Exception e) { } }
void function(BoxFolder arg0, int arg1) { String loc0 = "srini_string"; for(BoxItem.Info loc1 : arg0) { for(int loc2 = 0; loc2 < arg1; loc2++) { loc0 += INDENT_APPEND; } if(loc1 instanceof BoxFolder.Info) { BoxFolder loc2 = (BoxFolder) loc1.getResource(); listFolder(loc2, arg1 + 1); } } }
void function() { try { vCloseRequested = true; socket.close(); } catch (IOException e) { throw new RuntimeException("Error while closing connection to server", e); } }
I'm sorry, but I cannot complete this task as the given method body is incomplete and lacks context. Please provide a complete and clear method body for me to work with.
float function() { return mFinal; }
void function(Map map) { try { Assert.notEmpty(map, "srini_string"); } catch (IllegalArgumentException e) { } }
void function() { try { notificationController.registerUserSession(null, mockServerMessage); fail("Expected NullPointerException was not thrown"); } catch (NullPointerException e) { } }
public void function(int step) { if (step < 0 || step >= panels.size()) { return; } while (panels.size() > step + 1) { removePanel(panels.size() - 1); } this.step = step; }
public int function(Tag arg0) { int keyComparison = this.key.compareTo(arg0.getKey()); if (keyComparison != 0) { return keyComparison; } return this.value.compareTo(arg0.getValue()); }
void function(float defaultValue) { if (!mHasAliasesSet) { mDefaultSpacing = newSpacingResultArray(defaultValue); } }
List<URL> function(Collection<String> basePackages, String extension, ClassLoader loader) { try { return findResources(basePackages, extension, loader); } catch (IOException e) { return Collections.emptyList(); } }
void function(QName arg0) { attributes.put(getLast(path).getName(arg0), getLast(path)); }
String function(Message msg) { for (ContentTypeRule rule : rules) { String contentType = rule.getContentType(msg); if (contentType != null) { return contentType; } } return defaultContentTypeProperty; }
private GetOfferDetailsResponse.Return.DetailOfferData.FulfillmentPartner function() { GetOfferDetailsResponse response = createGetOfferDetailsResponse(); GetOfferDetailsResponse.Return responseReturn = createGetOfferDetailsResponseReturn(); GetOfferDetailsResponse.Return.DetailOfferData detailOfferData = createGetOfferDetailsResponseReturnDetailOfferData(); return detailOfferData.getFulfillmentPartner().function(); }
public void function(ItemList<T> arg0) { try { this.items = arg0; } catch (Exception e) { } }
public boolean function(T payload) { DirectedAcyclicGraphNode<T> node = mIndex.get(payload); return mRoots.contains(node) && contains(payload); }
public long function(String arg0) { try { FileStatus loc1 = getFileStatus(arg0); return loc1.getLen(); } catch (IOException e) { } }
public void function() { List<String> parsers; try { parsers = instance.listParsers(); SentenceId[] sentenceIds = SentenceId.values(); assertEquals(parsers.size(), sentenceIds.length); for (SentenceId sentenceId : sentenceIds) { assertTrue(parsers.contains(sentenceId.name())); } } catch (Exception e) { } }
I'm sorry, but the method signature and the description you provided do not match. The method signature states that the method should get the Global Chromosomal Stop, but the description is about getting the Global Chromosomal Start. Could you please clarify which one you want me to implement?
int function() { return mStartCount; }
public int function() { try { return p1.recordsOutput() * ii.recordsOutput(); } catch (Exception e) { return -1; } }
public List<String> function(String key) { String value = getString(key); return Arrays.asList(value.split("\\s+")); }
public void function() { try { events.clear(); } catch (Exception e) { } }
public void function() { try { mClientRWLock = new ClientRWLock(); mReadLock = mClientRWLock.readLock(); mWriteLock = mClientRWLock.writeLock(); } catch (Exception e) { System.out.println("Exception caught: " + e.getMessage()); } }
public void function(int hour) { if (hour < 0 || hour > 23) { throw new IllegalArgumentException("Hour must be between 0 and 23 inclusive"); } this.hour = hour; }
public void function() { try { Configuration conf = new Configuration(); Evictor evictor = CommonUtils.createNewClassInstance( conf.getClass("dfs.block.evictor.classname", DefaultEvictor.class, Evictor.class), new Class<?>[] { BlockMetadataManagerView.class, Allocator.class }, new Object[] { view, allocator } ); } catch (Exception e) { } }
public long function() { try { return getIssuedAt(); } catch (Exception e) { } return -1; }
ArrayList<T> function(Iterable<T> iterable) { ArrayList<T> list = new ArrayList<>(); for (T item : iterable) { list.add(item); } return list; }
int function(String username) { if (log.isDebugEnabled()) { log.debug("Retrieving authorities for user: " + username); } Collection<String> authorities = getUserAuthorities(username); int size = authorities.size(); return size; }
public static EigenDecomposition<DenseMatrix64F> function(int matrixSize, DenseMatrix64F inputMatrix) { EigenDecomposition<DenseMatrix64F> eig; if (MatrixFeatures_DDRM.isSymmetric(inputMatrix, UtilEjml.TEST_F64)) { eig = DecompositionFactory_DDRM.symmEigen(matrixSize); } else { eig = new SwitchingEigenDecomposition_DDRM(matrixSize, -1); } eig.decompose(inputMatrix); return eig; }
public void function(ComparisonListener listener) { try { compListeners.add(listener); diffListeners.add(listener); matchListeners.add(listener); } catch (Exception e) { } }
public int function() { try { return getType().toInt(); } catch (Exception e) { return -1; } }
Matrix function(Matrix matrix) { int n = matrix.getNrows(); Matrix cofactor = new Matrix(n, n); for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { Matrix subMatrix = createSubMatrix(matrix, i, j); int sign = changeSign(i + j); double det = determinant(subMatrix); cofactor.setValueAt(i, j, sign * det); } } return cofactor; }
void function(boolean cacheTokens) { setCacheTokens(cacheTokens); }
public String function(String filePath, String pattern) { Pattern compiledPattern = Pattern.compile(pattern); try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) { String line; StringBuilder stringBuilder = new StringBuilder(); while ((line = reader.readLine()) != null) { Matcher matcher = compiledPattern.matcher(line); if (matcher.find()) { stringBuilder.append(matcher.group()).append(System.lineSeparator()); } } return stringBuilder.toString(); } catch (IOException e) { throw new RuntimeException(e); } }
public ServletConfig function() { return this.config; }
public Schema function() { return sch; }
public void function() { try { long duration = 1000L; instance.setDuration(duration); System.out.println("Duration set to: " + duration); } catch (Exception e) { System.out.println("Error setting duration: " + e.getMessage()); } }
void function() { while (s.next()) { if (idx.search(s.getVal(joinfield)) != null) { return; } if (!ts.next()) { return; } s.moveToRid(ts.getDataRid()); resetIndex(); } }
double function() { checkState(count() > 0, "Cannot compute covariance with zero values."); double meanX = xStats().mean(); double meanY = yStats().mean(); return sumOfProductsOfDeltas / count() - meanX * meanY; }
public void function() { try { zda.setTime(EXAMPLE); zda.setLocalZone("+0200"); assertEquals(0, zda.getLocalZoneMinutes()); } catch (Exception e) { } }
void function(String startTime) { setStartTime(startTime); }
boolean function(Schema schema, String fieldName) { return schema.fields().contains(fieldName); }
boolean function(Object obj) { if (!(obj instanceof TtlBucket)) { return false; } TtlBucket other = (TtlBucket) obj; return this.mTtlIntervalStartTimeMs == other.mTtlIntervalStartTimeMs; }
public int function() { try { return eig.getNumberOfEigenvalues(); } catch (Exception e) { return -1; // or some default value } }
public static Object function() { try { return new ObjectFactory().createCheckServiceAccessRequest(); } catch (Exception e) { return null; } }
void function(String arg0) { try { this.destFileExistsDTO.setFeedId(arg0); } catch (Exception e) { System.out.println("Error setting feed id: " + e.getMessage()); } }
void function() { triggerShutdown(); }
double[] function(BidiagonalDecompositionRow_D64 obj) { double[] loc0 = null; try { loc0 = obj.getGammasU(); } catch (Exception e) { e.printStackTrace(); } return loc0; }
public Bounds function(Node arg0) { Bounds loc0 = arg0.getBoundsInParent(); return loc0; }
void function(MapType arg0) { try { this.mapType = arg0; } catch (Exception e) { } }
public static int function(int arg0, String arg1) { try { return ParamChecker.checkGEZero(arg0, arg1); } catch (IllegalArgumentException e) { throw new IllegalArgumentException(XLog.format("Invalid argument {0}: {1}", arg1, arg0), e); } }
void function() { ExpectedException loc0 = ExpectedException.none(); loc0.expect(RuntimeException.class); loc0.expectMessage("Error creating instance of class: com.example.NonexistentProvider"); CustomAuthenticationProvider loc1 = new CustomAuthenticationProvider("com.example.NonexistentProvider"); }
void function() { SpringBolt subject = new SpringBolt(); subject.setScatterOutput(true); subject.run(); verify(outputCollectorMock).ack(tupleMock); verifyNoMoreInteractions(outputCollectorMock); }
Escaper function() { return new PercentEscaper("-._~!$'()*,;&=@:+/?", false) { @Override protected boolean safeOctets(int octet) { return (octet >= 'a' && octet <= 'z') || (octet >= 'A' && octet <= 'Z') || (octet >= '0' && octet <= '9') || octet == '.' || octet == '-' || octet == '~' || octet == '_' || octet == '@' || octet == ':' || octet == '!' || octet == '$' || octet == '\'' || octet == '(' || octet == ')' || octet == '*' || octet == '+' || octet == ',' || octet == ';' || octet == '=' || octet == '/' || (super.safeOctets(octet) && octet != '%'); } }; }
Long function(TestResultDetailsDTO obj) { Long loc0 = obj.getSeqNo(); return loc0; }
void function(int value) { try { ensureCapacity(3); mBuffer[mWriter.position()] = (byte) (value >> 16); mWriter.putShort((short) (value & 0xFFFF)); } catch (BufferOverflowException e) { } }
void function(Connection con) { JdbcUtils.closeAll(con, null, null); String name = JdbcUtils.getName(con); }
void function(ClassdiagramNode node) { try { uplinks.add(node); } catch (Exception e) { } }
void function() { Assert.assertEquals(TieredBlockStoreTestUtils.TIER_PATH[TEST_TIER_LEVEL], mTestTierView.getDirViews().get(0).getDirPath()); }
public boolean function(int period) { List<Element> elements = getElementsOfPeriod(period); return elements.stream() .filter(e -> e.getTID() == item) .findFirst() .isPresent(); }
boolean function() { String lowerUrl = url.toLowerCase(); return lowerUrl.startsWith("http://") || lowerUrl.startsWith("https://"); }
public Script function(ECKey pubKey) { byte[] pubKeyBytes = pubKey.getPubKey(); return new ScriptBuilder() .data(pubKeyBytes) .op(OP_CHECKSIG) .build(); }
void function(Cookie[] cookies) { for (int i = 0; i < cookies.length; i++) { Cookie cookie = cookies[i]; if (!cookie.isExpired(new Date())) { cookies.remove(cookie); // Remove any existing cookies with the same name cookies.add(cookie); // Add the new cookie } } }
public double function() { return x; }
public String function(List<Object> objects) { StringBuilder sb = new StringBuilder(); for (int i = 0; i < objects.size(); i++) { sb.append(objects.get(i)); if (i != objects.size() - 1) { sb.append(","); } } return sb.toString(); }
public int function() { try { return _size; } catch (Exception e) { System.err.println("An exception occurred: " + e.getMessage()); return -1; } }
public Object[] function() { try { return originalMatrix.getItems(); } catch (Exception e) { System.err.println("Error getting items from original matrix: " + e.getMessage()); return null; } }
void function(ByteBuffer arg0) { ByteBuffer loc0 = mReadResponse == null ? null : mReadResponse.getPayloadDataBuffer(); if (loc0 != null && loc0 == arg0) { loc0.release(); } }
boolean function(Entity arg0, double arg1) { if (arg0 == null) { return false; } int loc0 = arg0.getEntityId(); if (lastAttackedItem == null || !activated || theTarget == null || theTarget.getEntityId() != loc0) { lastAttackedItem = mob.getHeldItem(); setAttackTarget(arg0); return true; } else { double loc1 = getDistanceToEntity(arg0); if (loc1 > arg1) { setAttackTarget(arg0); return true; } } return false; }
void function() { double loc0 = rand.nextDouble(); loc0 *= loc0 * c2; loc0 += s2; loc0 = Math.signum(loc0) * Math.sqrt(Math.abs(loc0)); performImplicitSingleStep(loc0, false); }
boolean function(lalr_item arg0) { not_null(arg0); return _all.containsKey(arg0); }
public static RemoteBlockWriter function(InetSocketAddress address, long blockId, long sessionId) { try { Class<? extends RemoteBlockWriter> clazz = Configuration.getClass(PropertyKey.USER_BLOCK_REMOTE_WRITER_CLASS); return CommonUtils.createNewClassInstance(clazz, new Class[]{InetSocketAddress.class, long.class, long.class}, new Object[]{address, blockId, sessionId}); } catch (Exception e) { throw Throwables.propagate(e); } }
public static boolean function(double d1, double d2) { double epsilon = 0.00001; return Math.abs(d1 - d2) < epsilon; }
public CertificateChainInfo function() { return chain; }
public String function() { return this.toString() + ", " + this.hashCode(); }
boolean function(byte arg0) { final byte SPACE = 32; final byte HT = 9; return arg0 == SPACE || arg0 == HT; }
public static EaseUI function(Object arg0, Object arg1) { if (instance == null) { synchronized (EaseUI.class) { if (instance == null) { instance = new EaseUI(); userProvider = (EaseUserProfileProvider) arg0; settingsProvider = (EaseSettingsProvider) arg1; } } } return instance; }
void function(Hessian2Output arg0) { if (arg0 != null) { arg0.free(); _freeHessian2Output.free(arg0); } }
Date function() { return expires; }
void function() { try { final RPCMessage loc0 = new RPCBlockReadRequest(0, 0, 0, 0, 0); mThrown.expect(IllegalArgumentException.class); mThrown.expectMessage(ExceptionMessage.NO_RPC_HANDLER.getMessage(loc0.getType())); mHandler.channelRead0(mContext, loc0); } catch (Exception e) { } }
I'm sorry, but I cannot provide a solution to this task as it requires access to external libraries and dependencies, and I am not currently running in an environment where those are available. Please provide a different task that can be solved with only the information provided in the prompt.
public Bus function(Bus bus) { return bus; }
private ELEvaluator function(Date arg0, Date arg1, Element arg2, Configuration arg3) { ELEvaluator loc0 = Services.get(ELService.class).createEvaluator(arg1); setConfigToEval(loc0, arg3); return loc0; }
public double function(String operationName, String metricName) { MetricCalculator<OperationStats> calculator = Metrics.get().getCalculator(metricName); Map<String, OperationStats> operationStatsMap = operations.get(new OperationSignature(operationName)); if (operationStatsMap == null) { return 0; } List<OperationStats> operationStatsList = new ArrayList<>(operationStatsMap.values()); return calculator.computeFor(operationStatsList); }
public String function() { return sender; }
public void function(RevCommit commit) { try { RepositoryCommit newCommit = new RepositoryCommit(commit); addCommit(newCommit); } catch (DuplicateCommitException e) { } }
boolean function(int arg0, int arg1) { return steps.contains(new Step(arg0, arg1), false); }
void function(int value) { format.checkType(PackFormatInputStream.FieldType.INT); packLong(value, true); }
public void function() { olderThan = 0; coordOlderThan = 0; limit = 0; }
Object function(byte[] arg0, TFieldIdEnum fieldIdPathFirst, TFieldIdEnum... fieldIdPathRest) { TField field = locateField(arg0, fieldIdPathFirst, fieldIdPathRest); if (field.type != TType.I32) { throw new TException("Expected i32 field"); } return partialDeserializeField(field.type, arg0, fieldIdPathFirst, fieldIdPathRest); }
void function(int index) { taskMode = index; }
boolean function() { Date now = new Date(); String ifModifiedSinceHeader = getHeader("If-Modified-Since"); if (ifModifiedSinceHeader != null && !ifModifiedSinceHeader.isEmpty()) { long ifModifiedSince = getDateHeader("If-Modified-Since"); if (ifModifiedSince != -1 && ifModifiedSince >= 0) { Date ifModifiedSinceDate = new Date(ifModifiedSince); if (ifModifiedSinceDate.before(now)) { return true; } } } return false; }
public void function(Collection<? extends PhaseInterceptor<? extends Message>> interceptors) { try { after.addAll(interceptors.stream().map(PhaseInterceptor::getId).collect(Collectors.toList())); } catch (Exception e) { } }
void function(String address) { try { this.to = address; } catch (Exception e) { } }
public void function(Entity target) { try { mob = (EntityMobWithInventory) source; destination = new Vec3(target.posX - mob.posX, target.posY - mob.posY, target.posZ - mob.posZ).normalize().scale(-1).addVector(mob.posX, mob.posY, mob.posZ); destinationSet = true; path = null; } catch (Exception e) { e.printStackTrace(); } }
void function() { mWriter.close(); assertTrue(mWriter.isClosed()); assertFalse(mWriter.isCanceled()); mThrown.expect(IllegalStateException.class); mWriter.close(); }
public void function() { MetadataEditorCompat metadataEditor = null; Object actualMetadataEditor = null; Object actualRemoteControlClient = null; if (HAS_REMOTE_CONTROL_APIS) { actualRemoteControlClient = getActualRemoteControlClientObject(); actualMetadataEditor = RemoteControlClientCompat.MetadataEditorCompat .create(actualRemoteControlClient); metadataEditor = new MetadataEditorCompat(actualMetadataEditor); } else { actualMetadataEditor = editMetadata(true); metadataEditor = new MetadataEditorCompat(actualMetadataEditor); } }
public void function(PersonBlogs arg0, HashMap<String, HashMap<String, Integer>> arg1) { for (int loc1 = 0; loc1 < arg0.getPosts().size(); loc1++) { String loc2 = arg0.getPosts().get(loc1); String[] loc3 = NaiveBayesTrain.cleanPost(loc2); NaiveBayesTrain.updateNaiveBayesMapForSinglePost(loc3, arg1, arg0.getBloggerAgeClass()); } }
public static String function(long startTime) { long endTime = System.nanoTime(); long elapsedTime = endTime - startTime; return "Time elapsed: " + elapsedTime + " nanoseconds"; }
private void function(HttpServletRequest arg0) { try { String requestHeaders = arg0.getRequestHeaders().toString(); LOG.debug(requestHeaders); } catch (Exception e) { e.printStackTrace(); } }
void function() { LOG.info("Loading journal checkpoint file for " + mJournal.getName()); String checkpointFilePath = mJournal.getCheckpointFilePath(); if (checkpointFilePath != null) { try (InputStream checkpointInputStream = mJournal.getCheckpointInputStream()) { mReader.processJournalCheckpoint(checkpointInputStream); mLatestSequenceNumber = mReader.getLatestSequenceNumber(); LOG.info("Loaded journal checkpoint file with latest sequence number: " + mLatestSequenceNumber); } catch (IOException e) { LOG.error("Failed to load journal checkpoint file: " + e.getMessage()); } } mReader.close(); }
public long function() { return mCurrEvent.getEventTime() - mPrevEvent.getEventTime(); }
void function(byte[] data) { try { clientSession.getSocket().doWrite(data); } catch (IOException e) { logger.error("Error while sending data: {}", e.getMessage()); } }
void function() { String[] satelliteIds = { "02", "", "07", "", "09", "24", "26", "", "", "", "", "" }; instance.setSatelliteIds(satelliteIds); String[] actualIds = instance.getSatelliteIds(); assertEquals(satelliteIds.length, actualIds.length); int index = 0; for (String expectedId : satelliteIds) { assertEquals(expectedId, actualIds[index++]); } }
void function(String arg0, int arg1) throws UnknownHostException { InetAddress loc0 = InetAddress.getByName(arg0); clientSession.connect(loc0, arg1); }
public int function() { try { return this.index; } catch (Exception e) { return -1; // or some other default value } }
public Constant function() { return dataval; }
void function(String valueType) { setWsseValueType(valueType); }
Map<String, String> function(Parcel in) { Map<String, String> map = new HashMap<>(); int size = in.readInt(); for (int i = 0; i < size; i++) { String key = in.readString(); String value = in.readString(); map.put(key, value); } return map; }
void function(LevenbergMarquardt lm) { int n = lm.H.getNumElements(); double lambda = lm.initialLambda; lm.A.set(lm.H); for (int i = 0; i < n; i += n + 1) { lm.A.set(i, i, lm.A.get(i, i) + lambda); } }
public void function(ComplexNode arg0) { try { this.singleNestedComplexNode = arg0; } catch (Exception e) { } }
BoxFolder function(String folderName) { try { return currentFolder.getFolder(folderName); } catch (BoxAPIException e) { } return null; }
void function(String arg0) { try { this.units = arg0; } catch (Exception e) { } }
I cannot proceed with the request as it seems incomplete. Can you please provide the complete method signature or clarify the intention of the method?
public class JavaFxWebEngine { private WebEngine webEngine; public void function(String arg0) { try { webEngine.load(arg0); } catch (Exception e) { } } public void loadContent(String content) { } public void setOnAlert(EventHandler<WebEvent<String>> eventHandler) { } public Object executeScript(String command) { } public Worker<Void> getLoadWorker() { } public void setOnError(EventHandler<WebErrorEvent> eventHandler) { } }
function(PropertyChangeListener listener) { propertyChangeSupport.addPropertyChangeListener(listener); }
public String function() { try { return this.xmiId; } catch (Exception e) { return null; } }
boolean function(ActivityRequest request) { try { if (request == null || request.getProcessInstanceId() == null) { return false; } return true; } catch (Exception e) { logger.error("Error occurred during request validation.", e); return false; } }
public boolean function() { return mCheckpointRead && mCheckpointLastModifiedTime == mUfs.getLastModifiedTimeMs(mCheckpointPath); }
void function() { Date time = rmc.getTime(); assertNotNull(time); assertEquals(12, time.getHours()); assertEquals(0, time.getMinutes()); assertEquals(44, time.getSeconds()); }
public void function() { loadState(); }
void function() { handleCharacterData(); listener.processGroupEnd(); }
File function(String arg0) { File loc0 = getBackupDir(arg0); backup(loc0); return loc0; }
void function(Constant arg0, RID arg1) { beforeFirst(arg0); leaf.insert(arg1); leaf.close(); BTreeDir loc0 = new BTreeDir(); loc0.insert(dirTi.getDataVal(leafTi.block(), 0), leafTi.rootBlock()); if (loc0.isFull()) { loc0.makeNewRoot(); } close(); }
Map<Class<?>, String> function() { Map<Class<?>, String> loc0 = new HashMap<>(); try { loc0.putAll(SHORT_NAMES_BY_TYPE.asInverseWithShortName()); } catch (Exception e) { } return loc0; }
void function(boolean returnEntropy) { this.returnEntropy = returnEntropy; }
String function() { return request.getMethod(); }
public int function() { try { return ++generatedClassSerial; } catch (Exception e) { return -1; } }
public int getIndex() { return _index; }
public static String function(String defaultFolder, String title) { String selectedFolder = null; JFileChooser fileChooser = new JFileChooser(defaultFolder); fileChooser.setDialogTitle(title); fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY); int option = fileChooser.showDialog(null, "Select"); if (option == JFileChooser.APPROVE_OPTION) { selectedFolder = fileChooser.getSelectedFile().getPath(); } return selectedFolder; }
public String function(final HttpParams params) { try { String contentCharset = (String) params.getParameter(CoreProtocolPNames.HTTP_CONTENT_CHARSET); if (contentCharset == null) { contentCharset = HTTP.DEFAULT_CONTENT_CHARSET; } return contentCharset; } catch (Exception e) { throw new IllegalArgumentException("srini_string", e); } }
I'm sorry, but I cannot perform this task as there are multiple methods in the class with similar functionalities and it is not clear which method you are referring to. Please provide more specific information on which method you want me to modify.
function() { try { acitivityController.registerUserSession(null, mockServerMessage); fail("Expected NullPointerException to be thrown."); } catch (NullPointerException e) { } }
void function(MessageWriter writer, String value) { try { writeAttribute(writer, SOAP_ENCODING_REF_1_1, "#" + value); } catch (Exception e) { throw new RuntimeException("Error writing SOAP 1.1 ref attribute", e); } }
String function(String arg0) { String loc0 = ""; try { URL url = new URL(arg0); BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream())); String inputLine; while ((inputLine = in.readLine()) != null) { loc0 += inputLine + "\n"; } in.close(); } catch (Exception e) { e.printStackTrace(); } return loc0; }
void function(Config arg0) { config = arg0; }
public String function(int arg0) { String loc0 = null; switch(arg0) { case 0: loc0 = _rss_link; break; case 1: loc0 = _title; break; case 2: loc0 = _id.toString(); break; case 3: loc0 = _image; break; case 4: loc0 = _description; break; case 5: loc0 = _link; break; } return loc0; }
public BrowseOffersResponse.Return function() { try { BrowseOffersResponse.Return loc0 = new BrowseOffersResponse.Return(); return loc0; } catch (Exception e) { } }
String function(Builder arg0, final String arg1) { arg0.setObjectType(arg1); final LikeContent loc0 = arg0.build(); return loc0.getObjectType(); }
public static Script createP2SHOutputScript(byte[] scriptHash) { checkArgument(scriptHash.length == 20, "Script hash must be 20 bytes"); ScriptBuilder builder = new ScriptBuilder(); builder.op(OP_HASH160).data(scriptHash).op(OP_EQUAL); return builder.build(); }
String function() { OAuthServerConfiguration loc0 = getOAuthServerConfiguration(); OpenIDConnectUserInfoEndpointAccessTokenValidator loc1 = loc0.getOpenIDConnectUserInfoEndpointAccessTokenValidator(); return loc1.getClass().getName(); }
ResourceTypeHandler function(String arg0) { try { ResourceTypeHandler loc0 = getResourceType(arg0); if (loc0.isValid(arg0)) { return loc0; } } catch (Exception e) { } return FILE; }
void function(Double value) { mPendingQueue.add(value); runIfIdle(); }
JPanel function() { JPanel loc0 = uiStack.getLastElement(); loc0.function(); return loc0; }
public LinearSolver<DenseMatrix64F> function(int arg0, int arg1, boolean arg2) { QRColPivDecompositionHouseholderColumn_D64 qr = new QRColPivDecompositionHouseholderColumn_D64(); SolvePseudoInverseQrp solvePseudoInverseQrp = new SolvePseudoInverseQrp(); LinearSolverQrpHouseCol solver = new LinearSolverQrpHouseCol(qr, arg2); solver.setSingularThreshold(1e-12); if (arg0 == arg1) { solver = new LinearSolverQrpHouseCol(qr, arg2); } else if (arg0 > arg1) { solver = new LinearSolverQrpHouseCol(qr, arg2); solver.setA(new DenseMatrix64F(arg0, arg1)); } else { solver = new LinearSolverQrpHouseCol(qr, arg2); solver.setA(new DenseMatrix64F(arg0, arg0)); } return solver; }
public List<String> function() { List<String> loc0 = new ArrayList<>(); loc0.addAll(acceptedC14nAlgorithms); if (loc0.isEmpty()) { loc0.add(c14nAlgorithm); } return loc0; }
BigDecimal function() { BigDecimal loc0 = successorId; return loc0; }
public String function(DestinationFileExistsDTO obj) { String loc0 = ""; try { loc0 = obj.getFeedId(); } catch (NullPointerException e) { System.out.println("DestinationFileExistsDTO object is null"); } return loc0; }
List<NotationName> function() { return Collections.unmodifiableList(notations); }
byte[] function(int arg0, byte[] arg1, int arg2){ checkType(); getByteArrayInternal(arg0, arg1, arg2, arg1.length); return arg1; }
boolean function(String arg0) { String loc0 = "enemy"; String loc1 = "hand"; String loc2 = "getName"; String loc3 = "equals"; for (Card card : enemy.getHandCards()) { if (card.getName().equals(arg0)) { return true; } } return false; }
public String function() { String loc0 = null; try { loc0 = getReceiptDateType(); } catch (Exception loc1) { loc1.printStackTrace(); } return loc0; }
void function(int attempts, long sleepInMillis) { for (int i = 0; i < attempts; i++) { blockFxThreadWithSemaphore(); sleep(sleepInMillis, TimeUnit.MILLISECONDS); } }
long function(TokenRenewerResponse obj) { long loc0 = obj.getExpires().getTime() - obj.getCreated().getTime(); long loc1 = loc0 / 1000; return loc1; }
Object function(String arg0, boolean arg1) { return json != null && json.has(arg0) ? json.getBoolean(arg0) : arg1; } Object function(String arg0, boolean arg1, boolean arg2) { return json != null && json.has(arg0) ? json.getBoolean(arg0) : arg2; } Object function(String arg0) { return json != null && json.has(arg0) ? json.getString(arg0) : null; } boolean function(String arg0) { return json != null && json.has(arg0); }
void function() { canvas.setForegroundColor(color); canvas.fillCircle(xPosition, yPosition, diameter); }
void function(String arg0) { try { initializeModelImplementation(arg0); } catch (Exception loc0) { loc0.printStackTrace(); } }
short function(int arg0, int arg1) { short loc0 = lo16(arg0); short loc1 = hi16(arg1); return (short) (result(loc0, loc1) ^ arg0); }
String function(String arg0, String arg1) { String loc0 = ""; try { Transform transform = new Transform(); transform.setParameter(arg0, arg1); transform.transform(); loc0 = transform.getResultString(); } catch (Exception e) { loc0 = "Error during transformation: " + e.getMessage(); } return loc0; }
public String function() { return this.createdBy; } This function simply returns the value of the "createdBy" member variable of the "RegPCLTestResultEntity" object on which it is called. It does not take any arguments and does not have any exception handling.
class FuzzyTasker { HarvestCrops harvest; int taskMode; BuildFarm largefarm; RunAway runaway; int buildspeed; MeleeAttack melee; EntityMobWithInventory mob; ArrowAttack arrow; BuildMine longmine; BuildFarm smallfarm; MineOres mine; BuildMine shortmine; BuildHouse smallhouse; SowSeeds sow; StoreLoot loot; BuildHouse largehouse; FireballAttack fireball; Entity targeter(int mode) { return null; } void setTask(int mode) { } void nextStep() { } boolean function() { return mob.isBuilding(); } }
int function(int arg0) { checkState(); if (isOpCode()) { int loc0 = Script.decodeFromOpN(opcode); if (loc0 >= 0 && loc0 <= 16) { return loc0; } } return arg0; }
Book function(Book arg0) { log.debug("Saving book: {}", arg0); return bookRepository.save(arg0); }
void function() { runUrl(composeURL("stream")); URL loc0 = new URL(cameraIPAddress); URLConnection loc1 = loc0.openConnection(); loc1.connect(); DataInputStream loc2 = new DataInputStream(new BufferedInputStream(loc1.getInputStream())); InputStream loc3 = loc1.getInputStream(); }
void function(TreeModel arg0) { try { add(arg0); } catch (Exception loc0) { System.err.println("Error adding rule: " + loc0.getMessage()); } boolean loc1 = contains(arg0); if (!loc1) { add(arg0); } registerRule(arg0); }
void function(String arg0) { resultMessage = arg0; }
long function(DataServerMessage loc0) { loc0.function(); loc0.checkReady(); return loc0.mSessionId; }
void function() { Mode mode = new Mode(); mode.setOwnerBits("rwx"); mode.setGroupBits("r-x"); mode.setOtherBits("--x"); String loc0 = mode.toString(); String loc1 = "rwxr-x--x"; assertEquals(loc1, loc0); }
class VectorVectorMult { void function(double gamma, D1Matrix64F u, D1Matrix64F w, RowD1Matrix64F A) { int length = u.getNumElements(); double[] dataU = u.data; double[] dataW = w.data; double[] dataA = A.data; int indexA = A.getIndex(0); for (int i = 0; i < length; i++) { double valU = dataU[i]; int indexW = w.getIndex(0); for (int j = 0; j < length; j++) { dataA[indexA++] += gamma * valU * dataW[indexW++]; } } } }
void function() { NMEAParser loc0 = factory.createParser(); assertNull(loc0); instance.sentenceRead(event); NMEASentence loc1 = factory.createParser().parse(arg0); assertNotNull(loc1); assertEquals(loc1, instance.getSentences().get(0)); assertFalse(instance.getListeners().isEmpty()); }
void function(String arg0) { setAcceptedC14nAlgorithms(Collections.singletonList(arg0)); setC14nAlgorithm(WSConstants.C14N_EXCL_OMIT_COMMENTS); }
public static Response function(String arg0, String arg1) { Response loc0 = Response.serverError().entity(arg0).build(); return loc0; }
public static <F, T> Iterable<T> function(Iterable<F> arg0, Mapper<? super F, T> arg1) { try { return arg0.map(arg1::apply); } catch (Exception loc0) { throw new RuntimeException(loc0); } }
Map<String,Object> function() { Message message = new MessageImpl(); Map<String,Object> loc0 = new HashMap<String,Object>(); getHttpConduit().finalizeConfig(message); loc0.putAll(message.getExchange().getOutMessage().getInterceptorChain().getState()); loc0.remove(Client.REQUEST_CONTEXT); return loc0; }
public static Sha256Hash function(byte[] contents) { try { MessageDigest digest = MessageDigest.getInstance("SHA-256"); byte[] hash = digest.digest(contents); return new Sha256Hash(hash); } catch (NoSuchAlgorithmException e) { throw new RuntimeException(e); } }
<T> T function(Class<T> arg0, Service loc0) { return loc0.function(arg0); }
int function(Object arg0, Object arg1) { int loc0 = -1; try { TableCellListener tcl = (TableCellListener) arg0; loc0 = tcl.getTable().convertRowIndexToModel(tcl.getRow()); } catch (Exception e) { e.printStackTrace(); } return loc0; }
String function() { try { return address.getPostalZone().getValue(); } catch (NullPointerException e) { throw new RuntimeException("Postal zone is null", e); } }
void function(String arg0, String arg1, Exception arg2) { String loc0 = "Popup an SQL error"; String loc1 = Inter.get().toString(); String loc2 = arg2.toString(); popupError(loc0); warning(arg1); info(arg0 + " " + loc1 + " " + loc2); }
Condition function(String arg0) { LangCondition loc0 = new LangCondition(arg0); addCondition(loc0); return loc0; }
public static long function(JSONObject arg0, String arg1) { long loc0 = 0; try { loc0 = arg0.getLong(arg1); } catch (JSONException loc1) { loc0 = -1; } return loc0 != -1 ? loc0 : 0; }
void function(String arg0) { experimentTypes = arg0; } This method sets the "experimentTypes" member variable of the "Interaction" class to the value passed in as "arg0". It does not have any exception handling and does not have any return value.
public PasswordCredentials function() { return passwordCredentials; }
String function() { String loc0 = reason; return loc0; }
CheckMatrixMultShape arg0 = new CheckMatrixMultShape(); MatrixMatrixMult loc0 = new MatrixMatrixMult(); DenseMatrix64F loc1 = new DenseMatrix64F(5, 4); DenseMatrix64F loc2 = new DenseMatrix64F(4, 3); DenseMatrix64F loc3 = new DenseMatrix64F(5, 3); loc0.invoke(loc0.getClass().getMethod("mult", double.class, DenseMatrix64F.class, DenseMatrix64F.class, DenseMatrix64F.class), 2.0, loc1, loc2, loc3); arg0.checkAll(loc0);
void function() { for(int loc0 = 0; loc0 < PROPS.size(); loc0++) { AbstractSettings loc1 = PROPS.get(loc0); loc1.revertToDefault(); } }
void function(ArgoDiagramAppearanceEvent arg0, ArgoDiagramAppearanceEventListener arg1) { int loc0 = arg0.getEventType(); switch (loc0) { case ArgoEventTypes.DIAGRAM_FONT_CHANGED: arg1.diagramFontChanged(arg0); break; default: LOG.error("Unexpected event type: " + loc0); break; } }
double function(double arg0, double arg1) { double loc0 = 0; try { loc0 = Math.abs(arg0); double loc1 = UtilEjml.EPS * Math.max(Math.abs(arg0), Math.abs(arg1)); if (loc0 <= loc1) { loc0 = 0; } } catch (Exception e) { } return loc0; }
static void function(InputStream arg0) { BufferedReader loc0 = new BufferedReader(new InputStreamReader(arg0)); String loc1; try { while ((loc1 = loc0.readLine()) != null) { System.out.println(loc1); } } catch (IOException loc2) { loc2.printStackTrace(); } }
Boolean function(Object arg0) { return Boolean.TRUE.equals(arg0.get()); }
String[] function() { String outputStreamId = getOutputStreamId(); String[] outputFields = getOutputFields(); logger.info("Registering output fields: {}", Arrays.toString(outputFields)); arg0.declareStream(outputStreamId, new Fields(outputFields)); return outputFields; }
void function() { int numDirs = 5; for (int i = 0; i < numDirs; i++) { String dirPath = mTestFolder.getRoot().getPath() + "/dir" + i; mTestTierView.putAlias(i, dirPath); mTestTierView.putOrdinal(i, i); } for (int i = 0; i < numDirs; i++) { StorageDirView loc0 = mTestTierView.getDirView(i); assertEquals(i, loc0.getOrdinal()); assertEquals(mTestTierView.getAlias(i), loc0.getDirPath()); } }
import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMResult; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.Source; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import org.w3c.dom.Document; import org.w3c.dom.Node; public Document function(Source arg0, Source arg1) throws TransformerException { TransformerFactory loc0 = factory.newInstance(); loc0.setErrorListener(errorListener); loc0.setURIResolver(uriResolver); loc0.setStylesheet(styleSheet); DocumentBuilderFactory loc1 = DocumentBuilderFactory.newInstance(); DocumentBuilder loc2 = loc1.newDocumentBuilder(); Document loc3 = loc2.newDocument(); DOMResult loc4 = new DOMResult(loc3); loc0.newTransformer().transform(arg0, loc4); Node loc5 = loc4.getNode(); DOMSource loc6 = new DOMSource(loc5); loc0.newTransformer().transform(loc6, arg1); return loc3; }
String function(String arg0) { URI loc0 = URI.create(arg0); return loc0; } Note: This method takes a string argument that represents the URI to connect to a remote server. It creates a URI object from the given string and returns it as a result. It does not handle any exceptions that may occur during the creation of the URI object.
public T function(long arg0, TimeUnit arg1) { try { return acquire(arg0, arg1); } catch (TimeoutException e) { throw Throwables.propagate(e); } }
void function() { if (mOut != null) { mOut.close(); } if (mIn != null) { mIn.close(); } }
public static int function(int arg0, int arg1) { try { function(arg0, arg1); } catch (ValidationProblem e) { System.out.println("Validation problem occurred: " + e.getMessage()); System.out.println("Type: " + e.getType()); System.out.println("Line: " + e.getLine()); System.out.println("Column: " + e.getColumn()); return e.getColumn() != ValidationProblem.UNKNOWN ? e.getColumn() : ValidationProblem.UNKNOWN; } return ValidationProblem.UNKNOWN; }
void function(byte[] arg0, long arg1) { if (finalised) { throw new IllegalArgumentException("Generator already finalised."); } if (arg0.length != 32) { throw new IllegalArgumentException("Input length must be 32 bytes."); } for (int loc0 = 0; loc0 < 32; loc0++) { mixednumber[(ptr + loc0) % 32] ^= arg0[loc0]; } ptr = (ptr + 1) % 32; long loc1 = nextInt(); byte[] loc2 = hexToByte(Long.toHexString(loc1)); byte[] loc3 = hashByteArr(mixednumber); if (!Arrays.equals(loc2, loc3)) { throw new IllegalArgumentException("Verification failed."); } }
QualifiedName function(String arg0, OperationSigMask arg1) { QualifiedName qname = getQualifiedName(arg0); ClassStats classStats = getClassStats(qname, true); classStats.compute(arg1); return qname; }
void function() { try { YahooImageFactory loc0 = new YahooImageFactory(); runTest(arg0, loc0, arg1); } catch (Exception loc1) { LOG.error("Error running test: " + loc1.getMessage()); } }
String function(LocalCertificateStore locStore, String alias) { if (!locStore.containsAlias(alias)) { return "Alias not found"; } Matcher matcher = locStore.ALIAS_PATTERN.matcher(alias); if (!matcher.matches()) { return "Invalid alias"; } String keyId = alias.substring(locStore.ALIAS_PREFIX.length()); if (keyId.length() != 40) { return "Invalid keyId length"; } boolean success = locStore.deleteFile(locStore.FILE_PREFIX + keyId); if (success) { return "Certificate with alias " + alias + " deleted"; } else { return "Failed to delete certificate with alias " + alias; } }
void function(AuthType arg0) { try { if (arg0 == AuthType.SIMPLE || arg0 == AuthType.CUSTOM) { throw new UnsupportedOperationException(String); } arg0.getAuthName(); } catch (Exception e) { } }
void function(MediaRouter arg0, Object arg1) { try { arg0.addRemoteControlClient((RemoteControlClientCompat)arg1); } catch (RuntimeException loc0) { } }
public void function() { try { initializeDefault(); String loc0 = "org.argouml.model.mdr.MDRModelImplementation"; initializeModelImplementation(loc0); } catch (Exception loc1) { } }
boolean function() { return isBuildingDone && mob.getPositionVector().distanceTo(buildingSpot) < 1.0; } Note: It's unclear what the method is supposed to do, as there is no explanation or context provided. Therefore, this implementation is just a guess based on the method name and the variables used. Also, I have assumed that the "arg0", "arg1", etc. mentioned in the prompt are not relevant to this method.
void function() { try { k++; feedback(); } catch (Exception e) { } }
int function() { try { int loc0 = _size; return loc0; } catch (Exception e) { e.printStackTrace(); return NULL; } }
public static List<String> function() { List<String> abis = new ArrayList<>(); try { int sdkVersion = Build.VERSION.SDK_INT; int lollipop = Build.VERSION_CODES.LOLLIPOP; String abi = Build.CPU_ABI; String abi2 = Build.CPU_ABI2; String[] supportedAbis = LollipopSysdeps.getSupportedAbis(); class VersionDependent { List<String> getAbis() throws Exception { if (sdkVersion >= lollipop) { Method method = Class.forName("android.os.SystemProperties") .getDeclaredMethod("get", String.class); String systemArch = (String) method.invoke(null, "ro.product.cpu.abilist"); if (systemArch != null && !systemArch.isEmpty()) { abis.addAll(Arrays.asList(systemArch.split(","))); } else { abis.addAll(Arrays.asList(supportedAbis)); } } else { abis.add(abi); if (!TextUtils.isEmpty(abi2) && !abi2.equals(abi)) { abis.add(abi2); } } return abis; } } abis = new VersionDependent().getAbis(); } catch (Exception e) { e.printStackTrace(); } return abis; }
void function() { arg0.getServer().stop(); } This method calls the stop() function of the Server object stored in the "server" member variable to stop the execution of the server without any exception handling.
Map<String, List<String>> function() { try { if (connection == null) { createConnection(); } connection.setRequestMethod(verb.name()); addHeaders(connection); if (connection.getDoOutput()) { addBody(connection, getByteBodyContents()); } return connection.getHeaderFields(); } catch (IOException e) { throw new RuntimeException("An error occurred while getting connection headers.", e); } }
void function(String arg0) { Iterator<String> loc0 = resourceExtensions.iterator(); while (loc0.hasNext()) { String loc1 = loc0.next(); if (loc1.equals(arg0)) { loc0.remove(); break; } } }
public SearchFactory function() { SearchFactory loc0 = SearchFactory.getInstance(); SearchFactory loc1 = new SearchFactory(); return loc0 != null ? loc0 : loc1; } Note: This method returns an instance of SearchFactory using lazy instantiation. If an instance already exists, it returns that instance. Otherwise, it creates a new instance and returns it.
void function() { System.out.println("Test of listComPorts method, of class ComPortController."); ComPortController.listComPorts(); fail(); }
String function(String arg0) { String arg1 = "test"; ExpectedException loc0 = ExpectedException.none(); loc0.expect(IllegalArgumentException.class); loc0.expectMessage("Class " + arg0 + " does not implement AuthenticationProvider"); CustomAuthenticationProvider loc1 = new CustomAuthenticationProvider(arg0); return loc1.getName(); }
public void function(String arg0) { errorDescription = arg0; }
public boolean function(String arg0) { return lhsscan.hasField(arg0) || prodscan.hasField(arg0); }
public boolean function(String arg0) { List<SinkInfo> sinks = findSinkByMethodSignature(arg0); return !isEmpty() && sinks != null && !sinks.isEmpty(); }
public void function() { String filename = "test.pst"; URL resourceUrl = ClassLoader.getSystemResource(filename); File file = new File(resourceUrl.getFile()); PSTFile pstFile = new PSTFile(file); MessageStore msgStore = pstFile.getMessageStore(); boolean isPasswordProtected = msgStore.isPasswordProtected(); Assert.assertEquals(false, isPasswordProtected, "The test.pst file should not be password protected"); }
void function(String loc, double x, double y) { double dist = Math.sqrt(x*x + y*y); double dir = Math.atan2(y, x); if (dir < 0) { dir += 2*Math.PI; } Point2D pos = new Point2D.Double(dist*Math.cos(dir), dist*Math.sin(dir)); links.addVertex(loc); locationPositions.put(loc, pos); }
public List<String> function(DeterministicSeed seed) { List<String> mnemonicCode = null; try { mnemonicCode = seed.decodeMnemonicCode(seed.getMnemonicAsBytes()); } catch (Exception e) { } return mnemonicCode; }
public int function(String arg0) { try { Integer loc0 = offsets.get(arg0); if (loc0 != null) { return loc0.intValue(); } else { throw new IllegalArgumentException("Field not found: " + arg0); } } catch (Exception e) { return -1; // Return a default value or rethrow the exception } }
@Override public void stop(BundleContext arg0) { for (AutoSIMDeviceConfig loc0 : config.devices) { environments.deregisterConnectionFactory(loc0.name); factories.remove(loc0.name); } }
public boolean function(long fileId) { return mOutputFileIndex.containsKey(fileId); }
void function(Object arg0, Object arg1, Object arg2) { fetcherExecutionContextImpl.captureSourceMetadata(); StepContribution contribution = (StepContribution) arg1; contribution.setExitStatus(JobExitStatus.getExitStatus(ExitStatus.COMPLETED.getExitCode())); RepeatStatus loc0 = RepeatStatus.FINISHED; }
public int function() { int adapterPosition = -1; try { int childCount = recyclerView.getChildCount(); View lastVisibleChild = recyclerViewPositionHelper.findOneVisibleChild( childCount - 1, -1, false, true); if (lastVisibleChild != null) { RecyclerView.ViewHolder viewHolder = recyclerView.getChildViewHolder(lastVisibleChild); adapterPosition = viewHolder.getAdapterPosition(); } } catch (Exception e) { e.printStackTrace(); } return adapterPosition; }
public String function(ConfigurationKey arg0, String arg1) { String loc0 = null; try { loc0 = config.getString(arg0, arg1); } catch (Exception e) { } return loc0; }
int function(int arg0, String arg1, int arg2) { int loc0 = RecoveryMgr.txnum; Buffer buffer = BasicBufferMgr.bufferMgr().pin(arg0); if (RecoveryMgr.isTempBlock(buffer.block())) { BasicBufferMgr.bufferMgr().unpin(buffer); return -1; } else { SetStringRecord record = new SetStringRecord(arg1, arg2); int lsn = buffer.setInt(record, 0, 0, loc0); record.writeToLog(lsn); RecoveryMgr.commit(); BasicBufferMgr.bufferMgr().unpin(buffer); return lsn; } }
String function(String arg0, String arg1) { try { return builder() .addText(arg0) .addField("place", arg1) .buildFieldJSON(); } catch (Exception e) { System.err.println("Error occurred: " + e.getMessage()); } return "Not required"; }
public DiffBuilder function(Source arg0, Source arg1) { DiffBuilder builder = new DiffBuilder() .withTest(arg0) .compare(arg1) .checkForIdentical() .ignoreWhitespace() .ignoreComments(true) .withNodeMatcher(DefaultNodeMatcher.INSTANCE); return builder; } This function takes two Source objects as input arguments and returns a DiffBuilder object with the specified configurations. The `ignoreComments` method is set to true, which will remove all comment-Tags "&lt;!-- Comment --&gt;" from test- and control-XML before comparing.
ResponseEntity<Void> function(@PathVariable String arg0) { log.debug("REST request to delete DishCollection : {}", arg0); dishCollectionService.delete(arg0); return ResponseEntity.ok().headers(HeaderUtil.createEntityDeletionAlert(loc0)).build(); }
public static Map<Object, Double> function(BayesianNetwork arg0, AssignmentProposition[] arg1, RandomVariable[] arg2, int arg3, int arg4) { Map<Object, Double> w = new HashMap<Object, Double>(); for (int j = 1; j <= arg3; j++) { Pair<Map<RandomVariable, Object>, Double> wSample = weightedSample(arg0, arg1); Map<RandomVariable, Object> weightedSample = wSample.getLeft(); Double weight = wSample.getRight(); for (AssignmentProposition e : arg1) { if (weightedSample.containsKey(e.getTermVariable())) { weightedSample.remove(e.getTermVariable()); } } for (RandomVariable X : arg2) { if (weightedSample.containsKey(X)) { w.put(X, w.getOrDefault(X, 0.0) + weight); } } } Map<Object, Double> x = new HashMap<Object, Double>(); for (RandomVariable X : arg2) { double[] dist = new double[X.getDomain().size()]; for (int j = 0; j < dist.length; j++) { AssignmentProposition[] e = arg1.clone(); e = e == null ? new AssignmentProposition[0] : e; e[e.length] = new AssignmentProposition(X, X.getDomain().get(j)); double prob = 0.0; for (int k = 1; k <= arg4; k++) { Pair<Map<RandomVariable, Object>, Double> sample = weightedSample(arg0, e); Map<RandomVariable, Object> loc0 = sample.getLeft(); Double weight = sample.getRight(); prob += weight * (loc0.containsKey(X) && loc0.get(X).equals(X.getDomain().get(j)) ? 1 : 0); } dist[j] = prob / arg4; } x.put(X, ProbabilityTable.normalize(dist)); } return x; }
int function(Object arg0, int arg1, boolean arg2) { int loc0 = hashCode(arg0); int loc1 = loc0 % _prime; while (_keys[loc1] != null) { if (_keys[loc1].equals(arg0)) { if (arg2) { int loc2 = _values[loc1]; _values[loc1] = arg1; return loc2; } else { return NULL; } } loc1 = (loc1 + 1) % _prime; } _keys[loc1] = arg0; _values[loc1] = arg1; _size++; return NULL; }
byte[] function() { int loc0 = getByteArrayLength(); byte[] loc1 = new byte[loc0]; getByteArrayInternal(loc0, loc1, 0, loc0); return loc1; }
void function(String arg0) { SAMLSSOReqValidationResponseDTO loc0 = new SAMLSSOReqValidationResponseDTO(arg0); SPInitLogoutRequestProcessor loc1 = new SPInitLogoutRequestProcessor(); loc1.process(null, loc0.getResponse(), null); }
void function(Object arg0, PropertyChangeListener arg1, String[] arg2) { try { addElementListener(arg1, arg0, arg2); } catch (Exception e) { LOG.error("Error while initializing model change listeners for modelelement: " + arg0, e); } }
long function(long arg0, long arg1, int arg2, long arg3) { Mapping map = new Mapping(); map.qStart = arg0; map.tStop = arg1; map.blockSize = arg2; map.tStart = arg3; return map.getQStart(); }
JAXBElement<RegistrationRequest> function() { JAXBElement<RegistrationRequest> loc0 = null; try { ObjectFactory objFactory = new ObjectFactory(); loc0 = objFactory.createRegistrationRequest(); } catch (Exception loc1) { } return loc0; }
boolean function(File arg0, String[] arg1) { if (arg0 == null || arg1 == null || arg1.length == 0) { return false; } String filename = arg0.getName(); for (int i = 0; i < arg1.length; i++) { String suffix = arg1[i]; if (suffix != null && suffix.length() > 0 && filename.endsWith(suffix)) { return true; } } return false; }
Crypto function() { Crypto loc0 = this.signatureCrypto; if (loc0 == null) { loc0 = CryptoFactory.getInstance(this.signatureCryptoProperties); this.setSignatureCrypto(loc0); } return loc0; }
void function() { try { instance.maxMemory = 0; } catch (Exception e) { } }
void function(File arg0) { try { sourceCodeFile = arg0; if (sourceCodeFile == null && !ignoreExceptions) { throw new RuntimeException("File is null and ignoreExceptions is false"); } } catch (Exception e) { if (!ignoreExceptions) { report.addError(e.getMessage()); } } }
void function(Node arg0) { try { closed.removeValue(arg0); } catch (Exception e) { } }
String function() { String loc0 = ""; try { loc0 = new String(_messageBody, Charset.forName(_encoding)); } catch (Exception loc1) { loc0 = "rubbish string"; } return loc0; }
void function(Path path, int[] coordinates) { model.moveCharacter(path, coordinates); triggerEvent(); }
public boolean function(boolean arg0) { Object loc0 = getAttribute("skipFailingRules"); if (loc0 instanceof Boolean) { return (Boolean) loc0; } else { return arg0; } } Note: This method retrieves the value of the "skipFailingRules" attribute from the "attributes" member variable. If the attribute is present and is a boolean, it returns its value. Otherwise, it returns the value of the "ignoreExceptions" parameter passed as an argument. This implementation does not handle any exceptions that may occur during attribute retrieval.
String function(Iterable<String> arg0, char arg1) { StringBuilder loc0 = new StringBuilder(); for (String loc1 : arg0) { if (loc0.length() > 0) { loc0.append(arg1); } loc0.append(loc1); } return loc0.toString(); }
public void function(Map<String, SortedSet<String>> arg0, Map<String, SortedSet<String>> arg1) { Set<String> keys = arg1.keySet(); for (String key : keys) { SortedSet<String> values1 = arg0.get(key); SortedSet<String> values2 = arg1.get(key); if (values1 == null) { arg0.put(key, new TreeSet<>(values2)); } else { values1.addAll(values2); } } }
public int function(GroupValue obj) { int hash = 0; try { Map<String, Constant> loc0 = obj.vals; Set<Map.Entry<String, Constant>> loc1 = loc0.entrySet(); for (Map.Entry<String, Constant> loc2 : loc1) { Constant loc3 = loc2.getValue(); hash += loc3.hashCode(); } } catch (NullPointerException e) { hash = 0; } return hash; }
int function(int arg0, int arg1) { int loc0 = arg0; int loc1 = arg1; int tile = -1; while (loc0 >= 0 && loc0 < tiles.size && loc1 >= 0 && loc1 < tiles.get(loc0).size) { if (tiles.get(loc0).get(loc1).size == 0) { tile = loc0 * tiles.get(loc0).size + loc1; } loc0--; } return tile; }
String function() { String loc0 = null; String loc1 = null; if (this.transformedTokenIdentifier != null) { loc0 = this.transformedTokenIdentifier; } else if (this.id != null) { loc1 = this.id; if (this.getSHA1() != null) { loc0 = "_" + this.getSHA1(); } else { loc0 = loc1; } } return loc0; }
void function(String arg0) { try { loadedInCats = arg0; } catch (Exception loc0) { System.err.println("Error setting loadedInCats: " + loc0.getMessage()); } }
public int function() { try { return decisions; } catch (Exception e) { System.out.println("An error occurred while retrieving the number of decisions made: " + e.getMessage()); return -1; } }
String function(Date arg0) { try { DateTimeFormat loc0 = DateTimeFormat.SQL; return formatUTC(arg0, loc0, true); } catch (Exception loc1) { } return null; }
int function() { int loc0 = 0; try { loc0 = mSize; } catch (Exception e) { System.out.println("Error occurred while getting stack size: " + e.getMessage()); } return loc0; }
import java.util.prefs.Preferences; public class Prefs { boolean s_newVersionSet=false, s_newVersion=false, s_installed; Logger LOG=LoggerFactory.getLogger(Prefs.class); double getVersion() { return 0.0; } boolean hasId() { return false; } double getLastVersion() { return 0.0; } String getBaseUri() { return null; } boolean newVersion() { return false; } boolean running() { return false; } void setInstalled(final boolean installed) { s_installed = installed; } boolean isInstalled() { return s_installed; } long setId() { return 0; } long getId() { return 0; } File getTorrentDir() { return null; } void function(double arg0) { try { Preferences prefs = Preferences.userRoot(); prefs.putDouble("LastVersion", getVersion()); double loc0 = prefs.getDouble("LastVersion", 0.0); prefs.put("LastVersion", Double.toString(loc0)); } catch (Exception e) { LOG.error("Failed to set last version", e); } } }
String function() { String locHostname = null; try { InetAddress locAddress = InetAddress.getLocalHost(); locHostname = locAddress.getHostName(); } catch (UnknownHostException e) { e.printStackTrace(); } return locHostname; }
void function(RepositoryCommit commit) { if (commits.contains(commit)) { return; } commits.add(commit); }
void function() { try { int loc0 = cal.get(Calendar.MONTH); int loc1 = instance.getMonth(); assertEquals(loc0, loc1); } catch (Exception e) { } }
TableInfo function(String arg0, Transaction arg1) { TableInfo loc0 = new TableInfo(arg0, schema()); int loc1 = loc0.recordLength(); int loc2 = HashIndex.searchCost(loc0.blocksAccessed(), loc0.numRecords(), loc1); int loc3 = si.recordsOutput(); return loc0; }
void function(RuleContext arg0, List<Node> arg1, Language arg2) { RuleChainVisitor loc0 = languageToRuleChainVisitor.get(arg2); loc0.visitAll(arg0, arg1); }
Builder function(AddressPair arg0) { Builder loc0 = Builder.fromAddressPair(arg0); return loc0; }
Element function(String arg0, String arg1, int arg2, Element arg3) { Element loc0 = arg3.getOwnerDocument().createElement("Error"); loc0.setAttribute("Number", String.valueOf(arg2)); if (StringUtils.isNotEmpty(arg0)) { Element loc1 = arg3.getOwnerDocument().createElement("Message"); loc1.appendChild(arg3.getOwnerDocument().createTextNode(arg0)); loc0.appendChild(loc1); } if (StringUtils.isNotEmpty(arg1)) { Element loc2 = arg3.getOwnerDocument().createElement("Description"); loc2.appendChild(arg3.getOwnerDocument().createTextNode(arg1)); loc0.appendChild(loc2); } return loc0; }
void function(final String arg0) { try { instanceName = arg0; } catch (Exception e) { } } This method sets the unique name of the editor by assigning the value of the input argument to the member variable "instanceName". It also includes exception handling to catch and handle any potential exceptions that may occur during the assignment.
boolean function(Combination arg0) { boolean loc0 = true; String loc1 = arg0.toString(); boolean loc2 = configurations.containsKey(loc1); if (loc2) { loc0 = configurations.get(loc1); } return loc0; }
void function(boolean arg0) { setConsoleModeAndParseShowProgress(new String[]{String.valueOf(arg0)}); }
String function(String arg0, String arg1) { StringBuilder sb = new StringBuilder(); sb.append(arg0).append('=').append(HTTPTransportUtils.getRawQueryStringParameter(arg1, arg0)); return sb.toString(); }
Object function(String arg0, Scriptable arg1) { if (arg0.equals("dim")) { return dim; } return Scriptable.NOT_FOUND; }
List function(Object arg0, Object arg1) { List loc0 = new ArrayList(); try { loc0 = new ArrayList((List) arg0); loc0.removeAll(newFeatures); } catch (Exception e) { e.printStackTrace(); } return loc0; }
ClassStats function(String className, String nestedClassName) { try { ClassStats classStats = fields.get(new FieldSignature(className, nestedClassName)); if (classStats != null) { return classStats; } if (nestedClasses.containsKey(nestedClassName)) { return nestedClasses.get(nestedClassName); } return null; } catch (Exception e) { return null; } }
void function(String arg0) { this.gene = arg0; }
void function(String arg0) { if (!containsLocation(arg0)) { addResourceLocation(arg0); } }
public void function(Entry arg0) { if (mIsClosed) { throw new IllegalStateException("JournalWriter is closed"); } try { CheckpointEntry.Builder builder = CheckpointEntry.newBuilder() .setPayload(ByteString.copyFrom(arg0.serialize())) .setSequenceNumber(mNextEntrySequenceNumber++); CheckpointEntry checkpointEntry = builder.build(); mCheckpointOutputStream.write(checkpointEntry.toByteArray()); mCheckpointOutputStream.flush(); } catch (IOException e) { String errorMsg = "Failed to write entry to checkpoint file: " + e.getMessage(); LOG.error(errorMsg, e); throw new RuntimeException(errorMsg, e); } }
boolean function(byte arg0) { boolean[] loc0 = HTTP_CONTROLS; return loc0[arg0 & 0xFF]; }
void function(String arg0, CookieSpecFactory arg1) { try { if (arg0 == null || arg0.trim().isEmpty()) { throw new IllegalArgumentException("Invalid cookie spec name"); } String loc0 = arg0.toLowerCase(Locale.ENGLISH); registeredSpecs.put(loc0, arg1); } catch (Exception e) { } }
public void function(BoundingBox arg0, BoundingBox arg1) { float loc0 = Math.max(arg0.getLatMin(), arg1.getLatMin()); float loc1 = Math.min(arg0.getLatMax(), arg1.getLatMax()); arg0.latMin = loc0; arg0.latMax = loc1; loc0 = Math.max(arg0.getLonMin(), arg1.getLonMin()); loc1 = Math.min(arg0.getLonMax(), arg1.getLonMax()); arg0.lonMin = loc0; arg0.lonMax = loc1; }
Object function(Object arg0) { return ((AbstractExtensionMechanismsHelperDecorator) arg0).impl; }
public static <T> GeneralRange<T> function(Comparator<? super T> arg0, T arg1, BoundType arg2, T arg3, BoundType arg4) { return new GeneralRange<T>( arg3, arg4, true, arg1, true, null, arg0, null, arg2); }
public static void function(InputStreamReader arg0, RuleSets arg1, RuleContext arg2) { try { Reader loc0 = new BufferedReader(arg0); LanguageVersion loc1 = configuration.getDefaultLanguageVersion(); Parser loc2 = ParserTstUtil.createParser(loc1, configuration); Node loc3 = parse(arg2, loc0, loc2); symbolFacade(loc3, loc1.getLanguageVersionHandler()); usesDFA(loc1, loc3, arg1, loc1.getLanguage()); usesTypeResolution(loc1, loc3, arg1, loc1.getLanguage()); usesMetrics(loc1, loc3, arg1, loc1.getLanguage()); processSource(loc0, arg1, arg2); } catch (UnsupportedEncodingException loc4) { throw new PMDException(loc4.getMessage()); } catch (IOException loc5) { throw new PMDException(loc5.getMessage()); } }
void function() { try { String arg0 = "nonExistingClient"; service.setClientId(arg0); service.clearApprovedSitesForClient(); service.getByClientId(arg0); Mockito.verify(repository, Mockito.never()).remove(Mockito.any(ApprovedSite.class)); } catch (Exception loc0) { loc0.printStackTrace(); } }
void function(String arg0, String arg1) { try { mapping.put(arg0, arg1); String loc0 = mapping.get(arg0); if (loc0 != null && !loc0.equals(arg1)) { writer.setPrefix(loc0, arg1); } else { writer.setPrefix(arg0, arg1); } } catch (XMLStreamException loc1) { throw new SAXException(loc1); } }
ClassLoader function(ClassLoader arg0, Class<?>[] arg1) { ProxyHelper HELPER = ProxyHelper.HELPER; if (HELPER.canSeeAllInterfaces(arg0, arg1)) { return arg0; } else { ProxyClassLoader loc0 = new ProxyClassLoader(); for (Class<?> loc1 : arg1) { loc0.addLoader(loc1.getClassLoader()); } return loc0.getClassLoader(); } }
private void function(Object arg0, Object arg1) { try { long loc0 = BLOCK_LENGTH * 2; BlockStoreContext loc1 = BlockStoreContext.get(); TestBufferedBlockOutStream loc2 = new TestBufferedBlockOutStream(loc1, loc0); mTestStream = loc2; } catch (Exception loc3) { mThrown.expect(IllegalArgumentException.class); mThrown.expectMessage("Invalid block length"); } }
Constant function(String arg0) { Type loc0 = sch.getFieldType(arg0); if (loc0 == Type.INTEGER) { int loc1 = rf.getInt(arg0); return new IntConstant(loc1); } else { String loc2 = rf.getString(arg0); return new StringConstant(loc2); } }
public NodeVisitor function(Node arg0) { NodeVisitor loc0 = null; try { loc0 = enter(arg0); } catch (Exception e) { } return loc0; }
ThreadFactoryBuilder function(ThreadFactoryBuilder builder, ThreadFactory arg0) { try { ThreadFactory loc0 = checkNotNull(arg0, "The backing ThreadFactory cannot be null"); builder.backingThreadFactory = loc0; } catch (NullPointerException e) { } return builder; }
List<ClassdiagramNode> function() { List<ClassdiagramNode> loc0 = new ArrayList<>(); try { loc0 = new Vector<ClassdiagramNode>(downlinks); } catch (Exception e) { } return loc0; }
Long function(TestResultDetailsDTO arg0) { Long loc0 = arg0.getTestId(); return loc0; }
String function(Object arg0) { Object loc0 = null; Object loc1 = null; if (arg0 instanceof SomeClass) { loc0 = ((SomeClass) arg0).getOwner(); if (loc0 == null) { loc1 = ((SomeClass) arg0).getFacade(); if (loc1 != null && loc1 instanceof AnotherClass) { return ((AnotherClass) loc1).getUUID(); } } else if (loc0 instanceof AnotherClass) { return ((AnotherClass) loc0).getUUID(); } } return null; }
long function(String arg0) { try { String loc0 = getString(arg0, ""); if (StringUtils.isEmpty(loc0)) { return 0L; } return FileUtils.convertSizeToLong(loc0); } catch (Exception e) { logger.error("Error while getting file size for " + arg0 + ": " + e.getMessage()); return 0L; } }
public static String function(String str) { StringBuffer sb = new StringBuffer(); for (int i = 0; i < str.length(); i++) { char ch = str.charAt(i); if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '-' || ch == '_' || ch == '.' || ch == '!' || ch == '~' || ch == '\'' || ch == '(' || ch == ')') { sb.append(ch); } else if (ch == ' ') { sb.append("+"); } else { byte[] bytes = null; try { bytes = String.valueOf(ch).getBytes("UTF-8"); } catch (UnsupportedEncodingException e) { } for (byte b : bytes) { sb.append(hex[b & 0xFF]); } } } return sb.toString(); }
Timestamp function() { Timestamp loc0 = this.createdDate; return loc0; }
ELEvaluator function(Configuration arg0, String arg1, Element arg2, String arg3) { ELEvaluator loc0 = CoordELEvaluator.createInstancesELEvaluator(arg0, arg1, arg2, arg3); return loc0; }
QName function() { return qname; }
void function(TransformerFactory arg0) { try { factory = arg0; } catch (Exception e) { } }
int function() { int loc0 = gen.getAndIncrement(); return mix(salt + loc0); }
void function(Message message) { }
Executor function() { return MoreExecutors.newThreadRenamingDecorator( new ThreadFactoryBuilder().setNameFormat(serviceName() + "-%d").build()); }
void function() { RMBTest rmbTest = new RMBTest(); String arg0 = "ABC"; rmbTest.setOriginId(arg0); try { assertTrue(rmbTest.toString().contains(arg0)); assertEquals(arg0, rmbTest.getOriginId()); } catch (AssertionError e) { } }
Object function() { Object arg0 = null; // feature name to search for String arg1 = "UML"; // expected classifier name prefix Object model = Model.getFacade(); // UML model Object classifier = getClassifier(); if (classifier == null) { return null; } if (!classifier.getName().startsWith(arg1)) { return null; } for (Object feature : classifier.getFeatures()) { if (feature.equals(arg0)) { return feature; } } return null; }
void function(AbstractDosPlugin arg0) { String version = arg0.getVersion(); assertNotNull(version); }
public Object function(String attributeName) { for (Object feature : getFeatures("attribute")) { if (feature.equals(attributeName)) { return Model.getFacade().isAAttribute(feature) ? Model.getFacade().getName(feature) : null; } } return null; }
Timestamp function() { return endDate; }
public String function(String graphName, String sdd, String user, String commitMessage, String branchNameA, String branchNameB, String triples) { try { return String.format("MERGE-WITH <%s> USING <%s> AS (?a,?p,?o) \nWHERE {\n %s ?p ?o.\n ?a ?p ?o.\n }", graphName, sdd, triples); } catch (Exception e) { return null; } }
public String function() { try { return getApplicationDescription(); } catch (Exception e) { return null; // Or throw a new exception } }
void function() { setUp(); instance.setFaaMode(); instance.getVerticalDOP(); assertEquals(arg0, instance.getVerticalDOP(), 0.01); }
MultivaluedMap<String, String> function(String arg0, String arg1) { MultivaluedMap<String, String> loc0 = new MultivaluedHashMap<>(); loc0.add("redirect_uri", this.redirectUri); loc0.add("code", this.code); return loc0; }
void function() { try { Time loc0 = new Time(); loc0.setMinutes(30); int loc1 = loc0.getMinutes(); assertEquals(30, loc1); } catch (Exception e) { fail("Exception thrown: " + e.getMessage()); } }
SignatureProperties function() { SignatureProperties loc0 = new SignatureProperties(); loc0.setSignaturePropertiesFile(signaturePropertiesFile); return loc0; }
long function(K key, long x, LongBinaryOperator accumulatorFunction) { Objects.requireNonNull(key); Objects.requireNonNull(accumulatorFunction); return getAndUpdate(key, loc0 -> accumulatorFunction.applyAsLong(loc0 == null ? 0 : loc0, x)); }
class AbstractUmlModelFactoryMDR { void function(Object arg0, Object arg1) { ModelElement loc0 = new ModelElement(); ModelElement loc1 = new ModelElement(); } }
Method function(Class<?> arg0, String arg1, Class<?>... arg2) { try { return arg0.getMethod(arg1, arg2); } catch (NoSuchMethodException loc0) { return null; } }
void function(Exception loc0) { if (URLogs.sIsLogEnabled) { StackTraceElement loc1 = URLogs.getCurrentStackTraceElement(); String loc2 = URLogs.getContent(loc1); String loc3 = loc0.getMessage(); String loc4 = ""; for (StackTraceElement loc5 : loc0.getStackTrace()) { loc4 += loc5.toString() + "\n"; } Log.e(URLogs.sApplicationTag, URLogs.TAG_CONTENT_PRINT, URLogs.getCurrentStackTraceElement().getFileName(), URLogs.getCurrentStackTraceElement().getMethodName(), URLogs.getCurrentStackTraceElement().getLineNumber(), loc3, loc4); } }
void function(String arg0, String arg1) { OpenTagRegister tagList = new OpenTagRegister(); int elmId = 0; element(arg0); openTag(); element(arg1); closeTag(); unopenedTags(); ASTElement loc0 = element(arg0); openTag(); ASTElement loc1 = element(arg1); closeTag(); assertFalse(isUnclosed()); tagList.registerElement(loc0); assertTrue(isUnclosed()); openedIsolatedTag(); assertFalse(isUnclosed()); tagList.closeCurrent(); assertTrue(isUnclosed()); doubleNesting(); assertFalse(isUnclosed()); tagList.closeCurrent(); assertTrue(isUnclosed()); ASTElement loc2 = element(arg1); openTag(); ASTElement loc3 = element(arg0); closeTag(); tagList.registerElement(loc2); assertTrue(isUnclosed()); tagList.registerElement(loc3); assertFalse(isUnclosed()); interleavedTags(); assertFalse(isUnclosed()); tagList.closeCurrent(); assertFalse(isUnclosed()); }
void function(String arg0) { srcFileName = arg0; }
IConfigurationFactory function() { return SINGLETON.getConfigurationHandler(); }
boolean function() { Scan loc0 = s2; Scan loc1 = s1; Constant loc2 = getVal("LHS"); Constant loc3 = getVal("RHS"); loc0.beforeFirst(); while (loc0.next()) { Constant loc4 = loc0.getVal("LHS"); if (loc2.equals(loc4)) { Constant loc5 = loc0.getVal("RHS"); loc1.beforeFirst(); while (loc1.next()) { Constant loc6 = loc1.getVal("RHS"); if (loc3.equals(loc6) && loc5.equals(loc1.getVal("LHS"))) { return true; } } } } return false; }
V function() { SimpleEntry<V, K> loc0 = new SimpleEntry<>(); return loc0.value; }
int function() { try { return xPosition; } catch (Exception e) { System.err.println("Error getting ball's horizontal position: " + e.getMessage()); return 0; } }
int function(byte[] arg0) { int loc0 = arg0.length; int loc1 = 0; for (int loc2 = 0; loc2 < loc0; loc2++) { loc1 += (arg0[loc2] & 0xff); } return loc1; }
private void function(Collection arg0) { try { if(CollectionUtils.exists(arg0, PredicateUtils.nullPredicate())) { throw new NullPointerException(); } } catch(Exception e) { } }
public class RPCFileReadRequestTest { long OFFSET = 22; long TEMP_UFS_FILE_ID = 11; ByteBuf mBuffer = null; long LENGTH = 33; void function() { function(); RPCFileReadRequest(arg0, arg1, arg2); assertInvalid(arg3); } void assertValid(long loc0, long loc1, long loc2, RPCFileReadRequest loc3) { } void assertValid(RPCFileReadRequest loc0) { } void validate() { } void encodedLength() { } void invalidLength() { } void assertInvalid(RPCFileReadRequest loc0) { } void encodeDecode() { } void before() { } void validLength() { } }
boolean function(char arg0) { char loc0 = arg0; return (tok.ttype == loc0); }
import java.lang.IllegalArgumentException; public class Assert { public static void function(boolean arg0, String arg1) { if (!arg0) { throw new IllegalArgumentException(arg1); } } }
import org.powermock.reflect.Whitebox; public class LoginUserTestUtils { public static void function() { Whitebox.setInternalState(LoginUser.class, "srini_string", (String)null); } }
import java.util.Collections; import java.util.List; public class CollectionUtil { public static <T> List<T> function(List<T> arg0) { try { if (arg0 == null) { return Collections.emptyList(); } } catch (Exception e) { } } }
import org.apache.http.HttpHost; import org.apache.http.client.utils.URIUtils; import java.net.URI; public class URIUtils { public static URI function(URI arg0, HttpHost arg1) { try { return rewriteURI(arg0, arg1, true); } catch (Exception e) { e.printStackTrace(); return null; } } private static URI rewriteURI(URI loc0, HttpHost loc1, boolean loc2) { } }
void function() { try { arg0.clear(); } catch (Exception e) { } }
public class JavascriptRuntime { private IJavascriptRuntime runtime = null; private IWebEngine engine; public String function(String arg0, Object... arg1) { if (runtime == null) { runtime = new JavascriptRuntime(); } return runtime.getFunction(arg0, arg1); } private String getConstructor(String javascriptObjectType, Object... args) { } private String getArrayFunction(String function, Object[] ary) { } private String getFunction(String variable, String function, Object... args) { } private String getFunction(String function, Object... args) { } private void setDefaultWebEngine(IWebEngine e) { } private String getArrayConstructor(String javascriptObjectType, Object[] ary) { } private String getArgString(Object arg) { } private JSObject execute(String command) { } }
import java.util.Date; public class RuntimeManager { IStoredSettings settings; ServerStatus serverStatus; Logger logger = LoggerFactory.getLogger(getClass()); File baseFolder; TimeZone timezone; ServerSettings settingsModel; public RuntimeManager stop() { } public TimeZone getTimezone() { } public void logTimezone(String type, TimeZone zone) { } public boolean isDebugMode() { } public IStoredSettings getSettings() { } public RuntimeManager start() { } public File getFileOrFolder(String key, String defaultFileOrFolder) { } public File getFileOrFolder(String fileOrFolder) { } public boolean updateSettings(Map<String, String> updatedSettings) { } public ServerStatus getStatus() { } public ServerSettings getSettingsModel() { } public boolean isServingRepositories() { } public File getBaseFolder() { } public void setBaseFolder(File folder) { } public Date function() { return serverStatus.bootDate; } }
public class GeneSet { String name; String geneList; String getGeneList() { return geneList; } String getId() { return ""; } void setGeneList(String geneList) { this.geneList = geneList; } String getName() { return name; } void function(String arg0) { try { name = arg0; } catch (Exception e) { e.printStackTrace(); } } }
import static org.junit.Assert.assertEquals; public class HDGTest { HDGSentence hdg; String EXAMPLE = "$HCHDG,123.4,1.2,E,1.2,W"; void function() { try { HDGParser hdgParser = new HDGParser(EXAMPLE); assertEquals("Test method for {@link net.sf.marineapi.nmea.parser.HDGParser#getVariation()}.", hdgParser.getVariation(), loc0); } catch (Exception e) { } } }
import com.google.common.collect.HashMultimap; import org.bitcoinj.core.*; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.math.BigInteger; import java.util.Timer; import java.util.concurrent.locks.ReentrantLock; public class StoredPaymentChannelClientStates { TransactionBroadcaster announcePeerGroup; boolean active = false; Wallet containingWallet; HashMultimap<Sha256Hash, StoredClientChannel> mapChannels = HashMultimap.create(); Logger log = LoggerFactory.getLogger(StoredPaymentChannelClientStates.class); Transaction contract; String EXTENSION_ID = StoredPaymentChannelClientStates.class.getName(); BigInteger valueToMe; Transaction close; Transaction refund; ECKey myKey; BigInteger refundFees; Timer channelTimeoutHandler = new Timer(true); ReentrantLock lock = new ReentrantLock(); Sha256Hash id; void function() { Wallet arg0 = containingWallet; WalletExtensions arg1 = arg0.getExtensions(); WalletExtension loc0 = arg1.get(EXTENSION_ID); } }
class OpenIDBaseCache { String OPENID_CACHE_MANAGER = "OpenIDCacheManager"; String openidCacheName; void addToCache(K key, V entry) { } Cache<K, V> getOpenIDCache() { } V getValueFromCache(K key) { } void clearCacheEntry(K key) { } void function() { function(); getOpenIDCache(); Cache<K, V> cache = getOpenIDCache(); cache.removeAll(); } }
void function(String arg0) { String loc0 = arg0; setLoginName(loc0); }
void function() { assertEquals(Datum.WGS84, instance.getDatum()); }
import java.io.File; import java.util.HashMap; import java.util.Map; import javax.xml.transform.ErrorListener; import javax.xml.transform.Result; import javax.xml.transform.Transformer; import javax.xml.transform.URIResolver; import org.w3c.dom.Document; public class Transform { File PWD = new File("."); Map<String, Object> parameters = new HashMap<String, Object>(); Transformer transformation; public void function(Source arg0) { if (arg0 != null) { String loc0 = arg0.getSystemId(); int loc1 = loc0.length(); arg0.setSystemId(getDefaultSystemId()); } } public R transform() { } public void transformTo(Result result) { } public void setOutputProperty(String name, String value) { } public void clearParameters() { } public Object getParameter(String name) { } public void setOutputProperties(Properties outputProperties) { } public String getDefaultSystemId() { } public void setParameter(String name, Object value) { } public void setErrorListener(ErrorListener errorListener) { } public Document getResultDocument() { } public String getResultString() { } public void setURIResolver(URIResolver uriResolver) { } }
import java.util.List; import java.util.Vector; public class ParseState { Object mClassifier; Object namespace; List newFeatures; List newInnerClasses; Vector getNewInnerClasses() { return newInnerClasses; } Object newClassifier(String name) { return mClassifier; } Vector getNewFeatures() { return newFeatures; } Object getClassifier() { return mClassifier; } void newFeature(Object mFeature) { newFeatures.add(mFeature); } List getNewInnerClassesList() { return newInnerClasses; } List getAssociationEndsList() { return null;  // Remove the implementation or replace it with the desired logic } Vector getAssociationEnds() { return null;  // Remove the implementation or replace it with the desired logic } Object getNamespace() { return namespace; } void function(Object arg0, Object arg1) { Object loc0 = getNewFeatures(); Object loc1 = arg0; } }
void function(OpenIDRememberMeDO arg0) { cache.updateTokenData(arg0); Thread loc0 = new Thread() { @Override public void run() { try { dao.updateTokenData(arg0); } catch (Exception e) { log.error("srini_string", e); } } }; loc0.start(); }
void function() { serverSocket.close(); }
public void function(int arg0) { try { this.lane_id = arg0; } catch (Exception loc0) { System.out.println("Error setting lane_id: " + loc0.getMessage()); } }
public void function(MapNode arg0) { try { long loc0 = arg0.getId(); nodes.put(loc0, arg0); } catch (Exception loc1) { LOG.error("Failed to add node to hashtable: " + arg0, loc1); } }
public void function(String arg0, String arg1, String arg2, String arg3, String arg4, String arg5, String arg6, String arg7) { String loc0 = arg0; String loc1 = arg1; String loc2 = arg2; String loc3 = arg3; String loc4 = arg4; String loc5 = arg5; String loc6 = arg6; String loc7 = arg7; commitModel.setGraphName(loc0); commitModel.setSddName(loc1); commitModel.setUser(loc2); commitModel.setMessage(loc3); commitModel.setBranch1(loc4); commitModel.setBranch2(loc5); commitModel.setStrategy(loc6); commitModel.setType(loc7); String commitInfo = commitModel.getCommitInfo(); }
public void function() { char arg0 = 'a'; System.out.println(RequestInputTest.getChar(String.valueOf(arg0))); }
boolean function() { File loc0 = new File(Configuration.FILE_LOADED); return config.load(loc0); }
void function(List<Interceptor<? extends Message>> arg0) { inInterceptors = arg0; }
void function(ConfigurationKey arg0, boolean arg1) { try { config.setBoolean(arg0, arg1); } catch (Exception loc0) { } }
public String function() { String secondarySubject = ""; try { String primarySubject = getSubjectPrimary(); if (primarySubject.startsWith("O=")) { String[] subjectParts = primarySubject.split(",\\s*"); for (String subjectPart : subjectParts) { if (subjectPart.startsWith("OU=")) { secondarySubject = subjectPart.substring(3); break; } else if (subjectPart.startsWith("CN=")) { secondarySubject = subjectPart.substring(3); break; } } } } catch (Exception e) { } return secondarySubject; }
Object function(Object arg0, Object arg1) { DeadEvent deadEvent = (DeadEvent) arg0; return deadEvent.source; }
class DELETE { void function(String arg0, int arg1) { try { int loc0 = arg0.length(); int loc1 = arg1 / loc0; } catch (Exception e) { e.printStackTrace(); } } }
void function(String arg0) { this.tenantDomain = arg0; }
void function() { long loc0 = TEST_BLOCK_SIZE * mTestDir.getCapacity(); assertEquals(loc0, mTestDirView.getCapacityBytes()); }
String function(String arg0) { String loc0 = PersistenceManager.getInstance().getProjectBaseName(); String loc1 = arg0.endsWith(".zargo") ? ".zargo" : ".argo"; String loc2 = getType().equals("UseCase") ? getUniqueDiagramName() : getZipFileExtension(); String loc3 = loc0 + "_" + makeUniqueName(uniqueName) + loc2 + loc1; return loc3; }
void function(int arg0) { peakStart = arg0; } int peakSize() { return peakEnd - peakStart + 1; } void addGene(CanonicalGene gene) { genes_in_ROI.add(gene); } void setCytoband(String arg0) { cytoband = arg0; } void setPeakEnd(int arg0) { peakEnd = arg0; } String toString() { return "Gistic ID: " + gisticID + ", Chromosome: " + chromosome + ", Start: " + peakStart + ", End: " + peakEnd + ", Cytoband: " + cytoband + ", Amplification: " + amp + ", q-value: " + qValue; } void setChromosome(int arg0) { chromosome = arg0; } void setGenes_in_ROI(ArrayList<CanonicalGene> loc0) { genes_in_ROI = loc0; } void setqValue(double arg0) { qValue = arg0; }
void function(long arg0, long arg1, BlockLockType arg2) { mLockManager.lockBlock(arg0, arg1, arg2); long loc0 = mLockManager.getLockId(arg0, arg1); assertNotEquals(0, loc0); }
String function(String arg0) { int loc0 = arg0.length(); int[] loc1 = new int[(loc0 << 2) >>> 2]; for (int loc2 = 0; loc2 < loc0; loc2++) { loc1[loc2 >> 2] |= (arg0.charAt(loc2) & 0xFF) << ((3 - (loc2 & 3)) << 3); } int loc3 = loc0 << 3; loc1[((loc0 + 8) >> 6 << 4) + 15] = loc3; int loc4 = loc1.length; int[] loc5 = new int[80]; int loc6 = -1732584194; int loc7 = 0xEFCDAB89; int loc8 = -271733879; int loc9 = -1732584194; int loc10 = -1009589776; for (int loc11 = 0; loc11 < loc4; loc11 += 16) { int loc12 = loc6; int loc13 = loc7; int loc14 = loc8; int loc15 = loc9; int loc16 = loc10; for (int loc17 = 0; loc17 < 80; loc17++) { loc5[loc17] = (loc17 < 16) ? loc1[loc11 + loc17] : ((loc5[loc17 - 3] ^ loc5[loc17 - 8] ^ loc5[loc17 - 14] ^ loc5[loc17 - 16]) << 1 | (loc5[loc17 - 3] ^ loc5[loc17 - 8] ^ loc5[loc17 - 14] ^ loc5[loc17 - 16]) >>> 31); int loc18 = loc10 + ((loc6 << 5 | loc6 >>> 27) + ((loc7 & loc8 | ~loc7 & loc9) + loc5[loc17] + CHARS[loc17 / 20]) + 1518500249); loc10 = loc9; loc9 = loc8; loc8 = loc7 << 30 | loc7 >>> 2; loc7 = loc6; loc6 = loc18; } loc6 += loc12; loc7 += loc13; loc8 += loc14; loc9 += loc15; loc10 += loc16; } StringBuilder loc19 = new StringBuilder(); for (int loc20 : new int[]{loc6, loc7, loc8, loc9, loc10}) { for (int loc21 = 28; loc21 >= 0; loc21 -= 4) { loc19.append(CHARS[(loc20 >>> loc21) & 0xF]); } } return loc19.toString().toLowerCase(); }
void function(boolean arg0, MWVTest mwvTest) { assertTrue(mwvTest.mwv.isTrue()); mwvTest.mwv.setTrue(arg0); assertFalse(mwvTest.mwv.isTrue()); }
public int function() { CacheConfig cacheConfig = new CacheConfig(); cacheConfig.setMaxUpdateRetries(3); return cacheConfig.maxUpdateRetries; }
void function(int playerID) { int[] ticks = null; if (playerList.containsKey(playerID)) { ticks = playerList.get(playerID); } else { ticks = new int[1]; playerList.put(playerID, ticks); } ticks[0]++; }
void function(long arg0) { setDeliveryTag(arg0); }
StoredClientChannel function(Sha256Hash arg0, Sha256Hash arg1) { try { lock.lock(); Set<StoredClientChannel> loc0 = mapChannels.get(arg0); for (StoredClientChannel loc1 : loc0) { if (loc1.contract.getHash().equals(arg1)) { return loc1; } } return null; } finally { lock.unlock(); } }
void function(View arg0, int arg1, Object arg2) { try { destroyItem(arg0, arg1, arg2); } catch(Exception e) { e.printStackTrace(); } }
void function(ExceptionListener arg0) { exceptionListener = arg0; }
void function() { model.triggerEvent(); }
public String function() { String loc0 = this.caseId; return loc0; } Note: This method simply returns the value of the member variable "caseId" for the current object of the class "GeneticEventImpl".
public static int function(String arg0) { if (isWindows()) { throw new UnsupportedOperationException(); } Filestat loc0 = getFilestat(arg0); return loc0.st_mode; }
public String function(int arg0) { String loc0 = new String(Character.toChars(arg0)); EaseEmojicon emoji = new EaseEmojicon(); emoji.setEmojiText(loc0); return emoji.getEmojiText(); } This function takes in an integer argument "arg0", which represents the Unicode code point of the desired emoji icon. It creates a new string "loc0" using the given code point, and creates a new instance of the "EaseEmojicon" class named "emoji". It then sets the emoji text of the "emoji" object to the "loc0" string, retrieves the emoji text using the "getEmojiText()" method, and returns the resulting string. This function assumes that the "EaseEmojicon" class has been properly defined and imported into the current file. Note that this function does not include any error handling or input validation.
double[] function(Points points) { try { int k = points.dimension; double[] coordinates = points.coordinates; double[] result = new double[k]; for (int i = 0; i < k; i++) { result[i] = points.getCo(i); } return result; } catch (Exception e) { System.out.println("Error occurred: " + e.getMessage()); return null; } }
void function(String arg0) { try { setChecksumType(arg0); } catch (Exception loc0) { System.out.println("Error setting checksum type: " + loc0.getMessage()); } }
Set<T> function(Class<T> arg0, Set<T> allNodes) { Set<T> subset = new HashSet<>(); for (T loc0 : allNodes) { if (arg0.equals(loc0.getClass())) { subset.add(loc0); } } return subset; }
int function(int arg0) { try { rte.setSentenceCount(arg0); int loc0 = rte.getSentenceCount(); assertEquals(arg0, loc0); return loc0; } catch (Exception e) { e.printStackTrace(); return -1; } }
void function(Crypto arg0) { this.encryptionCrypto = arg0; }
public int function(int arg0, int arg1) { int utility = 0; try { utility = matrixItemUtility(arg0, arg1); } catch (Exception e) { System.out.println("Error getting utility for cell at position (" + arg0 + ", " + arg1 + ")"); e.printStackTrace(); } return utility; }
void function(String identifier, IndividualStructure structure) { try { if (individualStructures.containsKey(identifier)) { System.out.println("Individual structure already exists. Overwriting..."); } individualStructures.put(identifier, structure); } catch (Exception e) { System.out.println("Error occurred while adding individual structure: " + e.getMessage()); } }
Context function() { return context.function(); }
SDDTripleStateEnum function() { return tripleStateA; }
void function(String domainName, PropertyDTO[] properties) { Map<String, String> userStoreManager = convertArrayToMap(properties); userStoreManagers.put(domainName, userStoreManager); }
void function(JavaMailSender mailSender) { this.mailSender = mailSender; }
void function(Scriptable scope) { Scriptable parentScope = scope.getParentScope(); parentScope.associateValue(AKEY, this); }
void function(Bus arg0) { if(bus != null) { bus = arg0; } }
void function() { int numCols = 5; int numRows = 7; DenseMatrix64F matrix = new DenseMatrix64F(numCols, numRows); assertEquals(numCols, matrix.getNumCols()); assertEquals(numRows, matrix.getNumRows()); }
void function() { try { Date date = rmc.getDate(); assertEquals(2005, date.getYear()); } catch (Exception e) { fail("Unexpected exception: " + e.getMessage()); } }
void function(String genes) { geneList = genes; }
/** * Gets the live list of roles. * * @return the live list of roles */ public List<Role> function() { return this.roles; }
public void function(String arg0) { try { referencedRevisionA = arg0; } catch (Exception e) { } }
void function(IParserEvent arg0) { UprHandler handler = new UprHandler(this.handler); handler.handleEvent(arg0); handlerStack.push(handler); }
public BigDecimal function() { return downloadSize; }
private void function() { try { DenseMatrix64F A = new DenseMatrix64F(4,4,true,4,-4,0,0,1,4,1,0,0,1,4,1,0,0,0,4); RealEigenvalueHessenberg alg = new RealEigenvalueHessenberg(); EigenResults results = alg.process(A); double[] eigenvalues = results.getEigenvalues(); assertEquals(2.000, eigenvalues[0], tol); assertEquals(3.000, eigenvalues[1], tol); assertEquals(4.000, eigenvalues[2], tol); assertEquals(4.000, eigenvalues[3], tol); } catch(Exception e) { } }
public void function(AbstractSettings arg0) { try { PROPS.add(arg0); } catch (Exception e) { } }
String function() { removeLastEvent(); StringEvent newEvent = new StringEvent(); newEvent.append(getString()); events.addLast(newEvent); return newEvent.getString(); }
boolean function() { try { Date loc0 = new Date(); return loc0.after(getTimeoutDate()); } catch (Exception e) { } }
String function(String name, String value) { try { return new BasicNameValuePair(name, value); } catch (Exception e) { } }
public static String function(byte[] bytes, String charsetName) { try { return new String(bytes, charsetName); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }
void function(short value) { checkType(PackFormat.SHORT); packLong(value, true); }
public EmailTemplateDTO function(int index) { if (templates == null || index < 0 || index >= templates.length) { throw new IndexOutOfBoundsException("Invalid email template index"); } EmailTemplateDTO template = templates[index]; if (template == null) { throw new NullPointerException("Email template is null"); } return template; }
JSONArray function(List<JsonWorkflowAction> arg0) { JSONArray loc0 = new JSONArray(); for (JsonWorkflowAction arg1 : arg0) { loc0.add(arg1.toJSONObject()); } return loc0; }
import java.util.Map; public class CollectionUtil { private static final TypeMap COLLECTION_INTERFACES_BY_NAMES = new TypeMap(new Class[]{java.util.List.class, java.util.Collection.class, java.util.Map.class, java.util.Set.class}); private static final TypeMap COLLECTION_CLASSES_BY_NAMES = new TypeMap(new Class[]{java.util.ArrayList.class, java.util.LinkedList.class, java.util.Vector.class, java.util.HashMap.class, java.util.LinkedHashMap.class, java.util.TreeMap.class, java.util.TreeSet.class, java.util.HashSet.class, java.util.LinkedHashSet.class, java.util.Hashtable.class}); public static String function(String arg0) { Class<?> loc0 = COLLECTION_CLASSES_BY_NAMES.typeFor(arg0); if (loc0 != null) { return loc0.getName(); } loc0 = COLLECTION_INTERFACES_BY_NAMES.typeFor(arg0); if (loc0 != null) { return loc0.getName(); } return null; } }
EndpointReferenceType function(QName arg0, String arg1) { EndpointReferenceType loc0 = null; for (EndpointResolver loc1 : resolvers) { loc0 = loc1.resolve(new QName(arg0.getNamespaceURI(), arg1)); if (loc0 != null) { break; } } return loc0; }
int function(byte[] arg0, int arg1, int arg2) { checkBoundary(arg0, arg1, 4); arg0[arg1] = (byte) (arg2 & 0xff); arg0[arg1+1] = (byte) ((arg2 >> 8) & 0xff); arg0[arg1+2] = (byte) ((arg2 >> 16) & 0xff); arg0[arg1+3] = (byte) ((arg2 >> 24) & 0xff); return 4; }
void function() { GeneralMotorCon loc0 = GeneralMotorCon.getInstance(); loc0.appendToConsole(); loc0.setLedsAnimation(); loc0.spinLeft(); loc0.doFor(arg0, arg1); loc0.hover(); loc0.spin90Left(); }
Measurements function(Object arg0, Object arg1) { if (singleton == null) { synchronized (Measurements.class) { if (singleton == null) { singleton = new Measurements(); } } } return singleton; }
public void function(Marshaller arg0, Object arg1) { marshaller = arg0; object = arg1; }
void function(List<String> arg0) { acceptedKeyWrapAlgorithms = new ArrayList<>(arg0); }
public static boolean function(String arg0, String arg1) { try { UserRealm realm = IdentityTenantUtil.getRealm(null, arg0); UserStoreManager userStoreManager = realm.getUserStoreManager(); return userStoreManager.authenticate(arg1); } catch (UserStoreException e) { log.error("Error occurred while verifying user name/password authentication: " + e.getMessage(), e); } return false; }
synchronized boolean function(long arg0) { return mPersistingInProgressFiles.contains(arg0); }
public static AdjustableLinearSolver<DenseMatrix64F> function(int arg0, int arg1) { DenseMatrix64F loc0 = new DenseMatrix64F(arg0, arg1); AdjLinearSolverQr<DenseMatrix64F> loc1 = new AdjLinearSolverQr<>(true); return new AdjustableLinearSolver<>(loc1, loc0); }
class SimpleEndpointImplFactory { EndpointImplFactory singleton = new SimpleEndpointImplFactory(); EndpointImpl newEndpointImpl(Bus bus, Service service, EndpointInfo endpointInfo) { } EndpointImplFactory function() { return singleton; } }
void function() { mThrown.expect(IndexOutOfBoundsException.class); mThrown.expectMessage("Index out of bounds: " + loc0); try { mTestTierView.getDirView(loc0); } catch (IndexOutOfBoundsException e) { assertEquals("Index out of bounds exception message is incorrect.", "Index out of bounds: " + loc0, e.getMessage()); throw e; } }
int function(Map<?, ?> arg0) { int loc0 = arg0 == null || arg0.size() == 0 ? 1 : 0; return loc0; }
List<T> function(Class<T> arg0) { List<T> loc0 = new ArrayList<>(); Node loc1 = jjtGetParent(); while (loc1 != null) { if (loc1.getClass() == arg0) { loc0.add((T) loc1); } loc1 = loc1.jjtGetParent(); } return loc0; }
static int function(int arg0) { checkArgument(arg0 >= 0 && arg0 <= UnsignedInts.INT_MASK); return arg0; }
public static void function(double[] arg0, double[] arg1, int arg2) { int n = arg2; for (int i = n-1; i >= 0; i--) { double sum = 0.0; for (int j = i+1; j < n; j++) { sum += arg1[j] * arg0[j*n+i]; } arg1[i] = (arg1[i] - sum) / arg0[i*n+i]; } } Note: This method performs forward substitution to solve the system of linear equations represented by the non-singular upper triangular matrix arg0 and the vector arg1. The result is stored in arg1. The argument arg2 specifies the size of the matrix and the vector.
boolean function(String arg0) { String loc0 = arg0.trim(); return loc0 != null && !loc0.startsWith("//") && !loc0.equals(""); }
DeterministicKey function(List<ChildNumber> arg0) { return get(arg0, false, false); }
public static <X, Y, Z> TriConsumer<X, Y, Z> function(TriConsumer<? super X, ? super Y, ? super Z> consumer1, TriConsumer<? super X, ? super Y, ? super Z> consumer2) { Objects.requireNonNull(consumer1); Objects.requireNonNull(consumer2); return (arg0, arg1, arg2) -> { consumer1.accept(arg0, arg1, arg2); consumer2.accept(arg0, arg1, arg2); }; }
public static <T> Function<T, T> function() { try { return IdentityFunction.INSTANCE; } catch (Exception loc0) { return loc1 -> loc1; } }
void function(byte[] arg0) { this.challenge = arg0; }
void function(Object arg0, Object arg1) { try { Named loc0 = (Named) arg0; String loc1 = (String) arg1; if (loc0 == null || loc1 == null) { return; } if (TOPICS.stream().anyMatch(loc1::equals)) { table.put(loc0.name(), loc0); } if (Report.should_report(Report.types, 3)) { Report.report(3, "Adding " + loc0.name() + " to " + loc1); } } catch (InternalCompilerError e) { throw e; } catch (Exception e) { throw new InternalCompilerError("Unexpected exception", e); } }
void function(String arg0) { schedule(arg0); await(arg0); }
import org.hamcrest.Matcher; import org.hamcrest.Matchers; public class OrderingComparison { public static <T extends Comparable<T>> Matcher<T> function(T arg0) { return Matchers.lessThan(arg0); } }
void function(XCommand arg0, Map<Long, List<XCommand<?>>> queue) { try { arg0.acquireLock(); queue.computeIfAbsent(arg0.getPriority(), k -> new ArrayList<>()).add(arg0); } catch (Throwable loc0) { LOG.warn("Exception occurred while queuing command", loc0); arg0.releaseLock(); } }
void function(String threadName) { try (LockResource loc0 = new LockResource(sLock)) { while (!sTimers.containsKey(threadName)) { sCondition.await(); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } }
void function(Argument arg, String message) { arg.setInvalidationMessage(message); } This method takes an Argument object and a String message as input parameters and calls the setInvalidationMessage method on the Argument object with the provided message. This method will declare the Argument value to be invalid and redraw the Gui with a warning drawn in red above the entry widget.
public static int function(String arg0) { byte[] loc0 = arg0.getBytes(); int loc1 = loc0.length; int loc2 = 5381; for (int loc3 = 0; loc3 < loc1; loc3++) { loc2 = (loc2 << 5) + loc2 + loc0[loc3]; } return loc2; }
String function(ShellCommandContext context) { String loc0 = context.getDestination(); return loc0; }
void function(int arg0) { waitFor(arg0); }
String function(IdentitySAMLValidatorServiceStub stub) { String[] loc0 = null; try { loc0 = stub.getIssuersOfSAMLServiceProviders(); } catch (RemoteException loc1) { log.error("srini_string", loc1); throw new AxisFault(loc1.getMessage(), loc1); } String result = Arrays.toString(loc0); log.info("Issuer List: " + result); return result; }
void function(ConcurrentMap<String,Object> arg0, String arg1) { try { arg0.remove(arg1); } catch (Exception loc0) { if (!isIgnoreExceptions()) { Report loc1 = getReport(); String loc2 = "Error removing attribute value on RuleContext"; loc1.addRuleViolation(loc2, loc0); } } }
void function(int arg0) { doAction(arg0 + 1); makePanel(arg0 + 1); changed(); }
void function() { Date loc0 = new Date(); Date loc1 = new Date(); assertTrue(loc0.equals(loc1)); }
Node function(int arg0) { Node loc0 = new Node(arg0); if (head == null) { head = loc0; } else { Node loc1 = head; while (loc1.next != null) { loc1 = loc1.next; } loc1.next = loc0; } return head; }
Array<Asset> function() { Array<Asset> loc0 = new Array<>(); loc0.add(new Asset("sound1.ogg", AssetType.SOUND)); loc0.add(new Asset("sound2.ogg", AssetType.SOUND)); return loc0; }
void function(State arg0) { if (arg0 == State.STARTING) { } }
double function(double arg0, State loc0, StateListener loc1) { try { return loc0.power; } catch (Exception e) { } return 0.0; // Default return value if exception is caught }
public String function() { String loc0 = ""; try { loc0 = getReferencedRevisionLabelB(); } catch (Exception e) { } return loc0; }
String function(String loc0) { try { GraphViz graphViz = new GraphViz(); graphViz.readSource(loc0); return graphViz.getGraph(graphViz.getDotSource(), "dot"); } catch (Exception e) { return null; } }
void function(SentenceListener arg0, String arg1) { listeners.computeIfAbsent(arg1, key -> new ArrayList<>()).add(arg0); } This method adds a new SentenceListener to the list of listeners interested in receiving sentences of a certain type. It first checks if a list of SentenceListeners for the given type already exists in the listeners map. If it doesn't, a new list is created and added to the map using the computeIfAbsent method of the ConcurrentHashMap class. The new SentenceListener is then added to the list.
public ListenableFuture<PaymentIncrementAck> function(Coin arg0) { try { ListenableFuture<PaymentIncrementAck> loc0 = channelClient.incrementPayment(arg0, null); return loc0; } catch (Throwable loc1) { } }
public static String function(String arg0) { int loc0 = arg0.lastIndexOf("."); if (loc0 >= 0) { return arg0.substring(0, loc0); } else { return ""; } }
public void function() { try { String loc0 = "admin"; String loc1 = "admin-client-id"; UserInfo loc2 = new UserInfo(); loc2.setUsername(loc0); loc2.setClientId(loc1); loc2.setAuthorities(Arrays.asList(new SimpleGrantedAuthority("ROLE_USER"), new SimpleGrantedAuthority("ROLE_ADMIN"))); Mockito.when(userInfoRepository.getByUsername(loc0)).thenReturn(loc2); UserDetails loc3 = service.getByUsername(loc0, loc1); assertEquals(loc2.getUsername(), loc3.getUsername()); assertEquals(loc2.getClientId(), ((User) loc3).getUsername()); assertEquals(loc2.getAuthorities(), loc3.getAuthorities()); } catch (Exception e) { fail("An exception occurred: " + e.getMessage()); } }
boolean function(Scan arg0) { for (Term loc0 : terms) { if (!loc0.isSatisfied(arg0)) { return false; } } return true; }
void function(int arg0) { try { INSTANCE.release(arg0); } catch (Exception e) { throw new IllegalStateException("srini_string"); } }
public XHTMLPanel function() { XHTMLPanel loc0 = this.panel; return loc0; } Note: It's not recommended to remove exception handling in production code as it can lead to unexpected behavior and errors.
Map<String, String> function(File arg0, File arg1) { Map<String, String> loc0 = new HashMap<>(); List<String> loc1 = getList(arg0); List<String> loc2 = getList(arg1); for (String gene : loc1) { for (String caseFile : loc2) { String key = createKey(gene, caseFile); loc0.put(key, ""); } } return loc0; }
String function(long arg0, int arg1, ServiceInfoStat[] arg2) { String loc0 = getRetvalString(arg1); return loc0; }
void function(RtfDumpListener arg0) { try { arg0.writer.writeStartElement("group"); } catch (XMLStreamException loc0) { } }
public static double function(DenseMatrix64F arg0, DenseMatrix64F arg1) { double loc0 = 0; double loc1 = 0; try { loc0 = EigenOps.innerProd(arg1, arg0); loc1 = EigenOps.innerProdA(arg1, arg0); } catch (IllegalArgumentException e) { e.printStackTrace(); } return loc0 / loc1; }
boolean function(ActivityRequest arg0) { if (arg0 == null) return false; if (arg0.getDelayerFileAttributesExtractorStrategy() == null) return false; if (arg0.getFeedId() == null) return false; return arg0.getConfigProperties() != null; }
Properties function(String arg0) { Properties loc0 = getModuleProperties(arg0); ModuleConfiguration loc1 = getModuleConfigurations(arg0); List<Subscription> loc2 = buildSubscriptionList(arg0, loc0); loc1.setSubscriptions(loc2); return loc0; }
public void function(Map<String, String> arg0) { RedisRegistry registry = new RedisRegistry(registryUrl); InjvmService injvmService = new InjvmServiceImpl(); injvmService.setRegistry(registry); injvmService.setUrl(serviceUrl); injvmService.export(); InjvmService injvmConsumer = new InjvmServiceImpl(); injvmConsumer.setRegistry(registry); injvmConsumer.setUrl(consumerUrl); injvmConsumer.subscribe(); Map<String, String> loc0 = new HashMap<String, String>(); loc0.put(Constants.PID_KEY, "1234"); injvmService.register(loc0); List<URL> loc1 = injvmConsumer.lookup(service); Assert.assertEquals(1, loc1.size()); injvmService.destroy(); }
BlockPos function(int arg0) { BlockPos loc0 = getNextBlock(arg0); double loc1 = Math.sqrt(mob.getDistanceSqToCenter(loc0)); if (loc1 == Double.POSITIVE_INFINITY) { return new BlockPos(9999, 9999, 9999); } return loc0; }
HashMap<Integer, Playlist> function() { HashMap<Integer, Playlist> loc0 = new HashMap<>(); DbConnJaMuz loc1 = getDb(); List<Playlist> loc2 = getPlaylists(); for (Playlist loc3 : loc2) { loc0.put(loc3.getId(), loc3); } return loc0; }
void function(int arg0, int arg1) { SimpleDB.bufferMgr().flushAll(arg0); recoveryMgr.recover(); }
void function(String arg0) { this.password = arg0; }
public String function() { String loc0 = null; try { loc0 = new StaticSTSProperties().getSignatureUsername(); } catch (Exception e) { } return loc0; }
void function(String arg0) { try { log.debug("Deleting the ingredient with ID: {}", arg0); ingredientRepository.delete(arg0); } catch (Exception loc0) { log.error("Error occurred while deleting the ingredient with ID: {}", arg0, loc0); } }
void function() { try { createTextureAtlas(); loadTextureAtlas(); loadTextures(); loadSounds(); loadMaps(); } catch (IOException loc0) { Gdx.app.error(LOG, "Error occurred while loading assets", loc0); } }
long function() { try { return Math.max(children[0].depth(), children[1].depth()); } catch (Exception loc0) { return -1; // Return a default value or handle the exception as per your requirements } }
void function() { try { throw new UnsupportedOperationException("Guaranteed to throw an exception and leave the RangeMap unmodified."); } catch (Exception loc0) { } }
double[] function() { try { return getGammasU(); } catch (Exception loc0) { return null; // Return a default value or handle the exception differently } }
void function() { Properties properties = new Properties(); }
void function() { }
void function(Object value) { addHolder().value = String.valueOf(value); }
void function() { try { Ticket ticket = permissionService.createTicket(rs1, scopes1); assertNotNull(ticket); } catch (Exception loc0) { } }
void function() { if (!snake.isAlive) { this.gui.setTitle("Game Over"); } if (!border.isAlive || gameElements.size() == 0) { checkGameOver(); } }
T function() { Node minNode = extractMinNode(); if (minNode != null) { return minNode.key; } return null; }
void function() { InetSocketAddress address = new InetSocketAddress("127.0.0.1", 8080); String expectedFqdn = "localhost"; String fqdnHost = NetworkAddressUtils.getFqdnHost(address); assertEquals(expectedFqdn, fqdnHost); WorkerNetAddress workerNetAddress = new WorkerNetAddress("127.0.0.1", 8080); fqdnHost = NetworkAddressUtils.getFqdnHost(workerNetAddress); assertEquals(expectedFqdn, fqdnHost); }
double function() { checkState(count() > 0, "The count must be non-zero."); if (count() == 1) { return 0.0; } if (Double.isNaN(sumOfProductsOfDeltas)) { return Double.NaN; } return sumOfProductsOfDeltas / count(); }
void function() { List<Map.Entry<String, Integer>> entries = new ArrayList<>(_wordFrequency.entrySet()); Collections.sort(entries, SORT_BY_FREQUENCY); for (Map.Entry<String, Integer> entry : entries) { String word = entry.getKey(); int frequency = entry.getValue(); System.out.println("Word: " + word + ", Frequency: " + frequency); } }
void function(ThreadFactoryBuilder builder, int priority) { builder.setPriority(priority); }
String function(String servletPath) { String contextURL = getContextURL(); String protocol = "http"; // Assuming HTTP protocol if (!contextURL.endsWith("/")) { contextURL += "/"; } if (servletPath.startsWith("/")) { servletPath = servletPath.substring(1); } return protocol + "://" + contextURL + servletPath; }
void function(Attributes newAttributes) { if (newAttributes != null) { AttributesImpl attributes = new AttributesImpl(); for (int i = 0; i < newAttributes.getLength(); i++) { String attributeName = newAttributes.getQName(i); String attributeValue = newAttributes.getValue(i); attributes.addAttribute("", attributeName, attributeName, "CDATA", attributeValue); } this.attributes = attributes; } }
Object function(Object hint) { if (hint == null || hint == ScriptRuntime.ScriptableClass || hint == ScriptRuntime.FunctionClass) { return this; } return getDefaultValue(hint); }
byte[] function() { try { return getByteArray(); } catch (IOException e) { e.printStackTrace(); return null; // Or any appropriate value to indicate failure } }
String function() { String uri = function(); return new String(_uriResolver.resolve(uri)); }
String function() { try { return source; } catch (Exception e) { return null; // Or any other suitable value or action } }
Document function() { Document resultDocument = null; try { Document document = new Document(); DOMResult result = new DOMResult(document); performTransform(getCopyTransformation(), document, result); resultDocument = (Document) result.getNode(); } catch (Exception e) { } return resultDocument; }
void function(String fileName, byte[] imageData) { try { FileOutputStream outputStream = new FileOutputStream(fileName); outputStream.write(imageData); outputStream.close(); } catch (Exception e) { } }
void function() { try { function(); assertEquals(expectedValue, vtg.getTrueCourse()); } catch (Exception e) { } }
int function(int dimension) { int scaledValue = 0; try { scaledValue = function(dimension); } catch (Exception e) { } return scaledValue; }
Scriptable function() { Scriptable scope = null; try { scope = Scriptable.function(); Kit.codeBug(); } catch (Exception e) { } return scope; }
void function(File arg0) { try { function(arg0); setFolders(arg0); setFiles(arg0); } catch (Exception e) { } }
HashMap<String, GeneticProfile> function(boolean includeCNA, boolean includeMutation) { try { return getDefaultGeneticProfileMap(includeCNA, includeMutation); } catch (Exception e) { } return null; }
String function(String path) { try { if (path.endsWith("suffix")) { path = path + "_modified"; } if (path.startsWith("prefix")) { path = "modified_" + path; } return path; } catch (Exception e) { } return null; }
Page<DishCollection> function(Pageable pageable) { log.debug("Getting all the dishCollections"); return dishCollectionRepository.findAll(pageable); }
GetPriceResponse function() { return new GetPriceResponse(); }
int function() { return getKeyIdentifierType(); }
long function() { return getDataUnitId(); }
void function(BlockMatrix64F matrix) { applyQTran(matrix, false); }
void function(lalr_item item) { not_null(item); _all.remove(item); }
TreeNode function(TreeNode root, int key) { if (root == null || root.val == key) { return root; } if (key < root.val) { return function(root.left, key); } else { return function(root.right, key); } }
double function(D1Matrix64F arg0) { int numRows = arg0.numRows; int numCols = arg0.numCols; double product = 1.0; for (int i = 0; i < Math.min(numRows, numCols); i++) { product *= arg0.unsafe_get(i, i); } return product; }
String function(BufferedReader arg0) throws IOException { StringBuffer content = new StringBuffer(); String line; while ((line = arg0.readLine()) != null) { content.append(line); content.append(NEW_LINE); } arg0.close(); return content.toString(); }
String function(@Nullable String arg0) { return Strings.nullToEmpty(arg0); }
Expression function() { return newval; }
BufferedByteWriter function(long val) { try { return put64(val); } catch (Exception e) { return null; // or perform any other appropriate action } }
String function() { return getContentType(); }
boolean function() { return parseLazy; }
void function(boolean arg0) { validateUseKey = arg0; }
void function(Long arg0) { try { setDataSetId(arg0); } catch (Exception e) { } }
float function() { return dotsPerDeg; }
boolean function(Object o) { for (Type type : v) { if (type instanceof Type && ts.isSubtype((Type) o, type)) { return true; } } return false; }
void function(ServiceID arg0, int arg1, int arg2, InetAddress arg3) { }
String function() { WorkflowJobBean workflow = getWorkflow(); String user = workflow.getUser(); return user; }
ProjectActions function() { if (theInstance == null) { theInstance = new ProjectActions(); } return theInstance; }
void function(O word, int multiplicity) { assert word != null : "Word cannot be null"; assert multiplicity >= 0 : "Multiplicity must be non-negative"; DocumentElement<O> element = data.get(word); if (element == null) { element = new DocumentElement<>(word); data.put(word, element); } element.setMultiplicity(multiplicity); }
Image function() { if (_image == null || _image.isDisposed()) { if (_uac != null) { _image = _uac.getImageResource(_uri); } } return _image; }
void function() { rmc.setCourse(90.0); double course = rmc.getCourse(); double variation = rmc.getVariation(); double correctedCourse = rmc.getCorrectedCourse(); assertEquals(90.0, course, 0.01); assertEquals(0.0, variation, 0.01); assertEquals(90.0, correctedCourse, 0.01); }
View function() { android.view.View actionView = mMenuItem.getActionView(); if (actionView == null) { actionView = new View(null); } return actionView; }
void function() { final double value = 1.5; // Variable declaration with the final keyword and double data type instance.setHorizontalDOP(value); // Method call: setHorizontalDOP(double) assertEquals(value, instance.getHorizontalDOP()); // assertEquals() method call }
Character function() { String characterName = "ShadowStruggles"; // Example character name RpgMap rpgMap = new RpgMap(); // Create an instance of RpgMap SettingsDAO settingsDAO = new SettingsDAO(); // Create an instance of SettingsDAO String defaultTileLayer = settingsDAO.getSettings().getDefaultTileLayer(); Character character = new Character( characterName, x, y, width, height, sprite, map, defaultTileLayer, id, triggerType, layer, collidable, actions ); return character; }
String function(String nmea) { int checksum = 0; for (int i = 1; i < nmea.length(); i++) { checksum ^= nmea.charAt(i); } String hexChecksum = String.format("%02X", checksum); return hexChecksum; }
void function(Object o) { try { add(o); } catch (Exception e) { } }
void function(int milliseconds) { sleepMs(milliseconds); }
Writable function(byte[] byteArray) { try { return WritableUtils.toByteArray(byteArray); } catch (IOException e) { e.printStackTrace(); } return null; }
ConfigurationKey function(String component1, String component2, String component3) { try { return new ConfigurationKeyImpl(component1, component2, component3); } catch (IllegalArgumentException e) { e.printStackTrace(); } return null; }
void function() { Iterator<ImageResource> iterator = _imageCache.values().iterator(); while (iterator.hasNext()) { ImageResource imageResource = iterator.next(); Image image = imageResource.getImage(); if (image != null) { image.dispose(); } } _imageCache.clear(); }
void function() { try { Mockito.when(mClient.listObjects(Mockito.any())).thenThrow(new ServiceException("List objects failed")); mOSSUnderFileSystem.delete(PATH, false); Assert.assertFalse("Assert failed", false); } catch (ServiceException e) { } }
void function() { Node parsedNode = parse(SourceFile.class, "SourceFile %s", toArray(subst)); }
int function(ByteBuffer key) { ByteBuffer hashBuffer = ByteBuffer.allocate(BUCKET_SIZE_BYTES); hashBuffer.put(key); hashBuffer.flip(); int bucketIndex = hashBuffer.get() & 0xFF; byte[] byteArray = BufferUtils.newByteArrayFromByteBuffer(hashBuffer); return bucketIndex; }
String function() { return relativeFullPath; }
boolean function(Language arg0) { for (RuleSet loc0 : ruleSets) { if (loc0.usesTypeResolution(arg0)) { return true; } } return false; }
void function(String arg0) { setBuild(arg0); }
Bitmap function(Bitmap img, int idealWidth, int idealHeight) { try { int[] dims = getDims(); int originalWidth = dims[0]; int originalHeight = dims[1]; float widthScale = (float) idealWidth / originalWidth; float heightScale = (float) idealHeight / originalHeight; float scaleFactor = Math.min(widthScale, heightScale); int scaledWidth = Math.round(originalWidth * scaleFactor); int scaledHeight = Math.round(originalHeight * scaleFactor); return Bitmap.createScaledBitmap(img, scaledWidth, scaledHeight, false); } catch (Exception e) { e.printStackTrace(); return null; } }
JWSAlgorithm function(JsonObject o, String member) { JWSAlgorithm algorithm = null; try { String value = getAsString(o, member); if (value != null) { algorithm = JWSAlgorithm.parse(value); } } catch (Exception e) { e.printStackTrace(); } return algorithm; }
String function(List<String> words, String password, String salt, int rounds, int length) { String joinedWords = Joiner.on(' ').join(words); byte[] seed = PBKDF2SHA512.derive(password, salt, rounds, length); return Hex.encodeHexString(seed); }
void function(String arg0) { this.testData = arg0; }
void function() { try { connect(); } catch (Exception e) { } }
void function(Activity activity, int requestCode, String address) { try { Intent intent = makeIntent(address, null); startForResult(activity, requestCode, intent); } catch (Exception e) { } }
void function() { final double velocity = 10.5; rmb.setVelocity(velocity); assertTrue(rmb.toString().contains("V," + velocity)); assertEquals(velocity, rmb.getVelocity(), 0.0); }
void function() { BiAdAdapterSwitcher adapterSwitcher = new BiAdAdapterSwitcher(); adapterSwitcher.setDefaultOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() { @Override public void onRefresh() { Handler handler = new Handler(); handler.postDelayed(refresh_default, 1000); } }); }
import com.google.common.collect.ImmutableMap; import org.junit.Assert; public class BlockStoreMetaTest { private BlockStoreMeta mBlockStoreMeta; private BlockStoreMeta mBlockStoreMetaFull; private long TEST_BLOCK_SIZE = 200L; private BlockMetadataManager mMetadataManager; private TemporaryFolder mTestFolder = new TemporaryFolder(); private long COMMITTED_BLOCKS_NUM = 10L; private long TEST_SESSION_ID = 33L; private void function() { ImmutableMap<String, Long> arg0 = ImmutableMap.of("tier1", 100L, "tier2", 200L, "tier3", 300L); Assert.assertEquals(ImmutableMap.of("tier1", 100L, "tier2", 200L, "tier3", 300L), arg0); long loc0 = mBlockStoreMeta.getCapacityBytesOnTiers().get("tier1"); long loc1 = mBlockStoreMeta.getCapacityBytesOnTiers().get("tier2"); long loc2 = mBlockStoreMeta.getCapacityBytesOnTiers().get("tier3"); } }
import java.io.InputStream; import java.io.OutputStream; import java.security.SecureRandom; public class Session { private String x11FakeCookie = null; private boolean flag_x11_requested = false; private boolean flag_closed = false; private boolean flag_pty_requested = false; private SecureRandom rnd; private ChannelManager cm; private Channel cn; private boolean flag_execution_started = false; private void function() { Integer arg0 = cn.getExitStatus(); function(arg0); } private void function(Integer arg0) { Integer loc0 = cn.getExitStatus(); } }
import java.net.Proxy; import java.net.URI; import java.util.regex.Pattern; public class ProxyFactory { private HTTPClientPolicy systemProxyConfiguration; private String HTTP_NON_PROXY_HOSTS = "http.nonProxyHosts"; private String HTTP_PROXY_PORT = "http.proxyPort"; private String HTTP_PROXY_HOST = "http.proxyHost"; private void function() { ProxyBuilder.build(); Pattern.matcher(""); Proxy.NO_PROXY; createProxy(systemProxyConfiguration); } private Proxy createProxy(HTTPClientPolicy policy) { Proxy loc0 = Proxy.NO_PROXY; return loc0; } }
import org.apache.thrift.protocol.TFieldIdEnum; import org.apache.thrift.protocol.TProtocol; import org.apache.thrift.transport.TMemoryInputTransport; public class TDeserializer { private TProtocol protocol_; private TMemoryInputTransport trans_; private void function() { try { reset(); read(); clear(); } catch (Exception e) { e.printStackTrace(); } } private void reset() throws Exception { } private void read() throws Exception { } private void clear() throws Exception { } }
public static void function(String arg0, String arg1, Exception e) { try { StackTraceElement loc0 = getCurrentStackTraceElement(); String loc1 = getContent(loc0); Log.e(arg0, arg1 + " " + loc1); String loc2 = e.getMessage(); StackTraceElement[] loc3 = e.getStackTrace(); e.printStackTrace(); } catch (Exception ex) { ex.printStackTrace(); } }
public String function() { return this.signatureAlias; }
public void function() { try { Event event = new Event(NotificationController.EVENT_TOPIC, Collections.singletonMap(Notification.NOTIFICATION_KEY_APPLICATION, "")); notificationController.put(mockServerSession, testEventProperties); notificationController.handleEvent(event); event = new Event(NotificationController.EVENT_TOPIC, Collections.singletonMap(Notification.NOTIFICATION_KEY_APPLICATION, "testApp")); notificationController.handleEvent(event); } catch (Exception e) { fail("Unexpected exception: " + e.getMessage()); } }
public static String function(KeyStroke arg0) { try { if (arg0 != null) { String modifiersText = KeyEventUtils.getModifiersText(arg0.getModifiers()); String keyText = KeyEventUtils.getKeyText(arg0.getKeyCode()); return modifiersText + KeyEventUtils.MODIFIER_JOINER + keyText + "srini_string"; } } catch (Exception e) { } return null; // or throw an exception, depending on the desired behavior }
public void function(String charset) { try { this.charset = charset; if (this.connection != null) { this.connection.setRequestProperty(CONTENT_TYPE, DEFAULT_CONTENT_TYPE + "; charset=" + charset); } } catch (Exception e) { } }
function(String jsonString) { ClientDetailsEntity entity = new ClientDetailsEntity(); JsonElement jsonEl = parser.parse(jsonString); RegisteredClient client = parseRegistered(jsonEl); entity.setClient(client); return entity; }
public void function(String portId) { try { RouterInterface.Builder builder = new RouterInterface.Builder(); builder.portId(portId); } catch (Exception e) { } }
void function() { rte.setRouteType(RouteType.ACTIVE); assertTrue(rte.isWorkingRoute()); assertFalse(rte.isActiveRoute()); }
void function() { for (Action action : actions) { if (action instanceof ConditionalAction) { ConditionalAction condAction = (ConditionalAction) action; for (Condition condition : conditions) { condAction.evaluateCondition(condition); } } action.update(); } }
@Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + id; result = prime * result + ((description == null) ? 0 : description.hashCode()); result = prime * result + ((testNodeDetail == null) ? 0 : testNodeDetail.hashCode()); result = prime * result + ((controlNodeDetail == null) ? 0 : controlNodeDetail.hashCode()); result = prime * result + (recoverable ? 1231 : 1237); return result; }
public HexDigest function() { byte[] digestBytes = getDigestBytes(); return HexDigest.createFromDigestBytes(digestBytes); }
ProctorResult function(Identifiers identifiers, Map<String, Object> context, Map<String, Integer> allocationIds) { return determineTestGroups(identifiers, context, allocationIds, Collections.<String>emptyList()); }
public static Date function(String arg0) { SimpleDateFormat loc0 = new SimpleDateFormat(FORMAT_ISO, LOCALE); loc0.setTimeZone(TIMEZONE); try { return loc0.parse(arg0); } catch (ParseException loc1) { throw new RuntimeException("Error parsing date", loc1); } }
boolean function(String arg0) { String loc0 = getValue(); if (loc0 == null || loc0.isEmpty()) { return true; } String loc1 = arg0.trim(); if (loc1.isEmpty()) { return true; } if (loc0.contains(loc1)) { return false; } return true; }
void function() { String EXAMPLE = "$RATTM,11,25.3,13.7,T,7.0,20.0,T,10.1,20.2,N,NAME,Q,,175550.24,A*34"; TTMParser loc0 = new TTMParser(); TTMParser loc1 = new TTMParser(); loc0.setTimeToCPA(10.0); assertEquals(10.0, loc0.getTimeToCPA(), 0.01); String str = loc0.toString(); assertTrue(str.contains("$RATTM")); loc0.setReference(false); assertFalse(loc0.getReference()); loc0.setReference(true); assertTrue(loc0.getReference()); }
static void function(FileChannel arg0, FileChannel arg1, int bufferSize) throws IOException { ByteBuffer loc0 = ByteBuffer.allocateDirect(bufferSize); while (arg0.read(loc0) != -1) { loc0.flip(); while (loc0.hasRemaining()) { arg1.write(loc0); } loc0.clear(); } }
String function(Object arg0, String arg1, Element arg2) { String loc0 = ""; Object loc1 = null; String loc2 = ""; if ("class".equals(arg1)) { loc0 = getClass(arg2); } else if ("visited".equals(arg1)) { loc1 = isVisited(arg2); } else if ("focus".equals(arg1)) { loc1 = isFocus(arg2); } else if ("id".equals(arg1)) { loc0 = getID(arg2); } else if ("style".equals(arg1)) { loc0 = getNonCssStyling(arg2); } else if ("active".equals(arg1)) { loc1 = isActive(arg2); } else if ("link".equals(arg1)) { loc1 = isLink(arg2); } else if ("hover".equals(arg1)) { loc1 = isHover(arg2); } else if ("lang".equals(arg1)) { loc0 = getLang(arg2); } else if ("elementStyle".equals(arg1)) { loc0 = getElementStyling(arg2); } else { loc0 = nsh.handleNamespaceAttribute(arg2, arg1); } if (loc1 != null) { loc2 = loc1.toString(); } else { loc2 = loc0; } return loc2; }
void function(String arg0) { this.album = arg0; }
FiltersType function() { return cipherSuiteFilters.function(); }
public void function() { MemoryLogger.instance.function(); }
void function() { try { vtg.setMagneticCourse("srini_string"); assertTrue(false, "setMagneticCourse did not throw exception"); } catch (Exception loc0) { assertTrue(loc0.getMessage().contains("srini_string"), "Exception message does not contain srini_string"); } }
boolean function(Map<String, Object> arg0, String arg1) { Object loc0 = arg0.get(arg1); if (loc0 == null) { return false; } if (loc0 instanceof Boolean) { return (Boolean) loc0; } if (loc0 instanceof String) { String loc1 = (String) loc0; return !"false".equalsIgnoreCase(loc1.trim()); } return false; }
void function(String arg0, String arg1) { XMLUnit.setIgnoreWhitespace(true); XMLUnit.setNormalize(true); Config.readConfig("srini_string"); }
String function(String arg0) { String loc0 = arg0.substring(1, arg0.length() - 1); return loc0; }
void function(String arg0, String arg1) { String loc0 = arg0.trim(); String loc1 = arg1.trim(); PROPS.put(loc0, loc1); loadValue(loc1); }
String function(Fig arg0) { Fig loc0 = arg0.getEnclosingFig(); return getId(loc0); }
Sha256Hash function(File arg0) { try { FileInputStream loc0 = new FileInputStream(arg0); byte[] loc1 = ByteStreams.toByteArray(loc0); loc0.close(); return Sha256Hash.create(loc1); } catch (IOException e) { throw new RuntimeException("Error reading file " + arg0.getName(), e); } }
boolean function(Connection arg0) throws SQLException { DatabaseMetaData loc0 = arg0.getMetaData(); String loc1 = loc0.getDriverName().toLowerCase(); return loc1.contains("mysql"); }
public Class<? extends Service> function() { return UUIDService.class; } This method returns the class object that represents the UUIDService class, with a wildcard type that indicates it is an unknown type that extends the Service class. The method is concise and does not include any exception handling or comments. The method name is "function", and it has no arguments. The local variable names are "loc0", "loc1", and so on.
void function() { System.out.println("Method calling to use the direct connection."); HTTPDirectConnection directConn = new HTTPDirectConnection(); URLConnection loc0 = directConn.getURLConnection(this.URI); BufferedReader loc1 = directConn.getBufferedReader(loc0); this.reader = loc1; this.urlConn = loc0; }
Date function(String arg0, DateTimeFormat arg1) { Date loc0 = new DateTime(this.pattern).parseUTC(arg0, DateTimeFormat.SQL); return loc0; }
public void function(String arg0) { try { setName(arg0); } catch (Exception loc0) { System.out.println("Error setting transducer name: " + loc0.getMessage()); } }
void function() { byte[] arg0 = new byte[10]; writeByte(); mStream.write(arg0, 0, 10); mStream.close(); Mockito.verify(mLocalOutputStream, Mockito.times(1)).write(arg0, 0, 10); }
public void function() { String arg0 = "$GPGGA"; NMEASentenceParser loc0 = instance.createParser(arg0); assertNotNull(loc0); assertTrue(loc0 instanceof GPGGASentence); assertEquals(arg0, loc0.getSentenceId()); String arg1 = "$GPRMC"; NMEASentenceParser loc1 = instance.createParser(arg1); assertNotNull(loc1); assertTrue(loc1 instanceof GPRMCSentence); assertEquals(arg1, loc1.getSentenceId()); String arg2 = "$GPGSV"; NMEASentenceParser loc2 = instance.createParser(arg2); assertNotNull(loc2); assertTrue(loc2 instanceof GPGSVSentence); assertEquals(arg2, loc2.getSentenceId()); String arg3 = "$INVALID"; NMEASentenceParser loc3 = instance.createParser(arg3); assertNull(loc3); }
public void function(StateListener arg0) { try { listeners.add(arg0); } catch (Exception loc0) { } }
void function(Project arg0) { if (currentProject == null) { arg0.remove(); } }
public boolean function(String arg0, String arg1) { boolean loc0 = false; try { loc0 = StringUtils.contains(arg0, arg1); } catch (Exception e) { } return loc0; }
HashMap<String, SoftReference<ReplacedElement>> imageCache = new HashMap<>(); void function(String arg0, ReplacedElement arg1) { CacheKey key = new CacheKey(arg0, null); SoftReference<ReplacedElement> loc0 = new SoftReference<>(arg1); imageCache.put(key.toString(), loc0); }
void function(String arg0) { setErrorMsg(arg0); }
List<String> function() { List<String> loc0 = new ArrayList<>(federationRegistrations.size()); for (FederationModel loc1 : federationRegistrations) { loc0.addAll(loc1.getToken().values()); } return loc0; }
public void function(String arg0, String arg1) { try { EaseUser loc0 = SuperWeChatDBManager.getInstance().getUser(arg0); if (loc0 == null) { return; } List<EaseUser> loc1 = new ArrayList<>(); loc1.add(loc0); SuperWeChatDBManager.getInstance().saveContact(loc1); } catch (Exception e) { e.printStackTrace(); } }
public int function(String arg0) { byte[] loc0 = Base58.decodeChecked(arg0); return loc0[0] & 0xff; }
int function(int arg0) { Step loc0 = steps.get(arg0); return loc0.getY(); }
List<String> function() { List<String> loc0 = null; try { loc0 = Collections.unmodifiableList(Arrays.asList(new String[]{AuthPolicy.SPNEGO, AuthPolicy.NTLM, AuthPolicy.DIGEST, AuthPolicy.BASIC})); } catch (Exception loc1) { } return loc0; }
void function() { try { LogManager.shutdown(); XLog.Info.reset(); XLogStreamer.Filter.reset(); } catch (Exception loc0) { } }
DirectionsResult function(String arg0, String arg1, TravelMode arg2) { DirectionsApiRequest loc0 = DirectionsApi.newRequest(mapsClient.getContext()); LatLng loc1 = new LatLng(Double.parseDouble(arg0.split(",")[0]), Double.parseDouble(arg0.split(",")[1])); LatLng loc2 = new LatLng(Double.parseDouble(arg1.split(",")[0]), Double.parseDouble(arg1.split(",")[1])); DirectionsResult loc3 = loc0.origin(loc1) .destination(loc2) .mode(arg2) .await(); return loc3; }
String function() { String loc0 = null; try { loc0 = getCSSName().getPropertyName(); } catch (Exception e) { } return loc0; }
Message function(Message arg0) { PhaseInterceptorChain loc0 = createChain(); loc0.add(getRoutingInterceptors()); loc0.add(getBindingInterceptors()); Exchange loc1 = new ExchangeImpl(); setExchangeProperties(loc1, arg0); loc1.put(Message.ENDPOINT_ADDRESS_PROPERTY, ENDPOINTS); loc1.setClassLoader(loader); loc1.setBus(bus); loc1.setInMessage(arg0); loc1.setOutMessage(new MessageImpl()); loc0.doIntercept(loc1, arg0); return loc1.getOutMessage(); }
Filters function(GameRequestContent arg0) { Filters loc0 = arg0.filters; return loc0; }
String function(String arg0, Document arg1) { try { Jaxp13XpathEngine engine = new Jaxp13XpathEngine(); engine.setNamespaceContext(null); NodeList loc0 = engine.getMatchingNodes(arg0, arg1); StringWriter loc1 = new StringWriter(); for (int i = 0; i < loc0.getLength(); i++) { TransformerFactory.newInstance().newTransformer().transform( new DOMSource(loc0.item(i)), new StreamResult(loc1)); } return loc1.toString(); } catch (XMLUnitException | XPathException ex) { Throwable loc2 = ex.getCause(); if (loc2 == null) { loc2 = ex; } throw new RuntimeException(loc2); } catch (Exception ex) { throw new RuntimeException(ex); } }
void function() { try { links.clear(); } catch (UnsupportedOperationException e) { } }
public static ChangeableKind function(String arg0, String arg1) { try { ChangeableKindEnum loc0 = ChangeableKindEnum.forName(arg0); List<String> loc1 = Arrays.asList(arg1.split(",")); loc0.typeName = loc1; return loc0; } catch (Exception loc2) { throw new IllegalArgumentException("Error resolving serialized instance of enumeration value.", loc2); } }
void function(String arg0, DifferenceGroup arg1) { try { differenceGroups.put(arg0, arg1); } catch (Exception loc0) { } }
void function(Object arg0) throws IOException { beforeValue(); mWriter.write(JSON.LSQUARE); mStack.push(new State(ARRAY)); return this; }
void function() { setUp(); instance.getHorizontalDOP(); assertEquals(loc0, instance.getHorizontalDOP(), loc1); }
void function(ResourceBundle arg0) { Set<String> loc0 = new HashSet<>(); Enumeration<String> loc1 = arg0.getKeys(); while (loc1.hasMoreElements()) { String loc2 = loc1.nextElement(); Assert.assertTrue("Key entered twice: " + loc2, !loc0.contains(loc2)); loc0.add(loc2); } }
public String function(String arg0) { String loc0 = ""; try { String loc1 = System.getProperty("user.dir"); File loc2 = new File(loc1 + "/log"); if (!loc2.exists()) { loc2.mkdirs(); } loc0 = loc2.getAbsolutePath() + "/" + arg0; } catch (Exception loc3) { logger.error("Failed to retrieve log path: " + loc3.getMessage()); } return loc0; }
import java.io.OutputStream; public class Hex { private Encoder encoder = new HexEncoder(); int function(String arg0, OutputStream arg1) { byte[] loc0 = arg0.replaceAll("\\s", "").getBytes(); return encoder.decode(loc0, 0, loc0.length, arg1); } }
public static boolean function(Object arg0, Object arg1) { try { if (arg0 == null || arg1 == null) { return false; } else if (arg0.equals(arg1)) { return true; } else if (arg0.toString().equalsIgnoreCase(arg1.toString())) { return true; } } catch (Exception e) { } return false; }
int function() { try { return _all.size(); } catch (NullPointerException e) { return 0; } }
void function() { try { buffer.flushEvents(); for (ConnectionThread thread : threads) { thread.clientFlushedEvents(); } } catch (Exception loc0) { loc0.printStackTrace(); } }
Thread function() { Thread loc0 = this.waiter; this.waiter = null; return loc0; }
void function(InputStream arg0) { try { if (arg0 != null) { arg0.close(); } } catch (IOException e) { System.err.println("Input Stream management not safe"); } }
void function() { long loc0 = -22; long loc1 = 11; ByteBuf loc2 = null; long loc3 = 0; RPCFileWriteRequestTest test = new RPCFileWriteRequestTest(); test.function(); RPCFileWriteRequest req = new RPCFileWriteRequest(loc0, loc1, loc2, loc3); test.assertInvalid(req); } Note: It's worth noting that the current implementation of the member function `RPCFileWriteRequestTest.function()` calls itself recursively, leading to an infinite loop and a stack overflow error. This should be modified accordingly to avoid such an issue.
public static String function(String arg0, String arg1) { try { AggregationKindEnum loc0 = AggregationKindEnum.forName(arg0); String loc1 = loc0.literalName; String loc2 = loc1 + "." + arg1; return loc2; } catch (Exception e) { return null; } }
BufferedImage function(int arg0, int arg1) { BufferedImage loc0 = ImageUtil.createCompatibleBufferedImage(arg0, arg1, BufferedImage.TYPE_INT_RGB); ImageUtil.clearImage(loc0); return loc0; }
public static void function() { try { File tempDir = File.createTempFile("prefix", "suffix"); tempDir.delete(); tempDir.mkdir(); } catch (IOException e) { LOG.error("Failed to create temporary directory", e); } }
public void function(Date arg0) { try { setFetcherStartTimeStamp(arg0); } catch (Exception e) { e.printStackTrace(); } }
float function(int arg0, int arg1) { float loc0 = 0.0f; try { loc0 = (float) arg0 / (float) arg1; } catch (ArithmeticException e) { System.out.println("Cannot divide by zero."); } return loc0; } This method takes in two integer arguments "arg0" and "arg1" and returns a float value representing the result of dividing "arg0" by "arg1". Type casting is used to ensure that the division is performed using floating-point arithmetic rather than integer arithmetic. Exception handling is used to handle the case where "arg1" is zero and prevent a division-by-zero error. If an ArithmeticException is caught, the method prints a message indicating that division by zero is not allowed and returns 0.0f. Otherwise, the result of the division is returned.
public int function() { try { return this.yPosition; } catch (Exception e) { System.err.println("An error occurred while getting the vertical position of the ball: " + e.getMessage()); return -1; } }
public void function(String arg0) { try { setId(arg0); } catch (Exception loc0) { System.out.println("Error setting ID: " + loc0.getMessage()); } }
boolean function(T arg0) { return nodePosition.containsKey(arg0); }
public static String function(String viaHeader) { String viaValue = SipHeaderValue.getBaseValue(viaHeader); String sentByValue = StringUtils.substringAfterLast(viaValue, "sent-by="); String sentByHost = StringUtils.substringBetween(sentByValue, "[", "]"); if (sentByHost == null) { sentByHost = StringUtils.substringBefore(sentByValue, ";").trim(); } return sentByHost; }
String function(MyComplexStruct obj) { String loc0 = obj.elem2; return loc0; }
void function() { Time loc0 = new Time(12, 0, 45.0); instance.setTime(loc0); assertTrue(instance.getTime().equals(loc0)); }
public static boolean function(ByteBuffer arg0, RudpConnectionId arg1) { int loc0 = arg0.position(); UInt loc1 = arg0.getUInt(); UInt loc2 = UIntImpl.getChecksum(arg0); arg0.putUInt(loc0, loc1); return loc2.equals(getChecksum(arg0)) && arg1.equals(toId(arg0)); }
List<Vertice> function(Grafo arg0) { List<Vertice> loc0 = arg0.obterVerticesOrdenados(); return loc0; }
void function(Item arg0) { try { this.mob.setCurrentItemOrArmor(0, new ItemStack(arg0)); } catch (Exception e) { } }
void function(LoadMetadataType arg0) { mLoadMetadataType = arg0; return; }
AbstractPlugin function(String arg0) { for (AbstractPlugin loc0 : plugins) { if (loc0.getName().equals(arg0)) { return loc0; } } return null; }
void function() { long loc0 = System.currentTimeMillis(); goal.run(); long loc1 = System.currentTimeMillis(); exclusive_time += loc1 - loc0; inclusive_time += loc1 - loc0; }
void function() { mThrown.expect(BlockDoesNotExistException.class); mThrown.expectMessage("Block id " + TEST_BLOCK_ID + " not found"); try { mMetaManagerView.getBlockMeta(TEST_BLOCK_ID); } catch (BlockDoesNotExistException loc0) { } }
Mode function(Mode arg0, Mode arg1) { Mode loc0 = FILE_UMASK.applyUMask(arg0); return loc0.getUMask(arg1); }
import java.io.UnsupportedEncodingException; import java.net.URLEncoder; public class SignedRequestsHelper { public static String function(String arg0, String arg1) { String loc0; try { loc0 = URLEncoder.encode(arg0, "UTF-8") .replace("+", "%20") .replace("*", "%2A") .replace("%7E", "~"); } catch (UnsupportedEncodingException e) { loc0 = arg0; // fallback to the original value } String loc1 = arg1.replace("+", "%20") .replace("*", "%2A") .replace("%7E", "~"); return loc0 + "=" + loc1; } }
File function(String arg0) { File loc0 = new File(arg0); try { Files.createDirectories(loc0.toPath().getParent()); loc0.createNewFile(); } catch (IOException e) { LOG.error("Failed to create file", e); } return loc0; }
public void function() { setUp(); assertEquals("160705", rmc.getDate()); assertEquals(7, rmc.getMonth()); }
void function(Document arg0) { doc = arg0; eval(); }
USAddress function() { return billTo; }
void function() { try { OutputStream loc0 = mOutputStreamMock; HttpURLConnection loc1 = mHttpConMock; loc1.getOutputStream(); mThrown.thenThrow(new IOException()); mThrown.expect(IOException.class); mThrown.expectMessage("Error closing output stream"); loc0.close(); } catch (IOException e) { } }
byte[] function(int arg0, Entropy arg1) { if (!computedKey) { createSymmetricKey(); } LOG.debug("Getting the secret"); byte[] loc0 = new byte[keySize / 8]; System.arraycopy(secret, 0, loc0, 0, loc0.length); return loc0; }
public symbol function() { symbol arg0 = this._on_symbol; return arg0; } Note: I assumed that "symbol" is a valid class or data type that represents the symbol being referred to in the member variable "_on_symbol". If that's not the case, please replace "symbol" with the appropriate data type or class name.
void function() { setHeader("Allow", "GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH"); getContentType(); setStatus(200); }
boolean function(Object arg0, Object arg1) { if (arg0 instanceof Decision && arg1 instanceof Decision) { String loc0 = ((Decision) arg0).getName(); String loc1 = ((Decision) arg1).getName(); return loc0.equals(loc1); } return false; }
import org.apache.cxf.ws.addressing.ContextUtils; import org.apache.cxf.ws.addressing.AddressingProperties; import org.apache.cxf.message.Message; public class RMContextUtils { public static AddressingProperties function(Message arg0, boolean arg1, boolean arg2) { return ContextUtils.retrieveMAPs(arg0, arg1, arg2); } }
public GetOfferDetailsResponse.Return.DetailOfferData.Products.Product function(String arg0, String arg1) { GetOfferDetailsResponse.Return.DetailOfferData.Products loc0 = createGetOfferDetailsResponseReturnDetailOfferDataProducts(); GetOfferDetailsResponse.Return.DetailOfferData.Products.Product loc1 = loc0.createProduct(); loc1.setArg0(arg0); loc1.setArg1(arg1); return loc1; }
void function() { ServerSession loc0 = null; ServerMessage loc1 = mock(ServerMessage.class); activityController.deregisterUserSession(loc0, loc1); }
void function() { function(); wireParser.closeConnection(); } Note: This implementation will cause a stack overflow due to the infinite recursion caused by calling the function within itself. Additionally, it is not clear how the "wireParser" object is initialized and whether it is safe to call "closeConnection()" without checking for null or ensuring that it is properly initialized.
@Override public boolean hasPermission(Authentication arg0, Object arg1, Object arg2) { try { throw new UnsupportedOperationException("We do not support this method call."); } catch (UnsupportedOperationException loc0) { log.error("Error: " + loc0.getMessage(), loc0); throw loc0; } }
Here's the updated method named "function" that calls the required methods with exception handling: ``` import java.awt.Dimension; import java.awt.Toolkit; import java.awt.event.ActionEvent; import java.io.File; import javax.swing.JOptionPane; import org.openstreetmap.gui.jmapviewer.DefaultMapController; import org.openstreetmap.gui.jmapviewer.DefaultTileSource; import org.openstreetmap.gui.jmapviewer.MapViewer; import org.openstreetmap.gui.jmapviewer.OsmFileCacheTileLoader; import org.openstreetmap.gui.jmapviewer.OsmFileCacheTileSource; import org.openstreetmap.gui.jmapviewer.OsmMercator; import org.openstreetmap.gui.jmapviewer.OsmMercator.OpenStreetMapTile; import org.openstreetmap.gui.jmapviewer.Style; import org.openstreetmap.gui.jmapviewer.interfaces.MapController; import org.openstreetmap.gui.jmapviewer.interfaces.TileLoader; import org.openstreetmap.gui.jmapviewer.interfaces.TileSource; public class OsmViewerPlusApp { private JButton leftButton; private JButton zoomOutButton; private JButton upButton; private JButton downButton; private JToggleButton nightButton; private JButton zoomInButton; private JButton rightButton; private MapViewFrame frame; public OsmViewerPlusApp() { this.frame = new MapViewFrame(createDayRenderer()); this.leftButton = new JButton(); this.zoomOutButton = new JButton(); this.upButton = new JButton(); this.downButton = new JButton(); this.nightButton = new JToggleButton(); this.zoomInButton = new JButton(); this.rightButton = new JButton(); initializeButtons(); } public DefaultEntityRenderer createDayRenderer() { } public void actionPerformed(ActionEvent e) { } public MapViewFrame getFrame() { return frame; } public void showFrame() { frame.setVisible(true); } public static void main(String[] args) { function(args); } private static void function(String[] args) { try { int width = 0; double size = 0; for (String arg : args) { if (arg.startsWith("-screenwidth=")) { String loc0 = arg.substring("-screenwidth=".length()); width = Integer.parseInt(loc0); } else if (arg.startsWith("-screensize=")) { String loc1 = arg.substring("-screensize=".length()); size = Double.parseDouble(loc1); } } if (width > 0) { double height = ((double) width / 2.54) * 100; Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); double scale = height / screenSize.getHeight(); int loc2 = (int) (screenSize.getWidth() * scale); frame.setSize(loc2, (int) height); } else if (size > 0) { double widthInCm = Math.sqrt(Math.pow((size / 2.54), 2) / 2); double heightInCm = widthInCm / 2; Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); double scale = widthInCm / screenSize.getWidth(); int loc3 = (int) (screenSize.getHeight() * scale); frame.setSize((int) widthInCm, loc3); } else { throw new IllegalArgumentException("Either screen width or screen size should be specified as program argument."); } setDefault(); OsmViewerPlusApp app = new OsmViewerPlusApp(); MapViewFrame frame = app.getFrame(); File ul
public void function() { try { TTMParser loc0 = new TTMParser(); loc0.parse(EXAMPLE); double loc1 = 7.0; double loc2 = loc0.getSpeed(); assertEquals(loc1, loc2, 0.01); } catch (Exception e) { e.printStackTrace(); } }
public void function() { try { Device dev = new Device(); Capability cap1 = new Capability("Cap1"); Capability cap2 = new Capability("Cap2"); dev.addCapability(cap1); dev.addCapability(cap2); ArrayList<Capability> loc0 = dev.getCapabilities(); assertEquals(loc0.size(), 2); assertEquals(loc0.get(0).getName(), "Cap1"); assertEquals(loc0.get(1).getName(), "Cap2"); ArrayList<Capability> loc1 = null; try { loc1 = dev.getCapabilities(); } catch (NullPointerException e) { fail("getCapabilities returned null"); } System.out.println("Test of getCapabilities method, of class Device: Passed"); } catch (Exception e) { fail("Test of getCapabilities method, of class Device: Failed"); } }
public static Position function(Position arg0, Position arg1) { if (arg0.isComparable(arg1)) { if (arg0.endLine() > arg1.endLine()) { return arg0; } else if (arg0.endLine() == arg1.endLine() && arg0.endColumn() > arg1.endColumn()) { return arg0; } else { return arg1; } } else { return null; } }
void function(Object arg0) { try { setTransformedTokenIdentifier((String) arg0); } catch (Exception e) { } }
List<VertexLabelType> function() { List<VertexLabelType> loc0 = new ArrayList<>(); try { loc0.addAll(vertexLabels); } catch (Exception e) { } return loc0; }
void function() { RTETest test = new RTETest(); test.setUp(); assertTrue(test.rte.isActiveRoute()); }
float function() { try { float loc0 = getLatMax(); float loc1 = getLatMin(); return getDistKM(loc0, loc1); } catch (Exception e) { return -1; } }
public void function() { final HDGTest hdgTest = new HDGTest(); final double loc0 = 5.0; hdgTest.setUp(); try { hdgTest.hdg.setDeviation(loc0); } catch (IllegalArgumentException | Exception e) { fail("Exception was thrown: " + e.getMessage()); } final double loc1 = hdgTest.hdg.getDeviation(); assertTrue(Double.compare(loc0, loc1) == 0); }
boolean function() { return mConnected; }
import java.util.Calendar; import java.util.TimeZone; public static Calendar function(Date arg0) { Calendar loc0 = Calendar.getInstance(); loc0.setTimeZone(TimeZone.getTimeZone("UTC")); loc0.setTime(arg0); return loc0; }
public void function() { DataNettyBuffer loc0 = new DataNettyBuffer(mBuffer, LENGTH); int loc1 = loc0.getLength(); Assert.assertEquals(LENGTH, loc1); }
void function(String arg0) { this.testId = arg0; }
void function() { try { HDGTest hdgTest = new HDGTest(); hdgTest.setUp(); HDGParser parser = new HDGParser(); parser.parse(hdgTest.EXAMPLE); double loc0 = parser.getDeviation(); double loc1 = 1.2; assertEquals(loc1, loc0, 0.001); } catch (Exception e) { fail("Exception: " + e.getMessage()); } }
void function() { LogEntryInterval loc0 = new LogEntryInterval(); loc0.setNumberRequests(5); System.out.println("Test of getNumberRequests method, of class LogEntryInterval."); assertEquals(5, loc0.getNumberRequests()); }
char[] function(char[] arg0) { int loc0 = 0; int loc1 = arg0.length - 1; while (loc0 < loc1) { char temp = arg0[loc0]; arg0[loc0] = arg0[loc1]; arg0[loc1] = temp; loc0++; loc1--; } return arg0; }
void function() { andOperation(); notOperation(); implies(); getSymbol(); Assert.assertEquals(Mode.Bits.WRITE_EXECUTE, arg0); Assert.assertEquals(Mode.Bits.WRITE, arg1); Assert.assertEquals(Mode.Bits.EXECUTE, arg2); Assert.assertEquals(Mode.Bits.READ_EXECUTE, arg3); Assert.assertEquals(Mode.Bits.READ, arg4); Assert.assertEquals(Mode.Bits.READ_WRITE, arg5); }
void function(Intent arg0, int arg1, Activity arg2) { try { arg2.startActivityForResult(arg0, arg1); } catch (ActivityNotFoundException loc0) { AlertDialog loc1 = new AlertDialog.Builder(arg2) .setTitle(DEFAULT_TITLE) .setMessage(DEFAULT_MESSAGE) .setPositiveButton(DEFAULT_YES, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { Intent loc0 = new Intent(Intent.ACTION_VIEW, Uri.parse("market://details?id=" + BS_PACKAGE)); try { arg2.startActivity(loc0); } catch (ActivityNotFoundException loc1) { Intent loc2 = new Intent(Intent.ACTION_VIEW, Uri.parse("http://play.google.com/store/apps/details?id=" + BS_PACKAGE)); arg2.startActivity(loc2); } } }) .setNegativeButton(DEFAULT_NO, null) .create(); loc1.show(); } }
double function(DenseMatrix64F arg0, DenseMatrix64F arg1, DenseMatrix64F arg2) { configure(arg0, arg1, arg2); compute(param, arg1, arg2); double loc0 = diffNormF(); return loc0 * loc0 / arg2.numRows(); }
DAVResource function(URI arg0) { URI uri = arg0.isAbsolute() ? arg0 : base.resolve(arg0); URI normalizedURI = uri.normalize(); String path = normalizedURI.getPath(); if (!path.startsWith(root.getPath())) { throw new IllegalArgumentException("URI " + arg0 + " is not within repository " + root); } String relativePath = path.substring(root.getPath().length()); if (relativePath.isEmpty()) { relativePath = "/"; } DAVResource resource = factory.getResource(relativePath); File file = resource.getFile(); if (!file.isAbsolute()) { file = new File(root, relativePath); } resource.setFile(file.getAbsoluteFile()); return resource; }
void function(boolean arg0, String arg1) { if(progressMonitor.isRunningOnServer()) { progressMonitor.arg0 = arg0; progressMonitor.log.append(arg1); System.out.println("Logs a Message."); } }
public static boolean function(Pattern arg0, String arg1) { Matcher loc0 = arg0.matcher(arg1); return loc0.find(); }
boolean function(UserModel arg0) { try { return userService.updateUserModel(arg0); } catch (Exception loc0) { logger.error("Error updating user model: " + loc0.getMessage()); return false; } }
void function(String arg0) { UnderFileSystemUtils.deleteDir(arg0); }
import java.io.BufferedReader; import java.io.File; import java.io.FileReader; import java.io.IOException; public class WebFileConnect { private String TAB = "\t"; private String NEW_LINE = "\n"; private String[][] retrieveMatrix(File file) throws IOException { } private String readFile(BufferedReader in) throws IOException { } private String[][] parseMatrix(String content) { } private String[][] prepareMatrix(String content) { } public String function(String arg0) { String loc0 = arg0; String content = ""; try { File loc1 = new File(loc0); BufferedReader loc2 = new BufferedReader(new FileReader(loc1)); content = readFile(loc2); } catch (IOException e) { e.printStackTrace(); } String[][] loc3 = parseMatrix(content); String[][] loc4 = prepareMatrix(content); return content; } }
void function() { try { Event loc0 = new Event("test.topic", Collections.singletonMap(ActivityEvent.ID_KEY, "")); acitivityController.put(MOCK_SESSION_ID, mockServerSession); acitivityController.handleEvent(loc0); fail("Expected IllegalArgumentException was not thrown."); } catch (IllegalArgumentException e) { } }
String function(Object obj) { if (obj == null) { return "null"; } Class<?> clazz = obj.getClass(); String shortName = ClassUtil.SHORT_NAMES_BY_TYPE.get(clazz); if (shortName != null) { return shortName; } return clazz.getName(); }
Object function(AccessibilityEvent arg0, int arg1) { try { Object loc0 = AccessibilityEventCompat.IMPL.getRecord(arg0, arg1); return loc0; } catch (IndexOutOfBoundsException loc1) { return null; } }
QRDecomposition<DenseMatrix64F> function(int numRows, int numCols) { QRDecompositionHouseholderColumn_D64 qr = new QRDecompositionHouseholderColumn_D64(); qr.setExpectedMaxSize(numRows, numCols); return qr; }
void function(byte[] arg0) { try { _messageBody = arg0; } catch (Exception loc0) { } }
void function(MenuItemWrapper loc0, MenuItem.OnMenuItemClickListener loc1) { try { loc0.mMenuItem.setOnMenuItemClickListener(loc1); } catch (Exception e) { } }
public void function(String arg0) { VHWParser loc0 = new VHWParser(arg0); assertTrue(loc0.getTalkerId().isEmpty()); assertEquals("$VWVHW", loc0.getSentenceId()); String loc1 = "$VWVHW,000.0,T,001.5,M,1.0,N,1.85,K"; VHWParser loc2 = new VHWParser(loc1); assertEquals("$VWVHW", loc2.getSentenceId()); assertEquals(0.0, loc2.getHeading(), 0.1); assertEquals(0.0, loc2.getSpeedKnots(), 0.1); assertEquals(0.0, loc2.getSpeedKilometres(), 0.1); assertEquals(1.5, loc2.getMagneticHeading(), 0.1); assertEquals(1.0, loc2.getSpeedKnots(), 0.1); assertEquals(1.85, loc2.getSpeedKilometres(), 0.1); assertEquals(loc1, loc2.toString()); }
void function() { trace(); handleMessages(); clear(); }
double function() { checkState(count > 1); double loc0 = sumOfSquaresOfDeltas - ((sum * sum) / count); ensureNonNegative(loc0); loc0 /= count - 1; return isNaN(loc0) ? Double.NaN : loc0; }
Object function(String arg0) { Object loc0 = getContext().currentClassifier(); if (loc0 != null) { for (Object loc1 : (Collection) loc0.getClass().getMethod("getMethods").invoke(loc0)) { if (loc1.getClass().getMethod("getName").invoke(loc1).equals(arg0) && (boolean) loc1.getClass().getMethod("isAMethod").invoke(loc1)) { return loc1; } } } return null; }
void function(HttpParams arg0, boolean arg1) { try { HttpConnectionParams.setBooleanParameter(arg0, CoreConnectionPNames.TCP_NODELAY, arg1); } catch (RuntimeException loc0) { } }
boolean function(HttpServletRequest arg0) { String loc0 = arg0.getHeader("User-Agent"); return (arg0 == null) ? false : check(loc0); }
void function(int arg0, AbstractReportNode arg1) { try { if (arg1 != null) { arg1.setParentNode(this); } if (arg0 >= 0 && arg0 <= childNodes.size()) { childNodes.add(arg0, arg1); } } catch (Exception e) { } }
boolean function() { for (int loc0 = 0; loc0 < bufferSize; loc0++) { if (buffer[loc0] != 0) { return false; } } return true; }
public static <T> Function<Object, T> function(Supplier<T> arg0) { return (arg1) -> arg0.get(); }
void function() { try { HDGTest test = new HDGTest(); double arg0 = 150.0; test.hdg.setHeading(arg0); double loc0 = test.hdg.getHeading(); assertEquals(arg0, loc0, 0.1); } catch (Exception e) { fail("Exception thrown: " + e.getMessage()); } }
int function() { int loc0 = mMetadataManager.getTierViewOrdinal(mAliasToTierViews.get(mTierViews.get(mTierViews.size()-1).getTierAlias())) + 1; int loc1 = mTierViews.size(); StorageTierView loc2 = mMetadataManager.getTierView(loc0); mAliasToTierViews.put(loc2.getTierAlias(), loc2); mTierViews.add(loc2); return loc1; }
void function(File arg0, String arg1) { arg0.delete(); FileOutputStream loc0 = new FileOutputStream(arg0); StringReader loc1 = new StringReader(arg1); IOUtils.copy(loc1, loc0); loc0.flush(); loc0.close(); loc1.close(); }
void function(THashSet<String> arg0) { try { THashSet<String> loc0 = new THashSet<>(); for (String entry : arg0) { String regex = entry.replace(".", "\\.").replace("*", ".*"); loc0.add(regex); } mWhitelist.addAll(loc0); } catch (Exception e) { } }
int function() { int numDistinct = 0; Schema schema1 = p1.schema(); Schema schema2 = p2.schema(); if (schema1.hasField(fldname1)) { int loc1 = schema1.fieldNumber(fldname1); numDistinct += p1.distinctValues(loc1); } if (schema2.hasField(fldname2)) { int loc2 = schema2.fieldNumber(fldname2); numDistinct += p2.distinctValues(loc2); } return numDistinct; }
File function(File arg0) { File loc0 = null; try { loc0 = arg0.getCanonicalFile(); } catch (IOException e) { loc0 = arg0.getAbsoluteFile(); } return loc0; }
public int function(DHGexParameters obj) { int loc0; try { loc0 = obj.getPref_group_len(); if (loc0 < obj.getMin_group_len() || loc0 > obj.getMax_group_len()) { loc0 = (obj.getMin_group_len() + obj.getMax_group_len()) / 2; } } catch (Exception e) { loc0 = (obj.MIN_ALLOWED + obj.MAX_ALLOWED) / 2; } return loc0; }
double function(D1Matrix64F arg0) { double loc0 = 0; int loc1 = arg0.getNumElements(); for (int i = 0; i < loc1; i++) { double loc2 = arg0.get(i); loc0 += loc2 * loc2; } return sqrt(loc0); }
int function(RowD1Matrix64F arg0) { return arg0.getNumElements(); }
public class MessageUtils { public static boolean function(Message arg0) { Boolean loc0 = arg0.getContextualProperty("MessageContext.REQUEST_OUTBOUND_PROPERTY", "true").booleanValue(); return loc0.booleanValue(); } } In the method "function", we use the "getContextualProperty" method to retrieve the value of the "MessageContext.REQUEST_OUTBOUND_PROPERTY" property, which indicates if the message is outbound. We then call the "booleanValue" method to get the boolean value of the retrieved property and return it. The method is declared as static and takes a single argument of type "Message".
public String function() { String loc0 = null; try { loc0 = this.fldname; } catch (Exception loc1) { loc1.printStackTrace(); } return loc0; }
List<File> function(List<String> arg0, String arg1) { List<File> loc0 = new ArrayList<>(); for (String location : arg0) { File file = new File(location); loc0.add(file); } String type = "jpg"; String unit = "pixel"; String renameSuffix = arg1 + "." + suffix; saveFiles(type, unit, loc0, renameSuffix); return loc0; }
boolean function(ActivityRequest arg0) { boolean loc0 = false; try { String loc1 = arg0.getFeedId(); Properties loc2 = arg0.getConfigProperties(); if (loc1 != null && !loc1.isEmpty() && loc2 != null && !loc2.isEmpty()) { loc0 = true; } } catch (Exception loc3) { } return loc0; }
class LZ4FastDecompressor { public byte[] decompress(byte[] src, int srcOff, int destLen) throws LZ4Exception { } public byte[] function(byte[] arg0, int arg1, int arg2) { byte[] result = null; try { result = decompress(arg0, arg1, arg2); } catch (LZ4Exception e) { e.printStackTrace(); } return result; } public String toString() { } }
public static TermCounter function(String arg0, String arg1) { String loc0 = arg1.replaceAll("(?s)<!--.*?-->", ""); String[] loc1 = loc0.toLowerCase().split("\\W+"); TermCounter loc2 = new TermCounter(arg0); for (String loc3 : loc1) { loc2.incrementTermCount(loc3); } return loc2; }
AdaptableHeuristicFunction function(Object arg0, Map arg1) { try { AdaptableHeuristicFunction adaptableHeuristicFunction = new AdaptableHeuristicFunction(); adaptableHeuristicFunction.setGoal(arg0); adaptableHeuristicFunction.setMap(arg1); return adaptableHeuristicFunction; } catch (Exception e) { } return null; }
int function(MutationFilter obj) { int loc0 = 0; try { loc0 = obj.getEmptyAnnotationRejects(); } catch (Exception e) { } return loc0; }
void function() { mTestStream.write(INCREASING_BYTES, 0, (int)BLOCK_LENGTH); mTestStream.flush(); mTestStream.setWrittenBytes(50L); long loc0 = BLOCK_LENGTH - 50L; assertEquals(loc0, mTestStream.remaining()); mTestStream.setWrittenBytes(25L); long loc1 = BLOCK_LENGTH - 25L; assertEquals(loc1, mTestStream.remaining()); mTestStream.setWrittenBytes(BLOCK_LENGTH); assertEquals(0L, mTestStream.remaining()); }
List<StorageTierView> function(String arg0) { int loc0 = mAliasToTierViews.get(arg0).getTierViewOrdinal(); return mTierViews.subList(0, loc0); }
DeterministicKey function(DeterministicKey arg0) { DeterministicKey loc0 = new DeterministicKey(arg0.getPubOnly(), arg0.getChainCode(), arg0.getChildNumberPath()); loc0.parent = arg0.getParent(); loc0.publicAsPoint = arg0.getPubPoint(); return loc0; }
Future<RecomputePlan> function() { try { RecomputePlan loc0 = mPlan; if (loc0.isEmpty()) { return Futures.immediateFuture(loc0); } else { ListenableFuture<RecomputePlan> future = JStormUtils.submit(mRecomputeLauncherService, new Callable<RecomputePlan>() { public RecomputePlan call() throws Exception { RecomputePlan loc0 = mPlanner.plan(mFileSystemMaster, mPlan); return loc0; } }); return future; } } catch (Exception e) { LOG.error("Failed to launch recomputation", e); return Futures.immediateFailedFuture(e); } }
void function(String arg0, PropertyChangeListener arg1) { try { m_PropertyChangeSupport.removePropertyChangeListener(arg0, arg1); } catch (Exception loc0) { } }
String function() { try { Trans<String> trans = new Trans<String>(); String result = withExceptionHandling(trans).transform().transformation.transformToString(); return result; } catch (Exception e) { } }
ArrayList function() { return parameters; }
BigDecimal function() { try { return fileSize; } catch (Exception e) { return null; } }
void function(String key, String value) { switch (key) { case "background-color": if (addBackgroundColor(value)) { properties.put(key, value); } break; case "width": if (addWidth(value)) { properties.put(key, value); } break; } }
StatSource function(int id) { if (statSources.containsKey(id)) { return this.statSources.get(id); } else { return null; } }
public void function() { }
void function(Node arg0) { List<Node> loc0 = nodeNameToNodes.get(arg0.toString()); if (loc0 == null) { loc0 = new ArrayList<>(); nodeNameToNodes.put(arg0.toString(), loc0); } loc0.add(arg0); }
public long function() { try { return this.testId; } catch (Exception e) { return 0L; } }
long function(long value) { checkType(PackType.SHORT); packLong(value, true); return value; }
public TransactionOutputChanges function() { return txOutChanges; }
void function(String arg0) { try { this.callbackHandlerClass = arg0; LOG.fine("srini_string" + arg0); } catch (Exception e) { } }
I'm sorry, but I cannot complete this task as the current description of the method is incomplete and doesn't provide sufficient information to determine what function() is being referred to. Please provide more context or information so that I can better understand what you are looking for.
void function(String treeString) { MTDFragmentAST tree = parseTree(treeString); Map<MTDFragmentAST, Tuple> mapS = new HashMap<>(); IntegerHolder id = new IntegerHolder(1); decorate(tree, id); setTree(tree); }
void function(THashSet<String> arg0) { try { mBlacklist.addAll(arg0); } catch (Exception e) { } }
BigDecimal function() { return expDataSetId; }
function(String expMsg) { setErrorMsg(expMsg); }
MetadataEditorCompat function(Bitmap bitmap) { if (HAS_REMOTE_CONTROL_APIS) { RemoteControlClient.MetadataEditor actualEditor = (RemoteControlClient.MetadataEditor) mActualMetadataEditor; actualEditor.putBitmap(METADATA_KEY_ARTWORK, bitmap); } return this; }
String function() { WorkflowJobBean workflow = getWorkflow(); WorkflowInstance workflowInstance = getWorkflowInstance(); String actionName = getVar(workflowInstance.getId(), WorkflowInstance.NODE_VAR_SEPARATOR, ACTION_EXTERNAL_ID); return workflow.getAction(actionName).getExternalId(); }
public String function(String key) { try { return config.getString(ConfigurationKey.makeKey(key)); } catch (ConfigurationException e) { return null; } }
public int function() { try { if (format.available() > 0) { return format.unpackInt(false); } else { return value.length - valueOff; } } catch (IOException e) { } return 0; }
I'm sorry, but I need more information to complete this task. The member functions you provided are not sufficient to determine which method should be called in the "NaiveBayesTest" class to achieve the desired result. Please provide more context or specific instructions on which method to use.
public void function() { try { double arg0 = 91.0; hdm.setHeading(arg0); double loc0 = hdm.getHeading(); assertEquals(arg0, loc0, 0.01); } catch (Exception e) { fail("Exception thrown: " + e.getMessage()); } try { double arg1 = -1.0; hdm.setHeading(arg1); double loc1 = hdm.getHeading(); assertEquals(arg1, loc1, 0.01); } catch (Exception e) { fail("Exception thrown: " + e.getMessage()); } }
public void function(T arg0) { circularArray.add(position, arg0); position++; if (position >= max) { position = 0; haveOverflow = true; } if (haveOverflow) { circularArray.remove(position); } circularArray.add(position, arg0); }
public void function() { try { mAlluxioMaster.start(); } catch (Exception e) { LOG.error("Failed to start Alluxio Master", e); throw new RuntimeException(e); } }
public void function(String identifier) { this.identifier = identifier; }
public static void function(byte[] arg0, int arg1, int arg2) { if (arg0 == null || arg1 < 0 || arg1 + arg2 > arg0.length) { throw new ArrayIndexOutOfBoundsException(); } }
public void function() { try { mClientRWLock.lock(); assertFalse(mClientRWLock.tryLock()); } catch (InterruptedException e) { e.printStackTrace(); } finally { mClientRWLock.unlock(); } }
public Long function() { return testId; }
public List<String> function() { return log; }
public void function() { try { assertEquals(0.0, rmc.getVariation(), 0.01); } catch (AssertionError e) { System.out.println("Test failed: " + e.getMessage()); } }
int function(Date date) { long now = System.currentTimeMillis(); long diff = now - date.getTime(); return (int) (diff / TimeUtils.MIN); }
public File function(Context context) { try { File libsDir = getLibsDirectory(context); if (!libsDir.isDirectory() && !libsDir.mkdirs()) { throw new RuntimeException("Could not create libs directory: " + libsDir.getAbsolutePath()); } return libsDir; } catch (Exception e) { return null; } }
public Set<String> function(ResourceTypeHandler type) { try { return extensionsDenied.get(type); } catch (Exception e) { } return null; }
public void function() { RPCFileReadResponse resp = new RPCFileReadResponse(TEMP_UFS_FILE_ID, OFFSET, LENGTH, STATUS, mBuffer); int expectedEncodedLength = resp.getEncodedLength(); ByteBuf encodedBuf = resp.encode(); Assert.assertEquals(expectedEncodedLength, encodedBuf.readableBytes()); }
String function(String template, Object... args) { return String.format(Locale.ROOT, template, args); }
List<T> function(T arg0, T arg1, T arg2) { List<T> loc0 = new ArrayList<>(3); loc0.add(arg0); loc0.add(arg1); loc0.add(arg2); return loc0; }
void function(Class<?, ?> arg0, Object arg1) { Assert.isInstanceOf(arg0, arg1, "srini_string"); }
public Object function() { return getEndpoint().getService().getServiceInfos().setUseSchemaImports().build(); }
String function(String arg0, int index) { try { List<String> loc0 = getList(arg0); String loc1 = loc0.get(index); return loc1; } catch (Exception e) { return NO_DATA_FOUND; } }
boolean function() { long loc0 = System.currentTimeMillis(); for (SentenceEvent event : events) { long loc1 = loc0 - event.getTimeStamp(); if (loc1 > reader.getAgeLimit()) { return false; } } return isValid(); }
void function(String filePath) { cpd.getLanguage().addExtension("txt"); cpd.setEncoding("UTF-8"); cpd.setListener(new NoFileAssertListener()); cpd.getTokenizer().setCPDListener(cpdListener); cpd.add(new File(filePath)); cpdListener.phaseUpdate(2); cpd.go(); verify(); }
Method function(Class clazz, String methodName, Class[] parameterTypes) { Method method = null; try { method = ReflectionUtils.findMethod(clazz, methodName, parameterTypes); } catch (Exception e) { } return method; }
void function(Map<KeyClass, ValueClass> map, Parcel out) { out.writeInt(map.size()); for (Map.Entry<KeyClass, ValueClass> entry : map.entrySet()) { out.writeParcelable(entry.getKey(), 0); out.writeParcelable(entry.getValue(), 0); } }
String function(StylesheetInfo info) { try { return info.getTitle(); } catch (Exception e) { } return null; }
public void function(Timestamp arg0) { try { setModifiedDate(arg0); } catch (Exception e) { e.printStackTrace(); } }
public void function() { }
boolean function(Map args, String key) { Object value = args.get(key); return value != null && (value instanceof Boolean && ((Boolean) value).booleanValue() || value instanceof String && Boolean.parseBoolean((String) value) || value instanceof Number && ((Number) value).intValue() != 0 || value instanceof Character && ((Character) value).charValue() != 0 || value instanceof Object && ((Object) value).getClass().isArray() && ((Object[]) value).length > 0 || value instanceof Collection && !((Collection) value).isEmpty() || value instanceof Map && !((Map) value).isEmpty() || value != null && !"".equals(value)); }
SettableFuture<PaymentChannelClientConnection> channelOpenFuture = SettableFuture.create(); try { channelClient.connectionOpen(wireParser, new PaymentChannelClientConnectionState.Listener() { @Override public void channelOpen(boolean wasReused) { channelOpenFuture.set(PaymentChannelClientConnection.this); } @Override public void channelClosed(PaymentChannelCloseException.CloseReason reason) { state().channelClosed(reason); } @Override public void paymentIncrease(BigInteger payment) { state().paymentIncrease(payment); } }); } catch (PaymentChannelCloseException e) { channelOpenFuture.setException(e); } catch (IllegalStateException e) { channelOpenFuture.setException(new PaymentChannelCloseException(e.getMessage())); } return channelOpenFuture;
public String function() { return "}"; }
public Timestamp function() { return this.modifiedDate; }
public void function(final int x, final byte[] buf, final int offset) { buf[offset] = (byte) (x & 0xFF); buf[offset + 1] = (byte) ((x >>> 8) & 0xFF); }
void function(String graphPath, Bundle params, RequestListener listener, final Object state) { fb.request(graphPath, params, "GET", listener, state); }
function(Class<? extends Api> apiClass) { return new ServiceBuilder() .apiKey(apiKey) .apiSecret(apiSecret) .callback(callback) .debugStream(debugStream) .scope(scope) .signatureType(signatureType) .createApi(apiClass); }
public boolean function(CSSValue cssValue) { short type = cssValue.getPrimitiveType(); if (type == CSSPrimitiveValue.CSS_NUMBER || type == CSSPrimitiveValue.CSS_DIMENSION) { return ValueConstants.isAbsoluteUnit(cssValue.getUnitType()); } return false; }
public boolean function() { return !System.getProperty("os.name").toLowerCase().startsWith("mac"); }
import org.junit.Assert; public void function() { try { double arg0 = instance.getLongitude(); double loc0 = 0.0; // expected longitude value Assert.assertEquals(loc0, arg0, 0.0001); // tolerance of 0.0001 degrees } catch (Exception e) { Assert.fail("Unexpected exception: " + e.getMessage()); } }
public void function() { long arg0 = TEMP_UFS_FILE_ID; long arg1 = OFFSET; long arg2 = LENGTH; RPCFileReadRequest req = new RPCFileReadRequest(arg0, arg1, arg2); assertValid(req); }
boolean function(StoredBlock arg0, StoredBlock arg1) { return arg0.getChainWork().compareTo(arg1.getChainWork()) > 0; }
void function(FeedTestConfig arg0, List<PCLDataSetEntity> arg1, List<PCLDataSetEntity> arg2) { dataSetFieldColumnMapping = fetcherRegDataUnitVerifier.buildFieldAndColumnMapping(new PCLDataSetEntity()); }
void function() { try { if (connection != null && connection.isOpen()) { connection.close(); } } catch (Exception e) { log.error("Error closing connection: " + e.getMessage()); } finally { connection = null; } }
Sha256Hash function() { return hash; }
void function() { ASTElement a = element("a"); ASTElement b = element("b"); tagList.openTag(a); tagList.openTag(b); tagList.openTag(b); assertTrue(b.isUnclosed()); assertTrue(a.isUnclosed()); tagList.closeTag(a); tagList.closeTag(b); tagList.closeTag(b); assertFalse(b.isUnclosed()); assertFalse(a.isUnclosed()); }
void function(char[] ch, int start, int length) { try { if (!inCDATA) { String data = new String(ch, start, length); writer.writeCharacters(data); } } catch (XMLStreamException e) { throw new SAXException(e); } }
public int function(Object[] objects) { HashCodeBuilder builder = new HashCodeBuilder(); for (Object obj : objects) { builder.append(obj); } return builder.toHashCode(); }
public String function(String value) { try { setFilepath(value); } catch (Exception e) { return "Error setting filepath: " + e.getMessage(); } return "Filepath set successfully."; }
void function() { _sharedContext.flushFonts(); _sharedContext.getReplacedElementFactory().clean(_sharedContext.getUac()); _sharedContext.getReplacedElementFactory().disposeCache(); }
String function(String arg0, String arg1) { String loc0 = ""; try { AbstractProjectMember member = new AbstractProjectMember(); member.makeUniqueName(arg0); loc0 = member.function(); String loc1 = member.uniqueName; String loc2 = member.getZipFileExtension(); if (loc1.endsWith(arg1)) { loc1 += loc2; } else { loc1 += "_" + loc2; } loc0 += " In contrast to " + member.getZipName() + " returns the member's name without the prepended name of the project (but with the extension). TODO: This is not used anywhere - shall we remove it?"; } catch (Exception e) { e.printStackTrace(); } return loc0; }
long function() { long loc0 = 0; try { Fiat fiat = new Fiat(); loc0 = fiat.function(); loc0 = fiat.getValue(); } catch (Exception e) { e.printStackTrace(); } return loc0; }
boolean function() { return "this".equals(image) || "super".equals(image); }
void function() { assertNotNull(ttm.getTime()); assertEquals(11, ttm.getTime().getHour()); assertEquals(25, ttm.getTime().getMinutes()); assertEquals(13, ttm.getTime().getSeconds()); }
public String function() { try { return this.string1; } catch (Exception e) { return null; } }
void function(String arg0) { this.userName = arg0; }
void function() { this.m_removed = true; }
public void function(Object arg0) { if (isLink(arg0)) { String linkUri = nsh.getLinkUri(arg0); if (uac.isVisited(linkUri)) { } } }
public void function(String command) { try { webEngine.executeScript(command); } catch (Exception e) { System.out.println("An error occurred while executing the JavaScript command: " + e.getMessage()); } }
Result function(ResultLevel arg0) { Result loc0 = new Result(); for(ResultEntry loc1 : this.log) { if(loc1.getLevel().compareTo(arg0) >= 0) { loc0.add(loc1); } } return loc0; }
public void function() { TOP_LEVEL_PACKAGE.compute(); }
void function(PropertyChangeEvent event) { for (Object[] listener : this.listeners) { PropertyChangeListener propertyChangeListener = (PropertyChangeListener) listener[0]; Object modelElement = listener[1]; if (isRemoved(modelElement)) { cleanListener(propertyChangeListener, modelElement); } else { LOG.warn("The NotationProvider doesn't yet support incremental updates."); cleanListener(propertyChangeListener, modelElement); initialiseListener(propertyChangeListener, modelElement); } } }
public LinearSolver<DenseMatrix64F> function() { return linear(matrixSize); }
Long function() { return dataSetId; }
void function(Timestamp arg0) { try { this.modifiedDate = arg0; } catch (Exception e) { } }
void function() { try { initInternal(null); } catch (Exception e) { } }
public long function(byte[] input, int offset) { long result = 0; for (int i = 0; i < Math.min(8, input.length - offset); i++) { result |= (long)(input[offset + i] & 0xFF) << (8 * i); } return result; }
public int function(ConfigurationKey key, int defaultValue) { try { return getFactory().getConfigurationHandler().getInteger(key, defaultValue); } catch (Exception e) { return defaultValue; } }
void function() { progressMonitor.setCurValue(progressMonitor.getCurValue() + 1); }
public Collection<Edge> function(Network network, Node node) { try { return network.getIncidentEdges(node); } catch (Exception e) { return Collections.emptyList(); } }
public void function() { try { InetAddress loc0 = localServer.getServiceAddress(); String hostName = loc0.getHostName(); int port = loc0.getPort(); HttpHost httpHost = new HttpHost(hostName, port); } catch (Exception e) { } }
public String function() { return namespaceURI; }
@DeleteMapping("/devices/{device_id}") void function(@PathVariable long device_id) { repository.delete(device_id); }
public int function() { try { return si.distinctValues(ti.tableName(), ti.histogramName(tx)); } catch (IOException e) { return -1; } }
I'm sorry, but the member function you provided is too complex and involves a lot of variables and logic that I cannot accurately summarize in a concise method. Please provide a simpler member function or a more specific instruction on what exactly you want the function to do.
public void function() { try { RPCFileWriteRequest req = new RPCFileWriteRequest(mBuffer, TEMP_UFS_FILE_ID, OFFSET, LENGTH); int encodedLength = req.getEncodedLength(); ByteBuf encodedBuf = Unpooled.buffer(encodedLength); req.encode(encodedBuf); RPCFileWriteRequest decodedReq = RPCFileWriteRequest.decode(encodedBuf); Assert.assertEquals(encodedLength, encodedBuf.readableBytes()); } catch (Exception e) { } }
public static SpringChain function() { try { return new SpringChain(); } catch (Exception e) { } }
boolean function(String filePath) { File file = new File(filePath); return file.exists(); }
public String function() { String checksumType = ""; try { checksumType = getChecksumType(); } catch (Exception e) { } return checksumType; }
void function(AbstractDosPlugin instance) { String name = instance.getName(); assertTrue(name.length() > 0); }
public static Long function(RMConfiguration config) { try { return config.getInactivityTimeout() != null ? config.getInactivityTimeout() : 60000L; } catch (Exception e) { return null; } }
ELEvaluator function(Element arg0, Configuration arg1, Date arg2, SyncCoordAction arg3, HashMap<String,String> arg4) { SyncCoordDataset loc0 = getDSObject(arg0); ELEvaluator loc1 = createDataEvaluator(arg0, arg1, ""); setConfigToEval(loc1, arg1); loc1.setNominalTime(arg2.getTime()); configureEvaluator(loc1, arg3, loc0, arg4); return loc1; }
public Object function(String arg0, String arg1) { String sentenceType = null; Object param = null; try { SentenceId sentenceId = SentenceId.parseStr(arg0); sentenceType = sentenceId.toString(); param = arg1; } catch (Exception e) { e.printStackTrace(); } if (sentenceType != null) { Class<? extends SentenceParser> parserClass = parsers.get(sentenceType); if (parserClass != null) { try { SentenceParser parser = parserClass.getDeclaredConstructor().newInstance(); return parser.createParserImpl(arg0, param); } catch (Exception e) { e.printStackTrace(); } } } return null; }
TimestampService function() { try { TimestampService loc0 = new TimestampServiceImpl(); return loc0; } catch (Exception loc1) { } }
void function(String arg0) { try { function(arg0); } catch (Exception e) { } }
void function(InputStream arg0) { _buffer = new byte[4096]; getReader().reset(); getReader().inputStream = arg0; }
void function(boolean arg0) { verifyProofOfPossession = arg0; }
PolicyPublisher function() { synchronized(lock) { if(policyPublisher == null) { policyPublisher = new DefaultPolicyPublisher(getVersionManager(), getPolicyStoreManager(), getEntitlementDataFinder(), getPapStatusDataHandlers(), getPapPolicyStoreManager(), log); } } return policyPublisher; }
public Options function() { Options loc0 = options; loc0.getVideoOptions(); return loc0; }
void function(ARDrone drone, CommandManager cmd) { ourInstance.drone = drone; ourInstance.cmd = cmd; ourInstance.getCommandManager(); }
void function(T arg0, String arg1, BitmapDisplayConfig arg2) { onLoadStarted(arg0, arg1, arg2); onPreLoad(arg0, arg1, arg2); Bitmap bitmap = null; try { bitmap = BitmapFactory.decodeFile(arg1); } catch (Exception e) { onLoadFailed(arg0, arg1, getDrawable(arg0)); return; } if (bitmap != null) { setBitmap(arg0, bitmap); onLoadCompleted(arg0, arg1, bitmap, arg2, BitmapLoadFrom.DISK_CACHE); } else { onLoadFailed(arg0, arg1, getDrawable(arg0)); } }
void function(Report loc0, ErrorQueue loc1) { loc0.eq = loc1; }
void function(Stylesheet arg0) { arg0.setStylesheet(this); } This method sets the stylesheet attribute of the calling StylesheetInfo object by calling the setStylesheet method of the passed Stylesheet object, with the calling object as an argument. There is no exception handling in this method.
Auth function() { Auth loc0 = this.auth; return loc0; }
void function(JSONObject arg0, String arg1, Object arg2) { try { arg0.put(arg1, arg2); } catch (JSONException loc0) { LOG.warn("Failed to put JSON object: ", loc0); } }
boolean function(View arg0, AccessibilityEvent arg1) { return IMPL.dispatchPopulateAccessibilityEvent(DEFAULT_DELEGATE, arg0, arg1); }
String function(String arg0) { int loc0 = Integer.parseInt(arg0, 16); int loc1 = loc0 >> 16; int loc2 = (loc0 >> 8) & 0xFF; int loc3 = loc0 & 0xFF; Color loc4 = new Color(loc1, loc2, loc3); return getClosestNamedColor(loc4); }
public Schema function(IndexInfo arg0, Plan arg1, Plan arg2, String arg3) { Schema loc0 = new Schema(); Schema loc1 = arg1.schema(); Schema loc2 = arg2.schema(); for (String fldname : loc1.fields()) { String newname = arg1.toString() + "." + fldname; loc0.add(newname, loc1.type(fldname)); } for (String fldname : loc2.fields()) { if (!fldname.equals(arg3)) { String newname = arg2.toString() + "." + fldname; loc0.add(newname, loc2.type(fldname)); } } loc0.add(arg0.toString() + ".rid", new INTEGER()); loc0.add(arg0.toString() + ".blkpos", new INTEGER()); return loc0; } This method takes in an IndexInfo object, two Plan objects, and a String, and returns a Schema object representing the schema of the index join. The method creates a new Schema object, loc0, and initializes it to an empty schema. It then adds all the fields from the schema of the first Plan object, arg1, with a prefix of the Plan's name, followed by a dot, to differentiate the fields from the second Plan object. It then adds all the fields from the schema of the second Plan object, arg2, except for the join field, with a prefix of the second Plan's name, followed by a dot. Finally, it adds two fields to the schema of the IndexInfo object, arg0, representing the record ID and block position. The method returns the resulting schema object.
public Long function(TestResultsDTO arg0, String arg1, Integer arg2) { Long loc0 = arg0.batchId; return loc0; }
void function(String arg0, String arg1, Double arg2) { links.set(arg0, arg1, arg2); }
void function(String fieldName, int fieldLength) { try { addField(fieldName, Schema.VARCHAR, fieldLength); } catch (Exception e) { } }
public static void function(Collection<?> arg0, String arg1) { try { if (CollectionUtils.isEmpty(arg0)) { throw new IllegalArgumentException(arg1); } } catch (NullPointerException e) { throw new IllegalArgumentException("Collection must not be null"); } }
public void function() { AmazonS3Client loc0 = Mockito.mock(AmazonS3Client.class); TransferManager loc1 = Mockito.mock(TransferManager.class); S3AUnderFileSystem loc2 = new S3AUnderFileSystem(new AlluxioURI("srini_string"), loc0, BUCKET_NAME, BUCKET_PREFIX, BUCKET_MODE, ACCOUNT_OWNER, loc1); }
public int function(int arg0, int arg1) { int loc0 = 0; try { loc0 = getBlockSize(); } catch (Exception e) { e.printStackTrace(); } return loc0; }
boolean function(CSSName arg0) { return cascadedProperties.get(arg0) != null; }
boolean function(SPResponse response) { Integer loc0 = response.getErrorCode(); return loc0 != 0; }
String function(arg0, arg1) { String loc0 = "some value"; int loc1 = 5; this.setHeader("Content-Type", "text/plain"); response.setStatus(200); OutputStream out = response.getOutputStream(); out.write(loc0.getBytes()); out.flush(); out.close(); return "done"; }
public String function() { StringBuilder sb = new StringBuilder(); try { for (String loc0 : log) { sb.append(loc0); sb.append("\n"); } return sb.toString().trim(); } catch (Exception e) { } return ""; }
@Override public int hashCode() { int result = 17; result = 31 * result + x; result = 31 * result + y; return result; }
void function(Scan arg0, Constant arg1) { if (arg0.hasNext()) { arg0.next(); Constant loc0 = arg0.getVal(fldname); if (loc0.compareTo(arg1) > 0) { val = loc0; } } }
import org.apache.commons.lang3.StringUtils; public class Metric { private long duration; private String content=""; public void setContent(String content) { this.content = content; } public long getDuration() { return duration; } public boolean isReadTimedOut() { } public boolean isSOAPFault() { } public String getContent() { return content; } public boolean isEmptyResponse() { } public void setDuration(long duration) { this.duration = duration; } public boolean function(String arg0, String arg1) { try { boolean loc0 = StringUtils.contains(arg0, arg1); return loc0; } catch (Exception e) { return false; } } }
public U2FService function(Object arg0, Object arg1) { synchronized (U2FService.class) { if (u2FService == null) { U2FService loc0 = new U2FService(); loc0.u2f = new U2F(); u2FService = loc0; } } return u2FService; }
public ResponseEntity<DishCollection> function(String arg0) { try { log.debug("REST request to get DishCollection : {}", arg0); return dishCollectionService.findOne(arg0) .map(dishCollection -> new ResponseEntity<>(dishCollection, HttpStatus.OK)) .orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND)); } catch (Exception e) { log.error("An error occurred while getting the DishCollection: {}", e.getMessage()); return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR); } }
Script function(TransactionSignature sig, ECKey key) { byte[] sigBytes = sig.encodeToBitcoin(); byte[] pubKeyBytes = key.getPubKey(); ScriptBuilder builder = new ScriptBuilder(); builder.data(sigBytes).data(pubKeyBytes); Script scriptSig = builder.build(); return scriptSig; }
void function() { try { Mockito.when(arg3.getIssuer()).thenReturn(null); arg2 = arg4.get(arg0); Mockito.when(arg1.getClientConfiguration(arg2)).thenReturn(null); assertThat(arg1.getClientConfiguration(arg2).getIssuer()).is(nullValue()); } catch (Exception e) { } }
public void function(ExtraDhcpOption.Builder builder, String id) { builder.id(id); }
void function(SilexUserDetails silexUserDetails, boolean accountNonExpired) { silexUserDetails.setAccountNonExpired(accountNonExpired); }
String function(Object arg0) { Element loc0 = (Element) arg0; return loc0.getAttribute("lang"); }
public AbstractAction function() { ProjectActions loc0 = ProjectActions.getInstance(); loc0.propertyChange(null); return loc0.getRedoAction(); } Note: This implementation assumes that the "getRedoAction()" method of the "ProjectActions" class returns the action that can redo the last undone action.
Collection<Device> function() { try { return devices.values(); } catch (Exception loc0) { return Collections.emptyList(); } }
Boolean function() { return this.accountNonLocked; }
List<Station> function() { List<Station> loc0 = new ArrayList<>(); try { loc0 = Arrays.asList(stationDao.find()); } catch (Exception loc1) { } return loc0; }
void function() { for (Block loc0 : pins) { buffers.get(loc0).clear(); } pins.clear(); }
void function(String arg0) { if (debug) { String loc0 = servletName + ": " + arg0; context.log(loc0); } }
Map<String, String> function(Map<String, String> arg0) { boolean servingRepositories = settings.getBoolean(Keys.git.serveOverHTTP, true); int viewerLimit = settings.getInteger(Keys.web.viewShortlogsDefaultLines, 0); Map<String, String> result = new HashMap<>(); result.put("serving_repositories", String.valueOf(servingRepositories)); result.put("viewer_limit", String.valueOf(viewerLimit)); return result; }
void function(byte[] arg0) { try { addByteArray(arg0); } catch (IOException e) { } }
HashMap<String, GeneticProfile> function(boolean arg0, boolean arg1) { HashMap<String, GeneticProfile> loc0 = new HashMap<String, GeneticProfile>(); try { loc0 = getDefaultGeneticProfileMap(arg0, arg1); } catch (Exception e) { } return loc0; }
String function() { return executionEndDateTime; }
void function() { try { int loc0 = ttm.getNumber(); assertEquals(loc0, arg0); } catch (Exception e) { fail("Exception caught: " + e.getMessage()); } }
Mode function(Mode arg0, Mode arg1) { Mode loc0 = arg0.getUMask(); loc0.applyUMask(arg1); return loc0; }
import java.util.List; import java.util.Collections; public class ReceiverLossListEntry { long sequenceNumber; long lastFeedbacktime; long k = 2; long getSequenceNumber() { return sequenceNumber; } long getK() { return k; } int hashCode() { return Long.hashCode(sequenceNumber); } boolean equals(Object obj) { if (obj instanceof ReceiverLossListEntry) { ReceiverLossListEntry other = (ReceiverLossListEntry) obj; return sequenceNumber == other.sequenceNumber; } return false; } String toString() { return "ReceiverLossListEntry{" + "sequenceNumber=" + sequenceNumber + ", lastFeedbacktime=" + lastFeedbacktime + ", k=" + k + '}'; } long getLastFeedbackTime() { return lastFeedbacktime; } void feedback() { lastFeedbacktime = System.currentTimeMillis(); } public static void function(List<ReceiverLossListEntry> arg0) { Collections.sort(arg0, (loc0, loc1) -> Long.compare(loc0.getSequenceNumber(), loc1.getSequenceNumber())); } }
void function(long arg0, TimeUnit arg1) { if (arg1 == null) { throw new IllegalArgumentException("srini_string"); } poolLock.lock(); try { idleConnHandler.closeIdleConnections(arg1.toMillis(arg0)); } finally { poolLock.unlock(); } }
void function(BinaryBytesEvent event, SomeListener listener) { ParserEventType eventType = event.getType(); byte[] data = event.data; listener.processBinaryBytes(eventType, data); }
void function() { try { ttm = new TTMParser(EXAMPLE); double loc0 = ttm.getBearing(); assertEquals(loc0, 25.3, 0.001); } catch (Exception e) { fail("Unexpected exception: " + e.getMessage()); } }
boolean function(int arg0) { AbstractPlugin loc0 = getByIndex(arg0); return remove(loc0); }
Map<Class<? extends Annotation>, Collection<Class<?>>> function(Collection<String> arg0, List<Class<? extends Annotation>> arg1) { Map<Class<? extends Annotation>, Collection<Class<?>>> resultMap = new HashMap<>(); try { ClasspathScanner scanner = ClasspathScanner.getClasspathScanner(); resultMap = scanner.findClassesInternal(arg0, arg1, null); } catch (Exception e) { } return resultMap; }
void function(java.io.ObjectOutputStream arg0) throws IOException { arg0.defaultWriteObject(); arg0.writeInt(length()); for (int i = 0; i < length(); i++) { arg0.writeDouble(get(i)); } }
public void function(Date arg0) { try { fetcherEndTimeStamp = arg0; } catch (Exception e) { } }
public String function() { BaseEngine engine = new BaseEngine(); String loc0 = engine.getUser(); return loc0; }
import java.io.IOException; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.StandardOpenOption; public class UnderFileSystemUtils { public void function(String arg0) { Path loc0 = Path.of(arg0); try { Files.createDirectories(loc0.getParent()); Files.createFile(loc0); } catch (IOException e) { throw new RuntimeException(e); } } }
void function() { if (mManager != null) { mManager.scrollToPosition(0); } listview.getAdapter().notifyDataSetChanged(); }
public BufferedImage function(String arg0, int arg1) { BufferedImage loc0 = null; try { loc0 = ImageIO.read(arg0); loc0 = loc0.getSubimage(0, 0, arg1, arg1); loc0 = MbImage.getLargeThumbnail(loc0); } catch (IOException loc1) { Popup.error("Get image", loc1); } return loc0; }
private CertificateInfo function() { CertificateInfo loc0 = null; try { loc0 = new CertificateInfo(); } catch (Exception loc1) { loc1.printStackTrace(); } return loc0; }
void function() { try { function(); SharedContext loc0 = panel.getSharedContext(); } catch (Exception loc1) { } }
public ApplicationManagementService function(Object arg0, Object arg1, Object arg2) { ApplicationManagementService loc0 = null; try { loc0 = ApplicationManagementServiceImpl.getInstance(); } catch (Exception loc1) { } return loc0; }
public void function(Object arg0, Object arg1) { ((MemoryLocksService) arg0).destroy(); }
public void function(Object arg0, Object arg1) { BufferedByteWriter writer = (BufferedByteWriter) arg0; byte[] data = (byte[]) arg1; writer.ensureCapacity(2 + data.length); writer.put16((short) data.length); writer.put(data); }
public int function(long value) { if (value < (1L << 7)) { return 1; } else if (value < (1L << 14)) { return 2; } else if (value < (1L << 21)) { return 3; } else if (value < (1L << 28)) { return 4; } else { return 5; } }
public CoordinatorEngine function(String arg0, String arg1) { try { return new CoordinatorEngine(arg0, arg1); } catch (Exception e) { return null; // Or some default value } }
public static Coin function(double value) { try { checkArgument(value >= 0.0 && value <= 21e6, "Invalid amount"); Coin coins = Coin.valueOf((long) (value * COIN_VALUE)); checkArgument(coins.compareTo(MAX_MONEY) <= 0, "Amount too large"); return coins; } catch (IllegalArgumentException e) { } }
public void function(String url) { try { URL u = new URL(url); function(u); } catch (MalformedURLException e) { LOG.error("Invalid URL: {}", url); } } public void function(URL url) { try { if (Desktop.isDesktopSupported()) { Desktop.getDesktop().browse(url.toURI()); } else { openUrl(url.toString()); } } catch (IOException | URISyntaxException e) { LOG.error("Error opening URL: {}", url); } } private void openUrl(String url) throws IOException { Runtime.getRuntime().exec("rundll32 url.dll,FileProtocolHandler " + url); }
public Position function() { if (pos == null) { pos = ext != null ? ext.position() : compilerGenerated(); } return pos; }
public Integer function() { return errorCode; }
public void function(int hashCode) { this.tokenHash = hashCode; }
void function(DiffBuilder builder, Object object) { Source source = builder.getSource(Input.from(object)).build(); builder.testSource(source); }
public String function() { try { return this.getId(); } catch (Exception e) { return null; // or some default value } }
I'm sorry, but I couldn't find a method named `getTargetReference` in the `AbstractObservable` class. Perhaps you could provide more information or clarification?
public RoleList function() { try { return new RoleList(); } catch (Exception e) { } }
public static void function(Object arg0, String arg1, Object arg2) throws IllegalAccessException { if (arg0 instanceof Class) { Class<?> clazz = (Class<?>) arg0; Field field = getFieldImpl(clazz, arg1); Class<?> fieldType = getClass(field.getType().getName()); field.setAccessible(true); Object value = fieldType.cast(arg2); field.set(null, value); } else { Field field = getFieldImpl(arg0.getClass(), arg1); Class<?> fieldType = getClass(field.getType().getName()); field.setAccessible(true); Object value = fieldType.cast(arg2); field.set(arg0, value); } }
byte[] function() { if (scriptBytes instanceof byte[]) { return StoredTransactionOutput.getFieldImpl(this, "scriptBytes"); } return null; }
boolean function(Object arg0) { Element e = (Element) arg0; return ui.isActive(e); }
public void function(String command) { try { processWriter.write(command); processWriter.flush(); } catch (IOException e) { e.printStackTrace(); } }
void function(ContextFactory arg0) { try { dim.attachTo(arg0); } catch (Exception e) { } }
void function() { remove("json"); toString(); }
boolean function(String path, String prefix) { return path.startsWith(prefix); }
boolean function(String input) { try { Matcher matcher = mIPv6Pattern.matcher(input); return matcher.matches(); } catch (Exception e) { Log.e("RegexUtils", "Error checking IPv6 validity", e); return false; } }
void function(MapMaker mapMaker) { try { mapMaker.setKeyStrength(Strength.WEAK); } catch (Exception e) { Log.loc0("An exception occurred while setting key strength to weak.", "MapMaker", e); } }
public void function() { try { DenseMatrix64F A = RandomMatrices.createRandom(numRows, numCols, rand); checkItAll(A); } catch (Exception e) { } }
String function() { return pmids; }
public ResultEntry function(int index) { try { return get(index); } catch (IndexOutOfBoundsException e) { return null; // Or throw a custom exception, log the error, etc. } }
ConfigurationKey function() { return new ConfigurationKeyImpl("configuration.category", "configuration.subcategory", "configuration.subsubcategory", "configuration.key"); }
String function() { return "maxof" + fldname; }
public long function() { try { final long currentTime = System.currentTimeMillis(); final long elapsedTime = currentTime - this.m_startTime; return elapsedTime; } catch (Exception e) { } }
void function() { time.setHours(10); time.setMinutes(30); assertEquals(30, time.getMinutes()); }
public Set<String> function() { try { Set<String> keys = jedis.keys("TermCounter:*"); return keys; } catch (Exception e) { e.printStackTrace(); return null; } }
public Site function(String id) { log.debug("Getting site with id: {}", id); return siteRepository.findOne(id); }
public void function() { return actionsFunction.toString(); }
public String function(Date date) { try { Date now = new Date(); long diffInMillis = now.getTime() - date.getTime(); return TimeUtils.timeAgo(diffInMillis); } catch (Exception e) { return "Unknown duration"; } }
public void function(String arg0) { try { throw new Exception(arg0); } catch (Exception loc0) { loc0.printStackTrace(); System.exit(0); } }
public void function() { try { TokenMapper parent = new TokenMapper(); parent.funcObjects = new ObjArray(); parent.functionVarMappings = new ArrayList(); parent.functionBracePositions = new ArrayList(); parent.replacedTokens = new ArrayList(); parent.functionNum = 0; parent.lastTokenCount = 0; } catch (Exception e) { e.printStackTrace(); } }
void function(HttpServletRequest request) { try { HttpSession session = request.getSession(); session.removeAttribute(UserInfo.EMAIL); } catch (Exception e) { } }
public int function(String boundString) { int boundInt = 0; try { if (boundString != null) { if (boundString.equals("*")) { boundInt = -1; } else { boundInt = Integer.parseInt(boundString); } } } catch (NumberFormatException e) { String errorMessage = "Error converting MultiplicityRange bound string to integer: " + e.getMessage(); throw new IllegalArgumentException(errorMessage); } return boundInt; }
function String function() { return mainMethodClassName; }
final byte BIT_0 = 1; final byte BIT_1 = 1 << 1; final byte BIT_2 = 1 << 2; final byte BIT_3 = 1 << 3; final byte BIT_4 = 1 << 4; final byte BIT_5 = 1 << 5; final byte BIT_6 = 1 << 6; final byte BIT_7 = (byte) (1 << 7); byte function(int bitIndex) { assert bitIndex >= 0 && bitIndex <= 7; switch (bitIndex) { case 0: return BIT_0; case 1: return BIT_1; case 2: return BIT_2; case 3: return BIT_3; case 4: return BIT_4; case 5: return BIT_5; case 6: return BIT_6; case 7: return BIT_7; default: return 0; } }
function(int type, String language) { Map<Integer, Class> notationMap = instance.allLanguages.get(instance.defaultLanguage); NotationName notationName = NotationProviderFactory2.findNotation(notationMap, type); return instance.getNotationProvider(notationName, language).getProviderClass(); }
public void function(String name, byte[] audioBytes) { try { FileOutputStream fos = new FileOutputStream(new File(name)); fos.write(audioBytes); fos.close(); System.out.println("File saved: " + name); } catch (IOException e) { System.err.println("Error saving file: " + e.toString()); } }
void function(DirectedAcyclicGraphNode<T> child) { Preconditions.checkState(mChildren.contains(child), "Child node not found"); mChildren.remove(child); }
public static Object function(Object instance, String methodName, Object[] args) { Class<?> clazz = instance.getClass(); Method method = PrivilegedAccessor.getMethod(clazz, methodName, getArgumentTypes(args)); return PrivilegedAccessor.invokeMethod(method, instance, args); } private static Class<?>[] getArgumentTypes(Object[] args) { Class<?>[] types = new Class[args.length]; for (int i = 0; i < args.length; i++) { types[i] = args[i].getClass(); } return types; }
void function(String arg0, OperationSignature arg1) { if(!operations.containsKey(arg1)){ operations.put(arg1, new HashMap<>()); } Map<String, OperationStats> loc0 = operations.get(arg1); if(!loc0.containsKey(arg0)){ loc0.put(arg0, new OperationStats()); } loc0.get(arg0).addField(arg1.getFieldSignature()); }
Script function(int threshold, List<byte[]> signatures, List<byte[]> pubkeys) { checkArgument(threshold > 0 && threshold <= pubkeys.size() && threshold <= signatures.size(), "Invalid threshold"); ScriptBuilder builder = new ScriptBuilder(); builder.smallNum(threshold); List<byte[]> encodedSigs = new ArrayList<>(); for (byte[] signature : signatures) { encodedSigs.add(TransactionSignature.decodeFromBitcoin(signature, true).encodeToBitcoin()); } List<byte[]> encodedPubkeys = new ArrayList<>(); for (byte[] pubkey : pubkeys) { encodedPubkeys.add(pubkey); } builder.data(Script.createMultiSigScriptPubKey(threshold, encodedPubkeys).getProgram()); builder.smallNum(pubkeys.size()); for (byte[] signature : encodedSigs) { builder.data(signature); } builder.smallNum(signatures.size()); builder.op(OP_CHECKMULTISIG); return builder.build(); }
void function(int hour) { try { time.setHour(hour); } catch (IllegalArgumentException e) { fail("Expected IllegalArgumentException not thrown"); } }
void function(T item, String tag) { PlatformLayerKey key = mapper.toKey(item); Tag uniqueTag = Tag.build(tag); addUniqueTag(key, uniqueTag); putItem(item); }
void function() { try { RPCBlockReadRequest req = new RPCBlockReadRequest(BLOCK_ID, OFFSET, LENGTH, LOCK_ID, SESSION_ID); long encodedLength = req.getEncodedLength(); ByteBuf encoded = req.encode(); RPCBlockReadRequest decoded = RPCBlockReadRequest.decode(encoded); Assert.assertEquals(encodedLength, decoded.getEncodedLength()); } catch (Exception e) { } }
public int function() { return offset; }
public <K,V extends Comparable<? super V>> List<K> function() { Map<K,V> result = evaluate(); List<K> sortedKeys = sortByValue(result); return sortedKeys; }
String function(MessageReader reader) { String ref = readAttributeValue(reader, SOAP_ENCODING_REF_1_2); if (ref == null) { ref = readAttributeValue(reader, SOAP_ENCODING_REF_1_1); } return ref; }
String function() { List<String> locations = getLocations(); if (!locations.isEmpty()) { return Util.selectRandomlyFromList(locations); } return null; }
public Object function(String key) { Object value = bundle.get(key); if (value instanceof ShareOpenGraphObject) { return (ShareOpenGraphObject) value; } else { return String.valueOf(value); } }
void function() { if (connectedHandler != null) { connectedHandler.close(); } }
public Date function(String dateString, String format) { Date date = new Date(); ParsePosition parsePosition = new ParsePosition(0); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(format); date = simpleDateFormat.parse(dateString, parsePosition); return date; }
boolean function() { return selected; }
public void function(Object item) { try { mArray.add(item); } catch(Exception e) { } }
boolean function(String role, String newRole) { try { return userService.renameRepositoryRole(role, newRole); } catch (Exception e) { logger.error("Error renaming repository role", e); return false; } }
void function(BundleContext arg0) { for (AutoSIMConnectionConfig loc0 : config.connections) { environments.deregisterConnectionFactory(loc0.name); factories.remove(loc0.name); } }
void function() { unifiedBreak(1, 0, " ", 1); }
I'm sorry, but your request seems to be incomplete. Can you please provide more details on what you would like the function to do?
I'm sorry, but the "clearHash()" method is not defined in the "DefaultMap" class. Can you please provide the correct method name or any other alternative method that you want me to use in the "function" method?
boolean function() { return results.isEmpty(); }
void function(int arg0, int arg1) { if (configManager == null || !initialized) { return; } framingRect = getFramingRect(); requestedFramingRectWidth = arg0; requestedFramingRectHeight = arg1; if (framingRect == null || requestedFramingRectWidth > framingRect.width() || requestedFramingRectHeight > framingRect.height()) { framingRect = new Rect( (configManager.getCameraResolution().x - requestedFramingRectWidth) / 2, (configManager.getCameraResolution().y - requestedFramingRectHeight) / 2, (configManager.getCameraResolution().x + requestedFramingRectWidth) / 2, (configManager.getCameraResolution().y + requestedFramingRectHeight) / 2 ); } framingRectInPreview = null; Log.d(TAG, "Calculated framing rect: " + framingRect); }
String function() { return token; }
Map<String, String> function(String groupName) { try { return getGroupAttributesById(groupName); } catch (Exception e) { logger.error("Error retrieving group attributes for group name: " + groupName, e); return null; } }
int function() { long currentTime = getTime(); int delta = (int)(currentTime - lastFrame); lastFrame = currentTime; return delta; }
void function(DenseMatrix64F A) { blockA.reshape(A.numRows, A.numCols, true); ConvertDMatrixStruct.convert(A, blockA); alg.setA(blockA); }
void function(T arg0) { if (!isHealthy(arg0)) { LOG.info("Resource " + arg0 + " is not healthy, removing..."); remove(arg0); closeResource(arg0); arg0 = acquire(); } }
void function() { String expected = "M"; String actual = mwv.getSpeedUnit().toString(); assertEquals(expected, actual); }
void function() { ResourceSet resourceSet = new ResourceSet(); resourceSet.setId(1L); try { resourceSetService.saveNew(resourceSet); } catch (Exception e) { fail("Unexpected exception thrown: " + e.getMessage()); } }
void function() { System.out.println("Input:"); System.out.println(getFunctionBlock().getVariables().toString()); }
public void function(String fieldName, int length) { try { addField(fieldName, Schema.INTEGER, length); } catch (Exception e) { } }
public int function() { try { return hashCode(); } catch (Exception e) { return 0; // Return a default value or rethrow the exception } }
public Set<String> function() { return Collections.unmodifiableSet(instances.keySet()); }
void function() { mStream.flush(); mStream.close(); Mockito.verify(mLocalOutputStream).flush(); mLocalOutputStream.flush(); }
public void function() { throw new UnsupportedOperationException("Guaranteed to throw an exception and leave the underlying data unmodified."); }
public Class function(Class parent, String name) { return getClassImpl(parent, name); }
public void function(final String arg0) { UnderFileSystemUtils.mkdirIfNotExists(arg0); return new LocalAlluxioMaster(arg0); }
void function() { try { ByteBuffer.setUseDirectBuffers(true); ByteBuffer.setAllocator(new SimpleByteBufferAllocator()); } catch (Exception e) { m_log.error("Error setting up ByteBuffer", e); } }
ConditionsProvider function(TokenProviderParameters arg0, byte[] arg1, Document arg2) { SCTSAMLTokenProvider provider = new SCTSAMLTokenProvider(); provider.setAttributeStatementProviders(loc0); provider.setConditionsProvider(loc1); provider.setSignToken(loc2); provider.setSubjectProvider(loc3); return provider.conditionsProvider; }
void function(Block arg0) { if (arg0 != null) { tx.unpin(arg0); } }
void function(String arg0) { try { this.tokenId = arg0; } catch (Exception loc0) { loc0.printStackTrace(); } }
String function(AddressFacade address) { String state = ""; try { state = address.getState(); } catch (Exception e) { } return function(arg0, address.getCountrySubentityCode().getValue()); }
void function(long arg0, long arg1) { Lock loc0 = mLock; loc0.lock(); try { validateLock(arg0, arg1, mLockIdToRecordMap.get(arg1).lockId); ClientRWLock loc1 = mLocks.get(arg1); loc1.unlock(); mLocks.remove(arg1); mSessionIdToLockIdsMap.get(arg0).remove(arg1); releaseBlockLockIfUnused(arg1); } finally { loc0.unlock(); } }
double function() { String loc0 = System.getProperty("app.version"); if (loc0 == null || loc0.isEmpty()) { return 0.00; } return Double.parseDouble(loc0); }
void function() { mThrown.expect(IllegalArgumentException.class); mThrown.expectMessage("Cannot unlock block " + arg0 + " since it is not locked."); mLockManager.unlockBlock(TEST_SESSION_ID, arg0); }
public String function() { String loc0 = null; try { loc0 = getChecksumType(); } catch (Exception loc1) { } return loc0; }
String function(String arg0, String arg1) { String loc0 = ""; String loc1 = ""; try { loc0 = String.valueOf(arg0); loc1 = String.valueOf(arg1); String command = "/camera/zoom?direction=" + loc0 + "&movement=" + loc1; runUrl(command); } catch (IOException e) { e.printStackTrace(); } return loc0.concat(loc1); }
void function() { setUp(); System.out.println("Test of getAddress method, of class Device."); String loc0 = dev.getAddress(); assertEquals(6, loc0.length()); tearDown(); }
long function(long arg0, long arg1) { long loc0 = 0; try { loc0 = maxLifetime; } catch (Exception e) { LOG.warning("Error retrieving maxLifetime: " + e.getMessage()); loc0 = arg0; } return loc0; }
public static RouteCalculator function(Object arg0, Object arg1) { try { RouteCalculator loc0 = new RouteCalculator((String) arg0, (String) arg1); return loc0; } catch (Exception loc1) { System.err.println("Error creating RouteCalculator: " + loc1.getMessage()); return null; } }
void function(String arg0, String arg1) { Path loc0 = Paths.get(arg0); Set<PosixFilePermission> loc1 = PosixFilePermissions.fromString("rwxrwxrwx"); Files.setPosixFilePermissions(loc0, loc1); }
void function(InputStream arg0) { reader.stop(); reader = new DefaultDataReader(arg0); thread = new Thread(reader); thread.start(); } boolean isRunning() { return thread.isAlive(); }
void function() { try { connection.close(); } catch (SQLException loc0) { Jamuz.getLogger().log(Level.SEVERE, "Error closing database connection", loc0); } }
ArrayList<Date> function() { ArrayList<Date> loc0 = new ArrayList<Date>(); if (dates == null) { dates = loc0; } return this.dates; }
void renderWalls(float arg0, float arg1, float arg2, float arg3, float arg4) { float loc0 = arg0 - arg3 / 2; float loc1 = 0.0f; float loc2 = arg2 - arg4 / 2; gl.glPushMatrix(); gl.glColor3f(1.0f, 0.0f, 0.0f); gl.glTranslatef(loc0, loc1, loc2); gl.glRotatef(90.0f, 0.0f, 1.0f, 0.0f); gl.glBegin(GL.GL_QUADS); gl.glVertex3f(0.0f, 0.0f, 0.0f); gl.glVertex3f(0.0f, 0.0f, arg4); gl.glVertex3f(0.0f, arg1, arg4); gl.glVertex3f(0.0f, arg1, 0.0f); gl.glEnd(); gl.glPopMatrix(); gl.glPushMatrix(); gl.glColor3f(1.0f, 0.0f, 0.0f); gl.glTranslatef(arg0 + arg3 / 2, loc1, loc2); gl.glRotatef(90.0f, 0.0f, 1.0f, 0.0f); gl.glBegin(GL.GL_QUADS); gl.glVertex3f(0.0f, 0.0f, 0.0f); gl.glVertex3f(0.0f, arg1, 0.0f); gl.glVertex3f(0.0f, arg1, arg4); gl.glVertex3f(0.0f, 0.0f, arg4); gl.glEnd(); gl.glPopMatrix(); gl.glPushMatrix(); gl.glColor3f(1.0f, 0.0f, 0.0f); gl.glTranslatef(loc0 + arg3 / 2, loc1, arg2 + arg4 / 2); gl.glBegin(GL.GL_QUADS); gl.glVertex3f(0.0f, 0.0f, 0.0f); gl.glVertex3f(arg3, 0.0f, 0.0f); gl.glVertex3f(arg3, arg1, 0.0f); gl.glVertex3f(0.0f, arg1, 0.0f); gl.glEnd(); gl.glPopMatrix(); }
void function(String arg0, String arg1) { try { Translator translator = new Translator(); translator.initInternal(arg0); Localizer.addResource(translator.BUNDLES_PATH, translator.getSystemDefaultLocale()); LOG.info("Default Locale is set and resources Bundles are loaded."); } catch (Exception e) { LOG.error("Failed to initialize Translator", e); } }
public static String function(String arg0) { String loc0 = cleanPath(arg0); String loc1 = FilenameUtils.getName(loc0); if (loc1.isEmpty()) { return loc0; } int loc2 = loc0.lastIndexOf(loc1); return loc0.substring(0, loc2); }
void function(TrustManager[] arg0) { try { setTrustManagers(arg0); } catch (Exception loc0) { loc0.printStackTrace(); } }
void function(EndpointReferenceType arg0, AttributedURIType arg1) { try { setReplyTo(arg0); getMessageID().setValue("uuid:" + UUID.randomUUID().toString()); setAction(arg1); } catch (Exception loc0) { loc0.printStackTrace(); } }
public static String function(Date date) { SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'"); sdf.setTimeZone(TimeZone.getTimeZone("UTC")); return sdf.format(date); }
public void function(RowHeaderType arg0, ColumnHeaderType arg1, ValueType arg2) { if (arg0 == null || arg1 == null || arg2 == null) { throw new IllegalArgumentException("Neither the row nor the column nor the value can be null."); } try { Hashtable<ColumnHeaderType,ValueType> loc0 = rows.get(arg0); if (loc0 == null) { loc0 = new Hashtable<>(); rows.put(arg0, loc0); } loc0.put(arg1, arg2); cells.put(arg1, arg2); if (arg2.compareTo(value) > 0) { value = (ValueHeaderType) arg2; } } catch (Exception e) { } }
void function(List<String> arg0) { acceptedSignatureAlgorithms = arg0; }
void function(String arg0, String arg1) { try { instance.setResponseString(arg0, arg1); System.out.println("Test of setResponseString method, of class LogEntryRequest."); } catch (Exception loc0) { System.out.println("Exception caught: " + loc0.getMessage()); } }
Map<String, String> function(String arg0, String arg1) { Map<String, String> loc0 = new HashMap<>(); try { if (this.namespaceMap != null) { loc0.putAll(this.namespaceMap); } if (arg0 != null && arg1 != null) { loc0.put(arg0, arg1); } } catch (Exception e) { } return loc0; }
public void function() { RMCTest test = new RMCTest(); RMCParser parser = new RMCParser(test.EXAMPLE); assertEquals('A', parser.getMode()); }
void function() { RMBSentence loc0 = new RMBSentence(EXAMPLE); loc0.setSteerTo("123.4"); assertEquals("123.4", loc0.getSteerTo()); }
int function() { IndexSelectScan iss = new IndexSelectScan(ii, val); return iss.distinctValues(ii.fieldName()); }
public String function(SayHi arg0) { String loc0 = ""; try { loc0 = arg0.msg; } catch (NullPointerException loc1) { loc1.printStackTrace(); } return loc0; }
int function() { int loc0 = priority; return loc0; }
String function(String arg0) { String loc0 = NS_PREFIX_PREFIX + nsPrefixCount; nsPrefixCount++; NSDecl loc1 = new NSDecl(loc0, arg0); top.add(loc1); return loc0; }
Object function(Object arg0) { subst.entrySet().removeIf(entry -> entry.getValue().equals(arg0)); subst.put((Formal) arg0, (Actual) arg0); return arg0; }
public Item function(Object arg0, Object arg1, Object arg2, Object arg3) { BrowseOffersResponse.Return.OfferData.OfferMedia.OfferImage.Entry.Value loc0 = createBrowseOffersResponseReturnOfferDataOfferMediaOfferImageEntryValueItem(); return loc0.getItem(); }
void function() { RTETest test = new RTETest(); int expectedIndex = 42; try { test.rte.setSentenceIndex(expectedIndex); int actualIndex = test.rte.getSentenceIndex(); assertTrue("Expected index: " + expectedIndex + ", actual index: " + actualIndex, actualIndex == expectedIndex); } catch (Exception e) { fail("Unexpected exception: " + e.getMessage()); } try { test.rte.setSentenceIndex(-1); fail("Expected exception was not thrown"); } catch (IllegalArgumentException e) { String expectedMessage = "Sentence index cannot be negative"; String actualMessage = e.getMessage(); assertTrue("Expected message: " + expectedMessage + ", actual message: " + actualMessage, actualMessage.contains(expectedMessage)); } catch (Exception e) { fail("Unexpected exception: " + e.getMessage()); } }
void function() { undoAction(step); item.changed(); }
float function(MotionEvent arg0, int arg1) { if (IMPL.getApiLevel() >= 12) { return arg0.getX(arg1); } else { final int loc0 = arg1 << ACTION_POINTER_INDEX_SHIFT; final int loc1 = arg0.getActionIndex(); if (loc0 < 0 || loc0 >= loc1) { throw new IndexOutOfBoundsException("Pre-HC " + "device does not " + "support " + arg1 + " pointers"); } return arg0.getX(loc0); } }
long function() { long committedBytes = 0L; try { committedBytes = mDir.getCommittedBytes(); } catch (Exception e) { } return committedBytes; }
void function(long arg0, int arg1, long arg2) { long loc0 = arg0; int loc1 = arg1; long loc2 = arg2; loc0 = ThreadLocalRandom.current().nextLong(); defaults(); setUfsLength(loc1); toThrift(); assertEquals(loc2, loc0); }
ClassLoader function() { ClassLoader loc0 = null; try { loc0 = Thread.currentThread().getContextClassLoader(); } catch (Throwable ex) { } if (loc0 == null) { loc0 = ClassHelper.class.getClassLoader(); } return loc0; }
Wrapper function(Class<?> arg0) { Wrapper loc0 = WRAPPER_MAP.get(arg0); if (loc0 == null) { loc0 = makeWrapper(arg0); Wrapper loc1 = WRAPPER_MAP.putIfAbsent(arg0, loc0); if (loc1 != null) { loc0 = loc1; } } return loc0; }
public void function(String arg0, int arg1) { Scan loc0 = new Project(new Scan(new ProjectPlan().open()), arg0, arg1); loc0.fields(); }
public void function(int arg0) { int loc0 = arg0; int[] loc1 = new int[loc0 + 1]; for (int i = 0; i < coef.length && i <= loc0; i++) { loc1[i] = coef[i]; } coef = loc1; grado = loc0; }
public static Response function(RestCallable arg0) { Response loc0 = null; try { loc0 = createResponse(arg0.call()); } catch (Exception loc1) { LOG.error(loc1.getMessage(), loc1); loc0 = createErrorResponse(loc1.getMessage()); } return loc0; }
void function(int arg0) { try { instance.setYear(arg0); fail(); } catch (IllegalArgumentException loc1) { } }
QualifiedName function(ASTConstructorDeclaration arg0) { ASTClassOrInterfaceDeclaration loc0 = arg0.getFirstParentOfType(ASTClassOrInterfaceDeclaration.class); QualifiedName loc1 = QualifiedName.parseName(loc0.getQualifiedName().getImage()); String loc2 = arg0.getImage(); ASTFormalParameters loc3 = arg0.getFirstDescendantOfType(ASTFormalParameters.class); String loc4 = loc1.makeOperationOf(loc2, loc3); return loc1.makeNestedClassOf(loc1, loc4); }
void function(ApplicationManagementService arg0) { Log loc0 = LogFactory.getLog(OAuth2ServiceComponent.class); BundleContext loc1 = bundleContext; if (loc0.isDebugEnabled()) { loc0.debug("Unsetting Application management service implementation"); } OAuth2ServiceComponentHolder.setApplicationMgtService(null); }
List<String> function(CertificateConstraintsType arg0) { List<String> loc0 = Collections.emptyList(); if (arg0 != null && arg0.isSetSubjectDNConstraints()) { DNConstraintsType loc1 = arg0.getSubjectDNConstraints(); loc0 = loc1.getRegularExpression(); } return loc0; }
void function() { try { notificationController.deregisterUserSession(null, mockServerMessage); } catch (NullPointerException e) { } }
TiledMap function(Array<Asset> arg0, String arg1, ShadowStruggles game) { TiledMap loc0 = new TiledMap(null, arg0, "rpgMaps/FileMap.tmx", resourcesToDirectory("rpgMaps"), game.getAssets()); return loc0; }
boolean function(Collection arg0, Collection arg1) { if (!isEmpty(arg0) && !isEmpty(arg1)) { for (Object loc0 : arg1) { if (contains(arg0.iterator(), loc0)) { return true; } } } return false; }
public void function() { Position loc0 = new Position(37.7749, -122.4194); String loc1 = loc0.getLatHemisphere(); assertEquals("N", loc1); }
PasswordCredentials function() { try { return new PasswordCredentials(); } catch (Exception e) { throw new RuntimeException("Failed to create an instance of PasswordCredentials", e); } }
public void function() { ViolationNode loc0 = createViolationNode("file1", 1, 2, 3, 4, "var1"); ViolationNode loc1 = createViolationNode("file1", 1, 2, 5, 4, "var1"); assertFalse(loc0.equals(loc1)); }
BigDecimal function() { BigDecimal loc0 = this.expDataUnitId; return loc0; }
import static org.junit.Assert.assertTrue; public class DateTest { private Date instance; private GregorianCalendar cal; private void function() { try { assertTrue("arg0".equals("arg1")); } catch (Exception e) { e.printStackTrace(); } } }
void function(List<RegPCLTestResultDetailsEntity> arg0) { regPclTestResultDetails = arg0; }
void function() { try { Time time = new Time(); int arg0 = -1; time.setMinutes(arg0); fail("Expected exception was not thrown"); } catch (IllegalArgumentException loc0) { } }
public Integer function() { Integer loc0 = null; try { loc0 = getWeight(allNodes.get(0).key); } catch (Exception e) { e.printStackTrace(); } return loc0; }
String function(String arg0, String arg1) { String loc0 = null; try { loc0 = arg0.toUpperCase(); for (NotationName loc1 : notations) { if (loc1.getName().equalsIgnoreCase(loc0) && loc1.getVersion().equals(arg1)) { return loc1.getName(); } } } catch (Exception loc2) { LOG.error("Error in function", loc2); } return null; }
TopKSelector<T> function(int arg0) { TopKSelector<T> selector = new TopKSelector<T>().least(arg0, Ordering.natural()); return selector; }
Element function(String arg0, XKMSCacheToken arg1) { try { Element loc0 = new Element(arg0, arg1); cache.put(loc0); return loc0; } catch (Exception e) { return null; } }
ShareOpenGraphValueContainer function() { ShareOpenGraphValueContainer loc0 = (ShareOpenGraphValueContainer) this.clone(); loc0.bundle = (Bundle) this.bundle.clone(); return loc0; }
public int function() { int loc0 = 0; try { loc0 = this.quality; } catch (Exception e) { e.printStackTrace(); } return loc0; }
String function(DuplicateInfo obj) { String loc0 = obj.album; return loc0; }
void function(int arg0) { if (arg0 < -13 || arg0 > 13) { throw new IllegalArgumentException("srini_string"); } this.offsetHours = arg0; } This method takes an integer argument `arg0`, checks if it is within the range of -13 to 13, and assigns its value to the `offsetHours` instance variable of the current object (`this`). If `arg0` is not within the range, it throws an `IllegalArgumentException` with the message "srini_string". The method does not return any value (`void`).
What do you need help with regarding the "SeedPeers" Java class?
void function(Source arg0) { sources.add(arg0); validator.setSchemaSources(sources.toArray(new Source[0])); }
void function(TMXTiledMap arg0, int arg1) { TextureRegion loc0 = getTextureRegionFromGlobalTileID(arg1); TMXTile loc1 = arg0.getTMXTile(arg1); loc1.setTextureRegion(loc0); }
void function(Piloto arg0) { Comando loc0 = arg0.proximoComando(); try { loc0.ejecutar(this.getPartida()); } catch (Exception loc1) { this.notificarObservadoresException(arg0, loc0, loc1); } }
void function(boolean arg0) { try { this.timeoutEnabled = arg0; resetTimeout(); } catch (Exception loc0) { } }
Coin function() { return value; }
Items function() { return items; }
Map<String,String> function(String arg0) { Map<String,String> loc0 = createParameterMap(arg0); String loc1 = canonicalize(loc0); String loc2 = timestamp(); loc0.put("Timestamp", loc2); String loc3 = hmac(REQUEST_METHOD + "\n" + endpoint + "\n" + REQUEST_URI + "\n" + loc1); loc0.put("Signature", loc3); return loc0; }
Node function() { return node; }
void function(long arg0, long arg1, long arg2) { try { mLockManager.validateLock(arg0, arg1, arg2); fail("Expected an exception to be thrown"); } catch (Exception loc0) { expect(loc0.getClass(), is(ValidationFailedException.class)); expectMessage(loc0, "Lock validation failed for block " + arg0 + " with sessionId " + arg1 + " and lockId " + arg2); String loc1 = loc0.getMessage(); assertThat(loc1, containsString("Lock validation failed for block " + arg0 + " with sessionId " + arg1 + " and lockId " + arg2)); validateLock(loc1, arg0, arg1, arg2); } }
public static void function(String arg0, ServiceBuilder arg1) { try { Preconditions.checkNotNull(arg1, "ServiceBuilder cannot be null"); arg1 = new ServiceBuilder() .apiKey(arg1.apiKey) .apiSecret(arg1.apiSecret) .debugStream(arg1.debugStream) .signatureType(arg1.signatureType) .callback(arg0); } catch (NullPointerException e) { System.err.println("Error: " + e.getMessage()); } }
public void function(ClassType arg0, EfgType arg1, Map<ClassType,EfgClassInfo> arg2) { EfgClassInfo loc0 = arg2.get(arg0); if (loc0 == null) { loc0 = new EfgClassInfo(arg0.type()); arg2.put(arg0, loc0); } loc0.addAuto(arg1.type(), arg1.position()); }
String function(TaskStatus taskStatus) { String taskId = null; try { taskId = taskStatus.getId(); } catch (NullPointerException e) { System.err.println("Task ID is null."); } return taskId; }
void function(Iterable<Range<C>> arg0) { for (Range<C> loc0 : arg0) { remove(loc0); } }
String function(DestinationFileExistsDTO arg0) { return arg0.getTestId(); }
boolean function(final MoverDState<DsT> arg0) { final MoverDState.VisitorAdapter<Boolean, DsT> loc0 = new MoverDState.VisitorAdapter<Boolean, DsT>(Boolean.FALSE) { @Override public Boolean visitDownloading(final Downloading<DsT> downloadingState) { return Boolean.TRUE; } }; return arg0.accept(loc0).booleanValue(); }
I'm sorry, but the member functions for the class "SessionFactoryFactory" are missing. Can you please provide them so I can write the requested function?
function() { this.uri = uri; }
public Texture function(String filename) { Asset asset = game.getAssets().get(filename); if (asset != null && asset.getAssetType().equals(assetType)) { return (Texture) asset.getAsset(); } return null; }
public boolean function() { try { long currentTime = System.currentTimeMillis(); Date expirationDate = getExpiration(); if (expirationDate != null && expirationDate.getTime() < currentTime) { return true; } } catch (Exception e) { } return false; }
public String function(String fieldname) { if (s1.hasField(fieldname)) { return s1.getString(fieldname); } else { return s2.getString(fieldname); } }
I'm sorry, but the method signature you provided is incomplete and I cannot generate a concise method as it is. Can you please provide more details on what the method should do and what parameters it needs to receive?
String function() { return _stack_type; }
public String function() { try { return mUri.getPath(); } catch (Exception e) { return ""; } }
boolean function(int blockHeight, Sha256Hash blockHash) { Sha256Hash checkpointHash = checkpoints.get(blockHeight); return checkpointHash == null || checkpointHash.equals(blockHash); }
void function(IParserEventHandler handler, byte[] data) { handler.handleEvent(new BinaryBytesEvent(data, StandardCharsets.ISO_8859_1)); }
public int function(int defaultValue) { int result = defaultValue; if (currentValue != null && !currentValue.trim().isEmpty()) { try { result = Integer.parseInt(currentValue.trim()); } catch (NumberFormatException e) { } } return result; }
public void function(DirectedAcyclicGraphNode<T> parent) { try { mParents.add(parent); parent.addChild(this); } catch (Exception e) { } }
void function(String contentType) { this.response.setContentType(contentType); }
function to getTestId() { return this.testId; }
public void function(Source styleSheet) { try { this.styleSheet = styleSheet; } catch (Exception e) { } }
private void function() { File outputFile = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM), DIR_NAME); Log.d(TAG, "outputFile: " + outputFile.getAbsolutePath()); if (!outputFile.mkdirs() && !outputFile.isDirectory()) { Log.e(TAG, "Failed to create output directory"); return; } if (!outputFile.canWrite()) { Log.e(TAG, "Output directory is not writable"); return; } String dateTimeString = mDateTimeFormat.format(new Date()); mOutputPath = new File(outputFile, dateTimeString + ".mp4").getAbsolutePath(); Log.d(TAG, "Output file path: " + mOutputPath); }
public static String function(InputStream inputStream) { BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); StringBuffer response = new StringBuffer(); String line = ""; try { while ((line = reader.readLine()) != null) { response.append(line); } } catch (IOException e) { } return response.toString(); }
public void function(PropPanelFactory factory) { try { ppfactories.remove(factory); } catch (Exception e) { } }
void function() { m_selectorManager.addChannelInterestLater(m_socketChannel, SelectionKey.OP_WRITE); }
void function() { long oneMinute30Seconds = TimeUnit.MINUTES.toMillis(1) + TimeUnit.SECONDS.toMillis(30); String expectedClockTime = "01:30"; String actualClockTime = WebUtils.convertMsToClockTime(oneMinute30Seconds); Assert.assertEquals(expectedClockTime, actualClockTime); }
void function(@ModelAttribute TerminalDevice device) { try { repository.save(device); } catch (Exception e) { } }
boolean function() { return errorLevel > 0 || errorLevelFolder > 0; }
public void function() { OSSClient mockClient = Mockito.mock(OSSClient.class); AlluxioURI uri = new AlluxioURI(PATH); OSSUnderFileSystem underFS = new OSSUnderFileSystem(uri, new Configuration(), mockClient); String dst = new String(DST); String src = new String(SRC); }
void function() { if (currentblk != null && tx != null) { tx.unpin(currentblk); } }
public EndpointReferenceType function() { return from; }
String function() { return _on_symbol.name() + " -> " + _to_state.index(); }
public float function(Element element, String tagName, String attributeName) { NodeList nodeList = element.getElementsByTagName(tagName); if (nodeList.getLength() > 0) { Node node = nodeList.item(0); if (node.getNodeType() == Node.ELEMENT_NODE) { Element tagElement = (Element) node; String attributeValue = tagElement.getAttribute(attributeName); return Float.parseFloat(attributeValue); } } return 0.0f; }
I'm sorry, but it seems like the member function that should be called was not specified in your question. Could you please provide the name of the function to be called in the "ParseState" class?
void function(String arg0) { url = arg0; }
public int function() { try { return text.length(); } catch (Exception e) { return 0; } }
void function() { try { m_sipProxy.start(); m_turnServer.start(); synchronized (this) { wait(); } } catch (InterruptedException e) { e.printStackTrace(); } }
void function(SshDataReceivedEvent arg0) { System.out.println("srini_string"); System.out.print(arg0.getData()); }
public int function(T key) { return counter.getOrDefault(key, Integer.valueOf(0)); }
I'm sorry, but your request is unclear. The code snippet you provided is incomplete and it's not clear what you want the function to do. Could you please provide more context and clarify your request?
XYLocation function() { return north(); }
public Collection<GrantedAuthority> function() { try { return function(); } catch (Exception e) { } return this.grantedAuthorities; }
public void function(DenseMatrix64F seed) { try { DenseMatrix64F newMatrix = new DenseMatrix64F(); newMatrix.setQ0(seed); } catch (Exception e) { } }
public GetOfferDetailsResponse.Return.DetailOfferData.OfferMedia.OfferImage.Entry.Value.Item function() { GetOfferDetailsResponse response = new GetOfferDetailsResponse(); GetOfferDetailsResponse.Return ret = response.createGetOfferDetailsResponseReturn(); GetOfferDetailsResponse.Return.DetailOfferData detailOfferData = ret.createGetOfferDetailsResponseReturnDetailOfferData(); GetOfferDetailsResponse.Return.DetailOfferData.OfferMedia offerMedia = detailOfferData.createGetOfferDetailsResponseReturnDetailOfferDataOfferMedia(); GetOfferDetailsResponse.Return.DetailOfferData.OfferMedia.OfferImage offerImage = offerMedia.createGetOfferDetailsResponseReturnDetailOfferDataOfferMediaOfferImage(); GetOfferDetailsResponse.Return.DetailOfferData.OfferMedia.OfferImage.Entry entry = offerImage.createGetOfferDetailsResponseReturnDetailOfferDataOfferMediaOfferImageEntry(); GetOfferDetailsResponse.Return.DetailOfferData.OfferMedia.OfferImage.Entry.Value value = entry.createGetOfferDetailsResponseReturnDetailOfferDataOfferMediaOfferImageEntryValue(); GetOfferDetailsResponse.Return.DetailOfferData.OfferMedia.OfferImage.Entry.Value.Item item = value.function(); return item; }
public Object function(String name) { Object type = null; try { type = head.findClass(name); } catch (ClassNotFoundException e) { } return type; }
public void function(final ResourceTypeHandler arg0, final String arg1) { try { if (arg1 == null) { return; } Set<String> loc0 = new HashSet<>(); loc0.addAll(Arrays.asList(arg1.split(","))); extensionsDenied.put(arg0, loc0); extensionsAllowed.remove(arg0); } catch (Exception e) { System.out.println("Error occurred: " + e.getMessage()); } }
void function(String id) { try { Element element = new Element(id, ""); cache.put(element); } catch (CacheException e) { } }
void function() { CSP csp = new CSP(getVariables()); DomainRestoreInfo info = new DomainRestoreInfo(getVariables().length); FIFOQueue<Constraint> queue = new FIFOQueue<>(); for (Constraint constraint : csp.getConstraints()) { for (Variable var : constraint.vars) { queue.add(constraint); } } while (!queue.isEmpty()) { Constraint constraint = queue.pop(); for (Variable var : constraint.vars) { for (Variable var2 : csp.getNeighbors(var)) { if (revise(var2, var, constraint, csp, info)) { if (var2.size() == 0) { reduceDomains(info); return; } for (Constraint c : csp.getConstraints(var2)) { if (!c.contains(var2)) { queue.add(c); } } } } } } compactify(); }
public double function() { try { return altitude; } catch (Exception e) { return 0.0; // default value } }
public Object[] function() { List<Object> result = new ArrayList<>(); for (Object value : values) { if (value instanceof Object[]) { result.addAll(Arrays.asList((Object[]) value)); } else { result.add(value); } } return result.toArray(); }
public void function() { try { assertNotNull(Hardware.getInstance()); assertTrue(Hardware.getInstance().hasPressureSensor()); } catch (Exception e) { } }
void function(Parcel out, boolean value) { try { out.writeInt(value ? 1 : 0); } catch (Exception e) { } }
void function(EndpointResolver arg0) { try { resolvers.remove(arg0); } catch (Exception e) { } }
PrintStream function() { return debugGui.getConsole().getErr(); }
public int function() { try { return getInterval(); } catch (Exception e) { } }
public static ComplexNode function() { try { ObjectFactory factory = new ObjectFactory(); return factory.createComplexNode(); } catch (Exception e) { } }
public void function(ArrayList<CanonicalGene> arg0) { try { this.genes_in_ROI = arg0; } catch (Exception e) { } }
/** * Runs the given Callable in the JavaFX thread, waiting for it to complete before returning. * Also attempts to wait for any other JavaFX events that may have been queued in the Callable * to complete. If any Exception is thrown during execution of the Callable, that exception will * be re-thrown from invokeAndWait. * * @param arg0 the Callable to run in the JavaFX thread * @param arg1 the timeout to wait for the Callable to complete, in seconds */ public void function(final Callable<?> arg0, int arg1) { try { Future<?> loc0 = WaitForAsyncUtils.asyncFx(arg0); WaitForAsyncUtils.waitFor(arg1, TimeUnit.SECONDS, loc0); WaitForAsyncUtils.waitForFxEvents(); } catch (Exception e) { throw new RuntimeException(e); } }
public void function(String arg0) { try { log.add(arg0); } catch (Exception e) { System.err.println("Error occurred while adding to the log: " + e.getMessage()); } }
public int function() { try { return 0xCafe123; } catch (Exception e) { } }
public byte[] function() { return m_byteArray; }
public void function(final BigDecimal arg0) { this.fileCount = arg0; }
public int function() { try { int numSteps = getNumSteps(); int percentDone = step * 100 / numSteps; return percentDone; } catch (ArithmeticException e) { return 0; } }
public Region function() { ObjectFactory objFactory = new ObjectFactory(); BrowseOffersResponse.Return.OfferData.Geo geo = objFactory.createBrowseOffersResponseReturnOfferDataGeo(); return geo.getRegion().getCountry().getState().getRegion(); }
public int function() { int defaultPort = 0; try { defaultPort = new Scheme().getDefaultPort(); } catch (Exception e) { } return defaultPort; }
void function() { for (Item item : invMap.keySet()) { System.out.println(item.getUnlocalizedName() + ": " + invMap.get(item)); } }
void function(long length) { FileSizeComparable newFileSize = new FileSizeComparable(length); this.length = newFileSize; }
public LanguageVersion function(File sourceFile) { LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer(); LanguageVersion defaultLanguageVersion = discoverer.getDefaultLanguageVersionForFile(sourceFile); Language language = defaultLanguageVersion.getLanguage(); String name = language.getName(); return defaultLanguageVersion; }
public void function() { try { Image result = dev.getImage(); assertNotNull(result); assertEquals(10, result.getHeight(null)); assertEquals(10, result.getWidth(null)); } catch (Exception ex) { fail("Exception thrown: " + ex.getMessage()); } System.out.println("getImage test passed."); }
int function() { try { return -1; } catch (Exception e) { return 0; } }
public Builder function() { return Builder.fromNetworkSegment(this); }
private void function() { try { System.out.println("Test of setNumberRequests method, of class LogEntryInterval."); int loc0 = 0; LogEntryInterval loc1 = new LogEntryInterval(); loc1.setNumberRequests(loc0); } catch (Exception e) { } }
public static Reader function(String path, int maxLen) { return new InputStreamReader(IOUtils.getResourceAsStream(path, maxLen)); }
public void function() { DataNettyBuffer buffer = new DataNettyBuffer(Unpooled.buffer(LENGTH, LENGTH)); ByteBuffer readOnlyBuffer = buffer.getReadOnlyByteBuffer(); assertNotNull(readOnlyBuffer); assertEquals(LENGTH, readOnlyBuffer.capacity()); assertTrue(readOnlyBuffer.isReadOnly()); assertEquals(buffer.nioBuffer(), readOnlyBuffer); }
public boolean function(String uri) { return _imageCache.containsKey(uri); }
I'm sorry, but your instruction seems to be incomplete. Could you please provide me with the full instruction so that I can assist you better?
List<MeanValue> function() { List<MeanValue> loc0 = new ArrayList<>(); try { loc0.addAll(metrics); } catch (Exception e) { } return Collections.unmodifiableList(loc0); }
void function() { try { AttackModel loc0 = new AttackModel(); ChartObject loc1 = new ChartObject(loc0); assertNotNull(loc1.createOverlaidChart()); } catch (Exception e) { } }
public static int function(HighLevelEncoder hle, String msg, int startpos) { int count = 0; int len = msg.length(); while (startpos < len) { char c = msg.charAt(startpos); if (hle.isDigit(c)) { count++; } else { break; } startpos++; } return count; }
public int function() { try { return x; } catch (Exception e) { } }
public void function(Long arg0) { try { setTestId(arg0); } catch (Exception e) { System.out.println("An error occurred: " + e.getMessage()); } }
public void function(View host, AccessibilityNodeInfoCompat info) { IMPL.onInitializeAccessibilityNodeInfo(DEFAULT_DELEGATE, host, info); }
int function(boolean advance) { int result = 0; if (Character.isDigit(PackFormatInputStream.this.getType())) { result = Character.digit(PackFormatInputStream.this.getType(), 10); if (advance) { PackFormatInputStream.this.consume(); while (Character.isDigit(PackFormatInputStream.this.getType())) { result = result * 10 + Character.digit(PackFormatInputStream.this.getType(), 10); PackFormatInputStream.this.consume(); } } } return result; }
public String function(RegPCLTestResultDetailsEntity arg0) { String loc0 = null; try { loc0 = arg0.getActValue(); } catch (Exception loc1) { loc1.printStackTrace(); } return loc0; }
EaseUserProfileProvider function() { return userProvider.function(); }
void function(int newValue) { try { value = newValue; } catch (Exception e) { e.printStackTrace(); } }
void function() { try { String testTitle = null; Event testEvent = new Event("test_topic", testEventProperties); notificationController.handleEvent(testEvent); fail("Expected IllegalArgumentException not thrown."); } catch (IllegalArgumentException e) { } catch (Exception e) { fail("Unexpected exception thrown: " + e.getMessage()); } }
public String function() { try { return this.moduleName; } catch (Exception e) { return null; } }
boolean function(Class<?> arg0) { Map<Class<?>, Class<?>> loc0 = PRIMITIVE_TO_WRAPPER_TYPE; Map<Class<?>, Class<?>> loc1 = WRAPPER_TO_PRIMITIVE_TYPE; try { checkNotNull(arg0); return loc0.containsKey(arg0) || loc1.containsKey(arg0); } catch (Exception e) { return false; } }
void function(DenseMatrix64F arg0) { double loc0 = normF(arg0); double loc1 = arg0.getNumElements(); double loc2 = 1.0 / loc0; arg0.div(loc2); }
void function() { ArrayList<String> loc0 = new ArrayList<String>(); traverse(root, "srini_string"); }
ExceptionListener function() { return exceptionListener; }
void function() { try { mHostname = NetworkAddressUtils.getLocalHostName(); } catch (UnknownHostException e) { throw new RuntimeException(e); } }
void function() { }
public Map<String, String> function() { try { return this.attributes; } catch (Exception e) { return null; } }
BigDecimal function() { return new BigDecimal(); }
double function(int index) { return eig.getEigenvalue(index); }
public CoordinatorStore function() { CoordinatorStore store = null; try { store = new CoordinatorStore(); store.beginTransaction(); } catch (StoreException e) { throw new Exception("Error creating CoordinatorStore: " + e.getErrorCode().toString() + " " + e.getMessage(), e); } return store; }
I'm sorry, but I cannot complete this task as the description is unclear. There is no method in the `StoredTransactionOutPoint` class that takes an index as an argument, and there is no clear indication of what method should be implemented. Could you please provide more specific information or clarify the task?
Script function(byte[] data) { checkArgument(data.length <= MAX_OP_RETURN_DATA_SIZE, "Data size is too large"); ScriptBuilder builder = new ScriptBuilder(); builder.op(OP_RETURN); builder.data(data); return builder.build(); }
I'm sorry, but I believe there is an error in your request. It seems like you are trying to write a method that calls itself, which doesn't make sense. Could you please clarify your question or provide more context so I can assist you better?
public void function(String tenantDomain, String idPName) { try { idPMgtStub.deleteIdP(idPName, tenantDomain); } catch (RemoteException e) { String errorMsg = "Error deleting Identity Provider " + idPName + " from tenant " + tenantDomain + ": " + e.getMessage(); log.error(errorMsg, e); throw new RuntimeException(errorMsg, e); } }
Class<?> function() { return Main.class; }
Document function(String soapString) { try { DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance(); dbFactory.setNamespaceAware(true); DocumentBuilder dBuilder = dbFactory.newDocumentBuilder(); return dBuilder.parse(new InputSource(new StringReader(soapString))); } catch (Exception e) { log.error("Error converting String to DOM", e); return null; } }
int function(long value) { return (value <= 0xffffffffL) ? (int) value : (value >= 1L << 32) ? -1 : (int) (value >>> 32); }
public static String function(ParameterDirectionKindEnum value) { try { return value.toString(); } catch (Exception e) { return null; } }
void function() { mockServerConfig = mock(ServerConfiguration.class); when(mockServerConfig.getIssuer()).thenReturn(null); service = new StaticServerConfigurationService(mockServerConfig); ServerConfiguration result = service.getServerConfiguration(issuer); assertThat(result, is(nullValue())); }
void function(IdentityProvider identityProvider) { try { userAdminStub.updateIdP(identityProvider); } catch (RemoteException e) { String error = "Error while updating Identity Provider: " + e.getMessage(); log.error(error, e); } }
public boolean function(final HttpParams arg0) { try { if (arg0 == null) { throw new IllegalArgumentException("HTTP parameters may not be null"); } return arg0.getBooleanParameter(NIOReactorPNames.INTEREST_OPS_QUEUEING, false); } catch (IllegalArgumentException e) { } return false; }
public void function(String algorithm) { try { stub.setGlobalPolicyAlgorithm(algorithm); } catch (RemoteException e) { log.error("Error setting global policy algorithm: " + e.getMessage(), e); handleException("Error setting global policy algorithm", e); } }
public byte[] function() { try { return Utils.HEX.decode("f9beb4d9"); } catch (Exception e) { return null; } }
public Map<String, String> function() { Map<String, String> stringMap = new LinkedHashMap<>(); List<String> stringList = getStrings(); for (String s : stringList) { String[] split = s.split("=", 2); if (split.length == 2) { stringMap.put(split[0], split[1]); } } return stringMap; }
public String function(HttpServletRequest request, IssuerServiceResponse response) { try { return getIssuer(); } catch (Exception e) { } }
public Object function() { try { return getClass().newInstance(); } catch (Exception e) { throw ScriptRuntime.throwAsScriptRuntimeEx(e); } }
public BigInteger function() { try { return dh.generatePublic(DH_PARAMETER_SPEC).getY(); } catch (InvalidKeyException e) { throw new RuntimeException(e); } }
public long function() { try { return geneA; } catch (Exception e) { } }
String function(Repository repository, String repositoryName, String text) { String escapedText = StringUtils.escapeForHtml(text); String processedText = processTextRegex(repository, repositoryName, escapedText); return StringUtils.breakLinesForHtml(processedText); }
public Double function(String locationA, String locationB) { if (links.contains(locationA) && links.contains(locationB)) { return links.get(locationA).get(locationB); } return null; }
public static JsonElement function(Set<String> stringSet, boolean preserveEmpty) { if (stringSet == null || stringSet.isEmpty()) { return JsonNull.INSTANCE; } else { if (preserveEmpty) { List<String> stringList = new ArrayList<>(stringSet); return gson.toJsonTree(stringList, new TypeToken<List<String>>() {}.getType()); } else { return gson.toJsonTree(stringSet, new TypeToken<Set<String>>() {}.getType()); } } }
private void function(Context context, View view) { try { InputMethodManager inputMethodManager = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); inputMethodManager.showSoftInput(view, InputMethodManager.SHOW_IMPLICIT); } catch (Exception e) { } }
public Timestamp function() { try { return getReceiptDate(); } catch (Exception e) { } }
ConduitSelector function() { return conduitSelector; }
public static SpringChain function(SpringConfig arg0, int arg1) { try { SpringChain chain = new SpringChain(); chain.setControlSpringIndex(-1); chain.mMainSpringConfig = arg0; chain.mAttachmentSpringConfig = arg0; chain.mSprings.add(new SpringSystem().createSpring().setSpringConfig(arg0)); return chain; } catch (Exception e) { e.printStackTrace(); return null; } }
function(arg0) { return builder().addField("place_name", place_name) .addField("lng", lng) .addField("created_at", created_at) .addField("loc_radius", arg0) .addField("text", text) .addField("id_str", id_str) .addField("screen_name", screen_name) .addField("image", image) .addField("user_name", user_name) .addField("user_id", user_id) .addField("extras", extras) .addField("lat", lat) .buildFieldJSON(); }
/** * Returns a Map representing the substitution (i.e. a set of variable/term pairs) * or null which is used to indicate a failure to unify. */ public Map<Variable, Term> function(FOLNode arg0, FOLNode arg1, Map<Variable, Term> bindings) { try { return _substVisitor.unify(arg0, arg1, bindings); } catch (UnificationException e) { return null; } }
public String function(@Nonnull PublicKey key) { String algorithm = "SHA-256"; try { MessageDigest digest = MessageDigest.getInstance(algorithm); byte[] keyBytes = key.getEncoded(); byte[] hashBytes = digest.digest(keyBytes); return new String(hashBytes, StandardCharsets.UTF_8); } catch (NoSuchAlgorithmException e) { } return null; }
public TiledMap function() { RpgMap rpgMap = RpgMap.getInstance(); TiledMap map = rpgMap.getMap(); Array< TiledMapTileLayer > layers = map.getLayers(); for (TiledMapTileLayer layer : layers) { if (layer.getName().equals(rpgMap.getTileLayerString())) { return layer; } } return null; }
public static Document function(Source source) { try { Document document = tryExtractDocFromDOMSource(source); if (document != null) { return document; } InputSource inputSource = toInputSource(source); DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setNamespaceAware(true); DocumentBuilder builder = factory.newDocumentBuilder(); return builder.parse(inputSource); } catch (Exception e) { } return null; }
String function() { return "subgraph {"; }
void function(BundleContext context) { for(AutoSIMConnectionConfig conn : config.connections) { environments.deregisterConnectionFactory(conn.name); factories.remove(conn.name); } }
boolean function(String name) { AbstractPlugin plugin = getByName(name); return remove(plugin); }
public production function() { return _the_production; }
void function() { System.out.println("toString"); String expected = "Expected device string"; String actual = dev.toString(); assertEquals(expected, actual); fail("The test case is a prototype."); }
String function() { return getChangedRefs(Constants.R_TAGS); }
public Object function(String key) { return json.get(key); }
public void function(int movement) { recordedMovement[4] = recordedMovement[3]; recordedMovement[3] = recordedMovement[2]; recordedMovement[2] = recordedMovement[1]; recordedMovement[1] = recordedMovement[0]; recordedMovement[0] = movement; }
public void function() { try { Preconditions.checkState(mNettyBuf != null, "Netty ByteBuf is null"); if (mNettyBuf.refCnt() > 0) { mNettyBuf.release(); } } catch (Exception e) { } }
void function() { UnderStoreBlockInStream inStream = null; try { inStream = new UnderStoreBlockInStream(mFile); skipInternal(inStream, 0); } catch (IOException e) { } finally { if (inStream != null) { try { inStream.close(); } catch (IOException e) { } } } }
public BookPreview function(UUID uuid) { for (BookPreview preview : data) { if (preview.getUUID().equals(uuid)) { return preview.getPreview(); } } return null; }
String function() { int hour = getHour(); int minutes = getMinutes(); double seconds = getSeconds(); int offsetHours = getOffsetHours(); int offsetMinutes = getOffsetMinutes(); int offsetTotalMinutes = (int) Math.floor(offsetHours * 60.0 + offsetMinutes); return String.format(TIME_PATTERN, hour, minutes, (int) seconds, offsetHours, offsetMinutes); }
public void function(String feedId) { try { this.feedId = feedId; } catch (Exception e) { } }
void function() { Date instance1 = new Date(); Date instance2 = new Date(instance1.getTime()); assertFalse(instance1.equals(instance2)); }
public AppStatus function() { AppStatus.Builder builder = AppStatus.newBuilder(); for (Map.Entry<String, AppInstanceStatus> entry : instances.entrySet()) { builder.with(entry.getValue()); } return builder.build(); }
void function() { ViolationNode node1 = createViolationNode("file1", 1, 2, 3, 4, "var1"); ViolationNode node2 = createViolationNode("file2", 1, 2, 3, 4, "var1"); assertFalse(node1.equals(node2)); }
public Object function() { return impl.function(); }
void function(int numRows) { reshape(numRows, numCols, false); }
void function(String expMsg) { setErrorMsg(expMsg); }
public void function() { for (int i = 0; i < 10000; i++) { } }
public void function() { Locale[] locales = new Locale[]{Locale.ENGLISH, Locale.FRENCH, new Locale("srini_string", "srini_string"), Locale.GERMAN, Locale.ITALIAN, Locale.CHINESE, Locale.UK}; }
public Instrumentation function() { return instrumentation; }
public long function() { long currentMark = System.currentTimeMillis(); long elapsedMs = currentMark - lastMark; lastMark = currentMark; return elapsedMs; }
String function(ConfigSetUpDTO configSetUpDTO) { String loc0 = ""; try { loc0 = configSetUpDTO.getPclFeedId(); } catch (Exception loc1) { loc0 = ""; } return loc0; }
int function(MyComplexStruct myComplexStruct) { int loc0 = 0; try { loc0 = myComplexStruct.getElem3(); } catch (Exception loc1) { loc0 = 0; } return loc0; }
String function(Selector selector) { return selector.getOrder(); }
Node function(Node head) { return reverse(head); }
private OpenFileOptions function(CreateFileOptions createFileOptions) { return OpenFileOptions.defaults() .setReadType(createFileOptions.getWriteType() == WriteType.CACHE ? ReadType.CACHE : ReadType.NO_CACHE); }
I apologize, but I believe there's a mistake in your question. The member function "EncryptedKeyElement getEncryptedKeyElement()" already exists in the "KeyInfoElement" class and it seems that the instruction "calls function() without exception handling" doesn't make sense in this context. Could you please provide more details or clarify your question so that I can assist you better?
public void function(Message message, AddressingProperties maps) { try { org.apache.cxf.ws.addressing.ContextUtils.storeMAPs(message, null, maps, false); } catch (Exception e) { } }
String function() { return RELOAD_APP_ACTION_SUFFIX; }
void function() { try { String input = RequestInput.getString("Please enter a string:", null); System.out.println("User input: " + input); } catch (Exception e) { e.printStackTrace(); } }
String function() { WorkflowJobBean workflow = getWorkflow(); return workflow.getGroup(); }
public void function(String moduleName) { try { this.setModuleName(moduleName); } catch (Exception e) { } }
public void function(T obj) { try { if (checkDuplicate(obj)) { throw new IllegalStateException("Duplicate object cannot be freed."); } if (!allowFree(obj)) { return; } free(obj); } catch (Exception e) { System.out.println("Error occurred while freeing object: " + e.getMessage()); } }
public void function(String correlationId, Object arg0) { try { this.setCorrelationId(correlationId); } catch (Exception loc0) { } }
void function() { before(); mPlainSaslServer.evaluateResponse("PLAIN".getBytes()); Callback[] callbacks = {new NameCallback("user"), new PasswordCallback("password", false)}; mPlainSaslServer.handle(callbacks); String expectedUser = "testUser"; String expectedPassword = "testPassword"; byte[] expectedUserInfo = getUserInfo(expectedUser, expectedPassword); byte[] response = mPlainSaslServer.evaluateResponse(expectedUserInfo); assertNull(response); String actualAuthorizationID = mPlainSaslServer.getAuthorizationID(); Assert.assertEquals(expectedUser, actualAuthorizationID); }
void function(IParserEvent event) { handlerStack.push(handler); handler.handleEvent(event); handler = handlerStack.pop(); }
List<TempTable> function(Scan src) { p.open(); List<TempTable> runs = splitIntoRuns(src); p.close(); int numRuns = runs.size(); while (numRuns > 2) { runs = doAMergeIteration(runs); numRuns = runs.size(); } return runs; }
public void function() { try { if (mSubject.isReadOnly()) { throw new LoginException("Subject is read-only"); } Set<UserPrincipal> principals = mSubject.getPrincipals(UserPrincipal.class); for (UserPrincipal principal : principals) { if (principal.getName().equals(mUserName)) { mSubject.getPrincipals().remove(principal); } } } catch (LoginException e) { } }
public String function() { try { return postId; } catch (Exception e) { return null; } }
public int function(int version) { int[] acceptableAddressCodes = getAcceptableAddressCodes(); for (int code : acceptableAddressCodes) { if (code == version) { return true; } } return false; }
public boolean function(boolean arg0) { try { return appendSemicolon(arg0); } catch (Exception e) { return false; } }
void function() { rmc.setMode('A'); assertEquals('A', rmc.getMode()); }
void function(int id) { int pos = id * slotsize; blk.read(pos); currentslot = id; }
String function(String field) { if (lhs.isFieldName() && rhs.isFieldName() && lhs.asFieldName().equals(field)) { return rhs.asFieldName(); } else if (rhs.isFieldName() && lhs.asFieldName().equals(field)) { return lhs.asFieldName(); } else { return null; } }
void function(String arg0) { this.actValue = arg0; }
DiffBuilder function() { return this.normalizeWhitespace(true); }
public ClaimDTO[] function(String realmName) { RegistryBasedTrustedServiceStore store = new RegistryBasedTrustedServiceStore(); String claims = store.getTrustedServiceClaims(realmName); return // ... return some value ... }
boolean function(String key, boolean defaultValue) { try { return bundle.getBoolean(key, defaultValue); } catch (Exception e) { return defaultValue; } }
public boolean function(String logLevel, String logMessage) { String level = logLevel.toUpperCase(); if (!logLevels.containsKey(level)) { return false; } int levelValue = logLevels.get(level); if (levelValue < logFilter.getLevel()) { return false; } Matcher matcher = filterPattern.matcher(logMessage); if (!matcher.matches()) { return false; } return true; }
public void function(int value) { try { ensureCapacity(4); mWriter.putInt(value); } catch (BufferOverflowException e) { } }
public void function(AuthenticationHolderEntity authenticationHolder) { setAuthenticationHolder(authenticationHolder); }
void function() { Iterator<AbstractPlugin> pluginIterator = singleton.iterator(); while (pluginIterator.hasNext()) { AbstractPlugin plugin = pluginIterator.next(); plugin.removePluginObserver(); pluginIterator.remove(); } }
I'm sorry, but the method you provided in your request is incomplete. Please provide the full method signature so I can proceed with your request.
void function(InetSocketAddress address, Channel channel) { Preconditions.checkArgument(address != null, "Address cannot be null"); Preconditions.checkArgument(channel != null, "Channel cannot be null"); if (NETTY_CHANNEL_POOL_MAP.containsKey(address)) { NettyChannelPool channelPool = NETTY_CHANNEL_POOL_MAP.get(address); channelPool.release(channel); } }
public String function() { return systemId; }
public void function(ArrayList<Object> arg0) { bundle.putParcelableArrayList("key", arg0); return; }
public void function() { URIBuilder builder = new URIBuilder(); builder.setFragment(fragment); }
void function(long keySize) { setKeySize(keySize); }
void function() { int sessionTimeoutMs; try { sessionTimeoutMs = Configuration.getInt(PropertyKey.WORKER_SESSION_TIMEOUT_MS); } catch (Exception e) { return; } }
public Map<SpringConfig, String> function() { return Collections.unmodifiableMap(mSpringConfigMap); }
public static String function() { SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'"); dateFormat.setTimeZone(TimeZone.getTimeZone("UTC")); return dateFormat.format(new Date()); }
public void function() { try { synchronized(this) { m_storedDirectoryContents = getFiles(m_directory); m_newDirectoryContents = new HashSet<>(m_storedDirectoryContents); m_removed = false; m_markedForRemoval = false; } } catch(Exception e) { m_log.error("Error updating directory tracker", e); } }
void function(String path, String rawSQL) { try { SQLiteUriMatcher instance = SQLiteUriMatcher.instances.get(mAuthority); if (instance == null) { instance = SQLiteUriMatcher.getInstance(SQLiteUriMatcher.class, mAuthority); instance.instantiate(); } instance.addRawSQL(path, rawSQL); } catch (Exception e) { } }
void function() { try { individualStructures.clear(); } catch (Exception e) { } }
public LanguageVersion function() { return this.languageVersion; }
I'm sorry, but the method you are asking me to implement is not possible. The reason is that the class "StaticSTSProperties" has two member functions with the exact same name "setSignatureProperties" and "getSignatureProperties", so I cannot determine which one you are referring to. Please clarify your question with the correct member function name.
public Predicate function() { return pred; }
boolean function(DenseMatrix64F arg0) { return MatrixFeatures.isDiagonalPositive(arg0, TOL); }
void function(ByteBuffer arg0, int arg1) { arg0.putInt((arg1 & 0xFF)); }
void function(String loginName) { try { UserSubject subject = new UserSubject(loginName); setSubject(subject); } catch (OAuthSystemException e) { e.printStackTrace(); } }
void function(boolean value) { setBreakOnExceptions(value); getMenubar().getMenu(0).getItem(2).setSelected(value); }
public float function(int viewY) { try { double lat = y(viewY); float scale = computeScale(); int viewCenterX = 0; // replace with appropriate value int viewCenterY = viewY; int screenCenterX = 0; // replace with appropriate value int screenCenterY = 0; // replace with appropriate value float newLonCorr = (float) (lon(screenCenterX + (viewCenterX - screenCenterX) / scale) - originLon); return (float) lat; } catch (Exception e) { return Float.NaN; // or other appropriate value } }
public static USAddress function() { try { return new USAddress(); } catch (Exception e) { } return null; }
public void function() { doStart(); }
JSONObject function(int arg0) { Object loc0 = mArray.get(arg0); return loc0 == null ? null : loc0 instanceof JSONObject ? (JSONObject) loc0 : null; }
double function(DenseMatrix64F arg0) { int n = arg0.numRows; if (n != arg0.numCols) { throw new RuntimeException("Matrix must be square."); } int[] perm = PermuteArray.next(n); double sum = 0.0; do { double prod = 1.0; boolean neg = false; for (int i = 0; i < n; i++) { double val = arg0.get(i, perm[i]); prod *= val; for (int j = 0; j < i; j++) { if (perm[j] > perm[i]) { neg = !neg; } } } if (neg) { prod = -prod; } sum += prod; } while (PermuteArray.next(perm)); return sum; }
public Dish function(String arg0) { try { return dishRepository.findBySiteUrl(arg0); } catch (Exception loc0) { log.error("Error while getting dish by site url: {}", arg0, loc0); throw new RuntimeException("Error while getting dish by site url", loc0); } }
public String function() { try { Object loc0 = new java.rmi.server.UID(); return loc0.toString(); } catch (Exception loc1) { LOG.error("Error while generating new unique ID", loc1); throw new RuntimeException("Error while generating new unique ID", loc1); } }
void function() { flushed = true; errorCount = 0; }
void function(long xid, int retval, ServiceID id) { }
public List<String> function() { try { return registeredScopes; } catch (Exception e) { } }
public static void function(File arg0) { try { traverseDir(arg0, new FileAction() { @Override public void act(File arg1) { arg1.delete(); } }); arg0.delete(); } catch (IOException e) { String errorMsg = error("Error deleting directory: " + arg0.getAbsolutePath(), e); LOG.log(Level.SEVERE, errorMsg, e); } }
public String function() { return operation; }
public void function() { valid = true; invalidationMessage = null; }
void function() { Collections.shuffle(pilotos); for (Piloto piloto : pilotos) { runTurno(piloto); } long ronda = rondas.incrementAndGet(); notificarObservadoresRondaTerminada(ronda); }
public String function() { try { String path = request.getRequestURI().getPath(); String contextPath = request.getContextPath(); if (contextPath != null && path.endsWith(contextPath)) { path = path.substring(0, path.length() - contextPath.length()); } return path; } catch (Exception e) { return null; } }
public void function() { try { long fileId = IdUtils.createFileId(12345L); Assert.assertNotEquals(0L, fileId); } catch (Exception e) { } }
public List<PropertyDescriptor<?>> function() { try { return new ArrayList<>(propertyDescriptors); } catch (Exception e) { return null; // or throw a custom exception } }
public InputStream function() { try { return new ReaderInputStream(reader); } catch (IOException e) { } return null; }
public void function(String failedAttrib) { this.failedAttrib = failedAttrib; }
public void function(Profile profile) { try { getManager().registerProfile(profile); } catch (Exception e) { } }
boolean function(Method bridgeMethod, Method candidateMethod, Map<TypeVariable, Type> typeVariableMap) { return isResolvedTypeMatch(candidateMethod, bridgeMethod, typeVariableMap) && findGenericDeclaration(bridgeMethod) == candidateMethod; }
void function() { canvas.setForegroundColor(color); canvas.fillCircle(xPosition, yPosition, diameter); }
Object function(String name) { if (!vars.containsKey(name)) { throw new IllegalArgumentException(String.format("Variable '%s' not found", name)); } return context.get(name); }
I'm sorry, but it seems like the original instructions are incomplete and do not provide enough context to understand what the desired function should do. Could you please provide more information or clarify the instructions?
public int function() { try { return xPosition; } catch (Exception e) { return 0; // or some default value } }
public float function(short unitType) { float result = 0; try { switch (primitiveType) { case FSCssPrimitiveType.CSS_NUMBER: result = floatValue; break; case FSCssPrimitiveType.CSS_PERCENTAGE: result = rectValue.width * floatValue / 100; break; case FSCssPrimitiveType.CSS_EMS: result = rectValue.width * floatValue; break; case FSCssPrimitiveType.CSS_EXS: result = rectValue.width * floatValue / 2; break; case FSCssPrimitiveType.CSS_PX: result = floatValue; break; case FSCssPrimitiveType.CSS_CM: result = floatValue * 96 / 2.54f; break; case FSCssPrimitiveType.CSS_MM: result = floatValue * 96 / 25.4f; break; case FSCssPrimitiveType.CSS_IN: result = floatValue * 96; break; case FSCssPrimitiveType.CSS_PT: result = floatValue * 96 / 72; break; case FSCssPrimitiveType.CSS_PC: result = floatValue * 96 / 6; break; } } catch (Exception e) { } return result; }
void function(long arg0, long arg1) { mBlocksToMoveIn.add(arg0); mBlocksToMoveInSize += arg1; }
WSDLFactory function() { WSDLFactory factory = WSDLCorbaFactory.newInstance(); String factoryImplName = factory.findFactoryImplName(); return factory; }
List<EMGroup> function() { List<EMGroup> atMeGroups = new ArrayList<>(); try { Set<String> groupIds = EMClient.getInstance().groupManager().joinedGroupsFromServer(); for (String groupId : groupIds) { if (hasAtMeMsg(groupId)) { atMeGroups.add(EMClient.getInstance().groupManager().getGroup(groupId)); } } } catch (HyphenateException e) { e.printStackTrace(); } return atMeGroups; }
PropertyDescriptor function(Object obj, String propertyName) { PropertyDescriptor[] descriptors = PropertyUtil.propertyDescriptorsFor(obj, obj.getClass()); for (PropertyDescriptor descriptor : descriptors) { if (descriptor.getName().equals(propertyName)) { return descriptor; } } return null; }
public void function(int minutes) { if (minutes < 0 || minutes > 59) { try { throw new IllegalArgumentException("Invalid value for minutes"); } catch (IllegalArgumentException e) { } } else { this.minutes = minutes; } }
public String function(Coin coin) { try { return coin.toPlainString(); } catch (Exception e) { return ""; } }
void function(JPanel arg0) { uiStack.addToStack(arg0); }
public boolean function() { return defaultNillable; }
public List<SAXParseException> function(Source instance) { try { validator.validateInstance(instance); return Collections.emptyList(); } catch (SAXException e) { Iterable<ValidationProblem> problems = e.getProblems(); return problemToExceptionList(problems); } catch (IOException e) { return Collections.emptyList(); } }
public void function(DiffBuilder builder, ComparisonListener listener) { try { builder.withComparisonListeners(listener); builder.withComparisonListeners(Arrays.asList(listener)); } catch (Exception e) { } }
void function(ConduitSelector selector) { this.conduitSelector = selector; }
public static Class<?> function() { Message message = PhaseInterceptorChain.getCurrentMessage(); Exchange exchange = message.getExchange(); Message faultMessage = exchange.getOutFaultMessage() != null ? exchange.getOutFaultMessage() : exchange.getOutMessage(); return faultMessage.get(class); }
private void function(Context context, View view) { InputMethodManager inputMethodManager = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); try { inputMethodManager.hideSoftInputFromWindow(view.getWindowToken(), 0); } catch (NullPointerException e) { } }
public BigDecimal function() { return runId; }
public String function() { String tenantDomain = null; try { tenantDomain = this.getTenantDomain(); } catch (Exception e) { } return tenantDomain; }
Rect function() { return new Rect(); }
Collection<Playlist> function(HashMap<Integer,Playlist> arg0) { Collection<Playlist> loc0 = arg0.values(); List<Playlist> loc1 = new ArrayList<>(loc0); try { Collections.sort(loc1); } catch (NullPointerException e) { logger.warning("NullPointerException in function: " + e.getMessage()); } catch (ClassCastException e) { logger.warning("ClassCastException in function: " + e.getMessage()); } catch (IllegalArgumentException e) { logger.warning("IllegalArgumentException in function: " + e.getMessage()); } return loc1; }
Documents function(String arg0, String arg1, String arg2, String arg3) { Documents loc0 = null; try { Class.forName(arg0).newInstance(); Connection loc1 = DriverManager.getConnection(arg1, arg2, arg3); loc0 = new Documents(loc1); loc0.createDb(); } catch (ClassNotFoundException e) { System.err.println("Error: " + e.getMessage()); } catch (InstantiationException e) { System.err.println("Error: " + e.getMessage()); } catch (IllegalAccessException e) { System.err.println("Error: " + e.getMessage()); } catch (SQLException e) { System.err.println("Error: " + e.getMessage()); } return loc0; }
void function(CString arg0) { this.paramName = arg0; }
boolean function(String arg0) { if (_imageResourceLoader.getCachedImages().containsKey(arg0)) { return true; } if (_uriResolver.getCache().containsKey(arg0)) { return true; } return false; }
public String function(String arg0) { try { if (arg0 == null) { throw new NullPointerException(); } return DAVRepository.class.getName() + "srini_string" + arg0; } catch (NullPointerException e) { } return null; }
void function(Object arg0) { try { _out.writeStreamingObject(arg0); } catch (IOException e) { } }
void function(NoFileAssertListener listener, CPDListener cpdListener, File file) { listener.setCpdListener(cpdListener); cpdListener.add(file); listener.verify(); }
void function() { long newId = 5678; mGenerator.setNextContainerId(newId); assertEquals(newId, mGenerator.getNewContainerId()); }
void function() { checkRankNUpdate(N, N); }
public void function() { try { when(mockServerSession.getId()).thenReturn(null); notificationController.registerUserSession(mockServerSession, mockServerMessage); fail("Expected NullPointerException was not thrown."); } catch (NullPointerException e) { } }
public Rectangle function() { Dimension preferredSize = panel.getPreferredSize(); panel.setSize(preferredSize); panel.doLayout(); int width = panel.getWidth(); int height = panel.getHeight(); return new Rectangle(0, 0, width, height); }
public DenseMatrix64F getQR() { return QR; }
I cannot create a method for this task without any input arguments. Please provide additional information or requirements for the function you want me to create.
public int function() { int quantity = 0; try { OrderLineType lineItem = getLineItem(); if (lineItem != null) { quantity = lineItem.getQuantity().getValue().intValue(); } } catch (Exception e) { } return quantity; }
I'm sorry, but it seems like there is an error in the provided method description. The description states that the method should call "function()", but there is no such method in the "Gistic" class. Could you please provide a corrected description or additional information so that I can create the requested method?
public static ValidateAccess function() { ValidateAccess loc0 = new ValidateAccess(); loc0.setAccessRequest(null); return loc0; }
String function(HttpServletRequest arg0) { String loc0 = arg0.getParameter(WebService.FORMAT); return loc0 == null ? null : loc0.toLowerCase(); }
void function(DishCollection arg0) { dishCollectionRepository.save(arg0); log.debug("Saved dish collection: {}", arg0); }
public Sha256Hash function(byte[] contents) { byte[] hash1 = Sha256Hash.hash(contents); byte[] hash2 = Sha256Hash.hash(hash1); return new Sha256Hash(hash2); }
void function() { }
public static String function() { try { Calendar calendar = GregorianCalendar.getInstance(); return fromCalendar(calendar); } catch (Exception e) { return ""; } }
public static DiffBuilder function(final Object input) { try { return DiffBuilder .compare(Input.from(input).build()) .withTest(input) .withComparisonController(ComparisonControllers.Default) .withDifferenceListeners(new ArrayList<>()) .withNodeFilter(node -> true) .withAttributeFilter(attr -> true) .ignoreComments() .normalizeWhitespace(); } catch (IOException e) { throw new RuntimeException("Failed to create DiffBuilder from input", e); } }
public static void function(JSONObject json, String name, Object value) { try { json.put(name, value); } catch (JSONException e) { LOG.warn("Error putting {}:{} in JSON object", name, value); } }
public T function() { return V; }
public String function() { return mAlias; }
public void function(String[] args) { try { LOG.debug("Launching the SIP and TURN servers."); TurnLauncher turnLauncher = new TurnLauncher(); turnLauncher.start(); } catch (Exception e) { LOG.error("Error launching the SIP and TURN servers.", e); } }
void function(byte[] arg0) { projectSecret = arg0; }
public String function(Date date) { return String.valueOf(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(date)); }
int function(SymmetricQrAlgorithm arg0, double arg1, double arg2) { int loc0 = 0; for (int i = 0; i < arg0.getNumberOfEigenvalues(); i++) { if (Math.abs(arg0.getEigenvalue(i) - arg1) < arg2) { loc0++; } } return loc0; }
public static BasicNameManager function(ServiceInfo service) { BasicNameManager nameManager = new BasicNameManager(); try { nameManager.initialize(service, null); } catch (Exception e) { } return nameManager; }
public void function() { ConfigurationHandler handler = function(); } private ConfigurationHandler function() { return new ConfigurationProperties(); }
public FederationProposal function(String token) { List<FederationProposal> proposals = getPendingFederationProposals(); for (FederationProposal proposal : proposals) { if (proposal.getToken().equals(token)) { return proposal; } } return null; }
public void function(String arg0) { this._cssText = arg0; }
public void function() { blk = new Block(blk.fileName(), blk.number() - 1); pg.read(blk); currentrec = pg.getInt(LogMgr.LAST_POS); }
public void function() { Object targetObj = null; try { InitialContext ctx = new InitialContext(); targetObj = ctx.lookup("java:comp/env/ejb/TargetEJBLocal"); Class<?> targetClass = targetObj.getClass(); Method method = targetClass.getMethod("someMethod", String.class); method.invoke(targetObj, "argumentValue"); } catch (Exception e) { } }
public List<String> function() { return acceptedEncryptionAlgorithms; }
I'm sorry, but I cannot generate the requested function as there seems to be a mismatch between the provided member functions and the desired function. The provided class "RestServiceActivator" only has one member function "void start(BundleContext context)", but the desired function seems to be related to stopping the service, which would require a "void stop(BundleContext context)" member function. Please provide more information or clarify the desired function.
String function() { try { return FlipTable.of(headers, data, Borders.FULL); } catch (Exception e) { } }
public Object function() { return target; }
public Object function() { return impl.function(); }
void function() { long oneSecondInMillis = TimeUnit.SECONDS.toMillis(1); String expected = "00:00:01"; String actual = WebUtils.convertMsToClockTime(oneSecondInMillis); Assert.assertEquals(expected, actual); }
public String function() { try { return this.literalName; } catch (Exception e) { System.err.println("An error occurred while getting the string representation of the enumeration value: " + e.getMessage()); return null; } }
public Vector<ClassdiagramNode> function() { return new Vector<>(downlinks); }
public String function() { String runtimeDir = ""; try { runtimeDir = createRuntimeDir(); } catch (IOException e) { System.err.println("Error creating runtime directory: " + e.getMessage()); } return runtimeDir; }
public boolean function() { String value = currentValue.trim(); if (value.isEmpty()) { return Boolean.parseBoolean(defaultValue); } else { try { return Boolean.parseBoolean(value); } catch (Exception e) { return Boolean.parseBoolean(defaultValue); } } }
void function() { setProgress(getMax()); getProgress(); setProgress(getMax()); }
public void function() { assertEquals(10, time.getHour()); }
public Date function(DatePicker datePicker) { Calendar calendar = Calendar.getInstance(); int dayOfMonth = datePicker.getDayOfMonth(); int month = datePicker.getMonth(); int year = datePicker.getYear(); calendar.set(year, month, dayOfMonth); return calendar.getTime(); }
void function(Timestamp arg0) { try { setCreatedDate(arg0); } catch (Exception e) { } }
public boolean function(Collection<Assertion> coll1, Collection<Assertion> coll2) { return coll1.containsAll(coll2) && coll2.containsAll(coll1); }
NodeVisitor function(Node arg0) { return arg0.begin(); }
public XsdStringType function() { try { return this.paramValue; } catch (Exception e) { return null; } }
I'm sorry, I cannot complete this task as the requirements are not clear. Could you please provide more information on how to implement this method?
public int function(ViewConfigurationCompat instance, ViewConfiguration config) { int slop; try { slop = instance.IMPL.getScaledPagingTouchSlop(config); } catch (NoSuchMethodError e) { slop = config.getScaledTouchSlop(); } return slop; }
public TypeNode function(String fmt, Object... subst) { return QQ.parse(QQ.TYPE, fmt, subst); }
void function() { try { rmb.setSteerTo(null); fail("IllegalArgumentException was expected but not thrown"); } catch (IllegalArgumentException e) { assertTrue(e.getMessage().contains("Steer-To must be a valid CompassPoint")); } catch (Exception e) { fail("Unexpected exception was thrown: " + e.getMessage()); } }
void function() { if (connectedHandler != null) { connectedHandler.close(); } }
void function(final PropertyChangeListener arg0) { try { m_PropertyChangeSupport.addPropertyChangeListener(arg0); } catch (NullPointerException | IllegalArgumentException e) { System.err.println("Failed to add PropertyChangeListener: " + e.getMessage()); } }
public Client function() { return client; }
public String function(AccessibilityServiceInfo arg0) { try { return IMPL.getDescription(arg0); } catch (Exception e) { return null; } }
public void function(Locale newLocale) { try { Locale.setDefault(newLocale); this.bundles = new HashMap<String, ResourceBundle>(); } catch (Exception e) { } }
public Script function(ECKey key, @Nullable TransactionSignature signature, Address to) { List<ScriptChunk> chunks = new ArrayList<ScriptChunk>(); if (signature != null) { chunks.add(new ScriptChunk(signature.encodeToBitcoin())); } else { chunks.add(new ScriptChunk(ScriptOpCodes.OP_0)); } chunks.add(new ScriptChunk(key.getPubKey())); byte[] scriptBytes = Script.createOutputScript(to).getProgram(); chunks.add(new ScriptChunk(scriptBytes)); return new ScriptBuilder().addChunk(chunks).build(); }
public Timestamp function() { try { return this.receiptDate; } catch (Exception e) { } }
void function(boolean arg0) { enforceKnownIssuer = arg0; }
ValidateAccess function() { return access; }
public String function() { try { return VERSION; } catch (Exception e) { return "UNKNOWN"; } }
public void function(RID rid) { int blockNum = rid.blockNumber(); int id = rid.id(); moveTo(blockNum); currentRid().moveToId(id); }
void function(WalkDirection arg0) { viewer.moveCharacter2d(arg0); }
private void function(InetSocketAddress workerAddress) { Preconditions.checkNotNull(workerAddress); long sessionId = IdUtils.getRandomNonNegativeLong(); BlockWorkerClient client = RetryHandlingBlockWorkerClient .newBuilder() .setAddress(workerAddress) .setSessionId(sessionId) .setRpcTimeoutMs(mConfiguration.getMs("alluxio.worker.block.heartbeat.timeout")) .setMaxRetry(mConfiguration.getInt("alluxio.worker.block.retry.max")) .setMaxSleepMs(mConfiguration.getMs("alluxio.worker.block.retry.max.sleep.ms")) .setSubject(mSubject) .build(); }
String function() { return failedAttrib; }
public void function(String headerName, Object headerValue) { try { headers.put(headerName, headerValue); } catch (Exception e) { } }
@Override public int function(Object arg0) { int loc0 = 0; try { loc0 = super.hashCode(); } catch (Exception loc1) { } loc0 = 31 * loc0 + (arg0 != null ? arg0.hashCode() : 0); return loc0; }
public ValidatedItemDTO[] function(String arg0, boolean arg1) throws AxisFault { ValidatedItemDTO[] loc0; try { loc0 = stub.validateAuthnRequest(arg0, arg1); return loc0; } catch (RemoteException loc1) { log.error("srini_string", loc1); throw new AxisFault(loc1.getMessage(), loc1); } }
Sha256Hash function(Block block) { try { return block.getHash(); } catch (VerificationException e) { throw new RuntimeException("Error getting block hash", e); } }
public void function(String sourcePath, String destinationPath) throws IOException { Files.move(new File(sourcePath), new File(destinationPath)); }
public static List<Object> function(JSONArray jsonArray) { List<Object> nodes = new ArrayList<>(); for (int i = 0; i < jsonArray.length(); i++) { Object node = new JSONObject(jsonArray.get(i).toString()); nodes.add(node); } return nodes; }
void function() { try { md5Cache.clear(); } catch (Exception e) { } }
public String function() { try { return this.inactivationReasonType; } catch (Exception e) { return null; // or some default value } }
void function(Exception arg0) { try { log.error("Error occurred: " + arg0.getMessage(), arg0); throw new AxisFault("Error occurred: " + arg0.getMessage(), arg0); } catch (Exception loc0) { } }
public static ByteBuffer function(int start, int len) { ByteBuffer buf = ByteBuffer.allocate(len * 4); for (int i = start; i < start + len; i++) { buf.putInt(i); } buf.flip(); return buf; }
int function() { return this.lane_id; }
boolean function(String arg0) { if (arg0 == null || arg0.length() == 0 || !Character.isJavaIdentifierStart(arg0.charAt(0))) { return false; } for (int loc0 = 1; loc0 < arg0.length(); loc0++) { if (!Character.isJavaIdentifierPart(arg0.charAt(loc0))) { return false; } } return true; }
boolean function() { return config.loadDefault(); }
void function(List<Double> arg0) { try { profits.add(arg0); } catch (Exception e) { } }
void function(long arg0) { try { index = arg0; } catch (Exception e) { } }
public void function(long arg0) { this.mSeekBufferSizeBytes = arg0; }
public String function(DateTimeFormat format, boolean showTimeZone) { try { Date currentDate = new Date(); return formatUTC(currentDate, format, showTimeZone); } catch (Exception e) { return null; } }
void function(T arg0) { Integer loc0 = counter.get(arg0); if (loc0 == null) { counter.put(arg0, 1); } else { counter.put(arg0, loc0 + 1); } }
function(List<TestResultDTO> testResultLst) { try { this.testResultLst = testResultLst; } catch (Exception e) { } }
function(Context arg0, Scriptable arg1, Object arg2, Class<?> arg3) { try { return new NativeJavaObject(arg1, arg2, arg3); } catch (Exception e) { } return null; }
public String function() { return mTierAlias; }
public PaymentChannelServerState function(Wallet wallet, TransactionBroadcaster broadcaster) { checkArgument(connectedHandler != null, "Channel is not currently open"); PaymentChannelServerState state = PaymentChannelServerState.fromWallet(wallet, contract, clientOutput, myKey); state.setRefundTransactionUnlockTimeSecs(refundTransactionUnlockTimeSecs); state.setBestValueToMe(bestValueToMe); state.setBestValueSignature(bestValueSignature); state.setClientOutput(clientOutput); state.setConnectedHandler(connectedHandler, false); state.setContractHash(contract.getHash()); state.setMyKey(myKey); broadcaster.broadcastTransaction(state.contract()); return state; }
public String function(QName elementQName, boolean qualified) { String namespaceURI = elementQName.getNamespaceURI(); String prefix = getPrefix(namespaceURI); if (prefix == null) { NamespacePrefixAccumulator acc = new NamespacePrefixAccumulator(); acc.collect(null, namespaceURI); prefix = acc.getPrefix(namespaceURI); } String name = (qualified && prefix != null) ? prefix + ":" + elementQName.getLocalPart() : elementQName.getLocalPart(); return name.replaceAll("[^\\p{Alnum}]", "_"); }
public Scan function() { TempTable rhsTable = rhs.copyRecordsFrom(); TableInfo rhsTableInfo = rhsTable.getTableInfo(); int blockSize = BufferManager.getBlockSize(); int chunkSize = Math.min((int)Math.ceil((double)rhsTableInfo.recordsOutput() * rhsTableInfo.recordLength() / blockSize), BufferManager.getNumBuffers()); List<Plan> chunkPlans = new ArrayList<>(); for (int i = 0; i < rhsTableInfo.blocksAccessed(); i += chunkSize) { Plan chunkPlan = new MultiBufferProductPlan(tx, lhs, schema, rhsTable.open(), i, chunkSize); chunkPlans.add(chunkPlan); } return new MultiBufferProductScan(chunkPlans); }
public void function(boolean isHighPriority) { _highPriority = isHighPriority; }
public ServerSession function(String userId) { try { return userSessionMap.get(userId); } catch (Exception e) { LOGGER.error("Failed to obtain ServerSession for user {}", userId, e); return null; } }
public String function() { try { return applicationDescription; } catch (Exception e) { return null; // Or some default value } }
List<String> function() { try { return links.getVertexLabels(); } catch (Exception e) { return null; } }
public Object function(String fieldName) { if (groupfields.contains(fieldName)) { Object value = groupval.getVal(fieldName); if (value == null) { throw new RuntimeException("Null group value for field: " + fieldName); } return value; } else { for (AggregationFn aggf : aggfns) { if (aggf.fieldName.equals(fieldName)) { return aggf.value(); } } throw new RuntimeException("No aggregation function for field: " + fieldName); } }
public String function() { return testData; }
public void function(String key, String value) { try { LocalAlluxioClusterResource resource = new LocalAlluxioClusterResource.Builder() .setNumWorkers(1) .setStartCluster(true) .build(); resource.mConfiguration.put(PropertyKey.fromString(key), value); System.out.println(resource.mConfiguration.toString()); resource.get().close(); } catch (Exception e) { e.printStackTrace(); } }
String function(String arg0, String[] arg1) { try { if (StringUtils.isEmpty(arg0)) { throw new IdentityValidationException(String.format(msgSection1 + "cannot be empty")); } if (isValidOverBlackListPatterns(arg0, arg1)) { return arg0; } else { String patterns = getPatternString(arg1); throw new IdentityValidationException(String.format(msgSection1 + msgSection3 + msgSection4 + msgSection2, patterns)); } } catch (IdentityValidationException e) { throw e; } catch (Exception e) { throw new IdentityValidationException(e.getMessage()); } }
public Schema function() { return srcplan.schema(); }
public Result function(String source) { Result result = new Result(); for (ResultEntry entry : log) { if (!entry.getSource().equals(source)) { result.add(entry); } } if (globalLog != null) { for (ResultEntry entry : globalLog.log) { if (!entry.getSource().equals(source) && !result.contains(entry)) { result.add(entry); } } } for (Map.Entry<ResultObserver, ResultObserverSettings> observer : observers.entrySet()) { List<String> sources = getSources(observer.getKey()); if (sources != null && sources.contains(source)) { observer.getKey().notify(result, observer.getValue().getLevel()); } } return result; }
Map<Object,String> function(Set<Object> arg0, Color arg1) { Map<Object,String> loc0 = new HashMap<>(); for (Object key : arg0) { Color color = tintColor(getRandomColor(), FIXED_TINT_FACTOR); String colorString = getColorString(color); loc0.put(key, colorString); } return loc0; }
void function(int arg0) { try { setPopulationSize(0); setIterations(0); } catch (Exception e) { } }
Element function(Document arg0, Element arg1) { Element domainsAssignments = arg0.createElement("domain_assignments"); for (DomainPair loc0 : document.getDomainAssignment().getPairs()) { Element domainAssignment = arg0.createElement("domain_assignment"); writeSourceSinkDomPair(loc0.getSourceSinkDomPair(), arg0, domainAssignment); domainAssignment.setAttribute("policy", loc0.getPolicy().getName()); domainsAssignments.appendChild(domainAssignment); } arg1.appendChild(domainsAssignments); return domainsAssignments; }
int function() { int numTopLevelValues = 0; try { numTopLevelValues = values.size(); } catch (Exception e) { } return numTopLevelValues; }
void function(String arg0) { function(); String loc0 = arg0; setDirectory(loc0); }
I'm sorry, but there seems to be a mistake in your question. It is not clear what you are asking for. It appears that the member variables and member functions you have provided belong to two different Java classes - "Argo" and "XDebug". Additionally, the instructions provided in your question do not provide sufficient information to generate a valid method for either class. Can you please clarify your question?
Object function(long arg0, int arg1) { if (HAS_REMOTE_CONTROL_APIS) { MetadataEditorCompat loc0 = new MetadataEditorCompat(mActualMetadataEditor); loc0.putLong(METADATA_KEY_ARTWORK, arg0); loc0.apply(); } return null; }
void function() { GeneralMotorCon.getInstance().appendToConsole("Spinning left"); GeneralMotorCon.getInstance().setLedsAnimation(LEDAnimation.BLINK_ORANGE, 3, 10); GeneralMotorCon.getInstance().spinLeft(); GeneralMotorCon.getInstance().doFor(500); GeneralMotorCon.getInstance().hover(); }
public ResponseEntity<Ingredient> function(@PathVariable String id) { log.debug("REST request to get Ingredient : {}", id); Optional<Ingredient> ingredient = ingredientService.findOne(id); return ingredient.map(result -> new ResponseEntity<>(result, HttpStatus.OK)) .orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND)); }
void function(Element element) { try { } catch (Exception e) { } }
public String function() { String value = ""; try { value = getStringValue(); } catch (Exception e) { } return value.isEmpty() ? "{Empty}" : value; }
public String function(String classFullName) { try { int lastDotIndex = classFullName.lastIndexOf("."); if (lastDotIndex != -1) { return classFullName.substring(0, lastDotIndex); } else { return ""; } } catch (Exception e) { return null; } }
@Override public boolean function(Object obj) { if (this == obj) { return true; } if (!super.internalEquals(obj)) { return false; } if (getClass() != obj.getClass()) { return false; } SimpleTypedNameDeclaration other = (SimpleTypedNameDeclaration) obj; if (next == null) { if (other.next != null) { return false; } } else if (!next.internalEquals(other.next)) { return false; } if (type == null) { if (other.type != null) { return false; } } else if (!type.isAssignableFrom(other.type) && !other.type.isAssignableFrom(type)) { return false; } return true; }
public String function() { try { return lineItem.getLineItem().getItem().getSellersItemIdentification().getID().getValue(); } catch (NullPointerException e) { return ""; } }
void function(int skipBytes) { this.skipBytes = skipBytes; }
private void function() { try { setGlobalTileID(null, 0); } catch (Exception e) { } }
void function() { assertEquals(mBlockStoreMeta.getDefaultTotalCapacityBytes(), mBlockStoreMeta.getCapacityBytes()); }
void function() { lines.peek(); cbuf.clear(); int loc0 = reader.read(buf); lineBuf.add(buf, 0, loc0); lines.poll(); }
void function() { gsv.setSentenceCount(3); assertEquals(3, gsv.getSentenceCount()); }
void function(String iconPath) { this.iconPath = iconPath; }
public boolean function() { Proxy proxy = properties.getProxy(); if (proxy != null && proxy.getAuthenticator() != null) { Authentication auth = proxy.getAuthenticator().getAuth(); if (auth != null && auth.getUsername() != null && auth.getPassword() != null) { return true; } } return false; }
public void function() { IParserEventHandler handler = new DefaultEventHandler(); RawRtfParser parser = new RawRtfParser(handler); try { parser.parse(); } catch (IOException e) { } catch (ParserException e) { } }
I'm sorry, but I'm having trouble understanding your request. Could you please provide more context or clarify your question?
void function() { double conditionNumber = NormOps.conditionP2(squareMatrix); assertFalse(Double.isNaN(conditionNumber) || Double.isInfinite(conditionNumber)); checkUncountable(conditionNumber); assertEquals(2.0344, conditionNumber, 1e-4); }
void function() { try { String path = "path/to/delete"; ObjectListing objectListing = mock(ObjectListing.class); when(mClient.listObjects(any(ListObjectsRequest.class))) .thenReturn(objectListing); when(objectListing.getObjectSummaries()) .thenReturn(Collections.emptyList()); doThrow(new OSSException("Test Exception")) .when(mOSSUnderFileSystem).delete(eq(path), eq(true)); mOSSUnderFileSystem.delete(path, true); Assert.assertFalse(mOSSUnderFileSystem.exists(path)); } catch (Exception e) { fail("Exception not expected: " + e.getMessage()); } }
public List<Language> function(File sourceFile) { List<Language> languages = null; try { String fileName = sourceFile.getName(); String extension = getExtension(fileName); if (extension != null) { languages = getLanguagesForFile(fileName); } } catch (Exception e) { } return languages; }
public void function(Set<Method> methods) { suppressedTests.addAll(Arrays.asList(suppressing(methods))); }
void function(AudioManager audioManager, RemoteControlClientCompat remoteControlClient) { if (sHasRemoteControlAPIs) { audioManager.registerRemoteControlClient(remoteControlClient.getActualRemoteControlClientObject()); } }
public long function() { try { incrementMessagesSent(); return getMessagesSent(); } catch (Exception e) { } return 0; }
public lalr_item removeOne() { if (_all.size() == 0) { return null; } else { Iterator<lalr_item> it = _all.values().iterator(); lalr_item item = it.next(); it.remove(); return item; } }
public URI function() { return theURI; }
void function(String arg0) { String message = this.config.getFilterName() + "srini_string" + arg0; this.config.getServletContext().log(message); }
@Override public String function() { return null; }
void function() { GSVParser parser = new GSVParser("srini_string"); List<SatelliteInfo> satelliteInfoList = loc0.getSatelliteInfo(); assertEquals(2, satelliteInfoList.size()); assertEquals(loc1.get(0), satelliteInfoList.get(0)); assertEquals(loc1.get(1), satelliteInfoList.get(1)); testSatelliteInfo(satelliteInfoList.get(0), "srini_string", 56, 182, 51); testSatelliteInfo(satelliteInfoList.get(1), "srini_string", 38, 163, 47); }
void function() { DataByteBuffer buffer = new DataByteBuffer(); byte[] nettyOutput = buffer.getNettyOutput(); assertTrue(nettyOutput != null); }
boolean function() { return loggingEnabled; }
public RegisteredClient function(String issuer) { try { return clients.get(issuer).get(); } catch (NullPointerException e) { return null; } }
public String function(String fileName) { try { int lastDot = fileName.lastIndexOf("."); if (lastDot != -1) { return fileName.substring(0, lastDot); } else { return fileName; } } catch (Exception e) { System.err.println("Error getting filename without extension: " + e.getMessage()); return fileName; } }
boolean function(String arg0, FieldSigMask arg1) { for (FieldSignature signature : fields.keySet()) { if (arg1.covers(signature) && signature.getName().equals(arg0)) { Set<String> modifiers = fields.get(signature); if (modifiers != null && modifiers.contains(arg0)) { return true; } } } return false; }
void function(TreePath path) { TreePath parentPath = path.getParentPath(); Object lastPathComponent = path.getLastPathComponent(); Object parent = parentPath.getLastPathComponent(); int index = getIndexOfChild(parent, lastPathComponent); Object[] children = {lastPathComponent}; int[] indices = {index}; fireChildrenChanged(parentPath, indices, children); fireChildChanged(path.getParentPath(), index, lastPathComponent); }
String function(ServiceID id, int flags, int prefixBits, InetAddress addr)
void function(String arg0) { testId = arg0; }
void function() { Iterator<InetAddress> loc0 = m_trackedRemoteHosts.values().iterator(); while(loc0.hasNext()) { InetAddress arg0 = loc0.next(); m_permittedAddresses.remove(arg0); InetSocketAddress loc1 = new InetSocketAddress(arg0, 0); IoSession loc2 = m_connections.remove(loc1); if (loc2 != null) { loc2.closeNow(); } } }
public static JSONArray function(List<JsonWorkflowJob> arg0) { JSONArray loc0 = new JSONArray(); for (JsonWorkflowJob loc1 : arg0) { loc0.add(loc1.toJSONObject()); } return loc0; }
public boolean function() { MRNA loc0 = mrnaValue(); return loc0 != null && loc0 == MRNA.DOWNREGULATED; }
function() { return Verb.POST; }
public void function(boolean mCascade, DeleteLineageOptions options) { options.mCascade = mCascade; }
public boolean function() { return mrnaValue != null && mrnaValue.isUpregulated(); }
int function() { WorkflowJobBean loc0 = getWorkflow(); int loc1 = loc0.getRun(); return loc1; }
void function(List<ChildNumber> path, DeterministicKey key) { try { ImmutableList<ChildNumber> loc0 = getPath(path); ImmutableList<ChildNumber> loc1 = getParent(loc0); ChildNumber loc2 = getChildNumber(path); Map<ImmutableList<ChildNumber>, DeterministicKey> loc3 = keys; if (!loc3.containsKey(loc1)) { throw new IllegalArgumentException("Parent does not exist in the hierarchy, cannot create child."); } DeterministicKey loc4 = loc3.get(loc1); loc4.put(loc2, key); lastChildNumbers.put(loc1, loc2); } catch (NullPointerException e) { throw new IllegalArgumentException(e); } }
List<TestResultDTO> function() { try { return getTestResultLst(); } catch (NullPointerException e) { throw new IllegalArgumentException(e); } }
EncryptedKeyElement function() { return m_EncryptedKeyElement; }
public void function(String imgUrl, ImageLoadFailTracker tracker) { try { tracker.add(imgUrl); } catch (Exception e) { } }
void function(boolean currentScenario) { setCurrentScenario(currentScenario); }
public void function(File ignoreFile) throws IOException { Scanner scanner = new Scanner(ignoreFile); scanner.useDelimiter("srini_string"); while (scanner.hasNext()) { _ignoreWords.add(scanner.next()); } scanner.close(); }
public void function(String arg0) { try { setChecksum(arg0); } catch (Exception e) { System.err.println("Error setting checksum: " + e.getMessage()); } }
void function(Result arg0) { try { withExceptionHandling(new Trans<Object>(), () -> { Object loc0 = transformation.transformTo(arg0); return null; }); } catch (Exception e) { } }
void function(Node arg0) { String nodeId = arg0.getId(); graph.removeVertex(arg0); nodesByIds.remove(nodeId); }
public void function(RuleSet arg0) { try { if (arg0.getLanguage() == null) { arg0.setLanguage(LanguageRegistry.getLanguage("Java")); } for (int loc0 = 0; loc0 < ruleSets.size(); loc0++) { RuleSet loc1 = ruleSets.get(loc0); if (loc1.getLanguage().equals(arg0.getLanguage())) { ruleSets.remove(loc0); break; } } ruleSets.add(arg0); ruleChain.add(arg0.getRules()); } catch (Exception e) { System.err.println("Failed to add RuleSet: " + e.getMessage()); } }
void function(XMLLibImpl arg0, XmlCursor arg1) { String loc0 = arg1.getName(); String loc1 = arg1.getNamespaceURI(); String loc2 = uriToPrefix.get(loc1); int loc3 = loc2 == null ? 0 : loc2.size(); undeclared.add(loc0); arg1.add(); }
GetOfferDetailsResponse.Return.DetailOfferData function() { GetOfferDetailsResponse response = new GetOfferDetailsResponse(); GetOfferDetailsResponse.Return returns = new GetOfferDetailsResponse.Return(); GetOfferDetailsResponse.Return.DetailOfferData detailOfferData = new GetOfferDetailsResponse.Return.DetailOfferData(); detailOfferData.function(); returns.setDetailOfferData(detailOfferData); response.setReturn(returns); return detailOfferData; }
ThreadSafeSupplier<T> function(Supplier<T> delegate) { Preconditions.checkNotNull(delegate); return new ThreadSafeSupplier<>(delegate); }
Matrix function(CategoricalDistribution dist) { double[] values = dist.getValues(); int numRows = values.length; Matrix matrix = new Matrix(numRows, 1); for (int i = 0; i < numRows; i++) { matrix.set(i, 0, values[i]); } return matrix; }
List<Node> function() { try { return evaluationResults; } catch (Exception e) { LOGGER.log(Level.SEVERE, "Error retrieving evaluation results", e); return null; } }
boolean function() { synchronized (lock) { return services != null; } }
void function(int length) { if (mWriter.remaining() < length) { int newCapacity = mWriter.position() + length; byte[] newBuffer = new byte[newCapacity]; System.arraycopy(mBuffer, 0, newBuffer, 0, mWriter.position()); mBuffer = newBuffer; mWriter = ByteBuffer.wrap(mBuffer); mWriter.position(newCapacity); } }
String function() throws BadSyntaxException { if (!matchStringConstant()) { throw new BadSyntaxException("Expected a string constant."); } String result = tok.sval; nextToken(); return result; }
boolean function(Integer arg0) { try { return graph.addNode(arg0); } catch (Exception e) { } return false; }
public class AbstractConfigurableProvider { private List<String> produceMediaTypes; private Bus bus; private List<String> consumeMediaTypes; private boolean enableStreaming; private boolean enableBuffering; private final ResourceBundle BUNDLE = BundleUtils.getBundle(AbstractJAXBProvider.class); private final Logger LOG = LogUtils.getL7dLogger(AbstractJAXBProvider.class); public List<String> getConsumeMediaTypes() { return consumeMediaTypes; } public boolean getEnableBuffering() { return enableBuffering; } public boolean isPayloadEmpty(HttpHeaders headers) { } public boolean isPayloadEmpty(MultivaluedMap<String, String> headers) { } public Bus getBus() { return bus; } public void setConsumeMediaTypes(List<String> types) { this.consumeMediaTypes = types; } public void setProduceMediaTypes(List<String> types) { this.produceMediaTypes = types; } public void setEnableStreaming(boolean enableStream) { this.enableStreaming = enableStream; } public void setBus(Bus b) { this.bus = b; } public void reportEmptyContentLength() { } public void init(List<ClassResourceInfo> resources) { } public void setEnableBuffering(boolean enableBuf) { this.enableBuffering = enableBuf; } public boolean getEnableStreaming() { return enableStreaming; } public List<String> function() { try { return this.produceMediaTypes; } catch (Exception e) { } return null; } }
public Message function(String jsonString) { try { Object parsed = JSONValue.parseWithException(jsonString); if (!(parsed instanceof JSONObject)) { throw new ParserException("JSON object expected"); } return parseJSONValueToMessage(parsed); } catch (ParseException | ParserException e) { } return null; }
public DenseMatrix64F function(DenseMatrix64F A) { int numRows = A.numRows(); int numCols = A.numCols(); int min = Math.min(numRows, numCols); DenseMatrix64F B = new DenseMatrix64F(numRows, numCols); double[] u = new double[numRows]; double[] b = new double[numCols]; double[] gammasU = new double[min]; double[] gammasV = new double[min]; int loc = 0; for (int i = 0; i < min; i++) { u = handleU(A, false, true, numRows, numCols, i); b[i] = u[i]; B.set(i, i, -gammasU[i]); for (int j = i + 1; j < numCols; j++) { handleU(A, false, true, numRows, numCols, i); B.set(i, j, u[j]); } loc = i * numCols + i + 1; for (int j = i + 1; j < numRows; j++, loc++) { u[j] = B.data[loc]; } gammasV[i] = computeV(i); for (int j = i + 1; j < numRows; j++) { loc = i * numCols + j; for (int k = i + 1; k < numCols; k++, loc++) { B.data[loc] -= u[j] * gammasV[i] * B.data[i * numCols + k]; } } } this.UBV = B; this.m = numRows; this.n = numCols; this.gammasU = gammasU; this.gammasV = gammasV; this.b = b; return new DenseMatrix64F(A); }
public String function() { try { return label(); } catch (Exception e) { return ""; } }
public static String function(MediaInfo info, int index) { Uri uri = getImageUri(info, index); return uri.toString(); }
public static String function() { try { long loc0 = ((AtomicLong)RpcStatus.values.get("totalElapsed")).get(); return String.valueOf(loc0); } catch (Exception e) { return ""; } }
String function(BufferedReader reader) throws IOException { String line; while ((line = reader.readLine()) != null) { line = line.trim(); if (!line.startsWith("#") && !line.isEmpty()) { return line; } } return null; }
void function() { final double loc0 = 95.56789; vtg.setMagneticCourse(loc0); assertTrue(vtg.toString().contains("srini_string")); assertEquals(loc0, vtg.getMagneticCourse(), 0.1); }
function(MessageContext messageContext) { try { mc = messageContext; } catch (Exception e) { } }
int function() { return Objects.hashCode(this); }
public double function(int index1, int index2) { try { return W.get(index1, index2); } catch (Exception e) { e.printStackTrace(); return 0.0; } }
public void function() { try { RuleSet[] ruleSetArray = ruleSets.toArray(new RuleSet[0]); int size = ruleSets.size(); } catch (Exception e) { } }
public int function(String param) { try { return Integer.parseInt(params.get(param)); } catch (NumberFormatException | NullPointerException ex) { System.err.println("Unable to parse integer value for parameter " + param); return -1; } }
public boolean function(Bits arg0) { try { return this.ordinal() <= arg0.ordinal(); } catch (NullPointerException e) { return false; } }
void function() { try { } catch (Exception e) { LOG.warn("Exception occurred while disconnecting: {}", e.getMessage()); } }
public void function(String isActive) { this.isActive = isActive; }
String function() { String str = pg.getString(pos); pos += str.length(); return str; }
function(IdentValue display) { List<PropertyValue> values = Collections.singletonList(new PropertyValue(display)); PropertyDeclaration decl = new PropertyDeclaration(CSSName.DISPLAY, values); CascadedStyle style = new CascadedStyle(); style.addProperties(Collections.singletonList(decl).iterator()); return style; }
String function() { String message = avoidNull(xmlParser.getTitle()); return avoidNull(message); }
int function(Object key, int value) { int hash = System.identityHashCode(key); int i = hash & _mask; while (_keys[i] != null) { if (_keys[i] == key || _keys[i] == DELETED) { break; } i = (i + 1) & _mask; } _keys[i] = key; _values[i] = value; _size++; return value; }
int function() { return placementHint; }
String function(QName qname) { for (ServiceContractResolver loc0 : resolvers) { URI loc1 = loc0.resolveContractLocation(qname); if (loc1 != null) { return loc1.toString(); } } return null; }
boolean function() { return !hasMoves(OthelloSide.BLACK) && !hasMoves(OthelloSide.WHITE); }
public void function() { ResourceBundle bundle = ResourceBundle.getBundle("testresources/DBTypeTest"); String bundleName = bundle.getClass().getName(); System.out.println("Testing bundle: " + bundleName); Properties expectedProperties = new Properties(); expectedProperties.setProperty("prop1", "value1"); expectedProperties.setProperty("prop2", "value2"); Properties properties = DBType.getResourceBundleAsProperties(bundle); assertEquals(expectedProperties, properties); }
void function(Runnable task) { synchronized (internalLock) { queue.add(task); if (!isWorkerRunning && suspensions == 0) { startQueueWorker(); } } }
public void function(Date expires) { try { this.expires = expires; } catch (Exception e) { } }
void function() { int priority = 5; this.setPriority(priority); }
public int function(int dividend, int divisor) { try { long unsignedDividend = UnsignedInts.toLong(dividend); long unsignedDivisor = UnsignedInts.toLong(divisor); return (int) (unsignedDividend / unsignedDivisor); } catch (IllegalArgumentException e) { throw new ArithmeticException(e.getMessage()); } }
private Type function(Type type) { try { return TypeUtil.getSingleTypeParameter(type); } catch (Throwable t) { return null; } }
public static AegisType function(AegisContext globalContext, Object value, Type type) { AegisType baseType = getTypeMapping(globalContext).getType(type); if (baseType == null) { TypeCreator creator = getTypeCreator(globalContext); baseType = creator.createType(type); } AegisType writeType = getWriteTypeStandalone(globalContext, value, baseType); if (writeType == null) { throw new DatabindingException("Couldn't find AegisType for " + value.getClass().getName()); } if (Collection.class.isAssignableFrom(value.getClass())) { Type collectionType = getSingleTypeParameter(type); if (collectionType != null) { AegisType componentType = getTypeMapping(globalContext).getType(collectionType); if (componentType == null) { TypeCreator creator = getTypeCreator(globalContext); componentType = creator.createType(collectionType); } CollectionType typeMapping = new CollectionType(writeType, componentType); writeType = typeMapping; } } return writeType; }
public String function() { return reliableEndpoint.getManager().getIdGenerator().generateSequenceIdentifier(); }
public int function(String fieldName) { try { Schema.FieldInfo info = sch.fieldInfo(fieldName); int distinctValues = 0; Constant val = null; Scan s = open(); if (s.next()) { val = s.getVal(info.offset()); distinctValues++; } while (s.next()) { Constant nextVal = s.getVal(info.offset()); if (val.compareTo(nextVal) != 0) { distinctValues++; val = nextVal; } } s.close(); return distinctValues; } catch (Exception e) { return -1; } }
private byte[] function(ByteBuffer input) { ByteBuffer buf = ByteBuffer.allocate(input.capacity() + 1); buf.put((byte) 1); buf.put(input); buf.rewind(); MessageDigest digest = MessageDigest.getInstance("SHA-256"); digest.update(BufferUtils.newByteArrayFromByteBuffer(buf)); byte[] hash = digest.digest(); byte[] fingerprint = Arrays.copyOf(hash, 1); return fingerprint; }
void function() { int maxLocks = 10; BlockLockManager manager = new BlockLockManager(maxLocks); manager.lockBlock(TEST_BLOCK_ID, TEST_SESSION_ID); manager.unlockBlock(TEST_BLOCK_ID, TEST_SESSION_ID); manager.lockBlock(TEST_BLOCK_ID, TEST_SESSION_ID); mThrown.expect(LockException.class); mThrown.expectMessage("deadlock"); lockExpectingHang(manager, TEST_BLOCK_ID); }
String function(String string, int minLength, char padChar) { string = Strings.nullToEmpty(string); Preconditions.checkNotNull(padChar); if (string.length() >= minLength) { return string; } StringBuilder sb = new StringBuilder(minLength); sb.append(string); while (sb.length() < minLength) { sb.append(padChar); } return sb.toString(); }
public void function() { try { assertNotNull(Hardware.getInstance(getContext()).mPenEvent); } catch (Exception e) { } }
public int function(int row, int col) { try { return matrixItemUtility[row][col]; } catch (ArrayIndexOutOfBoundsException e) { } try { return matrixItemRemainingUtility[row][col]; } catch (ArrayIndexOutOfBoundsException e) { } return 0; // or some other default value }
void function() { setErrorLevel(errorLevelFolder); }
public static String function(int index, String[] parts) { try { String part = parts[index]; if (part == null || part.isEmpty()) { return NA_STRING; } return part; } catch (ArrayIndexOutOfBoundsException e) { return NA_STRING; } }
public void function(String value) { try { Long expectedDataUnitId = Long.valueOf(value); setExpectedDataUnitId(expectedDataUnitId); } catch (NumberFormatException e) { } }
internal_error create_internal_error(String message) { return new internal_error(message); } void function(Object obj) { if (obj == null) { throw create_internal_error("Parameter cannot be null."); } }
void function() { savePending.getAndSet(true); executor.schedule(saver, delay, delayTimeUnit); }
void function() { for (int i = 1; i <= N; i++) { checkSymmRankNMinus_U(i, i); checkSymmRankNMinus_U(i + 1, i); checkSymmRankNMinus_U(i, i + 1); } }
public boolean function(AbstractGoal other) { return job().equals(other.job()); }
public String function() { try { return workflowImplId; } catch (Exception e) { } return null; }
void function(boolean ignoreExceptions) { this.ignoreExceptions = ignoreExceptions; }
public String function(String input, String[] whiteListPatterns) { try { if (StringUtils.isEmpty(input)) { throw new IdentityValidationException("The provided input is empty or null"); } if (!isValidOverWhiteListPatterns(input, whiteListPatterns)) { String patternString = getPatternString(whiteListPatterns); String errorMsg = String.format("%s '%s' %s %s", msgSection1, input, msgSection2, patternString); throw new IdentityValidationException(errorMsg); } return input; } catch (Exception e) { return null; } }
final void function() { MWVTest test = new MWVTest(); double expected = 5.5; test.mwv.setSpeed(expected); assertEquals(expected, test.mwv.getSpeed(), 0.01); }
public void function(long milliseconds) { try { Thread.sleep(milliseconds); } catch (InterruptedException e) { } }
public void function() { try { double longitude = -123.456; // example longitude value instance.setLongitude(longitude); assertEquals(longitude, instance.getLongitude(), 0.001); assertEquals('W', instance.getLongitudeHemisphere()); instance.setLongitude(0.0); assertEquals(0.0, instance.getLongitude(), 0.001); assertEquals('E', instance.getLongitudeHemisphere()); } catch (Exception e) { } }
public static <T> Iterable<T> function(final Iterable<T> arg0, final Predicate<? super T> arg1) { return new Iterable<T>() { @Override public Iterator<T> iterator() { return new FilteringIterator<T>(arg0.iterator(), arg1); } }; }
public List<CoordinatorActionBean> function() { try { return actions; } catch (Exception e) { return null; } }
public void function(@ModelAttribute Schedule arg0) { try { repository.save(arg0); } catch (Exception e) { } }
public void function(Runnable runnable, long timeoutInMillis) throws TimeoutException { Future<Void> future = asyncFx(runnable); waitForMillis(timeoutInMillis, future); }
void function(Logger logger) { this.logger = logger; }
public void function() { try { Time time = new Time(); time.setSeconds(30); assertEquals(30, time.getSeconds()); } catch (Exception e) { } }
public static ByteBuffer function() { ByteBuffer buffer = null; try { buffer = ByteBuffer.allocate(4).order(ByteOrder.nativeOrder()); buffer.putInt(0).putInt(1).putInt(2).putInt(3); buffer.flip(); int prev = buffer.getInt(); while (buffer.hasRemaining()) { int next = buffer.getInt(); if (next != prev + 1) { throw new RuntimeException("Buffer does not contain an increasing sequence of integers"); } prev = next; } } catch (Exception e) { e.printStackTrace(); } return buffer; }
public Sentence function(String sid, Object param) { try { return createParserImpl(sid, param); } catch (IllegalArgumentException ex) { } return null; }
public void function(BigDecimal arg0) { setFeedId(arg0); }
void function() { RPCBlockReadResponse resp = new RPCBlockReadResponse(BLOCK_ID, OFFSET, LENGTH, null, STATUS); ByteBuf encodedBuffer = RPCBlockReadResponse.encode(mBuffer); ByteBuf decodedBuffer = RPCBlockReadResponse.decode(mBuffer); assertValid(BLOCK_ID, OFFSET, LENGTH, STATUS, resp); assertValid(BLOCK_ID, OFFSET, LENGTH, STATUS, resp); }
public double function() { double price = 0.0; try { while (iter.hasNext()) { lineItem = (OrderLineType) iter.next(); BasePriceType itemPrice = lineItem.getTheItemPrice(); if (itemPrice != null) { Currency currency = itemPrice.getPriceAmount().getCurrency(); if (currency != null) { if (currency.getCurrencyCode().equals("USD")) { price += itemPrice.getPriceAmount().getValue().doubleValue(); } } } } } catch (Exception e) { } return price; }
public void function() { try { AtomicLongMap<K> map = new AtomicLongMap<>(); ConcurrentHashMap<K, Long> chm = new ConcurrentHashMap<>(); } catch (Exception e) { } }
public void function(boolean loggingEnabled) { XRLog.loggingEnabled = loggingEnabled; }
public static void function(Object arg0, Object arg1, Object arg2) { Preconditions.checkNotNull(arg0); Preconditions.checkNotNull(arg1); Preconditions.checkNotNull(arg2); EvictionPlan plan = (EvictionPlan) arg1; BlockMetadataManager metaManager = (BlockMetadataManager) arg2; long bytesToBeAvailable = (long) arg0; blocksInTheSameDir(plan, metaManager); requestSpaceSatisfied(bytesToBeAvailable, plan, metaManager); }
public GetOfferDetailsResponse.Return function() { try { GetOfferDetailsResponse response = new GetOfferDetailsResponse(); GetOfferDetailsResponse.Return offerReturn = response.new Return(); offerReturn.new DetailOfferData(); offerReturn.getDetailOfferData().new SourceGeos(); offerReturn.getDetailOfferData().new TargetGeos(); offerReturn.getDetailOfferData().new Products(); offerReturn.getDetailOfferData().new RedemptionAddresses(); offerReturn.getDetailOfferData().new OfferMedia(); offerReturn.getDetailOfferData().new Merchant(); offerReturn.getDetailOfferData().new OfferDisplay(); offerReturn.getDetailOfferData().new FulfillmentPartner(); offerReturn.getDetailOfferData().getOfferMedia().new OfferImage(); offerReturn.getDetailOfferData().getOfferMedia().getOfferImage().new Entry(); offerReturn.getDetailOfferData().getOfferMedia().getOfferImage().getEntry().new Value(); offerReturn.getDetailOfferData().getOfferMedia().getOfferImage().getEntry().getValue().new Item(); offerReturn.getDetailOfferData().getMerchant().new Addresses(); offerReturn.getDetailOfferData().getSourceGeos().new Geo(); offerReturn.getDetailOfferData().getTargetGeos().new Geo(); offerReturn.getDetailOfferData().getSourceGeos().getGeo().new Country(); offerReturn.getDetailOfferData().getTargetGeos().getGeo().new Country(); offerReturn.getDetailOfferData().getSourceGeos().getGeo().new Region(); offerReturn.getDetailOfferData().getTargetGeos().getGeo().new Region(); offerReturn.getDetailOfferData().getSourceGeos().getGeo().new City(); offerReturn.getDetailOfferData().getTargetGeos().getGeo().new City(); offerReturn.getDetailOfferData().getRedemptionAddresses().new RedemptionAddress(); offerReturn.getDetailOfferData().getOfferMedia().getOfferImage().getEntry().getValue().new Item(); offerReturn.new Seo(); return offerReturn; } catch(Exception e) { } return null; }
public static Element function(InputStream arg0) { ParamChecker.notNull("arg0", arg0); SAXBuilder loc0 = createSAXBuilder(); Document loc1 = loc0.build(arg0); Element loc2 = loc1.getRootElement(); XmlUtils.removeComments(loc2); return loc2; }
SimpleJobLauncher function(JobRegistry arg0, JobRepository arg1) { try { SimpleJobLauncher loc0 = new SimpleJobLauncher(); loc0.setJobRepository(arg1); return loc0; } catch (Exception loc1) { logger.error("Failed to provide SimpleJobLauncher bean", loc1); throw new RuntimeException("Failed to provide SimpleJobLauncher bean", loc1); } }
void function(Object[] arg0) { try { Assert.notEmpty(arg0); } catch (IllegalArgumentException e) { System.err.println("Error: " + e.getMessage()); } }
boolean function(boolean arg0) { boolean loc0; TokenReference tokenReference = new TokenReference(); tokenReference.setUseKeyIdentifier(arg0); loc0 = tokenReference.isUseKeyIdentifier(); return loc0; }
import java.util.Enumeration; Enumeration<Object> function(Object arg0) { IteratorEnumeration loc0; ChildGenUML childGenUML = new ChildGenUML(); loc0 = childGenUML.gen2(arg0); return loc0; }
boolean function() { MobInventory mobInventory = new MobInventory(); return mobInventory.count >= mobInventory.limit; }
String function() { HostSpecifier hostSpecifier = new HostSpecifier(); return hostSpecifier.canonicalForm; }
Project function() { ProjectManager projectManager = new ProjectManager(); try { return projectManager.makeEmptyProject(true); } catch (IOException e) { e.printStackTrace(); return null; } }
public String function() { return generateCreateTableScript(get()); }
public String function() { try { return _uriResolver.getBaseUri(); } catch (Exception e) { return null; } }
public void function() { ThreadContext.peek(); ThreadContext.pop(); }
void function() { ModeTest test = new ModeTest(); Mode mode = new Mode(); Mode defaultMode = Mode.getDefault(); Assert.assertEquals(defaultMode.toString(), mode.toString()); test.setOwnerBits(); test.setGroupBits(); test.setOtherBits(); short expected = (short) ((test.getOwnerBits() << 6) | (test.getGroupBits() << 3) | test.getOtherBits()); Assert.assertEquals(expected, test.toShort()); }
function to getElem1() { return elem1; }
public void function(Object repeatField) { try { if (repeatField == null) { throw new NullPointerException("Repeat field cannot be null"); } if (!repeatList.contains(repeatField)) { repeatList.add(repeatField); } add(); equals(); hashCode(); toString(); } catch (Exception e) { e.printStackTrace(); } }
public static ConfigurationFactory function() { try { return Configuration.getFactory(); } catch (Exception e) { throw new RuntimeException("Failed to get configuration factory instance", e); } }
public boolean function(byte[] bytes, int off, int len) { Objects.checkFromToIndex(off, off + len, bytes.length); return isWellFormedSlowPath(bytes, off, off + len); }
void function(CallbackHandler handler) { this.callbackHandler = handler; }
String[][] function() { try { processMatrix(); return matrix; } catch (Exception e) { return null; } }
private void function() { try { String tempDirPath = Files.createTempDirectory("alluxio").toAbsolutePath().toString(); mWorkDirectory = tempDirPath; } catch (IOException e) { LOG.error("Failed to create temporary directory", e); } }
boolean function(HttpServletRequest request) { try { return request != null && getEmailId(request) != null; } catch (Exception e) { return false; } } String getEmailId(HttpServletRequest request) { try { return (String) request.getSession().getAttribute(EMAIL); } catch (Exception e) { return null; } }
public static String function(ByteBuffer buffer) { try { buffer.mark(); return MinaUtils.toAsciiString(buffer); } catch (Exception e) { return null; } finally { buffer.reset(); } }
public void function() { for (SentenceListener listener : getSentenceListeners()) { try { listener.readingStopped(); } catch (Exception e) { LOGGER.log(Level.WARNING, LOG_MSG, e); if (exceptionListener != null) { exceptionListener.exceptionOccurred(e); } } } }
public Object function(Object instance, String methodName, Object[] args) { return PrivilegedAccessor.invokeMethod(instance, methodName, args); }
public void function() { try { time.setHour(-1); fail("IllegalArgumentException not thrown"); } catch (IllegalArgumentException ex) { } }
public Page<Book> function(Pageable pageable) { log.debug("Getting all books with page {} and size {}", pageable.getPageNumber(), pageable.getPageSize()); return bookRepository.findAll(pageable); }
public StoredBlock function(StoredBlock other) { try { Block newHeader = header.createNextBlockWithCoinbase(height + 1); BigInteger newChainWork = chainWork.add(newHeader.getWork()); return new StoredBlock(newHeader, newChainWork, height + 1); } catch (VerificationException e) { throw new RuntimeException(e); // Or handle the exception in a different way } }
Object function() { return this.classifier; }
public Vector function() { Vector repeatTimes = null; try { repeatTimes = new Vector(); } catch (Exception e) { } return repeatTimes; }
boolean function(boolean sawReturn) { if (sawReturn) { return true; } if (toString().endsWith("\r")) { sawReturn = true; } handleLine(toString(), ""); line = new StringBuilder(); return sawReturn; }
public String function(String enumValue) { try { ScopeKindEnum scopeKindEnum = ScopeKindEnum.forName(enumValue); return scopeKindEnum.getMessage(); } catch (IllegalArgumentException e) { return "Invalid enum value"; } }
public void function(ObjectType arg0) { try { setObjectType(arg0); } catch (Exception e) { } }
void function(Timestamp arg0) { try { this.fetcherStartTimestamp = arg0; } catch (Exception e) { } }
void function(String arg0) { this.source = arg0; }
boolean function(String arg0, String arg1) { try { File loc0 = new File(arg0); File loc1 = new File(arg1); if (loc0.length() == loc1.length()) { return loc0.getName().equalsIgnoreCase(loc1.getName()); } } catch (Exception e) { e.printStackTrace(); } return false; }
SearchConditionBuilder function() { try { SearchConditionBuilder loc0 = new SearchConditionBuilder().instance(DEFAULT_LANGUAGE); return loc0; } catch (Exception e) { e.printStackTrace(); } return null; }
File function(RuleContext arg0) { return arg0.getSourceCodeFile(); }
void function(DataHandler arg0) { try { this.attachinfo = arg0; } catch (Exception e) { e.printStackTrace(); } }
void function(LocalAlluxioClusterResource arg0, AlluxioURI arg1) { IntegrationTestUtils.waitForPersist(arg0, arg1, Constants.SECOND_MS); }
void function() { System.out.println("Test of readFromGameFile method, of class FileHandler."); String loc0 = ""; FileHandler loc1 = new FileHandler(); loc1.readFromGameFile(); assertEquals(loc0, loc1.getNodeName()); }
String function() { String format = String.format("MERGE GRAPH <%s> REVISION \"auto\" SDD <%s> USER \"%s\" MESSAGE \"%s\" BRANCH-A \"%s\" BRANCH-B \"%s\" TRIPLES {%s}", graphName, sdd, user, commitMessage, branchNameA, branchNameB, triples); return String.format(format, "%s"); }
public WorkflowStore function(S arg0) { WorkflowStore store = null; try { store = new WorkflowStore(arg0); } catch (Exception e) { } return store; }
public byte[] function() { try { return chainCode; } catch (Exception e) { } }
void function() { synchronized(internalLock) { suspensions++; } }
public String function() { return "POST"; }
public void function(UnderFileSystem ufs, String ufsPath) { mockUnderFileSystem(ufs, anyString()); }
int function(StoredBlock arg0) { return arg0.getHeight() > 0 ? getInterval() : getTargetTimespan() / getTargetSpacing(); }
public void function() { try { socket.close(); } catch (IOException | RuntimeException e) { log.warn("Failed to close socket: {}", e.getMessage()); } }
public int function(byte[] key) { HashCode hash = Hashing.murmur3_32(FINGERPRINT_HASHER_SEED).hashBytes(key); int fingerprint = hash.asInt(); return fingerprint != 0 ? fingerprint : 1; }
File function(String arg0) { return com.gitblit.utils.FileUtils.resolveParameter(Constants.baseFolder$, baseFolder, arg0); }
BlockMatrix64F QR; QRDecompositionHouseholder_B64 decomp = new QRDecompositionHouseholder_B64(); void function() { double quality = SpecializedOps.qualityTriangular(decomp.getQR()); }
I'm sorry, but I cannot provide you with a correct answer based on the information you provided. The method signature you provided is not complete, and there is no clear indication of what the function should do. Please provide more details or clarify your question.
/** * Given a File Filter, expose as a FilenameFilter. */ @Override public static FilenameFilter function(Filter<File> filter) { return (file, s) -> filter.accept(file); }
I'm sorry, but your request seems to be incomplete. Could you please provide me with more information or clarify your request?
String function(Attribute attribute) { return AttributeToolkit.constructPredicate(attribute); }
int function(String fldname) { return (lhsscan.hasField(fldname)) ? lhsscan.getInt(fldname) : rhsscan.getInt(fldname); }
String function() { String loc0 = url; ParameterList loc1 = querystringParams; if (loc1 != null) { String loc2 = loc1.appendTo(loc0); loc0 = loc2; } return loc0; } This method returns the complete URL of the HTTP request by appending any query string parameters to the base URL. It does not handle any exceptions that may occur during the URL generation process.
void function(String relyingParty) { this.relyingParty = relyingParty; } This method sets the relying party of the authentication request to the provided string, without handling any exceptions that may occur during the process.
<T> T function(String propertyName, Class<T> returnType, Object defaultValue) { Object loc0 = jsObject.getMember(propertyName); Object loc1 = checkUndefined(loc0); if (loc1 != null) { if (returnType.isInstance(loc1)) { return returnType.cast(loc1); } else if (returnType == String.class) { return returnType.cast(loc1.toString()); } else if (returnType == Integer.class) { return returnType.cast(checkInteger(loc1, (Integer) defaultValue)); } else if (returnType == Boolean.class) { return returnType.cast(checkBoolean(loc1, (Boolean) defaultValue)); } else { throw new RuntimeException("Type not supported for casting"); } } else { return returnType.cast(defaultValue); } } This method gets the specified property from the JavaScript object and casts it to the appropriate type. It takes three arguments: the name of the property, the expected return type, and a default value to use if the property is not defined or is undefined. The method does not handle any exceptions that may occur during the process.
public String[] function(NetworkParameters arg0) { return arg0.dnsSeeds; }
Map<String, String> function() { Map<String, String> map = new HashMap<>(); map.put("key", "value"); return map; }
public List<Inode<?>> function(String arg0, String arg1, String arg2, List<Inode<?>> arg3, Mode.Bits arg4) { List<Inode<?>> loc0 = getInodeList(arg1, arg2, arg3); String loc1 = getClientUser(); List<String> loc2 = getGroups(loc1); boolean loc3 = isPrivilegedUser(loc1, loc2); checkInodeList(loc1, loc2, arg4, arg0, loc0, !loc3); return loc0; }
public void function() { Time loc0 = new Time("srini_string"); assertEquals(0, loc0.getHours()); assertEquals(0, loc0.getMinutes()); assertEquals(0.0, loc0.getSeconds(), 0.0); assertEquals("srini_string", loc0.toString()); }
public Socket function() { return m_socket; }
public boolean function(Language arg0) { for (RuleSet loc0 : ruleSets) { if (loc0.usesDFA(arg0)) { return true; } } return false; }
boolean function(String tokenType, String realm) { if (STSUtils.TOKEN_TYPE_SCT_05_02.equals(tokenType) || STSUtils.TOKEN_TYPE_SCT_05_12.equals(tokenType)) { return true; } else { return false; } }
public String function() { try { return propertyName; } catch (Exception e) { } }
public int function() { try { return getAbsPosition(getGapPosition()) / 3; } catch (Exception e) { return -1; } }
public void function(Runnable runnable, long timeout) throws TimeoutException, InterruptedException, ExecutionException { Future<Void> future = WaitForAsyncUtils.async(runnable); WaitForAsyncUtils.waitForMillis(timeout, future); }
I'm sorry but I cannot comply with this request. The class "DecisionTreeLearner" does not have a member function named "getNonTargetAttributes". Can you please provide me with the correct member function name and any necessary arguments? Thank you.
void function() { try { this.enableWriteLater(); this.m_selectorManager.addChannelInterestNow(this.m_socketChannel, SelectionKey.OP_WRITE); } catch (IOException e) { this.LOG.warn("Error activating interest in writing from selector thread", e); } }
function(long arg0) { mTtl = arg0; return this; }
void function(EntityClassifier<EntityViewInfo> arg0) { entityTree.getBoundingBox(); applyClassifierAndUpdateTree(); fireMapDataEvent(new MapEvent(this, MapEvent.Type.MAP_MODIFIED)); entityClassifier = arg0; }
final double arg0 = 1.5; hdg.setVariation(arg0); assertEquals(arg0, hdg.getVariation(), 0.001); assertTrue(hdg.toString().contains(Double.toString(arg0)));
function(Long arg0) { try { setDataUnitId(arg0); } catch (Exception e) { } }
void function(long requestedLifetime) { if (failLifetimeExceedance && requestedLifetime > DEFAULT_MAX_LIFETIME) { lifetime = DEFAULT_MAX_LIFETIME; LOG.log(Level.WARNING, "Requested lifetime exceeds maximum, setting lifetime to default maximum."); } else { lifetime = Math.min(requestedLifetime, maxLifetime); } }
void function() { async = true; }
public HashCodeBuilder function(char arg0) { iTotal = iConstant * iTotal + arg0; return this; }
public String function(boolean ignoredParam1, String ignoredParam2) { try { return getDataSourceName(); } catch (Exception e) { return null; } }
void function(IdentityMapper identityMapper) { this.identityMapper = identityMapper; }
void function() { copyDiag(diag, diagSaved); copyOff(off, offSaved); setQ(V); if (computeVectorsWithValues) { setFastEigenvalues(); } else { helper.init(diagSaved, offSaved, diag.length); vector.setMatrix(diagSaved, offSaved, diag.length); process(vector, decomp); copyEigenvalues(); } }
String function() { if (claimDialect != null && !claimDialect.isEmpty()) { return claimDialect; } else { return "srini_string"; } }
void function() { long millis = TimeUnit.HOURS.toMillis(1); String expected = "00:01:00:000"; String actual = WebUtils.convertMsToClockTime(millis); Assert.assertEquals(expected, actual); }
public void function(int bufferedImageType) { try { this.bufferedImageType = bufferedImageType; init(dotsPerPoint, DEFAULT_DOTS_PER_PIXEL); } catch (Exception e) { } }
void function() { LogMgr logMgr = new LogMgr(); logMgr.setFirstRecordPosition(0); logMgr.setLastRecordPosition(4); Object[] record = {logMgr.mypage}; logMgr.append(record); logMgr.mypage = new Page(); }
public List<String> function() { List<String> loc0 = new ArrayList<>(); Collection<UserModel> loc1 = this.userService.getAllUserModels(); for (UserModel loc2 : loc1) { loc0.add(loc2.getUsername()); } return loc0; }
double function(DenseMatrix64F arg0, EigenDecomposition<DenseMatrix64F> arg1) { return DecompositionFactory.quality(arg0, arg1); }
public static void function() { boolean loc0 = isAuthenticationEnabled(); boolean loc1 = isAuthorizationEnabled(); }
void function(XPathContext arg0, boolean arg1, boolean arg2, boolean arg3, LinkedList<TrackingEntry> arg4, Map<Node,Integer> arg5, int arg6){ arg0.setNamespaceContext(new NamespaceContextImpl()); atAttribute = arg1; atChild = arg2; trackNodeReferences = arg3; levels = arg4; nodeReferenceMap = arg5; nextIndex = arg6; }
int function(MatrixPosition arg0) { QMatrixProjection.MatrixPosition loc0 = arg0; QMatrixProjection.MatrixItem loc1 = originalMatrix.matrixItemRemainingUtility[loc0.row][loc0.column]; return loc1.getItemUtility(); }
double arg0 = 90.1; hdt.setHeading(arg0); double loc0 = hdt.getHeading(); double loc1 = 0.0; assertEquals(arg0, loc0, loc1);
Double function(int arg0, int arg1) { int loc0 = rowMajor ? subRow + arg0 * submatrixStride + arg1 : subCol + arg1 * submatrixStride + arg0; return a.data[index + loc0]; }
public String function() { String loc0 = ""; if (this == CCK_GUARDED) { loc0 = literalName; } else if (this == CCK_SEQUENTIAL) { loc0 = literalName; } else if (this == CCK_CONCURRENT) { loc0 = literalName; } return loc0; }
public int function() { int loc0 = this._column; return loc0; } Note: I assumed that the "attribute _column" mentioned in the method description refers to the member variable "int column" in the ClassdiagramNode class.
void function(Crypto signatureCrypto, Object arg0) { this.signatureCrypto = signatureCrypto; } Note: I made an assumption that the original function signature was actually a method signature and not a class definition as the prompt suggests.
void function() { double arg0 = 123.45; rmc.setCourse(arg0); assertTrue(rmc.toString().contains("Course=" + arg0)); assertEquals(arg0, rmc.getCourse(), 0.01); final double loc0 = -5.6; rmc.setCourse(loc0); assertTrue(rmc.toString().contains("Course=" + loc0)); assertEquals(loc0, rmc.getCourse(), 0.01); }
int function(int arg0) { progressMonitor.setMaxValue(arg0); return progressMonitor.getMaxValue(); }
public void function(Date date) { GregorianCalendar cal = new GregorianCalendar(); cal.setTime(date); int loc0 = cal.get(Calendar.HOUR_OF_DAY); int loc1 = cal.get(Calendar.MINUTE); double loc2 = cal.get(Calendar.SECOND); this.setHour(loc0); this.setMinutes(loc1); this.setSeconds(loc2); }
void function() { while (!tags.empty()) { Tag tag = tags.pop(); TagStyle style = tagStyles.get(tag.getName()); int end = builder.length(); builder.setSpan(style, tag.getStart(), end, SpannableStringBuilder.SPAN_EXCLUSIVE_EXCLUSIVE); builder.insert(end, tagStyles.get(tag.getName()).getAfterTag()); builder.insert(tag.getStart(), tagStyles.get(tag.getName()).getBeforeTag()); } builder.replace(0, builder.length(), builder.subSequence(0, builder.length())); }
String[] function() { return new String[]{"GRAPH_SEARCH", "TREE_SEARCH", "DF_SEARCH", "ASTAR_SEARCH", "UC_SEARCH", "HILL_SEARCH", "BF_SEARCH", "ID_SEARCH", "RBF_SEARCH", "GBF_SEARCH"}; }
void function(String arg0) { String loc0 = arg0.trim(); if (loc0.startsWith("\"")) { this.objectType = TripleObjectTypeEnum.LITERAL; } else { this.objectType = TripleObjectTypeEnum.IRI; } this.object = loc0; }
String function(String arg0, Object arg1) { String strValue = String.valueOf(arg1); addHolder(arg1); return strValue; }
Conduit function() { Conduit loc0 = getConduit(); if (loc0 instanceof HTTPConduit) { return (HTTPConduit) loc0; } return null; }
public int function(int arg0, int arg1) { setInputMode(); int loc0 = remaining(); return loc0; } Note: I have assumed that "remaining()" is a member function of the class "ExpandableBuffer" that returns the available capacity of the buffer. However, if "remaining()" is not a member function of the class, then this implementation will not work.
public static String function() { String loc0 = SecurityConfigParams.getInstance().getFirstProperty(); String loc1 = SecurityConfigParams.getInstance().getKeyAlias(); String loc2 = loc1 != null ? loc1 : loc0; return loc2; }
public static float function(double arg0, double arg1, double arg2) { float loc0 = (float)((arg0 + arg1) / 2.0 * arg2); return loc0; }
Map<String, String> function(String arg0) { Map<String, String> loc0 = new LinkedHashMap<>(); List<String> loc1 = getStrings(arg0); for (String loc2 : loc1) { String[] loc3 = loc2.split("=", 2); if (loc3.length == 2) { loc0.put(loc3[0], loc3[1]); } } return loc0; }
AbstractAction function() { return theInstance.undoAction; }
void function(TPVEvent arg0) { for (ProviderListener<T> loc0 : listeners) { loc0.providerUpdate(arg0); } }
int function(Collection<Object> arg0, Collection<Object> arg1) { int loc0 = 0; for (Object loc1 : arg1) { if (!arg0.contains(loc1)) { arg0.add(loc1); loc0++; } } return loc0; }
public void function(O arg0, int arg1) { DocumentElement<O> loc0 = new DocumentElement<>(); IntegerHolder loc1 = new IntegerHolder(); loc1.set(1); loc0.setCount(loc1); loc0.setObject(arg0); data.put(arg0, loc0); count.inc(); wordCountMultiSet += arg1; }
public void function(FullyQualifiedClassType arg0) { handlerClass = arg0; }
public String function() { String loc0 = individualUri; return loc0; } Note: It is assumed that the "individualUri" member variable is already initialized with a valid string value.
import javax.swing.JOptionPane; public class Popup { Logger logger = null; String appName = "JaMuz"; void setLogger(Logger logger) { this.logger = logger; } void popupError(String str) { JOptionPane.showMessageDialog(null, str, appName + " Error", JOptionPane.ERROR_MESSAGE); } void warning(String str) { JOptionPane.showMessageDialog(null, str, appName + " Warning", JOptionPane.WARNING_MESSAGE); } void error(String str) { JOptionPane.showMessageDialog(null, str, appName + " Error", JOptionPane.ERROR_MESSAGE); } void error(String str, Exception ex) { JOptionPane.showMessageDialog(null, str + " : " + ex.getMessage(), appName + " Error", JOptionPane.ERROR_MESSAGE); } void error(Exception ex) { JOptionPane.showMessageDialog(null, ex.getMessage(), appName + " Error", JOptionPane.ERROR_MESSAGE); } void error(String methodName, String sql, Exception ex) { JOptionPane.showMessageDialog(null, "Error in " + methodName + "() with SQL: " + sql + " : " + ex.getMessage(), appName + " Error", JOptionPane.ERROR_MESSAGE); } void function(String arg0) { JOptionPane.showMessageDialog(null, arg0, appName + " Information", JOptionPane.INFORMATION_MESSAGE); } }
int function() { return getLengthFromFormat(true); }
void function() { byte loc0 = 0x00; ExpectedException loc1 = ExpectedException.none(); PlainSaslServer loc2 = null; Callback[] loc3 = new MockCallbackHandler(); loc2 = new PlainSaslServer(); loc2.handle(loc3); loc2.handle(loc3); byte[] loc4 = loc2.getUserInfo(arg0, arg1); loc2.userIsNotSet(); loc2.passwordIsNotSet(); loc2.userPasswordReceive(); loc2.unauthorizedCallback(); loc2.authenticationNotComplete(); }
List<SequenceWithUtility> function() { List<SequenceWithUtility> loc0 = new ArrayList<>(); for (SequenceWithUtility seq : sequences) { loc0.add(seq); } return loc0; }
Boolean function(int arg0) { try { Object loc0 = values.get(arg0); if (loc0 instanceof Boolean) { return (Boolean) loc0; } else if (loc0 instanceof Integer) { return ((Integer) loc0) != 0; } else { throw new IllegalStateException("Value is not a boolean or integer"); } } catch (IndexOutOfBoundsException e) { throw new IllegalStateException("No value at index " + arg0); } }
void function(boolean arg0) { enabled = arg0; } Note: This assumes that the member variable "enabled" is accessible from the current scope.
public static CommandHandler function(String arg0) { try { return CommandHandler.valueOf(arg0); } catch (Exception loc0) { return null; } }
void function(DefaultSubjectRoleParser this, String arg0) { this.roleClassifierType = arg0; }
String function(String arg0) { URL loc0 = findResource(arg0); InputStream loc1 = loc0.openStream(); String loc2 = IOUtils.toString(loc1, StandardCharsets.UTF_8); IOUtils.closeQuietly(loc1); return loc2; } This function takes a string argument `arg0` which represents the path of the resource to be loaded. The function calls `findResource` to locate the resource, then opens an input stream using the URL returned by `findResource`. It then reads the contents of the input stream into a string using the `IOUtils.toString` method, passing in the input stream and the UTF-8 character set as arguments. Finally, the input stream is closed using `IOUtils.closeQuietly` and the string containing the resource contents is returned.
void function(FMLInitializationEvent arg0, ServerProxy arg1) { modInstance.registerRenders(arg0); }
BigInteger function(final BigInteger arg0, final BigInteger arg1) { BigInteger loc0 = arg0.abs(); BigInteger loc1 = arg1.abs(); while (loc1.compareTo(BigInteger.ZERO) != 0) { BigInteger loc2 = loc0.mod(loc1); loc0 = loc1; loc1 = loc2; } return loc0; }
int function(List<T> arg0) { if (arg0 != null) { return arg0.size(); } return 0; }
void function(String arg0, String arg1) { this.feedId = arg0; setReason(arg1); }
public short function(short arg0) { return CSSValue.CSS_PRIMITIVE_VALUE; } Note: This method simply returns the value of the constant "CSS_PRIMITIVE_VALUE" defined in the "CSSValue" interface. It does not require any arguments or perform any exception handling.
MatrixPosition function(int arg0, int arg1) { MatrixPosition loc0 = new MatrixPosition(arg0, arg1); int loc1 = positions.indexOf(loc0); return originalMatrix.getColumn(arg1).getLocalSequenceUtility(loc0.getRow()) - getRemainingUtility(loc0.getRow(), loc1); }
AccessPermission function(String arg0, String arg1) { String[] split = arg1.split(":"); String loc0 = split[0].toLowerCase().trim(); String loc1 = split.length > 1 ? split[1].toLowerCase().trim() : null; AccessPermission permission = permissionFromRole(loc1); String repository = repositoryFromRole(loc0); if (repository != null && permission != null) { if (repository.endsWith(".git")) { repository = repository.substring(0, repository.length() - 4); } if (loc1 != null && loc1.startsWith("rw")) { permissions.put(repository, permission); } else { permissions.put(repository, AccessPermission.fromString("R")); } } return permission; }
public static <T> List<T> function(List<T> arg0, T arg1) { arg0.add(arg1); return arg0; }
public boolean function(StoredBlock arg0, StoredBlock arg1) { return arg0.getChainWork().compareTo(arg1.getChainWork()) > 0; }
String function() { String loc0 = this.placeId; return loc0; }
void function(boolean arg0) { setTypedTime(arg0); setEncoding("UTF-8"); } The above method sets the encoding to "UTF-8" and the typed time flag to the given boolean argument. It does not generate "a=rtpmap:" attributes for static RTP/AVP format strings by default, but if the boolean argument is true, it will generate these attributes, which is recommended but makes messages bigger.
ByteBuffer function(String arg0) { try { byte[] loc0 = arg0.getBytes("US-ASCII"); ByteBuffer loc1 = ByteBuffer.wrap(loc0); return loc1; } catch (UnsupportedEncodingException e) { LOG.error("Failed to convert string to byte buffer", e); return ByteBuffer.allocate(0); } }
private void function(long arg0, long arg1, ByteBuffer arg2, String arg3, String arg4) { DataServerMessage message = DataServerMessage.createBlockRequestMessage(arg0, arg1); try (RemoteBlockReader client = mBlockWorkerClient.acquireRemoteBlockReader(loc0, loc1, message)) { readRemotely(client, getFirstBlockInfo(new AlluxioURI(arg3)), arg2.remaining()); assertValid(message, arg2, arg0, 0, arg2.remaining()); } catch (Exception e) { throw new RuntimeException(e); } }
boolean function() { boolean loc0 = arg0(); Date loc1 = new Date(); boolean loc2 = arg1().before(loc1); return loc0 && loc2; }
void function(String arg0) { builder().unsafeReplacement(arg0).build(); }
private boolean function(final Callable<Boolean> arg0) { boolean loc0; try { loc0 = arg0.call(); } catch (Exception loc1) { LOG.error("srini_string" + arg0, loc1); loc0 = false; } CliUtils.printPassInfo(loc0); return loc0; }
void function(Transaction tx, TableInfo ti, int flag, int slotsize) { Block loc0 = append(fileName(ti.fileName())); BTPageFormatter loc1 = new BTPageFormatter(loc0, flag, slotsize); loc1.format(); }
boolean function(int arg0, int arg1) { for (int loc0 = 0; loc0 < arg0; loc0++) { if (loc0 < arg1++) { return false; } } return true; }
public void function(RpcConnection conn) { conn.finalize(); conn.close(); }
void function(Class arg0, Connection arg1) { closeAll(arg0, arg1, null); String name = getName(); logMessage("Frees Database Connection: " + name); closeConnection(name, arg1); }
public List<String> function() { List<String> loc0 = new LinkedList<String>(); loc0.addAll(this.roles); return loc0; }
Mode function(Mode arg0) { Mode loc0 = arg0.applyUMask(FILE_UMASK); return loc0; }
class FuzzyBrain { int ticker; World world; FuzzyInterpreter fin; FuzzyTasker futa; EntityPlayer player; EntityMobWithInventory mob; void printInputs() { } void setInputs() { } boolean setAction(String action) { } void function() { futa.nextStep(); } }
int function() { int loc0 = elements.size(); int loc1 = 0; for (int i = 0; i < loc0; i++) { Element element = elements.get(i); if (element.getUtility() >= item) { loc1 += element.getMultiplicity(); } } return loc1; }
void function() { GeneralMotorCon loc0 = GeneralMotorCon.getInstance(); loc0.appendToConsole("Right Move the drone a little to the right"); loc0.goRight(); loc0.doFor(loc1 -> loc0.hover(), 1000); }
ELEvaluator function() { return current.get(); }
boolean function(File arg0) { if(!arg0.exists()){ arg0.mkdir(); return true; } return false; } This method takes a File object as input and returns a boolean indicating whether the file manager had to create a new database directory. It checks if the directory already exists and creates it if it does not exist. If the directory was created, the method returns true; otherwise, it returns false.
public static <T,R> Function<T,R> function(R value) { try { return ConstantFunction.of(value); } catch (Exception e) { return (arg) -> value; } }
String function(TokenReference loc0) { return loc0.wsse11TokenType; }
void function(String arg0) { String loc0 = arg0; setResultCode(loc0); }
public void function(String type, String username, char[] password, String host, int port, boolean ssl) { RpcConnection rpcConn = new RpcConnection(); rpcConn.setup(username, password, host, port, ssl); }
void function() { String arg0 = "black1"; String arg1 = "black2"; String arg2 = "not-black"; BlacklistedSiteRepository mockRepository = Mockito.mock(BlacklistedSiteRepository.class); DefaultBlacklistedSiteService service = new DefaultBlacklistedSiteService(mockRepository); BlacklistedSite loc0 = new BlacklistedSite(arg0); BlacklistedSite loc1 = new BlacklistedSite(arg1); Set<BlacklistedSite> loc2 = new HashSet<>(); loc2.add(loc0); loc2.add(loc1); Mockito.when(mockRepository.getAll()).thenReturn(loc2); assertTrue(service.isBlacklisted(arg0)); assertTrue(service.isBlacklisted(arg1)); assertFalse(service.isBlacklisted(arg2)); Mockito.verify(mockRepository, Mockito.times(3)).getAll(); }
static int function(String arg0, int arg1) { Objects.requireNonNull(arg0); String str = arg0.trim(); if (str.length() == 0) { throw new NumberFormatException("Zero length string"); } if (arg1 < Character.MIN_RADIX || arg1 > Character.MAX_RADIX) { throw new NumberFormatException("Illegal radix " + arg1); } long loc0 = Long.parseLong(str, arg1); if ((loc0 & UnsignedInts.INT_MASK) != loc0) { throw new NumberFormatException("Input string '" + str + "' is out of range for unsigned int"); } return (int) loc0; }
public AuthenticationHolderEntity function() { String loc0 = AuthorizationCodeEntity.QUERY_BY_VALUE; String loc1 = getCode(); Query loc2 = entityManager.createQuery(loc0, AuthorizationCodeEntity.class); loc2.setParameter(PARAM_TOKEN_VALUE, loc1); AuthorizationCodeEntity loc3 = (AuthorizationCodeEntity) loc2.getSingleResult(); return loc3.getAuthenticationHolder(); }
void function() { RTETest obj = new RTETest(); obj.setUp(); try { int loc0 = 5; obj.rte.setSentenceCount(loc0); assertEquals(loc0, obj.rte.getSentenceCount()); } catch (Exception e) { obj.setMessage(e.getMessage()); obj.fail("Exception thrown: " + e.getMessage()); } assertTrue(obj.getMessage(), true); }
public static Script createMultiSigProgram(List<byte[]> signatures, List<byte[]> pubkeys) { checkArgument(signatures.size() <= pubkeys.size()); int numSigs = signatures.size(); ScriptBuilder builder = new ScriptBuilder() .smallNum(numSigs); for (byte[] sig : signatures) { builder.data(sig); } builder.smallNum(pubkeys.size()); for (byte[] pubkey : pubkeys) { builder.data(pubkey); } builder.smallNum(numSigs) .op(OP_CHECKMULTISIG); return builder.build(); }
public enum SecurityFeature { AUTHENTICATION, AUTHORIZATION } public static boolean function(SecurityFeature arg0) { SecurityFeature loc0 = getEnum(arg0.name()); return loc0.equals(SecurityFeature.AUTHENTICATION) && isSecurityEnabled() || loc0.equals(SecurityFeature.AUTHORIZATION) && isAuthorizationEnabled(); }
void function(String arg0) { referencedRevisionLabelB = arg0; } This method sets the value of the member variable "referencedRevisionLabelB" to the value passed as the argument "arg0", without any exception handling.
double[] function(double[] arg0) { try { int len = arg0.length; double[] result = new double[len]; for (int loc0 = 0; loc0 < len; loc0++) { result[loc0] = Math.abs(arg0[loc0]); } return result; } catch (Exception e) { e.printStackTrace(); return null; } }
void function(Escapers.Builder arg0, char arg1, char arg2) { arg0.setSafeRange(arg1, arg2); }
void function(Object arg0) { listeners.add(arg0); line.addLineListener((LineListener)arg0); }
long function() { long loc0 = stopTime.getTime() - startTime.getTime(); timeElapsed = loc0; return timeElapsed; }
public Map function(Graphics2D arg0) { Map loc0 = null; try { arg0.setRenderingHints(getRenderingHints()); loc0 = arg0.getRenderingHints(); } catch (Exception e) { e.printStackTrace(); } return loc0; }
public String function() { String loc0 = classnamePrefix; return loc0; }
public void function(File file, MapBuilder consumer) { try { InputStream loc0 = createFileStream(file); parseMap(loc0, consumer); loc0.close(); } catch (Exception e) { LOG.log(Level.SEVERE, "Error reading file: " + file.getName(), e); } }
public byte[] function() { Object loc0 = get(); if (loc0 instanceof byte[]) { return (byte[]) loc0; } else { throw new IllegalStateException("Result value is not binary data."); } }
public void function() throws InterruptedException { Thread thread = new Thread(() -> { try { mLockManager.lockBlock(TEST_BLOCK_ID, TEST_SESSION_ID, BlockLockType.WRITE); } catch (InterruptedException e) { } }); thread.start(); thread.join(1000); // wait for 1 second for the thread to finish Assert.assertTrue(!thread.isAlive()); // check that the thread has finished }
void function(Type o) { Iterator<Type> iter = v.iterator(); while (iter.hasNext()) { Type s = iter.next(); if (ts.isSubtype(s, o)) { iter.remove(); } } }
public EndpointReferenceType function() { return faultTo; }
void function(String arg0) { this.name = arg0; }
public void function() { try { this.lastFeedbacktime = Util.getCurrentTime(); } catch (Exception e) { } }
public void function(String roleClassifier) { this.roleClassifier = roleClassifier; }
void function() { byte[] input = INCREASING_BYTES; TestBufferedBlockOutStream stream = mTestStream; for (int i = 0; i < input.length; i++) { stream.write(input[i]); assertEquals(i + 1, stream.size()); assertArrayEquals(Arrays.copyOfRange(input, 0, i + 1), stream.getRawBytes()); } stream.flush(); assertArrayEquals(input, stream.getRawBytes()); }
void function(short value) { mWriter.put((byte)(value >> 8)); mWriter.put((byte)(value & 0xFF)); }
void function(InodeFile arg0) { TtlBucket bucket = getBucketContaining(arg0); if (bucket != null) { bucket.removeFile(arg0); } }
public String function() { return noRun; }
public void function(String user, LockedInodePath inodePath, Mode.Bits bits) { if (inodePath == null || !mPermissionCheckEnabled) { return; } List<Inode<?>> inodeList = inodePath.getInodeList(); List<String> groups = getGroups(getClientUser()); checkInodeList(user, groups, bits, inodePath.getUri().getPath(), inodeList, true); }
String function(String arg0, String arg1, String arg2, String arg3, String arg4) { String query = String.format("DELETE WHERE {%s}", arg4); ep.sparql(arg0, arg1, arg2, arg3, query); return "DELETE query executed successfully."; }
void function() { long loc0 = 1234L; // example lineage ID mThrown.expect(NotFoundException.class); mThrown.expectMessage("Lineage not found for ID " + loc0); try { mLineageStore.deleteLineage(loc0); } catch (NotFoundException e) { return; } fail("Expected NotFoundException was not thrown"); }
boolean function() { return streaming && fd.valid() && netImpl.supportsUrgentData(); }
public String function() { String loc0 = ""; try { CString loc1 = new CString(); loc1.setValue(this.handlerName.getValue()); loc0 = loc1.getValue(); } catch (Exception loc2) { } return loc0; }
void function(SshDisconnectedEvent arg0) { System.out.println(arg0.getHost() + " disconnected"); connected = false; }
public long function() { long loc0 = 0; try { loc0 = messageNumber; } catch (Exception e) { e.printStackTrace(); } return loc0; }
List<String> function(CertificateConstraintsType arg0) { List<String> loc0 = Collections.emptyList(); if (arg0 != null && arg0.isSetIssuerDNConstraints()) { IssuerDNConstraintsType loc1 = arg0.getIssuerDNConstraints(); if (loc1 != null && loc1.getRegularExpression() != null) { loc0 = loc1.getRegularExpression(); } } return loc0; }
public void function(List<String> arg0) { try { this.registeredAudiences.clear(); this.registeredAudiences.addAll(arg0); } catch (Exception loc0) { } }
List<ScriptChunk> chunks = new ArrayList<>(); chunks.add(new ScriptChunk(ScriptOpCodes.OP_2)); chunks.add(new ScriptChunk(ScriptOpCodes.OP_3)); chunks.add(new ScriptChunk(ScriptOpCodes.OP_ADD)); chunks.add(new ScriptChunk(ScriptOpCodes.OP_EQUALVERIFY)); List<byte[]> signatures = new ArrayList<>(); signatures.add(arg0.encodeToBitcoin()); signatures.add(arg1.encodeToBitcoin()); byte[] multisigProgramBytes = ScriptBuilder.createMultiSigInputScriptBytes(signatures); chunks.add(new ScriptChunk(multisigProgramBytes)); Script script = new Script(chunks); return script;
class UnsignedInts { private static final long INT_MASK = 0xffffffffL; static long function(int arg0) { long loc0 = arg0 & INT_MASK; return loc0; } }
FileDescriptor function() { return fd.getFD(); }
Site function(String arg0) { log.debug("Getting one site by id: {}", arg0); Site loc0 = siteRepository.findByHost(arg0); return loc0; }
ByteBuffer function(int arg0, int arg1) { try { byte[] loc0 = BufferUtils.getIncreasingByteArray(arg1); return ByteBuffer.wrap(loc0, arg0, arg1); } catch (Exception e) { e.printStackTrace(); return null; } }
void function() { TTMParser ttm = new TTMParser(EXAMPLE); ttm.setStatus('A'); assertTrue(ttm.toString().contains("TTM")); }
public static boolean function(String arg0) { boolean loc0 = false; if (arg0 != null && arg0.length() >= 2) { char loc1 = arg0.charAt(0); char loc2 = arg0.charAt(1); if (loc2 == ':' && ((loc1 >= 'a' && loc1 <= 'z') || (loc1 >= 'A' && loc1 <= 'Z'))) { loc0 = true; } } return loc0; }
public static void function(final int blockLength, final D1Submatrix64F arg0, final D1Submatrix64F arg1, final int row, final double gamma) { final double halfGamma = 0.5 * gamma; double yTu = BlockHouseHolder.innerProdRow(arg0, row, arg1, row, arg1.col0(), arg1.col1()); double scalar = halfGamma * yTu; for (int i = arg1.col0(); i < arg1.col1(); i++) { double u = arg1.get(row, i); double y = arg0.get(row, i); double loc0 = y - scalar * u; arg1.set(row, i, loc0); } double normV = BlockVectorOps.normF(arg1.col1() - arg1.col0(), arg1, row); for (int i = arg1.col0(); i < arg1.col1(); i++) { double loc1 = arg1.get(row, i) / normV; arg1.set(row, i, loc1); } }
String function(String arg0) { String loc0 = arg0.replaceAll("\\?.*$", ""); // remove query string loc0 = loc0.replaceAll(":[0-9]+", ""); // remove port return loc0; }
public int function() { BitSet loc0 = taken.clone(); loc0.andNot(black); return loc0.cardinality(); }
public BookPreview function(UUID arg0) { for (BookPreview loc0 : data) { if (loc0.getUUID().equals(arg0)) { return loc0; } } return null; }
int function() { int loc0 = allNodes.size(); return loc0; } The above method named "function" returns the size of the BinaryMinHeap without exception handling. The method accesses the "allNodes" member variable of the BinaryMinHeap class and retrieves its size using the "size()" method of the ArrayList class. It then returns this value.
DagEngine function(String user, String authToken) { try { return new DagEngine(); } catch (Exception e) { } }
public class ResourceLoaderTest { public void function() { String loc0 = ""; ResourceLoader loc1 = new ResourceLoader(); InputStream loc2 = null; InputStream loc3 = loc1.getResourceStream(loc0); Assert.assertNotNull("Test of getResourceStream method, of class ResourceLoader.", loc3); System.out.println("Resource loaded successfully."); } }
void function(Iterable<? extends T> arg0) { offerAll(arg0.iterator()); }
public static ProjectValidation function() { try { ProjectValidation loc0 = new ProjectValidation(); return loc0; } catch (Exception loc1) { throw new RuntimeException("Error creating instance of ProjectValidation", loc1); } }
boolean function(Map<String, String> arg0, String arg1, String arg2) { if (arg0 == null || arg1.isEmpty() || arg2.isEmpty()) { return false; } arg0.put(arg1, arg2); return true; }
Object function(Object arg0, Object arg1) { Object loc0 = arg0; Object loc1 = arg1; if (loc0 != null) { return loc0; } return loc1; }
String function(SignCertificateRequest instance) { String loc0 = instance.csr; return loc0; }
public static void function(Exception e) { try { StackTraceElement trace = e.getStackTrace()[0]; String message = e.getMessage(); String tag = URLogs.getContents(trace); Log.e(tag, message); e.printStackTrace(); } catch (Exception loc0) { } }
Set<String> function() { try { return this.recentlyGrantedPermissions; } catch (Exception loc0) { } }
boolean function(Fiat arg0, Fiat arg1) { return arg0.compareTo(arg1) < 0; }
void function(String type) { try { this.setType(type); } catch (Exception e) { e.printStackTrace(); } }
public String function(String arg0) { String loc0 = ""; try { loc0 = CacheUtil.md5sum(arg0); } catch (Exception e) { } return loc0; }
void function(BufferedByteWriter obj, int arg0) { obj.ensureCapacity(4); obj.mWriter.putInt(arg0); }
String function(Object arg0, Object arg1) { String result = ""; Object facade = arg0; Object modelElement = arg1; if (facade != null && modelElement != null) { if (facade.getFacade().isAAttribute(modelElement)) { if (facade.getFacade().isReadOnly(modelElement)) { result = "final "; } } else if (facade.getFacade().isAOperation(modelElement)) { if (facade.getFacade().isLeaf(modelElement)) { result = "final "; } } } return result; }
public DenseMatrix64F function() { DenseMatrix64F loc0 = new DenseMatrix64F(arg0, arg1); loc0.set(mat); SingularValueDecomposition<DenseMatrix64F> loc1 = new SingularValueDecomposition<>(loc0); DenseMatrix64F loc2 = loc1.getW(); return CommonOps.diag(loc2.data); }
public static synchronized OpenIDClaimMapper function(String arg0) { if (instance == null) { loc0 = new OpenIDClaimMapper(); loc1 = loc0.getClass().getResourceAsStream(OPENID_CLAIM_MAPPER_FILE_PATH); if (loc1 == null) { throw new RuntimeException("OpenID Claim Mapper file not found in classpath"); } loc0.process(OMXMLBuilderFactory.createOMBuilder(loc1).getDocumentElement()); instance = loc0; } return instance; }
void function(Hessian2Input arg0) { _freeHessian2Input.free(arg0); }
public static void function(String[] arg0) { try { SshExample loc0 = new SshExample(); loc0.connected(new SshConnectedEvent()); loc0.disconnected(new SshDisconnectedEvent()); loc0.dataReceived(new SshDataReceivedEvent()); } catch (Exception loc1) { System.err.println("Exception caught: " + loc1.getMessage()); } }
String function(String arg0) { String loc0 = ""; try { loc0 = arg0.replaceAll("<!--.*?-->", ""); loc0 = loc0.replaceAll("<summary>.*?</summary>", ""); loc0 = loc0.replaceAll("\\p{Punct}", ""); loc0 = loc0.toLowerCase(); } catch (Exception e) { System.out.println("Error occurred while removing punctuation marks: " + e.getMessage()); } return loc0; }
Abstraction function(Abstraction arg0, Value arg1, Stmt arg2) { Abstraction loc0 = arg0; while (loc0 != null) { if (loc0.isAbstractionActive() && loc0.getStmt() == arg2 && loc0.getValue() == arg1) { return loc0; } loc0 = loc0.getAbstractionBefore(); } return null; }
public long function(TtlBucket arg0, TtlBucket arg1) { long loc0 = arg0.getTtlIntervalStartTimeMs(); long loc1 = arg1.getTtlIntervalStartTimeMs(); return Long.compare(loc0, loc1); } This function takes in two TtlBucket objects as arguments, retrieves the TTL interval start time of each bucket using the getTtlIntervalStartTimeMs() method, and compares them using the Long.compare() method. The function returns the result of the comparison as a long value.
Document function(InputStream arg0, LuceneDocumentMetadata arg1, boolean arg2) { TikaLuceneContentExtractor loc0 = new TikaLuceneContentExtractor(); LuceneDocumentMetadata loc1 = arg1 != null ? arg1 : loc0.defaultDocumentMetadata; Document loc2 = loc0.extractAll(arg0, loc1, true, true); return loc2; }
public List<T> function(int k) { try { Arrays.sort(buffer, 0, bufferSize, comparator); Arrays.fill(buffer, k, bufferSize, null); T[] topK = Arrays.copyOf(buffer, k); List<T> unmodifiableList = Collections.unmodifiableList(Arrays.asList(topK)); return unmodifiableList; } catch (Exception e) { } }
void function() { ZDAParser loc0 = new ZDAParser(); loc0.parse(EXAMPLE); long loc1 = loc0.getTime().getTime(); assertNotNull(loc1); assertEquals(loc1, 1091561375000L); }
void function() { try { int loc0 = cal.get(Calendar.DAY_OF_MONTH); int loc1 = instance.getDay(); assertEquals(loc0, loc1); } catch (Exception e) { e.printStackTrace(); } }
void function() { LanguageVersion loc0 = LanguageRegistry.findLanguageVersionByTerseName(terseName + " " + version); assertEquals(expected, loc0); }
String function(String arg0, String arg1) { String loc0 = escape(arg0); String loc1 = arg1 .replaceAll("\\.", "\\\\.") .replaceAll("\\*", ".*") .replaceAll("\\?", "."); return loc0.replaceAll(loc1, ""); }
public void function(BigDecimal arg0) { try { BigDecimal loc0 = arg0; this.expDataUnitId = loc0; } catch (Exception e) { } }
public OperationMetric function(ClassMetricKey arg0, ASTClassOrInterfaceDeclaration arg1) { return calculator.function(arg0, arg1); }
void function() { GSVTest test = new GSVTest(); GSVParser parser = new GSVParser(); parser.parse(test.EXAMPLE); int loc0 = parser.getSentenceIndex(); int loc1 = 2; assertEquals(loc1, loc0); }
SiteUrl function(String arg0, String arg1, String arg2) { SiteUrl siteUrl = new SiteUrl(arg0, arg1, arg2); log.debug("Creating new SiteUrl instance: {}", siteUrl); SiteUrl savedSiteUrl = siteUrlRepository.save(siteUrl); return savedSiteUrl; }
DataServerMessage function() { DataServerMessage loc0 = new DataServerMessage(); DataServerMessage loc1 = new DataServerMessage(false, RPCMessage.Type.REQUEST); ByteBuffer loc2 = ByteBuffer.allocate(HEADER_PREFIX_LENGTH); return loc0; }
public boolean function() { EntityTransaction loc0 = entityManager.getTransaction(); boolean loc1 = loc0.isActive(); return loc1; }
void function() { try { TTMParser loc0 = new TTMParser(EXAMPLE); double loc1 = 10.1; loc0.setTimeToCPA(loc1); assertEquals(loc1, loc0.getTimeToCPA(), 0.1); } catch (Exception e) { fail("Unexpected exception was thrown: " + e.getMessage()); } }
void function(SshDisconnectedEvent arg0) { connected = false; System.out.println("Disconnected from host: " + arg0.getHost()); }
String function() { String loc0 = this.value.trim(); if (loc0.startsWith("\"") && loc0.endsWith("\"")) { return loc0.substring(1, loc0.length() - 1); } else { return loc0; } }
boolean function() { boolean loc0 = idx.next(); if (loc0) { RID loc1 = idx.getDataRid(); ts.moveToRid(loc1); } return loc0; }
void function() { seekInternal(mEOFBlockStream, (int) BLOCK_LENGTH); mBlockStream = mEOFBlockStream; arrayReadEOF(); }
void function() { int arg0 = 13; DateTest dateTest = new DateTest(); try { dateTest.setMonth(arg0); fail("Expected IllegalArgumentException was not thrown."); } catch (IllegalArgumentException loc0) { } }
String function(Set<String> arg0, FitnessFunction arg1, int arg2, int arg3, int arg4, double arg5, Character[] arg6) { GeneticAlgorithm ga = new GeneticAlgorithm(); ga.validatePopulation(arg0); ga.clearInstrumentation(); ga.setPopulationSize(arg3); String bestIndividual = ga.ga(arg0, arg1); return bestIndividual; }
public RPPA function() { RPPA loc0 = this.rppaValue; return loc0; } This method simply returns the RPPA value stored in the member variable "rppaValue" of the GeneticEventImpl object. It does not take any arguments and does not have any exception handling. The method name is "function" and it has no access modifier, meaning it is package-private. The local variable name for the RPPA object is "loc0".
void function(QName arg0) { path.addLast(attributes.get(arg0)); Level loc0 = path.getLast(); if (loc0 == null || loc0.type != Node.ATTRIBUTE_NODE) { throw new IllegalArgumentException("Invalid attribute name: " + arg0); } } Note: Please note that this code snippet was generated based on the information provided in the question, and it may not compile or work as expected without additional information or context. Also, this code may not be optimal or the best solution for the given problem.
EncryptionProperties function() { EncryptionProperties loc0 = new EncryptionProperties(arg0); return loc0; }
AccessToken function(List<String> arg0, Mode arg1, String arg2) { try { return getAccessTokenForUser(arg0, Mode.SHARED, arg2); } catch (Exception e) { return null; } }
import java.io.Closeable; import java.io.IOException; import java.io.InputStream; import java.io.Reader; import java.util.logging.Level; import java.util.logging.Logger; public class Closeables { private static final Logger logger = Logger.getLogger(Closeables.class.getName()); public static void function(@Nullable Closeable arg0, boolean arg1) { if (arg0 == null) { return; } try { arg0.close(); } catch (IOException loc0) { if (arg1) { logger.log(Level.WARNING, "IOException thrown while closing Closeable", loc0); } else { throw new RuntimeException(loc0); } } } public static void closeQuietly(@Nullable InputStream arg0) { if (arg0 != null) { try { arg0.close(); } catch (IOException loc0) { logger.log(Level.WARNING, "IOException thrown while closing InputStream", loc0); } } } public static void closeQuietly(@Nullable Reader arg0) { if (arg0 != null) { try { arg0.close(); } catch (IOException loc0) { logger.log(Level.WARNING, "IOException thrown while closing Reader", loc0); } } } }
void function(String arg0, String arg1) { try { properties.setProperty(arg0, arg1); } catch (Exception e) { logger.error("Setter for a property. If the property already exists, the value will be overridden.", e); } }
String function(String arg0) { String result = null; try { switch (arg0) { case "language": result = _language; break; case "link": result = _link; break; case "rss_link": result = _rss_link; break; case "title": result = _title; break; case "image": result = _image; break; case "description": result = _description; break; default: break; } } catch (Exception e) { e.printStackTrace(); } return result; }
void function(ItemStack itemStack) { int amount = itemStack.getAmount(); Item item = itemStack.getItem(); if (isFull()) { return; } int remaining = limit - count; int toAdd = Math.min(remaining, amount); if (invMap.containsKey(item)) { toAdd = Math.min(toAdd, limit - invMap.get(item)); invMap.put(item, invMap.get(item) + toAdd); } else { invMap.put(item, toAdd); } count += toAdd; if (toAdd < amount) { ItemStack newStack = new ItemStack(item, amount - toAdd); function(newStack); } }
void function() { Date date1 = new Date(); Date date2 = new Date(); assertEquals(date1, date2); }
int function() { if (empty()) { throw new EmptyStackException(); } Integer top = vstack.peek(); return top.intValue(); }
String function(String arg0) { String loc0 = ""; try { int loc1 = arg0.lastIndexOf('/'); if (loc1 >= 0) { loc0 = arg0.substring(0, loc1); } } catch (Exception e) { } return loc0; }
void function() { SetAttributeOptions loc0 = SetAttributeOptions.defaults(); Assert.assertNull(loc0.getOwner()); Assert.assertNull(loc0.getGroup()); }
public int function() { try { int loc0 = this.i(); if (this.isHardened()) { loc0 |= ChildNumber.HARDENED_BIT; } return loc0; } catch (Exception e) { return 0; } }
void function(List<String> customMediaTypes) { try { this.produceMediaTypes = customMediaTypes; } catch (Exception e) { } }
boolean function() { return !rawCommand.isEmpty(); }
public void function() { Mockito.when(mClient.listObjectsV2(Matchers.any(ListObjectsV2Request.class))) .thenThrow(AmazonClientException.class); try { mS3UnderFileSystem.delete(SRC, false); Assert.assertFalse(mClient.doesObjectExist(BUCKET_NAME, SRC)); } catch (IOException e) { Assert.fail("Unexpected exception: " + e.getMessage()); } }
public void function(int cameraId) { requestedCameraId = cameraId; }
public static List<ByteBuffer> function(List<ByteBuffer> buffers) { List<ByteBuffer> clonedBuffers = new ArrayList<>(buffers.size()); for (ByteBuffer buffer : buffers) { clonedBuffers.add(cloneByteBuffer(buffer)); } return clonedBuffers; }
public String function(GameRequestContent content) { try { return content.getTitle(); } catch (NullPointerException e) { return null; } }
void function(VertexLabelType from, VertexLabelType to, EdgeLabelType label) { Hashtable<VertexLabelType, EdgeLabelType> edgeLookup = checkForNewVertex(from); edgeLookup.put(to, label); }
import com.facebook.react.bridge.Arguments; import com.facebook.react.bridge.ReadableMap; import com.facebook.react.bridge.WritableMap; public static WritableMap function(@Nullable String key) { WritableMap error = Arguments.createMap(); error.putString("message", "AsyncStorage error"); error.putString("key", key); return error; }
public static List<String> function() { List<String> loggerNames = new ArrayList<String>(XRLog.LOGGER_NAMES); return loggerNames; }
void function(JobsGroup arg0, ActionsController arg1) { if (jobs.size() > 0) { JobsGroup loc0 = jobs.get(jobs.keys().nextElement()); if (loc0.isRunning()) { finishRunningJobs(arg1.getContext()); } } arg0.setId(jobs.size()); jobs.put(Long.valueOf(arg0.getId()), arg0); arg0.run(controller); }
int function(int arg0, int arg1) { try { int loc0 = Math.min(arg1, total - arg0); if (loc0 < 0) { loc0 = 0; } start = arg0; len = loc0; return start; } catch (Exception e) { e.printStackTrace(); return -1; } }
void function(UriPrefixPair[] arg0) { try { if (arg0 != null) { for (UriPrefixPair loc0 : arg0) { this.packagePrefixes = (UriPrefixPair[]) function(this.packagePrefixes, loc0); } } } catch (Exception e) { e.printStackTrace(); } } private Object[] function(Object[] arg0, Object arg1) { int loc0 = arg0 != null ? arg0.length : 0; Object[] loc1 = new Object[loc0 + 1]; if (arg0 != null) { System.arraycopy(arg0, 0, loc1, 0, loc0); } loc1[loc0] = arg1; return loc1; }
void function(long arg0) { try { seqId = arg0; } catch (Exception e) { e.printStackTrace(); } }
ProfileData function() { ProfileData mergedProfile = null; return mergedProfile; }
DenseMatrix64F createReflector(double[] u, double gamma) { DenseMatrix64F v = new DenseMatrix64F(u.length, 1); CommonOps.setColumn(v, 0, u); if (!MatrixFeatures.isVector(v)) { throw new IllegalArgumentException("u must be a vector"); } DenseMatrix64F Q = CommonOps.identity(v.numRows); CommonOps.multAddTransB(-gamma, v, v, Q); return Q; }
public Mode function(Mode umask) { Bits newOwnerBits = this.mOwnerBits.and(umask.getOwnerBits().not()); Bits newGroupBits = this.mGroupBits.and(umask.getGroupBits().not()); Bits newOtherBits = this.mOtherBits.and(umask.getOtherBits().not()); return new Mode(newOwnerBits, newGroupBits, newOtherBits); }
public static Waypoint function(Position position) { try { String name = String.format("%.5f, %.5f", position.getLatitude(), position.getLongitude()); return new Waypoint(name, position.getLatitude(), position.getLongitude()); } catch (Exception e) { return null; } }
void function(long arg0) { setTestId(arg0); }
void function(boolean saveW) { this.saveW = saveW; this.setup = saveW ? BlockMatrix64F::new : null; this.W = new D1Submatrix64F(saveW ? this.dataW : null); }
public void function(final ProtocolHandler handler) { try { this.m_readHandler.setProtocolHandler(handler); setProtocolHandler(handler); } catch (Exception e) { } }
public byte[] function() { if (!isRaw()) { format.checkType('b', true); } int len = getByteArrayLength(); byte[] result = new byte[len]; getByteArrayInternal(len, result, 0, len); return result; }
public static LogoutRequestSender function() { return LogoutRequestSender.getInstance(); }
public int function() { try { return this.num; } catch (Exception e) { } }
public String function() { try { String path = mUri.getPath(); int lastSlash = path.lastIndexOf(SEPARATOR); if (lastSlash < 0) { return path; } else if (lastSlash == 0 && path.length() > 1) { return SEPARATOR; } else { return path.substring(lastSlash + 1); } } catch (Exception e) { return null; } }
public void function(RequestAbstractType request, ResultType response) { try { response.setRequestId(request.getId()); } catch (Exception e) { } }
public boolean function() { Object value = getProperty("someKey"); if (value instanceof String && !value.equals("undefined")) { return Boolean.parseBoolean((String) value); } return false; }
void function() { Page page = getPage(); draw(canvas, bitmap); view.invalidate(); }
void function() { final int latDeg = 60; final double latMin = 30.12345; final double expectedLat = latDeg + (latMin / 60.0); instance.setLatitude(latDeg, latMin); assertTrue(instance.toString().contains(Double.toString(expectedLat))); assertEquals(expectedLat, instance.parseLatitude(), 0.0001); }
void function() { try { mTextView.removeTextChangedListener(mChangeListener); } catch (Exception e) { } }
public void function(String identifier, HighLevelChangeRenaming highLevelChangeRenaming) { try { highLevelChangesRenaming.put(identifier, highLevelChangeRenaming); } catch (Exception e) { } }
void function(String endpoint, Bundle params, RequestListener listener, Object state) { AsyncFacebookRunner runner = new AsyncFacebookRunner(fb); runner.request(endpoint, params, null, listener, state); }
void function(Rotation rotation) { this.rotation = rotation; for (StateListener listener : this.listeners) { listener.onRotationChanged(this.rotation); } }
int function(char[] buffer, int offset, int length) { try { int matchedLength = 0; for (int i = 0; i < length; i++) { if (addChar(buffer[offset + i])) { matchedLength = i + 1; if (!hasFreePart() || endChar(buffer[offset + i])) { break; } } } reset(); return matchedLength; } catch (Exception e) { return 0; } }
void function() { try { mBuffer = BufferUtils.getIncreasingByteBuffer(LENGTH); } catch (Exception e) { mBuffer = null; } }
private void function() { assertTrue(rte.isFirst()); }
public void function(List<RSSItem> items) { try { this._items = items; } catch (Exception e) { } }
void function(long geneB) { try { this.geneB = geneB; } catch (Exception e) { } }
public void function() { mThrown.expect(ClosedChannelException.class); ByteBuffer buf = BufferUtils.getIncreasingByteBuffer((int) TEST_BLOCK_SIZE); mWriter.append(buf); mWriter.close(); mWriter.append(buf); assertEquals(0, mFolder.getRoot().listFiles().length); }
public void function() { BlockId blockId = BlockId.createBlockId(12345L, BlockId.MAX_SEQUENCE_NUMBER); long expected = 12345L << 24 | BlockId.MAX_SEQUENCE_NUMBER; long actual = blockId.getBlockId(); assertEquals(expected, actual); }
public void function() { try { LOG.debug("Running full test for YahooImageSearcher"); YahooImageSearcher searcher = new YahooImageSearcher(); runFullTest(searcher); } catch (Exception e) { System.err.println("Error in YahooSearchTest: " + e.getMessage()); } }
Object[] function(String fmt, Object... subst) { Stmt stmt = (Stmt) parse(STMT, fmt, subst); return stmt.toArray(); }
I'm sorry, I cannot generate the method you are requesting because there is no information in the given class that directly relates to the method you described. Could you please provide more information or context about the method you want me to generate?
public byte[] function() { try { return this.errors; } catch (Exception e) { } }
public void function() { String studyName1 = getCancerStudies().get(0).getName(); String studyName2 = getCancerStudies().get(1).getName(); int comparisonResult = studyName1.compareTo(studyName2); log.info("Comparison result: " + comparisonResult); }
byte[] function() { try { if (this.errors != null && this.errors.length > 0) { byte[] result = new byte[this.errors.length]; System.arraycopy(this.errors, 0, result, 0, this.errors.length); return result; } else { return new byte[0]; } } catch (Exception e) { return new byte[0]; } }
public ListIterator<BasicLogRecord> function() { flush(); return new LogIterator(getLastRecordPosition(), this); }
public GetOfferDetailsResponse.Return.DetailOfferData.Merchant.Addresses function() { GetOfferDetailsResponse response = createGetOfferDetailsResponse(); GetOfferDetailsResponse.Return ret = createGetOfferDetailsResponseReturn(); GetOfferDetailsResponse.Return.DetailOfferData detailOfferData = createGetOfferDetailsResponseReturnDetailOfferData(); GetOfferDetailsResponse.Return.DetailOfferData.Merchant merchant = createGetOfferDetailsResponseReturnDetailOfferDataMerchant(); return merchant.getAddresses(); }
void function(String arg0) { Block loc0 = new Block(arg0, contents.getInt(0)); filemgr.append(loc0, contents); }
void function(Node arg0, NodeTest arg1) { expectedNumNodes++; if (arg1.test(arg0)) { actualNumNodes++; } }
void function(int arg0) { conflictsNotApproved = arg0; }
void function(VertexLabelType arg0, VertexLabelType arg1) { Hashtable<VertexLabelType, EdgeLabelType> edgeLookup = globalEdgeLookup.get(arg0); if (edgeLookup != null) { EdgeLabelType edgeLabel = edgeLookup.get(arg1); if (edgeLabel != null) { edgeLookup.remove(arg1); } } }
void function() { mob.getNavigator().tryMoveToEntityLiving(attackTarget); }
public void function(String remoteUrl, String token) { String settingsUrl = FederationUtils.asLink(remoteUrl, token, FederationRequest.SETTINGS); String json = GitblitClient.retrieveJson(settingsUrl); Map<String,String> settings = GitblitClient.getGson().fromJson(json, FederationUtils.SETTINGS_TYPE); }
public static boolean function(CharSequence string, int index) { if (index < 0 || index >= string.length()) { return false; } char ch = string.charAt(index); if (Character.isHighSurrogate(ch)) { if (index + 1 < string.length() && Character.isLowSurrogate(string.charAt(index + 1))) { return true; } } return false; }
public String function() { try { return function() + mAlluxioMaster.getRPCBindHost(); } catch (Exception e) { return null; } }
I'm sorry, but your instructions are unclear. It is not clear how to implement the desired method based on the given member variables and member functions of the "Escapers" class. Please provide more specific instructions on what the method should do and how it should use the class members.
public void function() { try { when(mClient.listObjects(any())).thenThrow(ServiceException.class); assertFalse(mOSSUnderFileSystem.rename(SRC, DST)); } catch (Exception e) { } }
public void function(int opcode) { chunks.add(new ScriptChunk(opcode)); int size = chunks.size(); }
void function(BlockMetadataManagerView arg0) { Configuration.set("allocator.type", GreedyAllocator.class.getName()); Allocator loc0 = Allocator.Factory.create(arg0); Assert.assertTrue(loc0 instanceof GreedyAllocator); }
void function(String arg0) { this.setContentEncoding(arg0); }
void function(boolean arg0) { if (sawReturn || line.length() > 0) { boolean loc0 = finishLine(arg0); if (!loc0 && line.length() > 0) { handleLine(line.toString(), null); } } }
void function() { _use_count++; }
void function() { while (i < documents.length) { File loc0 = documents[i++]; if (loc0.isDirectory()) { File loc1 = new File(loc0, fragmentFileName); if (loc1.exists()) { directory = loc0; return; } } } }
void function(Intent resultIntent, String transactionHash) { try { resultIntent.putExtra(INTENT_EXTRA_TRANSACTION_HASH, transactionHash); String loc0 = resultIntent.getIntent().getStringExtra(INTENT_EXTRA_TRANSACTION_HASH); if (loc0 != null && loc0.equals(transactionHash)) { } else { } } catch (Exception e) { } }
public Iterator<OrderLineTypeFacade> function() { try { return new Iterator<OrderLineTypeFacade>() { private final Iterator<OrderLineType> iterator = order.getOrderLine().iterator(); public boolean hasNext() { return iterator.hasNext(); } public OrderLineTypeFacade next() { return new OrderLineTypeFacade(iterator.next()); } public void remove() { iterator.remove(); } }; } catch (NullPointerException e) { return null; } }
void function(FolderInfo.CheckedFlag checkedFlag) { this.checkedFlag = checkedFlag; }
void function(Bundle state) { state.putParcelable("mVista", mVista); }
public String function(Block blk, int offset) { try { sLock(blk); Buffer buff = getBuffer(blk); return buff.getString(blk, offset); } catch (InterruptedException e) { } finally { unLock(blk); } return null; }
private BitcoinPacketHeader function(ByteBuffer in) { try { byte[] header = new byte[HEADER_LENGTH]; in.get(header); return new BitcoinPacketHeader(header, params.getPacketMagic()); } catch (BufferUnderflowException e) { log.debug("Incomplete header in packet"); throw new ProtocolException("Incomplete header in packet", e); } }
void function(Rule rule) { for (Language language : languageToRuleChainVisitor.keySet()) { RuleChainVisitor visitor = getRuleChainVisitor(language); if (rule.accept(visitor)) { visitor.add(rule); } } }
void function() { trigger(null); }
void function() { ASTElement a = element("a"); tagList.openTag(a); ASTElement b1 = element("b"); tagList.openTag(b1); ASTElement b2 = element("b"); tagList.openTag(b2); tagList.closeTag(a); assertFalse(tagList.hasErrors()); assertTrue(tagList.isEmpty()); }
