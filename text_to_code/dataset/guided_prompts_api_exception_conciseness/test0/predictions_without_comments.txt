void function(ScriptOrFnNode arg0) { collectFuncNodes(arg0, loc0, null); }
public static Sha256Hash function(byte[] arg0) { try { FileInputStream loc0 = new FileInputStream(new File(new String(arg0))); byte[] loc1 = ByteStreams.toByteArray(loc0); loc0.close(); return Sha256Hash.create(loc1); } catch (IOException e) { throw new RuntimeException("Error reading file: " + e.getMessage()); } }
String function(Object arg0, boolean canCreate) { String loc0 = readObjectID(arg0); if (loc0 == null && canCreate) { loc0 = createObjectID(arg0); } return loc0; }
Matcher<T> function(T arg0, T arg1) { return ComparatorMatcherBuilder.<T>usingNaturalOrdering().greaterThan(arg1); }
int function() { return denom; }
GenericJSONBuilder function(String arg0, String image) { this.setPlaceName(arg0); this.addField("image", image); return this; }
public void function(BundleContext arg0) { deregisterConnectionFactory(); factories.remove("someKey"); }
void function() { mTestStream.seek(0); assertEquals(mBlockSize, mTestStream.getPos()); byte[] loc0 = new byte[(int) mBlockSize]; int loc1 = mTestStream.read(loc0); assertEquals((int) mBlockSize, loc1); mTestStream.seek(mBlockSize - mBufferSize / 2); assertEquals(mBlockSize - mBufferSize / 2, mTestStream.getPos()); byte[] loc2 = new byte[(int) mBufferSize]; int loc3 = mTestStream.read(loc2); assertEquals((int) mBufferSize, loc3); mTestStream.seek(mBlockSize + mBufferSize); assertEquals(mBlockSize + mBufferSize, mTestStream.getPos()); byte[] loc4 = new byte[(int) mBufferSize]; int loc5 = mTestStream.read(loc4); assertEquals(-1, loc5); }
void function(CountDownLatch arg0, WeakReference<?> arg1) { try { System.gc(); System.runFinalization(); arg0.await(); arg0.countDown(); arg1.finalize(); System.runFinalization(); } catch (InterruptedException | IOException e) { throw new RuntimeException("Error during full garbage collection cycle", e); } }
void function() { MockedClass loc0 = mock(MockedClass.class); when(loc0.mockedMethod(any(String.class), any(Integer.class))).thenReturn("mockedResponse"); TransferManager loc1 = mock(TransferManager.class); S3ObjectOutputStream loc2 = mock(S3ObjectOutputStream.class); when(loc1.upload(any(String.class), any(String.class), any(InputStream.class), any(ObjectMetadata.class))) .thenReturn(new UploadResult()); try { mStream = new S3ADirectOutputStream(BUCKET_NAME, KEY, loc1, new ObjectMetadata(), loc2); } catch (Exception e) { e.printStackTrace(); } }
String function(Object arg0, String arg1, String arg2, String arg3, String arg4) { String loc0 = new DocumentationManager().getComments(arg0, arg1, arg2, arg3); return loc0.replaceAll("\\/\\*\\*\\n\\s\\*\\s\\*\\sSummary\\:\\n\\s\\*\\s\\*\\s\\*\\s.*?\\n\\s\\*\\s\\*\\/", "") .replaceAll("\\/\\*\\*\\n\\s\\*\\s\\*\\sThrows\\:\\n\\s\\*\\s\\*\\s\\*\\s.*?\\n\\s\\*\\s\\*\\/", "") .replaceAll("\\/\\*\\*\\n", "") .replaceAll("\\s\\*\\/", "") .replaceAll("\\s\\*\\s\\*", "") .replaceAll("\\s\\*\\s", "") .replaceAll("^\\s", "") .replaceAll("\\s$", ""); }
Level function() { return Level.WARNING; }
String function(String arg0) { if (root == null) { return null; } TSTNode loc0 = search(root, arg0.toCharArray(), 0); if (loc0 == null || !loc0.is_End_Of_String) { return null; } return loc0.al.get(0); }
void function() { lhsscan.close(); prodscan.close(); if (rhsscan != null) { rhsscan.close(); } }
Map<String, String> function(String[] arg0) { Map<String, String> loc0 = new HashMap<>(); for (String arg1 : arg0) { String[] loc1 = arg1.split("#"); loc0.put(loc1[0], loc1[1]); } return loc0; }
public static String[] function(XMLSource arg0, String arg1) { try { String[] loc0 = arg0.getNodes(arg1, String.class); List<String> result = new ArrayList<>(); for (String s : loc0) { if (!s.startsWith("<!--") && !s.equals("summary")) { result.add(s); } } return result.toArray(new String[0]); } catch (Exception e) { return new String[0]; } }
boolean function(Collection<Source> arg0) { return runToGoal(arg0, new GoalFactory() { @Override public Goal getGoal(Job arg1) { return sourceExtension().getValidationGoal(arg1); } }); }
void function(boolean arg0) { ContentResolver loc0 = context.getContentResolver(); loc0.setLocationProviderEnabled(LocationManager.GPS_PROVIDER, arg0); }
boolean function(View arg0) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) { return arg0.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL; } else { return false; } }
public Checklist function(Object arg0) { Class loc0 = arg0.getClass(); Checklist loc1 = lookupChecklist(loc0); Class loc2 = loc0.getSuperclass(); return loc1; } Note: This implementation assumes that the "lookupChecklist" method handles any necessary exception handling.
void function() { try { DateTest test = new DateTest(); int loc0 = 10; // set day to 10 test.setDay(loc0); fail("setDay method did not throw an exception for invalid day value"); // expect exception to be thrown } catch (IllegalArgumentException loc1) { } catch (Exception loc2) { fail("Unexpected exception: " + loc2.getMessage()); } }
public int function(int arg0, int arg1) { int loc0 = -1; for (int loc1 = tiles[arg0].size - 1; loc1 >= 0; loc1--) { if (tiles[arg0][loc1][arg1] == null) { loc0 = loc1; break; } } return loc0; }
public static Matrix function(Matrix arg0) { Matrix loc0 = transpose(arg0); Matrix loc1 = cofactor(loc0); double loc2 = determinant(loc0); double loc3 = 1 / loc2; Matrix loc4 = multiplyByConstant(loc1, loc3); return loc4; }
String function() { String loc0 = thisExitStatus.getExitCode(); return loc0; }
boolean function(Element arg0) { return isHover(arg0); }
List<AttributeStatementProvider> function() { try { return attributeStatementProviders; } catch (Exception e) { LOG.error("Failed to get the list of AttributeStatementProviders", e); return new ArrayList<>(); } }
Remember you have a Java class named "Loader", member variables "Array<Asset> textureRegions, String LOG=DataManager.class.getName(), String assetType, ShadowStruggles game, Array<Asset> textures, Array<Asset> sounds, Array<Asset> rpgMaps, String assetName", member functions "void unloadSounds ( Array<Asset> soundsToLoad ), TiledMap getTiledMap ( String mapName ,  String resourceType ), void disposeMaps ( ), Texture getTexture ( String textureName ,  String resourceType ), void loadTextureAtlas ( ), void createTextureAtlas ( ), void disposeAtlas ( ), void disposeTextures ( ), void loadSounds ( ), void setAssetsToLoad ( Array<Asset> textureRegions ,  Array<Asset> textures ,  Array<Asset> sounds ,  Array<Asset> rpgMaps ), TextureRegion getTextureRegion ( String regionName ,  String resourceType ), void loadAssets ( ), void loadTextures ( ), void loadMaps ( ), boolean equals ( Object obj ), void dispose ( )". Write a concise method named function that calls getAssets(),unload() without exception handling to "Unloads the sounds from memory." remove comments; remove summary; remove throws; remove function modifiers; change method name to "function"; change argument names to "arg0", "arg1"...; change local variable names to "loc0", "loc1"...
public ProjectModel function(UserModel arg0) { List<ProjectModel> loc0 = getProjectModels(arg0, true); if (loc0.isEmpty()) { return null; } return loc0.get(0); }
String function(String arg0) { int loc0 = Integer.parseInt(arg0.substring(0, 2), 16); int loc1 = Integer.parseInt(arg0.substring(2, 4), 16); int loc2 = Integer.parseInt(arg0.substring(4, 6), 16); String namedColor = getClosestNamedColor(loc0, loc1, loc2); return namedColor; }
String function() { String loc0 = getSuffixFromType(); return String.format("%s.%s.%s%s", getSchema(), getType(), getName(), loc0); }
public int function() { int loc0 = 0; try { loc0 = port; } catch (Exception loc1) { } return loc0; }
Set<String> function(Jedis arg0) { Set<String> loc0 = null; try { loc0 = arg0.keys("URLSet:*"); } catch (Exception e) { System.err.println("Error getting URLSet keys from Redis: " + e.getMessage()); } return loc0; }
void function() { mBlocksToMoveIn.clear(); mBlocksToMoveOut.clear(); } This method will clear all the marks about blocks to move in/out in the StorageDirView object by calling the clear() method on both member variables mBlocksToMoveIn and mBlocksToMoveOut.
UserSubject function(Token arg0) { return arg0.subject.function(); }
int function(boolean arg0) { int loc0; try { loc0 = getIntFromFormat(arg0); } catch (Exception e) { loc0 = 1; } return loc0; }
String function(TestResultDetailsDTO arg0) { return arg0.errorMsg; }
boolean function(String arg0) { return _all.containsKey(arg0); }
String function(Node arg0) { StringBuilder sb = new StringBuilder(); NodeList children = arg0.getChildNodes(); Text loc0 = null; for (int i = 0; i < children.getLength(); i++) { Node child = children.item(i); if (child instanceof Text) { if (loc0 == null) { loc0 = (Text) child; } else { loc0.appendData(child.getNodeValue()); } } else if (child instanceof CDATASection) { sb.append(child.getNodeValue()); } } if (loc0 != null) { sb.append(loc0.getNodeValue()); } return sb.toString(); }
import java.util.*; public class Example { public void function() { Properties props = System.getProperties(); MarshalRegistry registry = (MarshalRegistry) props.getOrDefault("myapp.marshalregistry", new MarshalRegistry()); registry.setProperty("property1", "value1"); Object loc0 = registry.getProperty("property1"); registry.notMarshalled.put("key1", "value2"); Iterator<Object> loc1 = registry.iterator(); } }
ArrayList<Object> function(Object arg0, Object arg1) { ArrayList<Object> loc0 = new ArrayList<>(); try { loc0.add(arg0); loc0.add(arg1); } catch (Exception e) { } return loc0; }
void function(ParametersMetaData arg0) { try { setParametersMetaData(arg0); } catch (Exception e) { } }
public static Object function(Object arg0, int arg1) { ArrayList<Object> loc0 = new ArrayList<Object>(); try { loc0.add(DeveloperModule.getInstance().getName()); loc0.add(DeveloperModule.getInstance().getInfo(arg1)); loc0.add(DeveloperModule.getInstance().enable()); } catch (Exception loc1) { loc0.add("Error retrieving details: " + loc1.getMessage()); } return loc0; }
void function(String arg0, byte[] arg1) { try { writer.writeStartElement(arg0); writer.writeCharacters(new String(arg1)); writer.writeEndElement(); } catch (XMLStreamException loc0) { } }
String function() { String loc0 = this.isActive(); return loc0; }
Here's the revised code for the "function" method: ``
ECKey function(List<ECKey> arg0) { ECKey loc0 = null; for (ECKey key : arg0) { try { loc0 = key.getPrivKey(); break; } catch (ECKey.MissingPrivateKeyException e) { } } return loc0; }
void function() { init(services); instrumentation.destroy(); instrumentation = null; }
void function(long arg0) { this.maximumKeySize = arg0; }
String function(String arg0) { if (ts.hasField(arg0)) { return ts.getVal(arg0); } else { return s.getVal(arg0); } }
public int getBip32HeaderPub(byte arg0, byte arg1, byte arg2, byte arg3) { try { byte[] loc0 = new byte[]{arg0, arg1, arg2, arg3}; ByteBuffer loc1 = ByteBuffer.wrap(loc0); return loc1.getInt(); } catch (Exception e) { return 0; } }
public static long function(Coin arg0) { try { return arg0.longValue(); } catch (Exception loc0) { loc0.printStackTrace(); return 0; } }
public void function(MenuItem arg0, int arg1, Object arg2) { arg0.setActionView(arg1); arg0.setActionView(arg2, arg1); }
NotificationController notificationController = new NotificationController(); notificationController.deletePersistentNotification(null, mockServerMessage);
void function(double arg0) { try { if(arg0 < 0 || arg0 > 59.999) { throw new IllegalArgumentException("srini_string"); } seconds = arg0; } catch (IllegalArgumentException e) { System.out.println(e.getMessage()); } }
public void function(ServiceID arg0, ServalDatagramPacket packet) { try { packet.setServiceID(arg0); } catch (Exception e) { } }
int function(int arg0, int arg1, int arg2) { int loc0 = 32 + StoredBlock.COMPACT_SERIALIZED_SIZE; int loc1 = arg1 * loc0; int loc2 = arg0 + arg2 + loc1; return loc2; }
public T getPayload() throws Exception { return mPayload; }
String function() { return DateTime.formatUTCtoSqlUTC(this.addedDate); }
List<DirectedAcyclicGraphNode<T>> function(DirectedAcyclicGraphNode<T> node) { List<DirectedAcyclicGraphNode<T>> mChildren = new ArrayList<>(); try { mChildren = node.mChildren; } catch (NullPointerException e) { System.err.println("Node has no children."); } return mChildren; }
View function(RecyclerView arg0, View arg1, int arg2, int arg3) { int loc0 = arg0.getChildCount(); for (int loc1 = 0; loc1 < loc0; loc1++) { View loc2 = arg0.getChildAt(loc1); if (!itemIsObscuredByHeader(arg0, loc2, arg1, getOrientation())) { return loc2; } } return null; }
public void function(List<TestResultDetailsDTO> arg0) { List<TestResultDetailsDTO> loc0 = new ArrayList<>(arg0); this.regTestResultDetailsLst = loc0; }
public long function(RegPCLTestResultEntity arg0) { try { return arg0.getTestId(); } catch (Exception loc0) { return -1L; } }
void function() { TimeTest test = new TimeTest(); test.setUp(); test.testSetTime(); Date arg0 = new Date(); Time loc0 = new Time(arg0.getTime()); Time loc1 = new Time(arg0.getTime()); loc0.setTime(2000); loc0.toDate(arg0); assertEquals(loc0, loc1); long time0 = loc0.getTime(); long time1 = loc1.getTime(); }
void function(BigDecimal arg0) { try { this.feedConfigId = arg0; } catch (Exception e) { } }
function(String arg0) { writeCompressionType = arg0; }
boolean function(Range<C> loc0) { return encloses(loc0); }
void function(Map<String, Object> arg0) { try { vars.putAll(arg0); } catch (Exception loc0) { } }
void function() { function(); setOutputMode(); boolean loc0 = buffer.hasRemaining(); }
void function(int arg0, String arg1, int arg2, int arg3, String arg4, Block arg5) { StringBuffer rec = new StringBuffer(); rec.append("SETSTRING "); rec.append(arg0); rec.append(" "); rec.append(arg1); rec.append(" "); rec.append(arg2); rec.append(" "); rec.append(arg3); rec.append(" "); rec.append(arg5.fileName()); rec.append(" "); rec.append(arg4); logMgr.appendToLog(rec.toString()); }
void function(Object arg0, Object arg1, DataFlowHandler dataFlowHandler) { try { DataFlowNode loc0 = createDataFlowNode((int)arg0); dataFlow.add(loc0); dataFlowHandler.addNode(loc0); } catch (Exception e) { LOGGER.warning("Failed to create data flow node: " + e.getMessage()); } }
public User function() { try { if (!SecurityUtils.isAuthenticationEnabled()) { throw new IOException(ExceptionMessage.AUTHENTICATION_IS_NOT_ENABLED.getMessage()); } User loc0 = sUserThreadLocal.get(); return loc0; } catch (Exception e) { return null; } }
public void function(String arg0) { try { if (!selectedRecipients.contains(arg0)) { selectedRecipients.add(arg0); } } catch (Exception e) { System.out.println("Failed to add recipient to the required recipients list."); e.printStackTrace(); } }
void function() { File loc0 = new File("/"); String loc1 = loc0.getRoot().getAbsolutePath() + "non_existent_file.txt"; ExpectedException loc2 = ExpectedException.none(); try { FileUtils.delete(loc1); fail("Expected an exception when trying to delete a non-existent file."); } catch (Exception e) { loc2.expect(FileNotFoundException.class); } }
boolean function(String arg0, OperationSigMask arg1) { OperationSignature loc0 = new OperationSignature(arg0); if(arg1.covers(loc0)) { Map<OperationSignature,Map<String,OperationStats>> loc1 = operations.get(loc0); if(loc1 != null && !loc1.isEmpty()) { return true; } } return false; }
boolean function(Collection<UserModel> arg0) { return userService.updateUserModels(arg0); }
void function(Object arg0, Object arg1) { try { String loc0 = this.config.getFilterName() + "srini_string" + arg0; this.config.getServletContext().log(loc0, (Throwable) arg1); } catch (Exception e) { this.config.getServletContext().log("Error logging message", e); } }
import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class JsonControllerUtils { private static final Logger LOG = LoggerFactory.getLogger(JsonControllerUtils.class); public void function(HttpServletRequest arg0, HttpServletResponse arg1) { try { writeResponse(arg0, arg1, ""); } catch (Exception loc0) { LOG.error("Error occurred while writing response: {}", loc0.getMessage()); } } private void writeResponse(HttpServletRequest request, HttpServletResponse response, String content) { } }
void function(int arg0, ProgressMonitor arg1) { arg1.setCurValue(arg0); }
import org.json.JSONArray; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.net.URI; import java.util.Map; public class JsonDownloadsVisitor { private JLibTorrent m_libTorrent; private FileMapper m_fileMapper; private String m_escapedJson; private Logger m_log = LoggerFactory.getLogger(getClass()); private int STOP_DOWNLOAD_DELETE_FILES = 1; public void function() { try { String accessorJson = m_escapedJson; String jsonWithoutComments = removeComments(accessorJson); String jsonWithoutSummary = removeSummary(jsonWithoutComments); String jsonWithoutThrows = removeThrows(jsonWithoutSummary); String jsonWithoutModifiers = removeFunctionModifiers(jsonWithoutThrows); JSONArray arg0 = new JSONArray(); Map.Entry<URI, Pair<Downloader<MoverDState<Sha1DState<MsDState>>>, VisitableDownloader<MsDState>>> arg1 = null; JSONArray loc0 = new JSONArray(); File loc1 = null; addComplete(arg0, loc1); } catch (Exception e) { e.printStackTrace(); } } private String removeComments(String json) { return json; } private String removeSummary(String json) { return json; } private String removeThrows(String json) { return json; } private String removeFunctionModifiers(String json) { return json; } private void addComplete(JSONArray array, File file) { } }
class NodeTest { DocumentTraversal documentTraversal; short[] nodeTypes; Node rootNode; short acceptNode(Node arg0) { } DocumentTraversal getDocumentTraversal(Document arg0) { } boolean acceptNodeType(short arg0) { } void function() { NodeIterator loc0 = documentTraversal.createNodeIterator(rootNode, NodeFilter.SHOW_ALL, null, true); Node loc1 = loc0.nextNode(); NodeTester loc2 = new NodeTester(); boolean testNode = loc2.test(loc1); boolean noMoreNodes = (loc1 == null); String result = "Does this NodeTest pass using the specified NodeTester instance? " + (testNode && noMoreNodes); System.out.println(result); } }
public BlockStoreContext function(InetSocketAddress arg0) {
void function(String arg0, String arg1, float arg2) { FSImageWriter writer = new FSImageWriter(); writer.setWriteCompressionMode(2); writer.setWriteCompressionType(arg0); writer.setWriteCompressionQuality(arg2); }
String function(String arg0) { String loc0 = conditionallyPrependHttp(arg0); String loc1 = ""; try { URI uri = new URI(loc0); loc1 = uri.getHost(); String loc2 = uri.getPath(); String loc3 = uri.getQuery(); String loc4 = removePath(loc3); ArrayList<String> loc5 = getKeyList(getParameterMap(loc4)); String loc6 = createQueryString(loc5, getParameterMap(loc4)); return OMA_REDIRECT_LINK + SITE_PARAM + "=" + loc1 + loc2 + loc6; } catch (URISyntaxException e) { } return null; }
void function(Map<String, ThreadingParameters> arg0, Map<String, ThreadingParameters> threadingParametersMap) { try { threadingParametersMap.putAll(arg0); } catch (Exception loc0) { } }
void function(Language arg0, CodeGenerator arg1) { if (generators.containsKey(arg0)) { generators.remove(arg0); } generators.put(arg0, arg1); fireEvent("generator-registered", arg0.getName()); LOG.debug("Registered generator for language: {}", arg0.getName()); }
void function(String name, Object value) { try { setVariable(name, value); } catch (Exception e) { } }
int function(int arg0, long arg1, byte[] arg2) { try { if (arg0 < NONCOINBASE_HEIGHT) { throw new IllegalArgumentException("Index must be greater than or equal to NONCOINBASE_HEIGHT"); } this.index = arg1; this.scriptBytes = arg2.clone(); this.hash = Sha256Hash.twiceOf(this.scriptBytes); return arg0; } catch (Exception e) { e.printStackTrace(); return -1; } }
void function() { if (bulletTime - System.nanoTime() / 1000000 >= BULLET_INTERVAL && bullets.size() < MAX_BULLETS) { float angle = (float)Math.toRadians(heading); Bullet bullet = new Bullet(xPos, yPos + 0.4f, zPos, angle); bullets.add(bullet); bulletTime = System.nanoTime() / 1000000; } }
GetOfferDetailsResponse.Return.DetailOfferData.OfferDisplay function() { GetOfferDetailsResponse.Return.DetailOfferData.OfferDisplay loc0 = new GetOfferDetailsResponse.Return.DetailOfferData.OfferDisplay(); return loc0; }
public Long function(Long arg0) { Long loc0 = null; try { loc0 = (this.deliveryAssurance == DeliveryAssurance.AT_LEAST_ONCE) ? arg0.longValue() : null; } catch (NullPointerException e) { e.printStackTrace(); } return loc0; }
void function() { server.stopAsync(); server.awaitTerminated(); }
String function(String arg0, String arg1, int arg2) { StringBuffer message = new StringBuffer(); message.append("This is the standard way to report debugging information in the compiler. "); message.append("It reports a message of the specified level (which controls the presentation of the message). "); message.append("To test whether such message should be reported, use \"should_report\". "); message.append("NOTE: This is a change of spec from earlier versions of Report. "); message.append("NOTE: This version takes an explicit Position, so that position info gets properly associated with the ErrorInfo that gets created by enqueue()."); ErrorQueue queue = getQueue(); queue.enqueue(ErrorInfo.DEBUG, message.toString(), arg2); return message.toString(); }
JAXBElement<Access> function(String arg0, String arg1) { ObjectFactory objFactory = new ObjectFactory(); Access loc0 = objFactory.createAccess(); loc0.setDomain(arg0); loc0.setAction(arg1); return objFactory.createAccess(loc0); }
void function(String arg0) { failedAttributeName = arg0; }
import java.util.ArrayList; import java.util.LinkedHashSet; import java.util.List; public class ShellBasedUnixGroupsMapping { public List<String> function(String arg0) { List<String> loc0 = CommonUtils.getUnixGroups(arg0); ArrayList<String> loc1 = new ArrayList<>(loc0); LinkedHashSet<String> loc2 = new LinkedHashSet<>(loc1); ArrayList<String> loc3 = new ArrayList<>(loc2); return loc3; } }
void function() { try { Socket loc0 = clientEndpoint.getSocket(); loc0.getOutputStream().flush(); } catch (IOException loc1) { logger.error("Failed to flush outstanding data", loc1); } }
MetadataEditorCompat function(String arg0, String arg1) { MetadataEditorCompat loc0 = editMetadata(true); loc0.putString(METADATA_KEY_ARTWORK, arg0); loc0.apply(); return loc0; }
void function() { GeneralMotorCon loc0 = GeneralMotorCon.getInstance(); loc0.appendToConsole("Landing Land the drone"); loc0.landing(); loc0.doFor(5000, () -> {}); }
Optional<GroupConfiguration> function(GroupConfiguration groupConfig, Map<String,String> metadataToRemove) { try { Map<String,String> metadata = groupConfig.getMetadata(); metadata.keySet().removeAll(metadataToRemove.keySet()); GroupConfiguration.Builder builder = groupConfig.toBuilder().metadata(metadata); return Optional.of(builder.build()); } catch (Exception e) { return Optional.empty(); } }
void function() { RMCParser rmc = new RMCParser(EXAMPLE); assertEquals(6.1, rmc.getVariation(), 0.1); assertEquals(RMCTest.EXAMPLE.substring(24, 25), rmc.getDirectionOfVariation()); }
