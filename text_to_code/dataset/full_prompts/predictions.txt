public void generateMappings(ScriptOrFnNode parseTree) {     collectFuncNodes(parseTree, 0, null);     for (int i = 0; i < functionNum; i++) {         ObjArray funcNodeArray = (ObjArray) funcObjects.get(i);         FunctionNode functionNode = (FunctionNode) funcNodeArray.get(0);         ArrayList<String> paramMap = (ArrayList<String>) funcNodeArray.get(1);         ArrayList<String> varMap = (ArrayList<String>) funcNodeArray.get(2);         String functionName = functionNode.getName();         if (functionNode.getFunctionType() == FunctionNode.FUNCTION_EXPRESSION) {             functionName = "anonymous_" + i;         }         functionVarMappings.add(new FunctionVarMapping(functionName, paramMap, varMap));     } }
public static Sha256Hash hashFileContents(File file) throws IOException {     byte[] contents = Files.readAllBytes(file.toPath());     return Sha256Hash.create(contents); }
public String readObjectID(Object obj, boolean canCreate) {     if (obj == null) {         return null;     }     if (obj instanceof ItemUID) {         return ((ItemUID) obj).getId();     }     String id = null;     try {         id = (String) obj.getClass().getMethod("getId").invoke(obj);     } catch (Exception e) {         // Ignore exception, id will be null     }     if (id == null && canCreate) {         id = createObjectID(obj);     }     return id; } public String createObjectID(Object obj) {     String id = generateID();     if (obj instanceof ItemUID) {         ((ItemUID) obj).setId(id);     } else {         try {             obj.getClass().getMethod("setId", String.class).invoke(obj, id);         } catch (Exception e) {             // Ignore exception, id will not be set         }     }     return id; } public String generateID() {     return UUID.randomUUID().toString(); } @Override public String toString() {     return getId(); }
public static <T extends Comparable<T>> Matcher<T> greaterThan(T value) {     return new TypeSafeMatcher<T>() {         @Override         protected boolean matchesSafely(T item) {             return item.compareTo(value) > 0;         }         @Override         public void describeTo(Description description) {             description.appendText("greater than ").appendValue(value);         }     }; }
public int getDenom() {     return denom; }
null
@Override public void start(BundleContext context) throws Exception {     // Do nothing, as the framework will automatically unregister any registered services on stop() }
void before() {     // create a new test stream object     mTestStream = new TestBufferedBlockInStream(mBlockSize, mBufferSize);          // set the stream content     mTestStream.setStreamContent(new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}); }
public void awaitClear(final WeakReference<?> ref) {     CountDownLatch latch = new CountDownLatch(1);     createUnreachableLatchFinalizer(latch);     Runtime.getRuntime().gc();     try {         await(latch);     } catch (InterruptedException ex) {         Thread.currentThread().interrupt();         throw formatRuntimeException("Interrupted while waiting for GC to complete");     }     if (ref.get() != null) {         throw new AssertionError("Weak reference not cleared after GC");     } }
private void setTestProperties() {     mManager = TransferManagerBuilder.standard().withS3Client(AmazonS3ClientBuilder.standard().build()).build();     mStream = (S3ADirectOutputStream) mManager.getAmazonS3Client().createS3DirectOutputStream(BUCKET_NAME, KEY); }
private String getCStyleComment(String content) {     StringBuilder commentBuilder = new StringBuilder();     commentBuilder.append("/*").append(LINE_SEPARATOR);     String[] lines = content.split(LINE_SEPARATOR);     for (String line : lines) {         commentBuilder.append(" * ").append(line).append(LINE_SEPARATOR);     }     commentBuilder.append(" */").append(LINE_SEPARATOR);     return commentBuilder.toString(); } public String getComments(Object o) {     return getComments(o, null, null, null); } public String getComments(Object o, String header, String prefix, String footer) {     String content = defaultFor(o, null);     if (content == null) {         return null;     }     if (prefix == null) {         prefix = "";     }     if (header != null) {         prefix += header + LINE_SEPARATOR;     }     if (footer != null) {         prefix += footer + LINE_SEPARATOR;     }     return getCStyleComment(prefix + content); }
null
public boolean search(String word) {     if (root == null || word == null || word.length() == 0) {         return false;     }     TSTNode curr = root;     int i = 0;     while (i < word.length() && curr != null) {         char c = word.charAt(i);         if (c < curr.data) {             curr = curr.left;         } else if (c > curr.data) {             curr = curr.right;         } else {             i++;             if (i == word.length()) {                 return curr.is_End_Of_String;             }             curr = curr.middle;         }     }     return false; }
public void closeScans() {     if (prodscan != null) {         prodscan.close();         prodscan = null;     }     if (lhsscan != null) {         lhsscan.close();         lhsscan = null;     }     if (rhsscan != null) {         rhsscan.close();         rhsscan = null;     } }
private Map<String, String> convertToMap(String[] property) {     Map<String, String> map = new HashMap<>();     for (String s : property) {         String[] parts = s.split("#");         if (parts.length == 2) {             map.put(parts[0], parts[1]);         }     }     return map; }
public Object evaluate(String expression, Map<String,String> namespaces, QName type) {     try {         XPathFactory factory = XPathFactory.newInstance();         XPath xpath = factory.newXPath();         xpath.setNamespaceContext(new SimpleNamespaceContext(namespaces, XML_NAMESPACE));         XPathExpression expr = xpath.compile(expression);         Object result = expr.evaluate(doc, type);         return result;     } catch (XPathExpressionException e) {         throw new RuntimeException(e);     } }
public boolean compile(Collection<FileSource> sources) {     // create a goal for validation     Goal validationGoal = getGoal(Validation.PHASE_NAME);          // iterate through the sources and run passes dependent on the validation goal     for (FileSource source : sources) {         Job job = new Job(source, validationGoal);         if (!runToGoal(Collections.singleton(job), goal -> goal == validationGoal)) {             // compilation failed, return false             return false;         }     }          // compilation succeeded     return true; }
public class SystemCommands {     private Context context;     public SystemCommands(Context context) {         this.context = context;     }     public void reboot() {         // implementation for reboot     }     public boolean getGPS() {         // implementation for getGPS     }          public void enableGPS() {         // implementation for enableGPS     }          public void disableGPS() {         // implementation for disableGPS     }          // Implementing Enable/Disable GPS function     public void setGPS(boolean enabled) {         LocationManager locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);         if (locationManager != null) {             if (enabled) {                 locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, locationListener);             } else {                 locationManager.removeUpdates(locationListener);             }         }     }          private final LocationListener locationListener = new LocationListener() {         @Override         public void onLocationChanged(Location location) {             // implementation for onLocationChanged         }                  @Override         public void onStatusChanged(String provider, int status, Bundle extras) {             // implementation for onStatusChanged         }                  @Override         public void onProviderEnabled(String provider) {             // implementation for onProviderEnabled         }                  @Override         public void onProviderDisabled(String provider) {             // implementation for onProviderDisabled         }     }; }
public class ViewUtils {     private TypedValue mTmpValue = new TypedValue();     public static boolean isViewLayoutRtl(View view) {         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {             return view.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL;         } else {             return false;         }     }     // implementation for getStatusBarHeightInDp, getActionBarHeightInDp, getSystemBarHeight, getActionBarHeight, dpToPx, dpToPx, showSystemUI, getSystemBarHeightInDp, getStatusBarHeight, hideSystemUI, pxToDp, pxToDp, getResourceValue, findById, findById, getScreenRawSize }
public class CheckManager {     private Hashtable<Object, ChecklistStatus> statuses = new Hashtable<>();     private Hashtable<Class<?>, Checklist> lists = new Hashtable<>();     public ChecklistStatus getStatusFor(Object dm) {         return statuses.get(dm);     }     public Checklist lookupChecklist(Class<?> cls) {         return lists.get(cls);     }     public void register(Object dm, Checklist cl) {         statuses.put(dm, new ChecklistStatus(cl));         lists.put(cl.getClass(), cl);     }     // Implementing the "Gets the checklist for an element" function     public Checklist getChecklistFor(Object dm) {         ChecklistStatus status = getStatusFor(dm);         if (status != null) {             return status.getChecklist();         } else {             return null;         }     } }
public class DateTest {     private GregorianCalendar cal;     private Date instance;     @Before     public void setUp() {         cal = new GregorianCalendar();         instance = new Date();     }     // Implementing the "Test method for net.sf.marineapi.nmea.util.Date#setDay(int)" function     @Test     public void testSetDay() {         int day = 10;         instance.setDay(day);         cal.setTime(instance);         assertEquals(day, cal.get(Calendar.DAY_OF_MONTH));     }          // Other member functions and variables are not implemented in this code block }
public int nextAvailableTile(int lane, int player) {     for (int i = 0; i < tiles[lane][player].length; i++) {         if (tiles[lane][player][i] == null) {             return i;         }     }     return -1; // if no available tile found }
public Matrix inverse(Matrix matrix) throws Exception {     int n = matrix.getNumRows();     if (n != matrix.getNumColumns()) {         throw new Exception("Matrix is not square");     }     Matrix identity = new Matrix(n, n);     for (int i = 0; i < n; i++) {         identity.setValue(i, i, 1);     }     Matrix augMatrix = matrix.augment(identity);     for (int i = 0; i < n; i++) {         if (augMatrix.getValue(i, i) == 0) {             throw new Exception("Matrix is singular");         }         for (int j = 0; j < n; j++) {             if (i != j) {                 double ratio = augMatrix.getValue(j, i) / augMatrix.getValue(i, i);                 for (int k = 0; k < 2 * n; k++) {                     augMatrix.setValue(j, k, augMatrix.getValue(j, k) - ratio * augMatrix.getValue(i, k));                 }             }         }     }     for (int i = 0; i < n; i++) {         double divisor = augMatrix.getValue(i, i);         for (int j = 0; j < 2 * n; j++) {             augMatrix.setValue(i, j, augMatrix.getValue(i, j) / divisor);         }     }     Matrix invMatrix = new Matrix(n, n);     for (int i = 0; i < n; i++) {         for (int j = 0; j < n; j++) {             invMatrix.setValue(i, j, augMatrix.getValue(i, j + n));         }     }     return invMatrix; }
public String getExitDescription() {     return thisExitStatus.getExitDescription(); }
public String getHoverAttribute(Object e) {     String attrName = "hover";     String namespaceURI = "";     String value = getAttributeValue(e, namespaceURI, attrName);     return value; }
public List<AttributeStatementProvider> getAttributeStatementProviders() {     return attributeStatementProviders; }
public void unloadSounds(Array<Asset> soundsToUnload) {     for (Asset sound : soundsToUnload) {         if (game.getAssetManager().isLoaded(sound.fileName)) {             game.getAssetManager().unload(sound.fileName);         }     } }
public List<ProjectModel> getProjectModels(UserModel user, boolean includeUsers) {     List<ProjectModel> projectModels = new ArrayList<>();     for (ProjectModel projectModel : projectCache.values()) {         if (includeUsers || projectModel.isUserAllowed(user)) {             projectModels.add(projectModel);         }     }     return projectModels; }
public Optional<String> getNamedColor(String hexString) {     Color color = Color.decode(hexString);     double closestDistance = Double.POSITIVE_INFINITY;     String closestColorName = null;     for (Map.Entry<RGB, String> entry : namedColors.entrySet()) {         RGB rgb = entry.getKey();         Color namedColor = new Color(rgb.r, rgb.g, rgb.b);         double distance = calculateColorDistSq(color, namedColor);         if (distance < closestDistance) {             closestDistance = distance;             closestColorName = entry.getValue();         }     }     return Optional.ofNullable(closestColorName); } private static class RGB {     final int r;     final int g;     final int b;     RGB(int r, int g, int b) {         this.r = r;         this.g = g;         this.b = b;     }     @Override     public int hashCode() {         int result = 17;         result = 31 * result + r;         result = 31 * result + g;         result = 31 * result + b;         return result;     }     @Override     public boolean equals(Object obj) {         if (obj == this) return true;         if (!(obj instanceof RGB)) return false;         RGB other = (RGB) obj;         return r == other.r && g == other.g && b == other.b;     } } private double calculateColorDistSq(Color color0, Color color1) {     int rDiff = color0.getRed() - color1.getRed();     int gDiff = color0.getGreen() - color1.getGreen();     int bDiff = color0.getBlue() - color1.getBlue();     return rDiff * rDiff + gDiff * gDiff + bDiff * bDiff; }
public String getPseudoFileName() {     String suffix = getSuffixFromType();     return String.format("%s_%s.%s", name, revision, suffix); }
public int getDefaultPort() {     return port; }
public Set<String> termSet() {    Set<String> keys = jedis.keys("*");    Set<String> terms = new HashSet<String>();    for (String key : keys) {       if (key.startsWith("term:")) {          terms.add(key.substring(5));       }    }    return terms; }
public void clearAllBlockMoveMarks() {     mBlocksToMoveIn.clear();     mBlocksToMoveOut.clear();     mBlocksToMoveInSize = 0L;     mBlocksToMoveOutSize = 0L; }
public String getEndUserLoginName() {     if (subject != null) {         return subject.getLoginName();     }     return null; }
public int getLengthFromFormat(boolean advance) {     int length = getIntFromFormat(advance);     if (length == 0) {         return 1;     }     return length; }
public String getErrorMsg() {     return this.errorMsg; }
public boolean contains(symbol sym) {     return _all.containsKey(sym.get_name()); }
private static String mergeDirectTextAndCDATA(Node node) {     StringBuilder mergedText = new StringBuilder();     NodeList childNodes = node.getChildNodes();     for (int i = 0; i < childNodes.getLength(); i++) {         Node child = childNodes.item(i);         if (child.getNodeType() == Node.TEXT_NODE || child.getNodeType() == Node.CDATA_SECTION_NODE) {             mergedText.append(child.getNodeValue());         }     }     return mergedText.toString(); }
public static MarshalRegistry getOrCreateMarshalRegistry(Context context) {     if (context == null) {         throw new IllegalArgumentException("Context cannot be null");     }     MarshalRegistry registry = (MarshalRegistry) context.get(MarshalRegistry.class.getName());     if (registry == null) {         registry = new MarshalRegistry();         context.put(MarshalRegistry.class.getName(), registry);     }     return registry; }
public static <T> List<T> listContaining(T o1, T o2) {     List<T> list = new ArrayList<>();     list.add(o1);     list.add(o2);     return list; }
public void setParametersMetaData(ParametersMetaData value) {     this.parametersMetaData = value; }
public String getInfo(int type) {     // TODO: Add implementation for the details tab(s)     // This is just a proof of concept     return "This is a proof of concept only."; }
void processBinaryBytes(byte[] data) {     String bytesAsString = new String(data);     try {         writer.writeCharacters(bytesAsString);     } catch (XMLStreamException e) {         // Handle the exception     } }
public String getIsActive() {     return isActive; }
public static DataServer create() {     return new DataServer(); }
public ECKey getFirstKeyWithPrivateKey() {     for (ECKey key : keys) {         if (key.hasPrivKey()) {             return key;         }     }     return null; }
null
public void setMaximumKeySize(long maximumKeySize) {     this.maximumKeySize = maximumKeySize; }
public String getString(String fldname) {     return ts.getVal(fldname); }
public int getBip32HeaderPub() {     return bip32HeaderPub; }
public long getValue() {     return value; }
public MenuItem setActionView(View view) {     mMenuItem.setActionView(view);     return this; }
@Test(expected = IllegalArgumentException.class) public void testDeletePersistentNotificationThrowsIllegalArgumentOnNullServerSession() {     notificationController.deletePersistentNotification(null, mockServerMessage); }
public void setSeconds(double seconds) {     this.seconds = seconds; }
public void setServiceID(ServiceID serviceID) {     this.serviceID = serviceID; }
public long getFileSize() throws IOException {     lock.lock();     try {         return randomAccessFile.length();     } finally {         lock.unlock();     } }
public T getPayload() {    return mPayload; }
public String getFormattedAddedDate() {     SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");     String formattedDate = formatter.format(this.addedDate);     return formattedDate; }
public List<DirectedAcyclicGraphNode<T>> getChildren() {     return mChildren; }
public View getFirstVisibleItem(RecyclerView recyclerView) {     int count = recyclerView.getChildCount();     for (int i = 0; i < count; i++) {         View child = recyclerView.getChildAt(i);         if (!itemIsObscuredByHeader(recyclerView, child, null, mOrientationProvider.getOrientation(recyclerView))) {             return child;         }     }     return null; }
public void setRegTestResultDetailsLst(List<TestResultDetailsDTO> regTestResultDetailsLst) {     this.regTestResultDetailsLst = regTestResultDetailsLst; }
public void setTestId(long testId) {     this.testId = testId; } public long getTestId() {     return testId; }
public void testSetTimeToDataRoundTrip() {     Time time1 = new Time(10, 15, 30);     Date date = new Date();     date.setTime(time1.getTime());     Time time2 = new Time(date.getTime());     assertEquals(time1, time2); }
public void setFeedConfigId(BigDecimal feedConfigId) {     this.feedConfigId = feedConfigId; }
public void setCompressionType(String compressionType) {     ImageWriteParam params = getImageWriteParameters(lookupImageWriterForFormat(imageFormat));     if (params != null) {         params.setCompressionType(compressionType);     } }
public boolean enclosesAll(RangeSet<C> other) {     if (other.isEmpty()) {         return true;     }     for (Range<C> range : other.asRanges()) {         if (!encloses(range)) {             return false;         }     }     return true; }
public class ELEvaluator {     private ExpressionEvaluator evaluator = new ExpressionEvaluatorImpl();     private Map<String, Object> vars;     private Map<String, Method> functions;     private ThreadLocal<ELEvaluator> current = new ThreadLocal<ELEvaluator>();     private Context context;     // other member functions     public void addVariablesToContext(Map<String, Object> variables) {         if (vars == null) {             vars = new HashMap<>();         }         vars.putAll(variables);         context = new SimpleContext(vars, functions);         evaluator.setVariables(vars);     } }
public class ExpandableBuffer {     public static final int OUTPUT_MODE = 1;     public static final int INPUT_MODE = 0;     private int mode;     private ByteBuffer buffer = null;     private ByteBufferAllocator allocator;     // other member functions     public boolean containsData() {         return (buffer != null && buffer.position() > 0);     } }
public class SetStringRecord {     private Block blk;     private String oldval;     private int offset;     private int txnum;     private String newval;     // other member functions     public void writeToLog(LogManager lm) {         Object[] rec = new Object[] { SETSTRING, txnum, blk.fileName(), blk.number(), offset, oldval };         lm.append(rec);     } }
public class Structure {     // member variables here          // constructor and other member functions here          // This method encapsulates the access to the DataFlowNode class     // by creating the object and then adding it to the list     public void addDataFlowNode(DataFlowNode node) {         dataFlow.add(node);     } }
public User get() {     return sUserThreadLocal.get(); }
public boolean addRecipientToList(String recipient) {     if (recipient != null && !recipient.isEmpty()) {         if (!selectedRecipients.contains(recipient)) {             selectedRecipients.add(recipient);             return true;         }     }     return false; }
@Test public void deleteFile() throws IOException {     // create a test file     File file = mTestFolder.newFile("testFile.txt");     // delete the file     FileUtils.delete(file.getAbsolutePath());     // verify that the file has been deleted     assertFalse(file.exists());     // try to delete the same file again and expect an exception     mException.expect(FileNotFoundException.class);     FileUtils.delete(file.getAbsolutePath()); }
public boolean hasOperation(String name, OperationSignatureMask mask) {     for (OperationSignature sig : mask) {         Map<String, OperationStats> statsMap = operations.get(sig);         if (statsMap != null && statsMap.containsKey(name)) {             return true;         }     }     return false; }
public boolean updateUserModel(UserModel model) {     if (model == null) {         return false;     }     return updateUserModel(model.getUsername(), model); } public boolean updateUserModel(String username, UserModel model) {     if (username == null || model == null) {         return false;     }     try {         userService.updateUser(username, model);         return true;     } catch (Exception e) {         logger.error("Failed to update user model for user: " + username, e);         return false;     } }
private void logWithFilterName(String message, Throwable throwable) {     String filterName = config.getFilterName();     if (filterName == null) {         filterName = getClass().getName();     }     String logMessage = filterName + ": " + message;     if (throwable != null) {         config.getServletContext().log(logMessage, throwable);     } else {         config.getServletContext().log(logMessage);     } }
public static void writeEmptyResponse(HttpServletResponse response) {     response.setStatus(HttpServletResponse.SC_OK);     response.setContentLength(0);     response.setContentType("application/json");     try {         response.getWriter().flush();     } catch (IOException e) {         LOG.error("Error writing empty response", e);     } }
public void setCurrentValue(int currentValue) {     this.curValue = currentValue; }
public String getJsonString() {     return m_escapedJson; }
public boolean doesNodeTestPass(NodeTester nodeTester) {     if (nodeTypes == null || rootNode == null) {         return false;     }          for (int i = 0; i < nodeTypes.length; i++) {         Node node = documentTraversal.getFirstChild(rootNode);         while (node != null) {             if (acceptNodeType(nodeTypes[i]) && nodeTester.test(node) == NodeFilter.FILTER_ACCEPT) {                 return true;             }             node = documentTraversal.getNextSibling(node);         }     }          return false; }
public static BlockStoreContext getOrCreate(final InetSocketAddress masterAddress, final BlockMasterClientPool masterClientPool, final boolean hasLocalWorker) {     BlockStoreContext context = CACHED_CONTEXTS.get(masterAddress);     if (context == null) {         context = new BlockStoreContext(masterClientPool, hasLocalWorker);         CACHED_CONTEXTS.put(masterAddress, context);     }     return context; }
private void initializeJpegWriter() {     // Lookup image writer for JPEG format     ImageWriter writer = lookupImageWriterForFormat("JPEG");     if (writer != null) {         // Set compression type and mode         setWriteCompressionType("JPEG");         setWriteCompressionMode(ImageWriteParam.MODE_EXPLICIT);         // Set compression quality         setWriteCompressionQuality(writeCompressionQuality);         // Get the writer's parameters and set the compression quality         ImageWriteParam writeParam = getImageWriteParameters(writer);         if (writeParam != null) {             writeParam.setCompressionQuality(writeCompressionQuality);         }     } }
public String createOmaLink(String omaQueryString) {     // Remove the path from omaQueryString     String queryString = removePath(omaQueryString);          // Get the parameter map from the query string     String[] params = queryString.split("&");     HashMap<String, String> paramMap = getParameterMap(params);          // Create a list of parameter keys     ArrayList<String> keyList = getKeyList(paramMap);          // Conditionally prepend http:// to omaUrl     String omaUrl = conditionallyPrependHttp(paramMap.get(SITE_PARAM));          // Create the redirect link     StringBuilder sb = new StringBuilder(OMA_REDIRECT_LINK);     sb.append("path=/");     sb.append(getDelimiter(0, keyList));     sb.append(queryString);     return sb.toString(); }
public void setThreadingParametersForEngine(JettyHTTPServerEngine engine, ThreadingParameters threadingParams) {     String key = engine.getHost() + ":" + engine.getPort();     threadingParametersMap.put(key, threadingParams);     engine.setThreadingParameters(threadingParams); }
public void registerGenerator(Language language, CodeGenerator generator) {     if (generators.containsKey(language)) {         LOG.info("Replacing existing generator for language " + language);     }     generators.put(language, generator); }
public void setVariable(String name, Object value) {     vars.put(name, value); }
public long getIndex() {     return index; }
public void fireBullet() {     if (bullets.size() < MAX_BULLETS) {         bullets.add(new Bullet(xPos, yPos, zPos, heading));         bulletTime = System.nanoTime();     } }
public GetOfferDetailsResponse.Return.DetailOfferData.OfferDisplay createGetOfferDetailsResponseReturnDetailOfferDataOfferDisplay() {     return new GetOfferDetailsResponse.Return.DetailOfferData.OfferDisplay(); }
public Long getAcknowledgementInterval() {     return this.acknowledgementInterval; }
public void closeAllConnectionsGracefully() {     for (ServerConnection connection : server.getConnections()) {         connection.closeConnection(closeReason);     } }
public void report(int level, Position pos, String message) {     if (should_report(Report.types, level)) {         String fullMessage = formatMessage(level, pos, message);         ErrorInfo errorInfo = new ErrorInfo(fullMessage, pos, level);         eq.enqueue(errorInfo);     } } private String formatMessage(int level, Position pos, String message) {     StringBuilder sb = new StringBuilder();     sb.append("[").append(levelToString(level)).append("]");     if (pos != null) {         sb.append(" ").append(pos).append(":");     }     sb.append(" ").append(message);     return sb.toString(); } private String levelToString(int level) {     switch (level) {         case INFO:             return "INFO";         case WARNING:             return "WARNING";         case ERROR:             return "ERROR";         case FATAL:             return "FATAL";         default:             return "UNKNOWN";     } }
public Access createAccess() {     return new Access(); }
public void setFailedAttributeName(String failedAttributeName) {     this.failedAttributeName = failedAttributeName; }
public class ShellBasedUnixGroupsMapping {     // ...     public List<String> getGroupsForUser(String user) throws IOException, InterruptedException {         List<String> groups = new ArrayList<String>();         Process process = Runtime.getRuntime().exec("groups " + user);         process.waitFor();         String output = new String(process.getInputStream().readAllBytes());         String[] parts = output.trim().split(":")[1].split("\\s+");         for (String group : parts) {             groups.add(group);         }         return groups;     }     // ... }
public void flush() throws IOException {     clientEndpoint.flush(); }
public MetadataEditorCompat putString(int key, String value) {     if (mActualMetadataEditor != null) {         mActualMetadataEditor.putString(key, value);     }     return this; }
void landing() {     cmd.setLanding();     Log.d(TAG, "Landing"); }
public Builder metadata(Map<String,String> metadata) {     this.metadata = metadata;     return this; }
public void testGetDirectionOfVariation() {     RMCParser parser = new RMCParser(EXAMPLE);     assertEquals("E", parser.getDirectionOfVariation()); }
public String getCleanerInput(String dirty) {     if (dirty == null) {         return null;     }          String clean = dirty.replaceAll("(?i)javascript", "");     clean = clean.replaceAll("\\\\", "\\\\\\\\")                  .replaceAll("\\\"", "\\\\\"")                  .replaceAll("\\\'", "\\\\\'");          return clean; }
public String getWsseValueType() {     return this.wsseValueType; }
public GenericJSONBuilder addExtraText(String text) {     this.extras.add(text);     return this; }
public List<Resource> getResources() {     return this.resources; }
public boolean hasSetting(String key) {     return this.overrides.containsKey(key) || this.read().containsKey(key); }
public static ResourceTypeHandler valueOfSafe(final String name) {     if (name == null) {         return null;     }     try {         return valueOf(name);     } catch (IllegalArgumentException ex) {         return null;     } }
protected void testNode(Node aNode, NodeTest forTest) {     switch (aNode.getNodeType()) {         case Node.DOCUMENT_NODE:             testDocumentType((DocumentType) aNode);             break;         case Node.ELEMENT_NODE:             testElement((Element) aNode);             break;         case Node.TEXT_NODE:             testText((Text) aNode);             break;         case Node.CDATA_SECTION_NODE:             testCDATASection((CDATASection) aNode);             break;         case Node.COMMENT_NODE:             testComment((Comment) aNode);             break;         case Node.ENTITY_REFERENCE_NODE:             testEntityReference((EntityReference) aNode);             break;         case Node.ENTITY_NODE:             testEntity((Entity) aNode);             break;         case Node.PROCESSING_INSTRUCTION_NODE:             testProcessingInstruction((ProcessingInstruction) aNode);             break;         case Node.ATTRIBUTE_NODE:             testAttribute((Attr) aNode);             break;         default:             unhandled(aNode);             break;     } }
public long getAverageElapsed() {     long total = getTotal();     if (total == 0) {         return 0;     } else {         return getTotalElapsed() / total;     } }
public void setOK() {     setKO(true);     setWarning(false);     errorLevel = 0; }
/**  * Test method for {@link net.sf.marineapi.nmea.parser.RMBParser#setBearing(double)}.  */ void testSetBearing() {     double bearing = 180.0; // example value, can be replaced with any valid value for testing     rmb.setBearing(bearing);     assertEquals(bearing, rmb.getBearing(), 0.01); }
public AlluxioURI getFilePath(long fileId) throws FileDoesNotExistException, InvalidPathException {     FileInfo fileInfo = mFileSystemMaster.getFileInfo(fileId);     if (fileInfo == null) {         throw new FileDoesNotExistException(ExceptionMessage.FILE_NOT_FOUND.getMessage(fileId));     }     return new AlluxioURI(fileInfo.getPath()); }
@Override public int hashCode() {     return Arrays.hashCode(bytes); }
public int getTag() {     return tag; }
/**  * Returns the block header this object wraps. The referenced block object must not have any transactions in it.  */ public Block getHeader() {     return header; }
public FCKeditorConfig getConfig() {     return config; } public void setConfig(FCKeditorConfig config) {     this.config = config; }
public Difference getAdditionDifference() {     return additionDifference; }
public String getVersion() {     return this.version; }
void transferElement() {     if (!vstack.isEmpty()) {         throw new IllegalStateException("Virtual stack is not empty");     }     if (real_stack.isEmpty()) {         throw new IllegalStateException("Real stack is empty");     }     vstack.push(real_stack.pop().intValue()); }
public void assertTimeout() {     try {         countDownLatch.await(10, TimeUnit.SECONDS); // Wait for completion for up to 10 seconds         assertTrue(future.isDone()); // Verify that the future has completed         future.get(); // Ensure that the future does not throw an exception     } catch (InterruptedException e) {         fail("Interrupted while waiting for future to complete");     } catch (ExecutionException e) {         fail("Future threw an unexpected exception: " + e.getCause().getMessage());     } catch (TimeoutException e) {         fail("Future did not complete within the expected time frame");     } } public void assertException(Throwable expectedCause) {     try {         countDownLatch.await(10, TimeUnit.SECONDS); // Wait for completion for up to 10 seconds         assertTrue(future.isDone()); // Verify that the future has completed         future.get(); // Ensure that the future throws an exception         fail("Future did not throw an exception as expected");     } catch (InterruptedException e) {         fail("Interrupted while waiting for future to complete");     } catch (ExecutionException e) {         Throwable actualCause = e.getCause();         assertEquals(expectedCause.getClass(), actualCause.getClass());         assertEquals(expectedCause.getMessage(), actualCause.getMessage());     } catch (TimeoutException e) {         fail("Future did not complete within the expected time frame");     } }
public void setInternalId(int gisticID) {     this.gisticID = gisticID; }
public long getAndAdd(K key, long delta) {     LongAdder adder = new LongAdder();     Long currentValue = map.putIfAbsent(key, 0L);     if (currentValue != null) {         adder.add(currentValue);     }     adder.add(delta);     map.put(key, adder.sum());     return adder.sum() - delta; }
null
public void removePlugin(AbstractPlugin plugin) {     allPlugins.removePlugin(plugin);     notifyContainerChanged(); }
public List<String> getGroupsForUser(String username) {     List<String> groups = new ArrayList<>();     // TODO: implement the logic to retrieve groups for the user from a data source     return groups; }
public void bind(ServiceID localServiceID) {     try {         netImpl.bind(this, localServiceID);         this.localServiceID = localServiceID;     } catch (IOException e) {         // Handle or propagate the exception as appropriate     } }
void testGetResponseStringCsv() {     String expected = "1234,5678,90,true,0,1000,2000,3000,4000,\"test response\"";     instance.setThreadNumber(1234);     instance.setTsSend(5678);     instance.setTsReceived(90);     instance.setFaultFlag(true);     instance.setDuration(1000);     instance.setResponseString("test response");     String actual = instance.getResponseStringCsv();     assertEquals(expected, actual); }
TextButton defineTextButton(TextButton button, String text, BitmapFont font, Color fontColor, Drawable up, Drawable down, Drawable checked, float x, float y, float width, float height) {     if (button == null) {         button = new TextButton(text, new TextButton.TextButtonStyle(up, down, checked, font));     } else {         button.setText(text);         button.setStyle(new TextButton.TextButtonStyle(up, down, checked, font));     }     button.setPosition(x, y);     button.setWidth(width);     button.setHeight(height);     button.getLabel().setColor(fontColor);     return button; }
public Sha256Hash getDataHash() {     ByteArrayOutputStream stream = new ByteArrayOutputStream();     try {         write(stream);     } catch (IOException e) {         // Should not happen since we are writing to a ByteArrayOutputStream         throw new RuntimeException(e);     }     return Sha256Hash.of(stream.toByteArray()); }
void addRecordField(Object value) {     if (value == null) {         addByte(PackFormatInputStream.NIL);     } else if (value instanceof String) {         addByte(PackFormatInputStream.STRING);         addString((String) value);     } else if (value instanceof Long) {         addByte(PackFormatInputStream.INTEGER);         addLong((Long) value);     } else if (value instanceof Integer) {         addByte(PackFormatInputStream.INTEGER);         addInt((Integer) value);     } else if (value instanceof Double) {         addByte(PackFormatInputStream.REAL);         addString(value.toString());     } else if (value instanceof Boolean) {         addByte(PackFormatInputStream.BOOLEAN);         addByte((byte) (((Boolean) value) ? 1 : 0));     } else {         throw new IllegalArgumentException("Unsupported type: " + value.getClass());     } }
public void testIsTrue() {     String sentence = "$GPHDT,123.456,T*22";     HDTParser parser = new HDTParser(sentence);     assertTrue(parser.isTrue()); }
public void restrictVisibilitiesTo(Signature.Visibility... visibilities) {     visMask.clear();     for (Signature.Visibility visibility : visibilities) {         visMask.add(visibility);     } }
/**  * Ask the user for an input string.  *  * @param question the prompt displayed to the user  * @param words    the allowed words that the input string can match (case insensitive)  * @return the input string provided by the user  */ public String getStringIgnoreCase(String question, String... words) {     String input;     do {         System.out.print(question + " ");         input = scanner.nextLine();         input = input.trim();     } while (!Arrays.stream(words).anyMatch(input::equalsIgnoreCase));     return input; }
public Options getOptions() {     Options options = new Options();     options.addOption(PROPERTY_FILE_OPTION);     options.addOption(READONLY_OPTION);     options.addOption(MOUNT_SHARED_OPTION);     options.addOption(RECURSIVE_OPTION);     options.addOption(FORCE_OPTION);     return options; }
@Test public void testSetHeading() {     double heading = 123.45;     String sentence = EXAMPLE.replace("000.0", String.format("%.1f", heading));     vhw.parse(sentence);     assertEquals(heading, vhw.getHeading(), 0.01); }
public Variable getOtherVariableFromBinaryConstraint(Constraint binaryConstraint, Variable var) {     if (binaryConstraint.getScope().size() != 2) {         throw new IllegalArgumentException("Constraint must be binary.");     }     if (!binaryConstraint.getScope().contains(var)) {         throw new IllegalArgumentException("Variable is not in constraint scope.");     }     for (Variable v : binaryConstraint.getScope()) {         if (!v.equals(var)) {             return v;         }     }     // should never get here     throw new RuntimeException("Error finding other variable in binary constraint."); }
public double getOccupancy() {     return this.occupancy; }
@Override public String toString() {     return this.literalName; }
public void render(String url, int width, int height) {     try {         // Create a new XML parser for the given URL         XMLResource xmlResource = XMLResource.load(new URL(url));         // Set the document to render         this.panel.setDocument(xmlResource.getDocument());         // Set the dimensions         this.dim.setSize(width, height);         // Layout the document         layout((Graphics2D) this.panel.getGraphics(), dim);         // Render the document         render((Graphics2D) this.panel.getGraphics());     } catch (Exception e) {         e.printStackTrace();     } }
public String getDescription() {     String encodedHeadline = TodoParser.encode(item.getHeadline());     return encodedHeadline; }
public String accountNumberSummary() {     StringBuilder summary = new StringBuilder();     for (Customer customer : customers) {         summary.append("Account numbers for ").append(customer.getName()).append(": ");         List<Account> accounts = customer.getAccounts();         if (accounts.isEmpty()) {             summary.append("No accounts found\n");         } else {             for (Account account : accounts) {                 summary.append(account.getAccountNumber()).append(", ");             }             summary.delete(summary.length() - 2, summary.length()); // remove last comma and space             summary.append("\n");         }     }     return summary.toString(); }
public double min() {     if (count == 0) {         throw new IllegalStateException("Cannot calculate minimum value with empty dataset.");     }     double minValue = Double.POSITIVE_INFINITY;     boolean hasFiniteValue = false;     for (double value : values) {         if (Double.isNaN(value)) {             return Double.NaN;         }         if (value == Double.NEGATIVE_INFINITY) {             return Double.NEGATIVE_INFINITY;         }         if (value < minValue) {             minValue = value;             hasFiniteValue = true;         }     }     return hasFiniteValue ? minValue : Double.POSITIVE_INFINITY; }
@Test public void testGetDeviceBlock() {     // TODO: Implement test case for getDeviceBlock method }
public void lowerAltitude() {     // Lower the drone's altitude by sending the appropriate command     cmd.sendCommand("lowerAltitude");     // Wait for the drone to lower its altitude     waitFor(hoverTime); }
public void clear() {     bufferSize = 0;     buffer = new byte[INITIAL_BUFFER_CAPACITY]; }
public byte[] getAlertSigningKey() {     return alertSigningKey; }
public String getType(Uri uri) {     int match = mUriMatcher.match(uri);     for (E entry : mEntries) {         if (entry.match(match)) {             return entry.getType(uri);         }     }     throw new IllegalArgumentException("Unknown URI " + uri); }
public static void short2leb(final short x, final OutputStream os) throws IOException {     os.write((byte)(x & 0xFF));     os.write((byte)((x >> 8) & 0xFF)); }
public class VectorVectorMult {          // Member variables          // Member functions          /**      * Multiplies a householder reflection against a vector: y = (I + gamma * u * u^T) * x.      * The Householder reflection is used in some implementations of QR decomposition.      *       * @param x The vector x to be multiplied.      * @param y The resulting vector y after multiplication.      * @param A This parameter is not used in this method.      */     public void mult(DenseMatrix64F x, DenseMatrix64F y, DenseMatrix64F A) {         double gamma = -2.0 / innerProd(u, u);         outerProd(u, x, A);         addOuterProd(gamma, u, A, y);     }          // Other member functions }
public class CompressionUtils {     private static final Logger LOGGER = LoggerFactory.getLogger(CompressionUtils.class);     // Other member variables and methods     /**      * Tar.xz the contents of the tree at the (optionally) specified revision and the (optionally)      * specified basepath to the supplied outputstream.      *      * @param repository The repository containing the tree to be tar.xz'ed.      * @param basePath The base path of the tree to be tar.xz'ed.      * @param objectId The ID of the revision to be tar.xz'ed.      * @param os The OutputStream to write the tar.xz'ed contents to.      * @return True if the tar.xz'ing was successful, false otherwise.      */     public boolean tarXZ(Repository repository, String basePath, String objectId, OutputStream os) {         boolean success = false;         try {             TarArchiveOutputStream tarOut = new TarArchiveOutputStream(new XZCompressorOutputStream(os));             ObjectId rootId = repository.resolve(objectId);             RevWalk revWalk = new RevWalk(repository);             RevCommit commit = revWalk.parseCommit(rootId);             TreeWalk treeWalk = new TreeWalk(repository);             treeWalk.addTree(commit.getTree());             if (!basePath.isEmpty()) {                 treeWalk.setFilter(PathFilter.create(basePath));             }             while (treeWalk.next()) {                 if (treeWalk.isSubtree()) {                     tarOut.putArchiveEntry(new TarArchiveEntry(treeWalk.getPathString() + "/"));                     tarOut.closeArchiveEntry();                 } else {                     ObjectId objectIdOfEntry = treeWalk.getObjectId(0);                     ObjectLoader loader = repository.open(objectIdOfEntry);                     tarOut.putArchiveEntry(new TarArchiveEntry(treeWalk.getPathString()));                     loader.copyTo(tarOut);                     tarOut.closeArchiveEntry();                 }             }             treeWalk.close();             tarOut.close();             success = true;         } catch (IOException | GitAPIException e) {             error(e, repository, "Failed to tar.xz contents of tree at base path %s and object ID %s", basePath, objectId);         }         return success;     }     // Other member functions }
public String query() {     // Create instance of builder for specific language     return FIQL; }
private <T extends JspNode> void addNodeAndSubnodes(Set<JspNode> nodes, JspNode node, Class<T> clazz) {     if (clazz == null || clazz.isInstance(node)) {         nodes.add(node);     }     for (JspNode child : node.getChildren()) {         addNodeAndSubnodes(nodes, child, clazz);     } } public <T extends JspNode> Set<T> getNodes(Class<T> clazz, String source) {     // implementation to get nodes from the source     Set<JspNode> allNodes = getAllNodes(source);     Set<T> nodes = new HashSet<T>();     for (JspNode node : allNodes) {         addNodeAndSubnodes(nodes, node, clazz);     }     return nodes; }
public boolean useForWriting(MotionEvent event) {     return (event.getAction() == MotionEvent.ACTION_DOWN || event.getAction() == MotionEvent.ACTION_MOVE); }
public void reportInvalidRequestError(String errorDescription) {     if (blockUnsecureRequests) {         LOG.warning("Insecure request blocked: " + errorDescription);     } else {         LOG.warning("Insecure request detected: " + errorDescription);     } }
public void destroy() {     log.info("Stopping XMPP listener and disconnecting from all XMPP servers...");     // shutdown worker pool     if (workerPool != null) {         workerPool.shutdownNow();         try {             workerPool.awaitTermination(WORKER_KEEP_ALIVE, TIME_UNIT);         } catch (InterruptedException e) {             log.warn("Worker pool termination interrupted.", e);         }     }     // disconnect from all XMPP servers     if (xmppConnection != null && xmppConnection.isConnected()) {         for (ConnectionFactory connectionFactory : connectionFactories.values()) {             XMPPConnection connection = connectionFactory.getConnection();             if (connection.isConnected()) {                 connection.disconnect();             }         }         xmppConnection = null;     }     log.info("XMPP listener stopped and disconnected from all XMPP servers."); }
public String getString(String key) {     Object value = mMap.get(key);     if (value instanceof String) {         return (String) value;     } else if (value != null) {         return value.toString();     } else {         return null;     } }
public void processPCMBytes(byte[] pcmBytes) {     if (line != null && line.isOpen()) {         line.write(pcmBytes, 0, pcmBytes.length);     } }
public int sizeOf(long value) {     if ((value & (0xffffffffffffffffL << 7)) == 0) {         return 1;     }     if ((value & (0xffffffffffffffffL << 14)) == 0) {         return 2;     }     if ((value & (0xffffffffffffffffL << 21)) == 0) {         return 3;     }     if ((value & (0xffffffffffffffffL << 28)) == 0) {         return 4;     }     if ((value & (0xffffffffffffffffL << 35)) == 0) {         return 5;     }     if ((value & (0xffffffffffffffffL << 42)) == 0) {         return 6;     }     if ((value & (0xffffffffffffffffL << 49)) == 0) {         return 7;     }     if ((value & (0xffffffffffffffffL << 56)) == 0) {         return 8;     }     return 9; }
public boolean isParseRetain() {     return parseRetain; }
public void setRunStatus(String runStatus) {     this.runStatus = runStatus; }
public void spin90Right() {     drone.spinRight(spin90Time);     waitFor(spinTime); }
public Map<Long, Integer> createNewClientIdsMap() {     return new HashMap<Long, Integer>(); }
public XPathContext copy() {     XPathContext copy = new XPathContext();     copy.expression = this.expression;     copy.type = this.type;     copy.path = new LinkedList<Level>(this.path);     copy.children = new ArrayList<Level>(this.children.size());     for (Level child : this.children) {         copy.children.add(child.copy());     }     copy.uri2Prefix = new HashMap<String, String>(this.uri2Prefix);     copy.attributes = new HashMap<QName, Level>(this.attributes.size());     for (Map.Entry<QName, Level> entry : this.attributes.entrySet()) {         copy.attributes.put(entry.getKey(), entry.getValue().copy());     }     copy.name = this.name;     return copy; }
private int hashToBucketIndex(byte[] key) {     int hashCode = INDEX_HASHER.hashBytes(key).asInt();     int bucketIndex = Math.abs(hashCode) % mNumBuckets;     return bucketIndex; }
public void testHasParser() {     assertTrue(instance.hasParser("$GPGGA"));     assertTrue(instance.hasParser("$GPVTG"));     assertFalse(instance.hasParser("$XYZ")); }
public String getProxiesHeader() {     return proxiesHeader; }
public String stringifyXPath() {     StringBuilder xpathBuilder = new StringBuilder();     for (Level level : path) {         xpathBuilder.append(SEP);         xpathBuilder.append(level.getNode().getNodeName());         if (level.getType() == Level.ATTRIBUTE_NODE) {             xpathBuilder.append(ATTR);             xpathBuilder.append(level.getName().getLocalPart());         } else if (level.getIndex() >= 0) {             xpathBuilder.append(OPEN);             xpathBuilder.append(level.getIndex() + 1);             xpathBuilder.append(CLOSE);         }     }     return xpathBuilder.toString(); }
public void setRunId(BigDecimal runId) {     this.runId = runId; }
public boolean isDotAtEndOfProduction() {     return (_dot_pos == _the_production.rhs_size()); }
void equalsTest() {    CompleteFileOptions options1 = new CompleteFileOptions();    CompleteFileOptions options2 = new CompleteFileOptions();    // Assert that the two options objects are equal    assertEquals(options1, options2); }
public static Permission getPermissionById(int id) {     for (Permission p : PERMISSIONS.values()) {         if (p.m_permissionIndex == id) {             return p;         }     }     return null; }
public void cancelAllOperations() {     cancelled = true;     if(listener != null) {         listener.onCancelled(this);     } }
public static JsonArray translateToStringArray(Set<String> strings) {     if (strings == null || strings.isEmpty()) {         return null;     }     JsonArray array = new JsonArray();     for (String string : strings) {         array.add(new JsonPrimitive(string));     }     return array; }
public void testGetSpeedKnots() {     try {         vhw.parse(EXAMPLE);         assertEquals(0.0, vhw.getSpeedKnots(), 0.001);     } catch (Exception e) {         fail("Unexpected exception was thrown: " + e.getMessage());     } }
public class RPCMessage {     private int mId;     public ByteToMessageDecoder createFrameDecoder() {         // implementation     }     public int getId() {         return mId;     }     public Type decode(ByteBuf in) {         // implementation     }     public int getEncodedLength() {         // implementation     }     public void encode(ByteBuf out) {         // implementation     }     public Type getType() {         // implementation     }     public DataBuffer getPayloadDataBuffer() {         // implementation     }     public RPCMessage decodeMessage(Type type, ByteBuf in) {         // implementation     }     public boolean hasPayload() {         // implementation     }     public void validateMessage() throws Exception {         // implementation     } }
public class ProductScan {     Scan s1;     Scan s2;     public boolean next() {         // implementation code here     }     public int getInt(String fldname) {         // implementation code here     }     public Constant getVal(String fldname) {         // implementation code here     }     public void beforeFirst() {         // implementation code here     }     public String getString(String fldname) {         // implementation code here     }     public void close() {         // implementation code here     }     public boolean isFieldPresent(String fieldName) {         return s1.hasField(fieldName) || s2.hasField(fieldName);     } }
public class UserInfo {     private String EMAIL = "email_address";          public String getEmailId(HttpServletRequest request) {         // implementation     }          public boolean isUserAuthenticated(HttpServletRequest request) {         // implementation     }          public void logoutUser(HttpServletRequest request) {         // implementation     }          public void registerUserSessionAsAuthenticated(HttpServletRequest request) {         // implementation     }          // implementation of registerUserSessionAsAuthenticated method     public void registerUserSessionAsAuthenticated(HttpServletRequest request) {         HttpSession session = request.getSession();         session.setAttribute("authenticated", true);     } }
public FullyQualifiedClassType getHandlerClass() {     return handlerClass; }
public void saveOldRevisionInformationOfGraph(String graphName, String revisionGraph) {     oldRevisionGraphMap.put(graphName, revisionGraph);     logger.info("Saved old revision information of " + graphName); }
public int num_columns() {     int columns = 0;     if (_size > 0) {         columns = under_term[0].num_terminals();     }     return columns; }
public Spring getControlSpring() {     if (mControlSpringIndex < 0 || mControlSpringIndex >= mSprings.size()) {         return null;     }     return mSprings.get(mControlSpringIndex); }
public ExtensionInfo getExtensionInfo() {     ExtensionInfo extensionInfo = null;     List<ExtensionInfo> extensions = allExtensions();     for (ExtensionInfo ext : extensions) {         if (ext.getName().equals(job.extensionName())) {             extensionInfo = ext;             break;         }     }     return extensionInfo; }
public void setUp() {     EXAMPLE = "$GPRMB,A,0.00,R,,RUSKI,5536.200,N,01436.500,E,432.3,234.9,,V*58";     rmb = new RMBSentence(EXAMPLE);     empty = new RMBSentence();     // Set up other member variables if needed }
public void setScopes(List<OAuthPermission> scopes) {     this.scopes = scopes; }
public List<Ingredient> getAllIngredients() {     return ingredientRepository.findAll(); }
public String getAdjustedPartString(int index, String[] parts, int headerCount) {     String part = "";     if (index < headerCount && index < parts.length) {         part = parts[index].trim();         if (part.equals("NA")) {             part = "";         }     }     return part; }
public void setTimeoutEnabled(boolean timeoutEnabled) {     this.timeoutEnabled = timeoutEnabled;     if (timeoutEnabled) {         resetTimeout();     } else {         cancelTimeout();     } } private void resetTimeout() {     if (timeoutTask != null) {         timeoutTask.cancel();     }     if (timeoutMillis > 0) {         timeoutTask = new TimerTask() {             @Override             public void run() {                 timeoutOccurred();             }         };         timeoutTimer.schedule(timeoutTask, timeoutMillis);     } } private void cancelTimeout() {     if (timeoutTask != null) {         timeoutTask.cancel();         timeoutTask = null;     } } public void timeoutOccurred() {     // This method can be implemented as needed }
/**  * Recursively lists folders in the Box account. Primarily used for debugging.  */ void listFolders() {     System.out.println(INDENT_APPEND + "Listing folders in " + currentFolder.getName());     for (BoxItem.Info itemInfo : currentFolder) {         if (itemInfo instanceof BoxFolder.Info) {             BoxFolder folder = (BoxFolder) itemInfo.getResource();             System.out.println(INDENT_APPEND + INDENT_APPEND + folder.getName());             CloudStorage subCloudStorage = new CloudStorage(tb, INDENT_APPEND + INDENT_APPEND, LOGIN_MESSAGE, folder, MISSING_FOLDER_MESSAGE, folder, devToken);             subCloudStorage.listFolders();         }     } }
public void closeConnection() {     try {         vCloseRequested = true;         socket.close();         StreamParser.connectionClosed();     } catch (IOException e) {         log.error("Error occurred while closing the connection: ", e);     } }
public void assignEncoderToMuxer() {     if (mAudioEncoder != null && mAudioEncoder.isRunning()) {         int trackIndex = mMediaMuxer.addTrack(mAudioEncoder.getOutputFormat());         mAudioEncoder.setTrackIndex(trackIndex);     }          if (mVideoEncoder != null && mVideoEncoder.isRunning()) {         int trackIndex = mMediaMuxer.addTrack(mVideoEncoder.getOutputFormat());         mVideoEncoder.setTrackIndex(trackIndex);     }          if (mAudioEncoder != null && mVideoEncoder != null) {         mMediaMuxer.start();         mIsStarted = true;         mStatredCount++;     } }
public float getFinal() {     if (mInterpolator == null) {         return mFinal;     }          float distance = mFinal - mStart;     float timePassed = timePassed();     float duration = (float) mDuration;     float value = mInterpolator.getInterpolation(timePassed / duration);     float finalValue = mStart + distance * value;          return finalValue; }
public static void notEmpty(Map<?, ?> map, String message) {     if (map == null || map.isEmpty()) {         throw new IllegalArgumentException(message);     } } public static void notEmpty(Map<?, ?> map) {     notEmpty(map, "The map must not be null and must have at least one entry"); }
@Test(expected = NullPointerException.class) public void testRegisterUserSessionWithNullServerSessionThrowsException() {     notificationController.registerUserSession(null, mockServerMessage); }
void doAction(int oldStep) {     if (oldStep < 0 || oldStep >= step) {         return;     }     // Undo the actions for all steps after the given step     for (int i = step - 1; i >= oldStep; i--) {         WizardItem undoItem = panels.get(i).getToDoItem().getUndoItem();         if (undoItem != null) {             undoItem.doAction();         }         step--;     } }
@Override public int compareTo(Tag other) {     int result = key.compareTo(other.getKey());     if (result == 0) {         result = value.compareTo(other.getValue());     }     return result; }
/**  * Set a default spacing value. This is used as a fallback when no spacing  * has been set for a particular direction.  *  * @param value the default spacing value to be set  * @return true if the value was set successfully, false otherwise  */ public boolean setDefaultSpacing(float value) {     if (mDefaultSpacing == null) {         mDefaultSpacing = newFullSpacingArray();     }     for (int i = 0; i < sFlagsMap.length; i++) {         if ((mValueFlags & sFlagsMap[i]) == 0) {             mDefaultSpacing[i] = value;         }     }     return true; }
public List<URL> findResourcesInternal(Collection<String> basePackages, String extension, ClassLoader loader) throws IOException {     List<URL> result = new ArrayList<URL>();     for (String basePackage : basePackages) {         String packagePath = basePackage.replace('.', '/');         Enumeration<URL> resources = loader.getResources(packagePath);         while (resources.hasMoreElements()) {             URL resource = resources.nextElement();             if (resource.getProtocol().startsWith(CLASSPATH_URL_SCHEME)) {                 JarURLConnection jarConn = (JarURLConnection) resource.openConnection();                 JarFile jarFile = jarConn.getJarFile();                 Enumeration<JarEntry> entries = jarFile.entries();                 while (entries.hasMoreElements()) {                     JarEntry entry = entries.nextElement();                     String entryName = entry.getName();                     if (entryName.startsWith(packagePath) && entryName.endsWith(extension)) {                         result.add(loader.getResource(entryName));                     }                 }             } else {                 File directory = new File(resource.getFile());                 if (directory.exists()) {                     File[] files = directory.listFiles();                     for (File file : files) {                         if (file.getName().endsWith(extension)) {                             result.add(file.toURI().toURL());                         }                     }                 }             }         }     }     return result; }
public void navigateToAttribute(QName attribute) {     Level level = path.peekLast();     if (level != null && level.hasNode()) {         Level attrLevel = attributes.get(attribute);         if (attrLevel != null && attrLevel.hasNode()) {             path.addLast(attrLevel);             return;         }         NodeInfo node = level.getNode();         if (node != null) {             String value = node.getAttributeValue(attribute);             if (value != null) {                 Level newLevel = new Level(node, attribute);                 path.addLast(newLevel);                 attributes.put(attribute, newLevel);                 return;             }         }     } }
public String determineContentType(Message message) {     for (ContentTypeRule rule : rules) {         if (rule.matches(message)) {             return rule.getContentType();         }     }     return defaultContentTypeProperty; }
public GetOfferDetailsResponse.Return.DetailOfferData.FulfillmentPartner createGetOfferDetailsResponseReturnDetailOfferDataFulfillmentPartner() {     return new GetOfferDetailsResponse.Return.DetailOfferData.FulfillmentPartner(); }
public void setItems(ItemList<T> items) {     this.items = items; }
public class DirectedAcyclicGraph<T> {     private List<DirectedAcyclicGraphNode<T>> mRoots;     private Map<T, DirectedAcyclicGraphNode<T>> mIndex;          // Other member variable and function declarations          public boolean contains(T payload) {         for (DirectedAcyclicGraphNode<T> root : mRoots) {             if (root.getPayload().equals(payload)) {                 return true;             }         }         return false;     }          // Other member function implementations }
public class FsELFunctions {     // Member variable declarations     // Member function declarations     public FileSystem getFileSystem(URI uri) {         // Implementation     }     public boolean fs_isDir(String pathUri) {         // Implementation     }     public boolean fs_exists(String pathUri) {         // Implementation     }     public long fs_dirSize(String pathUri) {         // Implementation     }     public FileStatus getFileStatus(String pathUri) {         // Implementation     }     public long fs_blockSize(String pathUri) {         // Implementation     }     public long getLen(String pathUri) {         // Implementation     } }
public class SentenceFactoryTest {     private SentenceFactory instance = SentenceFactory.getInstance();     @Test     public void testHasParser() {         // Implementation     }     @Test     public void testCreateCustomParser() {         // Implementation     }     @Test     public void testRegisterInvalidParser() {         // Implementation     }     @Test     public void testCreateParserWithRandom() {         // Implementation     }     @Before     public void setUp() {         // Implementation     }     @Test     public void testCreateParserWithNull() {         // Implementation     }     @Test     public void testCreateParserWithUnregistered() {         // Implementation     }     @Test     public void testRegisterParserWithAlternativeBeginChar() {         // Implementation     }     @Test     public void testSupportedTypesRegistered() {         // Implementation     }     @Test     public void testCreateParserWithEmptyString() {         // Implementation     }     @Test     public void testCreateEmptyCustomParser() {         // Implementation     }     @Test     public void testCreateEmptyParserWithSentenceIdStr() {         // Implementation     }     @Test     public void testCreateEmptyParserWithSentenceId() {         // Implementation     }     @Test     public void testCreateParser() {         // Implementation     }     @Test     public void testGetInstance() {         // Implementation     }     @Test     public void testUnregisterParser() {         // Implementation     } }
public class Mapping {     private long tStart;     private long qStart;     private long tStop;     private int blockSize;     public long getTStart() {         // Implementation     }     public int getBlockSize() {         // Implementation     }     public long getQStart() {         // Implementation     } }
public class CountDownAnimation {     private Handler mHandler = new Handler();     private int mStartCount;     private CountDownListener mListener;     private Runnable mCountDown = new Runnable() {         public void run() {             if (mCurrentCount > 0) {                 mTextView.setText(mCurrentCount + "s");                 mTextView.startAnimation(mAnimation);                 mCurrentCount--;             } else {                 mTextView.setVisibility(View.GONE);                 if (mListener != null)                     mListener.onCountDownEnd(CountDownAnimation.this);             }         }     };     private TextView mTextView;     private Animation mAnimation;     private int mCurrentCount;     public void setCountDownListener(CountDownListener listener) {         // Implementation     }     public void setStartCount(int startCount) {         // Implementation     }     public void setAnimation(Animation animation) {         // Implementation     }     public void cancel() {         // Implementation     }     public Animation getAnimation() {         // Implementation     }     public void start() {         // Implementation     }     public void onCountDownEnd(CountDownAnimation animation) {         // Implementation     }     public void run() {         // Implementation     } }
public class IndexJoinPlan {     private IndexInfo ii;     private Plan p1;     private Plan p2;     private String joinfield;     private Schema sch = new Schema();     public Schema schema() {         // Implementation     }     public int blocksAccessed() {         // Implementation     }     public int distinctValues(String fldname) {         // Implementation     }     public Scan open() {         // Implementation     }     public int estimateOutputRecords() {         // Estimate the number of output records in the join using the given formula         int p1Records = p1.blocksAccessed() * p1.schema().numRecordsPerBlock();         int idxRecords = ii.blocksAccessed();         return p1Records * idxRecords;     } }
public class SettingModel {     private String SINCE = "SINCE";     private String defaultValue;     private boolean caseSensitive;     private String SPACE_DELIMITED = "SPACE-DELIMITED";     private String name;     private boolean spaceDelimited;     private String description;     private long serialVersionUID = 1L;     private String RESTART_REQUIRED = "RESTART REQUIRED";     private boolean restartRequired;     private String CASE_SENSITIVE = "CASE-SENSITIVE";     private String currentValue;     private String since;     public Map<String, String> getMap() {         // Implementation     }     public boolean isDefaultValue() {         // Implementation     }     public char getChar(char defaultValue) {         // Implementation     }     public boolean getBoolean(boolean defaultValue) {         // Implementation     }     public int getInteger(int defaultValue) {         // Implementation     }     public String getString(String defaultValue) {         // Implementation     }     public String getSpaceSeparatedStrings(String key) {         // Return a list of space-separated strings from the specified key         return getMap().getOrDefault(key, "");     } }
public abstract class AbstractProvider<T> {     private List<SentenceEvent> events = new ArrayList<SentenceEvent>();     private SentenceReader reader;     private List<ProviderListener<T>> listeners = new ArrayList<ProviderListener<T>>();     public void readingStarted() {         // Implementation     }     public List<Sentence> getSentences() {         // Implementation     }     public boolean hasAll(String... id) {         // Implementation     }     public boolean isReady() {         // Implementation     }     public void addListener(ProviderListener<T> listener) {         // Implementation     }     public boolean isValid() {         // Implementation     }     public void readingPaused() {         // Implementation     }     public T createProviderEvent() {         // Implementation     }     public void sentenceRead(SentenceEvent event) {         // Implementation     }     public boolean hasOne(String... id) {         // Implementation     }     public void removeListener(ProviderListener<T> listener) {         // Implementation     }     public boolean validate() {         // Implementation     }     public void fireProviderEvent(T event) {         // Implementation     }     public void readingStopped() {         // Implementation     }     public void clearEvents() {         // Clears the list of collected events         events.clear();     } }
public class ClientRWLockTest {     private ClientRWLock mClientRWLock;     private Lock mReadLock;     private Lock mWriteLock;     public void tryLockTestFail() {         // Implementation     }     public void unlock() {         // Implementation     }     public void lockInterruptibly() {         // Implementation     }     public void notSameLock() {         // Implementation     }     public void referenceCounting() {         // Implementation     }     // Sets up the constructors before a test run     public ClientRWLockTest() {         mClientRWLock = new ClientRWLock();         ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();         mReadLock = rwLock.readLock();         mWriteLock = rwLock.writeLock();     } }
public class Time {     private int offsetHours = 0;     private int offsetMinutes = 0;     private double seconds = 0.0;     private int minutes = 0;     private int hour = 0;     private static final String TIME_PATTERN = "%02d:%02d:%02d%+03d:%02d";     public long getMilliseconds() {         // Implementation     }     public void setSeconds(double seconds) {         // Implementation     }     public boolean equals(final Object obj) {         // Implementation     }     public String toString() {         // Implementation     }     public void setTime(Date d) {         // Implementation     }     public Date toDate(Date d) {         // Implementation     }     public void setMinutes(int minutes) {         // Implementation     }     public int getMinutes() {         // Implementation     }     public void setOffsetHours(int hours) {         // Implementation     }     public int getOffsetMinutes() {         // Implementation     }     public int getHour() {         // Implementation     }     public int getOffsetHours() {         // Implementation     }     public String toISO8601() {         // Implementation     }     public void setOffsetMinutes(int minutes) {         // Implementation     }     public double getSeconds() {         // Implementation     }     public int hashCode() {         // Implementation     }     // Set the hour of day     public void setHour(int hour) {         this.hour = hour;     } }
public class Evictor {     // Member variables     // Member functions     // Factory for Evictor     public static Evictor freeSpaceWithView(long availableBytes, BlockStoreLocation location, BlockMetadataManagerView view) {         // Implementation     } }
public class Token {     // Member variables     private String tokenString;     private long lifetime = -1;     private String tokenSecret;     private long issuedAt = -1;     private List<OAuthPermission> scopes = Collections.emptyList();     private UserSubject subject;     private Client client;     private boolean preAuthorized;     // Member functions     // Returns the time (in seconds) when this token was issued at.     public long getIssuedAt() {         return issuedAt;     } }
public class Linqy<T, F, E> {     // Member variables     private boolean iterated = false;     private Iterator<T> i;     private Mapper<? super F, T> mapper;     private T lookAhead = null;     private E element;     private Predicate<? super T> filter;     // Member functions     // Turns the iterable into a list.     public List<T> toList(Iterable<T> iterable) {         List<T> list = new ArrayList<>();         for (T item : iterable) {             list.add(item);         }         return list;     } }
public class PortalUserJDBCDAO {     // Member variables     private Log log = LogFactory.getLog(PortalUserJDBCDAO.class);     private NamedParameterJdbcTemplate namedParameterJdbcTemplate;     // Member functions     // Implementation of PortalUserDAO     public Collection<String> getUserAuthorities(final String username) {         // Implement the method logic here     }     public void addPortalUser(User user) {         // Implement the method logic here     }     public void addPortalUserAuthorities(UserAuthorities userAuthorities) {         // Implement the method logic here     }     public User getPortalUser(final String username) {         // Implement the method logic here     } }
public class DecompositionFactory {     // Member functions     // Returns an EigenDecomposition that has been optimized for the specified matrix size.     // If the input matrix is symmetric within tolerance then the symmetric algorithm will be used,     // otherwise a general purpose eigenvalue decomposition is used.     public static EigenDecomposition<DenseMatrix64F> eig(int matrixSize) {         // Implement the method logic here     } }
public class ComparisonListenerSupport {     // Member variables     private List<ComparisonListener> matchListeners = new CopyOnWriteArrayList<ComparisonListener>();     private List<ComparisonListener> compListeners = new CopyOnWriteArrayList<ComparisonListener>();     private List<ComparisonListener> diffListeners = new CopyOnWriteArrayList<ComparisonListener>();     // Member functions     // Registers a listener that is notified of each comparison for match outcome     public void addMatchListener(ComparisonListener l) {         matchListeners.add(l);     }     // Registers a listener that is notified of each comparison for comparison outcome     public void addDifferenceListener(ComparisonListener l) {         diffListeners.add(l);     }     // Notifies all registered listeners of a comparison event with the specified outcome     private void fire(Comparison comparison, ComparisonResult outcome, List<ComparisonListener> listeners) {         // Implement the method logic here     }     // Notifies all registered listeners of a comparison event with the specified outcome for match     public void fireComparisonPerformed(Comparison comparison, ComparisonResult outcome) {         fire(comparison, outcome, matchListeners);     }     // Notifies all registered listeners of a comparison event with the specified outcome for comparison     public void fireComparisonPerformed(Comparison comparison, ComparisonResult outcome) {         fire(comparison, outcome, compListeners);     } }
public class RPCMessage {     // Member variables     private int mId;     // Member functions     // Returns the int identifier of the type     // Note: This is only used for getting the int representation of the type for     // alluxio.worker.DataServerMessage, since that class needs to manually encode all messages.     // alluxio.worker.DataServerMessage and this method should no longer be needed     // when the client is converted to use Netty.     public int getEncodedLength() {         // Implement the method logic here     }     // Returns the type of the RPCMessage     public Type getType() {         // Implement the method logic here     }     // Returns the payload data buffer of the RPCMessage     public DataBuffer getPayloadDataBuffer() {         // Implement the method logic here     }     // Decodes the RPCMessage from the given ByteBuf with the specified type     public RPCMessage decodeMessage(Type type, ByteBuf in) {         // Implement the method logic here     }     // Returns whether the RPCMessage has a payload     public boolean hasPayload() {         // Implement the method logic here     }     // Encodes the RPCMessage into the given ByteBuf     public void encode(ByteBuf out) {         // Implement the method logic here     }     // Decodes the RPCMessage from the given ByteBuf     public Type decode(ByteBuf in) {         // Implement the method logic here     }     // Validates the RPCMessage     public void validate() {         // Implement the method logic here     }     // Enumeration for the type of the RPCMessage     public enum Type {         // Enum values for different types of RPCMessage         // Implement the enum values here     } }
public class MatrixMathematics {     // Member functions     // Returns the cofactor of a matrix     public Matrix cofactor(Matrix matrix) {         // Implement the method logic here     }     // Matrix multiplication     public Matrix multiply(Matrix matrix1, Matrix matrix2) {         // Implement the method logic here     }     // Creates a sub-matrix by excluding the specified row and column     public Matrix createSubMatrix(Matrix matrix, int excluding_row, int excluding_col) {         // Implement the method logic here     }     // Calculates the determinant of a matrix     public double determinant(Matrix matrix) {         // Implement the method logic here     }     // Changes the sign of an integer     public int changeSign(int i) {         // Implement the method logic here     }     // Matrix addition     public Matrix add(Matrix matrix1, Matrix matrix2) {         // Implement the method logic here     }     // Calculates the inverse of a matrix     public Matrix inverse(Matrix matrix) {         // Implement the method logic here     }     // Matrix subtraction     public Matrix subtract(Matrix matrix1, Matrix matrix2) {         // Implement the method logic here     }     // Transposes a matrix     public Matrix transpose(Matrix matrix) {         // Implement the method logic here     }     // Matrix class implementation     static class Matrix {         // Matrix class implementation logic here     } }
null
public class FileUtil {     // Member variables     // Member function headers     public String readFilelist(File filelist) {         // Implementation here     }     public String normalizeFilename(String fileName) {         // Implementation here     }     public List<DataSource> collectFiles(String fileLocations, FilenameFilter filenameFilter) {         // Implementation here     }     public List<DataSource> collect(List<DataSource> dataSources, String fileLocation, FilenameFilter filenameFilter) {         // Implementation here     }     public String getFileNameWithoutExtension(String fileName) {         // Implementation here     }     public String findPatternInFile(File file, String pattern) {         // Implementation here     } }
public class DAVServlet {     // Member variables     private ServletConfig config = null;     private DAVProcessor processor = null;     private ServletContext context = null;     private DAVLogger logger = null;     private DAVRepository repository = null;     // Member function headers     public String getRepositoryKey(String servletName) {         // Implementation here     }     public void destroy() {         // Implementation here     }     public String getServletInfo() {         // Implementation here     }     public void notify(DAVResource resource, int event) {         // Implementation here     }     public void init(ServletConfig config) {         // Implementation here     }     public ServletContext getServletContext() {         // Implementation here     }     public void service(ServletRequest request, ServletResponse response) {         // Implementation here     }     public ServletConfig getServletConfig() {         // Implementation here     } }
public class SortPlan {     // Member variables     private Schema sch;     private Plan p;     private RecordComparator comp;     private Transaction tx;     // Member function headers     public boolean copy(Scan src, UpdateScan dest) {         // Implementation here     }     public List<TempTable> doAMergeIteration(List<TempTable> runs) {         // Implementation here     }     public TempTable mergeTwoRuns(TempTable p1, TempTable p2) {         // Implementation here     }     public Scan open() {         // Implementation here     }     public List<TempTable> splitIntoRuns(Scan src) {         // Implementation here     }     public int blocksAccessed() {         // Implementation here     }     public int distinctValues(String fldname) {         // Implementation here     }     public int recordsOutput() {         // Implementation here     }     public Schema getSchema() {         // Implementation here     } }
public class LogEntryRequestTest {     // Member variables     private LogEntryRequest instance;     // Member function headers     public void testSetResponseString() {         // Implementation here     }     public void testGetResponseString() {         // Implementation here     }     public void testGetFaultFlag() {         // Implementation here     }     public void testGetErrorFlag() {         // Implementation here     }     public void testSetThreadNumber() {         // Implementation here     }     public void testSetTsSend() {         // Implementation here     }     public void testSetTsReceived() {         // Implementation here     }     public void testGetTsReceived() {         // Implementation here     }     public void testGetThreadNumber() {         // Implementation here     }     public void testGetDuration() {         // Implementation here     }     public void testGetTsSend() {         // Implementation here     }     public void testSetFaultFlag() {         // Implementation here     }     public void testGetResponseStringCsv() {         // Implementation here     }     public void testSetDuration() {         // Implementation here     } }
public class IndexJoinScan {     // Member variables     private Index idx;     private TableScan ts;     private Scan s;     private String joinfield;     // Member function headers     public boolean hasField(String fldname) {         // Implementation here     }     public int getInt(String fldname) {         // Implementation here     }     public Constant getVal(String fldname) {         // Implementation here     }     public void resetIndex() {         // Implementation here     }     public void beforeFirst() {         // Implementation here     }     public String getString(String fldname) {         // Implementation here     }     public void close() {         // Implementation here     }     public boolean next() {         // Implementation here     } }
public class PairedStatsAccumulator {     // Member variables     private StatsAccumulator yStats = new StatsAccumulator();     private double sumOfProductsOfDeltas = 0.0;     private StatsAccumulator xStats = new StatsAccumulator();     // Member function headers     public PairedStats snapshot() {         // Implementation here     }     public void addAll(PairedStats values) {         // Implementation here     }     public double ensurePositive(double value) {         // Implementation here     }     public Stats xStats() {         // Implementation here     }     public double ensureInUnitRange(double value) {         // Implementation here     }     public long count() {         // Implementation here     }     public double pearsonsCorrelationCoefficient() {         // Implementation here     }     public LinearTransformation leastSquaresFit() {         // Implementation here     }     public void add(double x, double y) {         // Implementation here     }     public Stats yStats() {         // Implementation here     }     public double sampleCovariance() {         // Implementation here     }     public double populationCovariance() {         // Implementation here     } }
public class ZDATest {     // Member variables     private String EXAMPLE = "$GPZDA,032915,07,08,2004,00,00*4D";     private ZDAParser zda;     private ZDAParser empty;     // Member function headers     public void testSetLocalZoneMinutes() {         // Implementation here     }     public void testSetTime() {         // Implementation here     }     public void testSetTimeAndLocalZone() {         // Implementation here     }     public void testGetDay() {         // Implementation here     }     public void testGetMonth() {         // Implementation here     }     public void testGetYear() {         // Implementation here     }     public void testToDate() {         // Implementation here     }     public void setUp() {         // Implementation here     }     public void testSetDate() {         // Implementation here     }     public void testGetTime() {         // Implementation here     }     public void testConstructor() {         // Implementation here     }     public void testSetLocalZoneHours() {         // Implementation here     }     public void testGetLocalZoneHours() {         // Implementation here     }     public void testGetDate() {         // Implementation here     }     public void testGetLocalZoneMinutes() {         // Implementation here     } }
public class TestResultsDTO {     // Member variables     private List<TestResultDTO> testResultLst;     private String startTime;     private String endTime;     private Long batchId;     private String batchStatus;     private Long totalElapsedSeconds;     private Long totalElapsedMinutes;     // Member function headers     public Long getTotalElapsedSeconds() {         // Implementation here     }     public void setTotalElapsedMinutes(Long totalElapsedMinutes) {         // Implementation here     }     public Long getTotalElapsedMinutes() {         // Implementation here     }     public Long getBatchId() {         // Implementation here     }     public void setBatchId(Long batchId) {         // Implementation here     }     public void setEndTime(String endTime) {         // Implementation here     }     public String getEndTime() {         // Implementation here     }     public String getStartTime() {         // Implementation here     }     public List<TestResultDTO> getTestResultLst() {         // Implementation here     }     public String getBatchStatus() {         // Implementation here     }     public void setBatchStatus(String batchStatus) {         // Implementation here     }     public void setTestResultLst(List<TestResultDTO> testResultLst) {         // Implementation here     }     public void setTotalElapsedSeconds(Long totalElapsedSeconds) {         // Implementation here     }     public String toString() {         // Implementation here     }     public void setStartTime(String startTime) {         // Implementation here     } }
public class Schema {     // Member variables     private int type;     private Map<String, FieldInfo> info = new HashMap<String, FieldInfo>();     private int length;     // Member function headers     public void addField(String fldname, int type, int length) {         // Implementation here     }     public void addIntField(String fldname) {         // Implementation here     }     public int length(String fldname) {         // Implementation here     }     public Collection<String> fields() {         // Implementation here     }     public int type(String fldname) {         // Implementation here     }     public void add(String fldname, Schema sch) {         // Implementation here     }     public void addStringField(String fldname, int length) {         // Implementation here     }     public void addAll(Schema sch) {         // Implementation here     }     public boolean hasField(String fldname) {         // Implementation here     }     private static class FieldInfo {         // Implementation here     } }
public class TtlBucket implements Comparable<TtlBucket> {     // Member variables     private long mTtlIntervalStartTimeMs;     private Set<InodeFile> mFiles;     private long sTtlIntervalMs = Configuration.getInt(PropertyKey.MASTER_TTL_CHECKER_INTERVAL_MS);     // Member function headers     public long getTtlIntervalMs() {         // Implementation here     }     public int hashCode() {         // Implementation here     }     public int compareTo(TtlBucket ttlBucket) {         // Implementation here     }     public Set<InodeFile> getFiles() {         // Implementation here     }     public long getTtlIntervalStartTimeMs() {         // Implementation here     }     public long getTtlIntervalEndTimeMs() {         // Implementation here     }     public void addFile(InodeFile file) {         // Implementation here     }     public void removeFile(InodeFile file) {         // Implementation here     }     private static class InodeFile {         // Implementation here     }     private static class Configuration {         public static int getInt(PropertyKey propertyKey) {             // Implementation here         }     }     private static class PropertyKey {         // Implementation here     } }
public class SimpleEVD<T> {     // Member variables     private DenseMatrix64F mat;     private EigenDecomposition<DenseMatrix64F> eig;     // Member function headers     public Complex64F getEigenvalue(int index) {         // Implementation here     }     public T getEigenVector(int index) {         // Implementation here     }     public EigenDecomposition getEVD() {         // Implementation here     }     public int getIndexMax() {         // Implementation here     }     public int getIndexMin() {         // Implementation here     }     public double quality() {         // Implementation here     }     private static class Complex64F {         // Implementation here     }     private static class EigenDecomposition {         // Implementation here     }     private static class DenseMatrix64F {         // Implementation here     } }
public CheckServiceAccessRequest createCheckServiceAccessRequest() {     return new CheckServiceAccessRequest(); }
public void setFeedId(String feedId) {     this.feedId = feedId; }
@Override public void stopAsync() {     triggerShutdown(); }
public double[] getGammasU() {     return gammasU; }
public Bounds boundsOnScreen(Node node) {     Bounds boundsInScene = node.localToScene(node.getBoundsInLocal());     Scene scene = node.getScene();     if (scene != null) {         Bounds boundsInWindow = scene.localToScreen(boundsInScene);         Window window = scene.getWindow();         if (window != null) {             return window.localToScreen(boundsInWindow);         }     }     return null; }
public void setMapType(MapType mapType) {     this.mapType = mapType; }
public int checkGEZero(int value, String name) {     if (value < 0) {         throw new IllegalArgumentException(name + " must be greater than or equal to 0");     }     return value; }
public void classNotProvider() {     mThrown.expect(AuthenticationException.class);     mThrown.expectMessage("Class not found");     new CustomAuthenticationProvider("NonExistentClass"); }
public void frameworkError() {     try {         SpringBolt subject = new SpringBolt(outputCollectorMock, outputFieldsDeclarerMock,                 topologyContextMock, stormConf, applicationContextMock);         subject.run(tupleMock);         fail("Expected NullPointerException not thrown");     } catch (NullPointerException e) {         // Expected NullPointerException     } }
public Escaper urlPathSegmentEscaper() {     return new PercentEscaper(URL_PATH_OTHER_SAFE_CHARS_LACKING_PLUS + "+", false); }
public Long getSeqNo() {     return seqNo; }
public BufferedByteWriter put24(int value) {     ensureCapacity(3);     mBuffer[mWriter.position()] = (byte) ((value >> 16) & 0xFF);     mBuffer[mWriter.position() + 1] = (byte) ((value >> 8) & 0xFF);     mBuffer[mWriter.position() + 2] = (byte) (value & 0xFF);     mWriter.position(mWriter.position() + 3);     return this; }
public void closeConnection(Class clazz, Connection con) throws SQLException {     if (con != null && !con.isClosed()) {         con.close();         Integer count = activeConnectionCount.get(clazz.getName());         if (count != null && count > 0) {             activeConnectionCount.put(clazz.getName(), count - 1);         }     } } public void closeConnection(String requester, Connection con) throws SQLException {     if (con != null && !con.isClosed()) {         con.close();         Integer count = activeConnectionCount.get(requester);         if (count != null && count > 0) {             activeConnectionCount.put(requester, count - 1);         }     } }
public void addUplink(ClassdiagramNode newUplink) {     uplinks.add(newUplink); }
@Test public void testGetDirViews() {     // Initialize test tier view     StorageTierViewTest mTestTierView = new StorageTierViewTest();     mTestTierView.before();     // Get directory views from the test tier view     List<StorageDirView> dirViews = mTestTierView.mTestTierView.getDirViews();     // Perform assertions or test cases on dirViews     // ...     // Clean up     mTestTierView.after(); }
public boolean checkItemsetInPeriod(int itemset, int period) {     List<Element> elements = getElementsOfPeriod(period);     for (Element element : elements) {         if (element.getTID() == itemset) {             return true;         }     }     return false; }
public boolean isPullResult() {     return sendStatus; }
public Script createPaymentToRawPubKeyScript(byte[] rawPubKey) {     ScriptBuilder scriptBuilder = new ScriptBuilder();     scriptBuilder.data(rawPubKey);     scriptBuilder.op(OP_CHECKSIG);     return scriptBuilder.build(); }
public void addCookies(Cookie[] cookies) {     for (Cookie cookie : cookies) {         if (!cookie.isExpired(new Date())) {             this.cookies.add(cookie);         } else {             this.cookies.remove(cookie);         }     } }
public double getX() {     return x; }
public String listToString(List<T> list) {     StringBuilder sb = new StringBuilder();     for (T obj : list) {         sb.append(obj.toString());     }     return sb.toString(); }
public int size() {     return _size; }
public int[] getOriginalItems() {     return originalMatrix.getItems(); }
@Override public ByteBuffer readRemoteBlock(InetSocketAddress address, long blockId, long offset, long length, long lockId, long sessionId) {     if (mReadResponse != null) {         ByteBuffer buffer = mReadResponse.getBuffer();         mReadResponse.release();         mReadResponse = null;         return buffer;     }     // Return empty ByteBuffer if no previous/current read response     return ByteBuffer.allocate(0); }
public boolean shouldExecute() {     return activated && lastAttackedItem != null && theTarget != null; }
void performRandomShift() {     double magnitude = Math.sqrt(Q.numRows * Q.numCols);     double angle = 2 * Math.PI * rand.nextDouble();     double run = magnitude * Math.cos(angle);     double rise = magnitude * Math.sin(angle);     computeRotation(run, rise); }
boolean contains(lalr_item item) {     return _all.containsKey(item); }
public static RemoteBlockWriter create() {     return new RemoteBlockWriter(); }
public static boolean areEqual(double a, double b) {     return Math.abs(a - b) < EPSILON; }
public CertificateChainInfo getChain() {     return chain; }
/**  * Check if this JobExitStatus is compatible with the equals implementation.  *  * @param obj The object to compare with.  * @return true if the provided object is compatible with the equals implementation, false otherwise.  */ @Override public boolean equals(Object obj) {     if (this == obj) {         return true;     }     if (!(obj instanceof JobExitStatus)) {         return false;     }     JobExitStatus other = (JobExitStatus) obj;     return this.getExitCode().equals(other.getExitCode()) &&             this.getExitDescription().equals(other.getExitDescription()); }
null
public class EaseUI {     private List<Activity> activityList = new ArrayList<Activity>();     private static EaseUI instance = null;     private String TAG = EaseUI.class.getSimpleName();     private EaseNotifier notifier = null;     private boolean sdkInited = false;     private EaseUserProfileProvider userProvider;     private EaseSettingsProvider settingsProvider;     private EaseEmojiconInfoProvider emojiconInfoProvider;     private Context appContext = null;     // Other member variables and member functions     // Get instance of EaseUI     public static EaseUI getInstance() {         if (instance == null) {             instance = new EaseUI();         }         return instance;     } }
public class HessianFactory {     private Logger log = Logger.getLogger(HessianFactory.class.getName());     private HessianFreeList<HessianInput> _freeHessianInput = new HessianFreeList<HessianInput>(32);     private HessianFreeList<HessianOutput> _freeHessianOutput = new HessianFreeList<HessianOutput>(32);     private HessianFreeList<Hessian2Input> _freeHessian2Input = new HessianFreeList<Hessian2Input>(32);     private HessianFreeList<Hessian2Output> _freeHessian2Output = new HessianFreeList<Hessian2Output>(32);     private SerializerFactory _serializerFactory;     private SerializerFactory _defaultSerializerFactory;     // Other member variables and member functions     // Frees a Hessian 2.0 serializer     public void freeHessian2Input(Hessian2Input in) {         if (in != null) {             _freeHessian2Input.free(in);         }     } }
public class AccessToken {     private Date ALREADY_EXPIRED_EXPIRATION_TIME = MIN_DATE;     private Date expires;     private long serialVersionUID = 1L;     private Date MIN_DATE = new Date(Long.MIN_VALUE);     private AccessTokenSource DEFAULT_ACCESS_TOKEN_SOURCE = AccessTokenSource.FACEBOOK_APPLICATION_WEB;     private AccessTokenSource source;     private Date MAX_DATE = new Date(Long.MAX_VALUE);     private Date lastRefresh;     private String ACCESS_TOKEN_KEY = "access_token";     private String token;     private long serialVersionUID = -2488473066578201069L;     private String EXPIRES_IN_KEY = "expires_in";     private Date DEFAULT_LAST_REFRESH_TIME = new Date();     private Date DEFAULT_EXPIRATION_TIME = MAX_DATE;     private List<String> permissions;          // Other member variables and member functions          // Gets the date at which the access token expires     public Date getExpires() {         return expires;     } }
public class ClientHandlerTest {     private ExpectedException mThrown = ExpectedException.none();     private ClientHandler mHandler;     private ChannelHandlerContext mContext;          // Other member variables and member functions          // Makes sure that an IllegalArgumentException is thrown when the message is not a RPCResponse     public void exceptionCaughtClosesContext() {         mThrown.expect(IllegalArgumentException.class);         mThrown.expectMessage("Message is not a RPCResponse");                  // Implementation logic     } }
public class FederationManager {     private Map<String, FederationModel> federationPullResults = new ConcurrentHashMap<String, FederationModel>();     private INotificationManager notificationManager;     private IStoredSettings settings;     private List<FederationModel> federationRegistrations = Collections.synchronizedList(new ArrayList<FederationModel>());     private IRuntimeManager runtimeManager;     private Logger logger = LoggerFactory.getLogger(getClass());     private IRepositoryManager repositoryManager;          // Other member variables and member functions          // Returns the path of the proposals folder. This method checks to see if Gitblit is running on a cloud service and may return an adjusted path.     public String getProposalsFolderPath() {         // Implementation logic     } }
public class ClientConfiguration {     private List<Interceptor<? extends Message>> inFault = new ModCountCopyOnWriteArrayList<Interceptor<? extends Message>>();     private Map<String, Object> responseContext = new HashMap<String, Object>();     private List<Interceptor<? extends Message>> outFault = new ModCountCopyOnWriteArrayList<Interceptor<? extends Message>>();     private ConduitSelector conduitSelector;     private Map<String, Object> requestContext = new HashMap<String, Object>();     private long synchronousTimeout = 60000;     private List<Interceptor<? extends Message>> outInterceptors = new ModCountCopyOnWriteArrayList<Interceptor<? extends Message>>();     private Logger LOG = LogUtils.getL7dLogger(ClientConfiguration.class);     private Bus bus;     private List<Interceptor<? extends Message>> inInterceptors = new ModCountCopyOnWriteArrayList<Interceptor<? extends Message>>();     // Other member variables and member functions     // Gets the bus.     public Bus getBus() {         return bus;     } }
public class CoordELEvaluator {     private static final Integer HOUR = 60 * MINUTE;     private static final Integer MINUTE = 1;     // Other member variables and member functions     // Create an evaluator to be used in resolving configuration vars and frequency constant/functions (used in Stage 1).     public static ELEvaluator createLazyEvaluator(Date actualTime, Date nominalTime, Element dEvent, Configuration conf) {         ELEvaluator eval = new ELEvaluator();         // Implementation logic here         return eval;     } }
public class ClassStats {     private Map<String, ClassStats> nestedClasses = new HashMap<>();     private Map<ClassMetricKey, Double> memo = new HashMap<>();     private Map<OperationSignature, Map<String, OperationStats>> operations = new HashMap<>();     private Map<FieldSignature, Set<String>> fields = new HashMap<>();     // Other member functions     // Computes the value of a metric for an operation.     public void addOperation(String name, OperationSignature sig) {         // Implementation logic here     }     // Computes the value of a metric for a field.     public void addField(String name, FieldSignature sig) {         // Implementation logic here     }     // Retrieves or creates a nested ClassStats object for the given className.     public ClassStats getNestedClassStats(String className, boolean createIfNotFound) {         // Implementation logic here     }     // Checks if the ClassStats object has an operation with a matching signature.     public boolean hasMatchingSig(String name, OperationSigMask mask) {         // Implementation logic here     }     // Checks if the ClassStats object has a field with a matching signature.     public boolean hasMatchingSig(String name, FieldSigMask mask) {         // Implementation logic here     } }
public class SMSMessage {     private Map<String, Object> properties = new HashMap<>();     private int OUT_MESSAGE = 2;     private String receiver;     private String sender;     private int IN_MESSAGE = 1;     private String content;     private int direction;     // Other member functions     // Returns the phone number of the sender.     public String getSender() {         // Implementation logic here         // Return the value of the sender member variable         return sender;     }     // Retrieves the properties of the SMSMessage.     public Map<String, Object> getProperties() {         // Implementation logic here         // Return the properties member variable         return properties;     }     // Adds a property to the SMSMessage.     public void addProperty(String key, Object value) {         // Implementation logic here         // Add the key-value pair to the properties member variable         properties.put(key, value);     }     // Retrieves the receiver of the SMSMessage.     public String getReceiver() {         // Implementation logic here         // Return the value of the receiver member variable         return receiver;     }     // Retrieves the direction of the SMSMessage.     public int getDirection() {         // Implementation logic here         // Return the value of the direction member variable         return direction;     }     // Retrieves the content of the SMSMessage.     public String getContent() {         // Implementation logic here         // Return the value of the content member variable         return content;     } }
public class Activity {     private Date endDate;     private Set<String> authorExclusions;     private Map<String, Metric> authorMetrics;     private Set<RepositoryCommit> commits;     private long serialVersionUID = 1L;     private Map<String, Metric> repositoryMetrics;     private Date startDate;     // Other member functions     // Adds a commit to the activity object as long as the commit is not a duplicate.     public void addCommit(RepositoryCommit commit) {         // Implementation logic here         // Check if the commit is not null and not already present in the commits member variable         if (commit != null && !commits.contains(commit)) {             // Add the commit to the commits member variable             commits.add(commit);         }     }     // Retrieves the author metrics of the activity.     public Map<String, Metric> getAuthorMetrics() {         // Implementation logic here         // Return the authorMetrics member variable         return authorMetrics;     }     // Retrieves the total commit count of the activity.     public int getCommitCount() {         // Implementation logic here         // Return the size of the commits member variable         return commits.size();     }     // Retrieves the commits of the activity.     public List<RepositoryCommit> getCommits() {         // Implementation logic here         // Convert the commits member variable to a list and return         return new ArrayList<>(commits);     }     // Retrieves the repository metrics of the activity.     public Map<String, Metric> getRepositoryMetrics() {         // Implementation logic here         // Return the repositoryMetrics member variable         return repositoryMetrics;     }     // Compares the activity with another activity.     public int compareTo(Activity o) {         // Implementation logic here         // Compare the start dates of the two activities         return startDate.compareTo(o.startDate);     }     // Excludes authors from the activity.     public void excludeAuthors(Collection<String> authors) {         // Implementation logic here         // Remove the authors from the authorExclusions member variable         authorExclusions.removeAll(authors);     } }
null
public void addInt(int value) {     byte[] buf = new byte[MAX_INT_BYTES];     int pos = 0;     // Convert integer value to bytes     while ((value & ~0x7F) != 0) {         buf[pos++] = (byte)((value & 0x7F) | 0x80);         value >>>= 7;     }     buf[pos++] = (byte)value;     // Add integer bytes to the stream     if (packed != null) {         packed.write(buf, 0, pos);     } else {         format.write(buf, 0, pos);     } }
public void run() {     // Destroy the Purge Jobs Service     // Add your implementation here }
public int partialDeserializeI32(byte[] bytes, TFieldIdEnum fieldIdPathFirst, TFieldIdEnum... fieldIdPathRest) throws TException {     TField field = locateField(bytes, fieldIdPathFirst, fieldIdPathRest);     if (field.type != TType.I32) {         throw new TException("Field is not of type I32");     }     protocol_.readFieldBegin(field);     int value = protocol_.readI32();     protocol_.readFieldEnd();     return value; }
public void setTaskIndex(int index) {     this.taskIndex = index; }
public boolean isDateBasedConditional() {     String ifModifiedSinceHeader = request.getHeader("If-Modified-Since");     String ifUnmodifiedSinceHeader = request.getHeader("If-Unmodified-Since");     return (ifModifiedSinceHeader != null || ifUnmodifiedSinceHeader != null); }
public class AbstractPhaseInterceptor<T extends Message> implements PhaseInterceptor<T> {     private String phase;     private Set<String> before = new SortedArraySet<String>();     private Set<String> after = new SortedArraySet<String>();     private String id;     public AbstractPhaseInterceptor(String phase) {         this.phase = phase;     }     public AbstractPhaseInterceptor(String id, String phase) {         this.id = id;         this.phase = phase;     }     public void handleFault(T message) {         // implementation     }     public String getId() {         return id;     }     public String getPhase() {         return phase;     }     public boolean isGET(T message) {         // implementation     }     public void addBefore(Collection<String> i) {         before.addAll(i);     }     public void addBefore(String i) {         before.add(i);     }     public Set<String> getAfter() {         return after;     }     public Set<String> getBefore() {         return before;     }     public Collection<PhaseInterceptor<? extends Message>> getAdditionalInterceptors() {         // implementation     }     public void setBefore(Collection<String> i) {         before.clear();         before.addAll(i);     }     public void setAfter(Collection<String> i) {         after.clear();         after.addAll(i);     }     public boolean isRequestor(T message) {         // implementation     }     public void addToAfter(Collection<String> i) {         after.addAll(i);     } }
public void setTo(String to) {     this.to = to; }
null
@Test public void closeAfterClose() throws IOException {     mWriter.put(KEY1, VALUE1);     mWriter.close();     mThrown.expect(IOException.class);     mWriter.close(); }
public MetadataEditorCompat createMetadataEditor() {     if (HAS_REMOTE_CONTROL_APIS) {         Object actualMetadataEditor = mActualRemoteControlClient.getMetadataEditor();         if (actualMetadataEditor != null) {             return new MetadataEditorCompat(actualMetadataEditor);         }     } else {         Object actualMetadataEditor = mActualMetadataEditor;         if (actualMetadataEditor != null) {             return new MetadataEditorCompat(actualMetadataEditor);         }     }     return null; }
void updateNaiveBayesMapForSinglePost(String[] cleanPostTokens, HashMap<String, HashMap<String, Integer>> naiveBayesMap, String ageClass) {     HashMap<String, Integer> wordCountMap = new HashMap<>();     for (String token : cleanPostTokens) {         if (stopWord.isStopWord(token)) {             continue;         }         wordCountMap.put(token, wordCountMap.getOrDefault(token, 0) + 1);     }     int totalWordsInPost = wordCountMap.values().stream().mapToInt(Integer::intValue).sum();     for (String word : wordCountMap.keySet()) {         double wordProbability = (double) wordCountMap.get(word) / totalWordsInPost;         naiveBayesMap.get(ageClass).put(word, naiveBayesMap.get(ageClass).getOrDefault(word, 0) + 1);         naiveBayesMap.get(ageClass).put(word, naiveBayesMap.get(ageClass).get(word) + 1);     } }
public static String formatTimeTakenNs(long startTimeNs, String message) {     long elapsedTimeNs = System.nanoTime() - startTimeNs;     double elapsedTimeMs = elapsedTimeNs / 1000000.0;     return String.format("%s took %.2f ms", message, elapsedTimeMs); }
public String getRequestHeaders(final HttpServletRequest request) {     Enumeration<String> headerNames = request.getHeaderNames();     StringBuilder sb = new StringBuilder();     while (headerNames.hasMoreElements()) {         String headerName = headerNames.nextElement();         sb.append(headerName).append(": ").append(request.getHeader(headerName)).append("\n");     }     return sb.toString(); }
public boolean checkpointExists() {     String checkpointFileName = Constants.CHECKPOINT_FILENAME_PREFIX + mLatestSequenceNumber + Constants.CHECKPOINT_FILENAME_SUFFIX;     return mJournal.hasFile(checkpointFileName); } public int processNextJournalLogFiles() {     int numFilesProcessed = 0;     while (mReader.hasLogFile()) {         JournalRecord record = mReader.getNextRecord();         if (record.getSequenceNumber() <= mLatestSequenceNumber) {             continue;         }         if (record.isCheckpoint()) {             mMaster.processCheckpoint(record);             numFilesProcessed++;             break;         }         mMaster.processRecord(record);         numFilesProcessed++;         if (record.getSequenceNumber() % Constants.NUM_RECORDS_TO_CHECKPOINT == 0) {             mMaster.checkpoint(record.getSequenceNumber());         }         mLatestSequenceNumber = record.getSequenceNumber();     }     return numFilesProcessed; }
private long getTimeDifference() {     if (mPrevEvent != null) {         return mCurrEvent.getEventTime() - mPrevEvent.getEventTime();     } else {         return mTimeDelta;     } }
public void sendBlocking(byte[] data) {     try {         ByteBuffer buffer = ByteBuffer.wrap(data);         while (buffer.hasRemaining()) {             clientEndpoint.send(buffer, clientSession.getDestination());         }     } catch (Exception e) {         logger.error("Error sending data: {}", e.getMessage());     } }
public void setSatellitesIds(String[] satelliteIds) {     GSASentence gsa = new GSASentence(EXAMPLE);     gsa.setSatelliteIds(satelliteIds);     assertEquals(satelliteIds.length, gsa.getSatelliteIds().length);     for (int i = 0; i < satelliteIds.length; i++) {         assertEquals(satelliteIds[i], gsa.getSatelliteIds()[i]);     } }
public void establishConnectionAndStartSenderThread(ServerAddress serverAddress) throws Exception {     clientEndpoint = new UDPEndPoint(serverAddress.getHost(), serverAddress.getPort(), true);     clientSession = clientEndpoint.connect();     logger.info("UDT client connected to server at {}:{}.", serverAddress.getHost(), serverAddress.getPort());     Thread senderThread = new Thread(() -> {         while (!Thread.interrupted()) {             try {                 clientSession.doSend();             } catch (Exception e) {                 logger.error("Error occurred while sending data to server: {}", e.getMessage());             }         }     });     senderThread.start(); }
public long getIndex() {     return index; }
public class DirEntry {     private final Constant dataval;     private int blocknum;     public int blockNumber() {         return blocknum;     }     public Constant getDataval() {         return dataval;     } }
public void setWsseValueType(String wsseValueType) {     this.wsseValueType = wsseValueType; }
public class UtilParcel {          // ... (Other member variables and member functions)          public Map<String, String> readHashMapStringKey(Parcel in, ClassLoader loader) {         Map<String, String> map = new HashMap<>();         int size = in.readInt();         for (int i = 0; i < size; i++) {             String key = in.readString();             String value = in.readString();             map.put(key, value);         }         return map;     } }
public class LevenbergMarquardt {     private DenseMatrix64F d;     private double finalCost;     private double initialLambda;     private double DELTA = 1e-8;     private DenseMatrix64F A;     private DenseMatrix64F jacobian;     private DenseMatrix64F H;     private DenseMatrix64F negDelta;     private DenseMatrix64F tempParam;     private DenseMatrix64F temp0;     private DenseMatrix64F temp1;     private Function func;     private DenseMatrix64F tempDH;     private double initialCost;     private DenseMatrix64F param;     // ... (Other member functions)     private void computeDandH(DenseMatrix64F param, DenseMatrix64F x, DenseMatrix64F y) {         // Compute D and H matrices         // A = H + lambdaI, where I is an identity matrix         // Compute H matrix         func.computeHessian(param, x, y, jacobian, H);                  // Compute lambdaI matrix         double lambda = initialLambda;         for (int i = 0; i < param.getNumElements(); i++) {             H.set(i, i, H.get(i, i) + lambda);         }     }     // ... (Other member functions) }
public class ComplexNode {     private List<ComplexNode> nestedComplexNodes;     private Double _double;     private long serialVersionUID = 1L;     private String id;     private BigDecimal decimal;     private Date date;     private Integer number;     private ComplexNode singleNestedComplexNode;     // ... (Other member functions)     public void setSingleNestedComplexNode(ComplexNode value) {         this.singleNestedComplexNode = value;     }     // ... (Other member functions) }
public class CloudStorage {     private TextBot tb;     private String INDENT_APPEND = "    ";     private String LOGIN_MESSAGE = "Thanks for logging in!";     private BoxFolder rootFolder;     private String MISSING_FOLDER_MESSAGE = "This folder is not located in your box account";     private BoxFolder currentFolder;     private String devToken;     // ... (Other member functions)     public BoxFolder getFolder(String name) {         // Implementation logic to return a specific folder in the Box account         // ...         return specificFolder;     }     // ... (Other member functions) }
public class Measurement {     private String name;     private String units;     private String type;     private Double value;     // ... (Other member functions)     public void setUnits(String units) {         // Implementation logic to set the units of measurement         // ...         this.units = units;     }     // ... (Other member functions) }
public class ChildNumber {     private int i;     public static final ChildNumber ZERO = new ChildNumber(0);     public static final ChildNumber ONE = new ChildNumber(1);     public static final ChildNumber ZERO_HARDENED = new ChildNumber(0, true);     public static final int HARDENED_BIT = 0x80000000;     // ... (Other member functions)     public int num() {         // Implementation logic to return the uint32 encoded form of the path element         // including the most significant bit         // ...         return i | HARDENED_BIT;     }     // ... (Other member functions) }
null
public void addPropertyChangeListener(PropertyChangeListener listener) {     propertyChangeSupport.addPropertyChangeListener(listener); }
public String getXmiId() {     return xmiId; }
private void validateRequest(ActivityRequest activityRequest) throws Exception {     if (activityRequest.getParameter("mandatoryParameter") == null) {         throw new Exception("Mandatory parameter missing.");     } }
public boolean isReaderValid() throws IOException {     long currentCheckpointLastModifiedTimeMs = mUfs.getLastModifiedTimeMs(mCheckpointPath);     if (currentCheckpointLastModifiedTimeMs > mCheckpointLastModifiedTime) {         LOG.debug("Journal checkpoint has been updated since the creation of this reader, this reader is no longer valid.");         return false;     }     return true; }
@Test public void testGetTime() {     String time = "120044.567";     rmc.setTime(time);     assertEquals(time, rmc.getTime()); }
/**  * Load the necessary state to perform an eager precondition check.  * This implementation does a NOP. Subclasses should override this method  * and load the state needed to do an eager precondition check.  * A trivial implementation is calling {@link #loadState}.  */ public void loadState() {     // No operation }
void handleGroupEnd() {     listener.groupEnd(); }
public void backupDescription(File dir) {     if (!dir.isDirectory()) {         Log.e(TAG, "Cannot backup notebooks, directory not found: " + dir.getAbsolutePath());         return;     }          for (BookPreview preview : data) {         File notebookFile = new File(dir, preview.getUUID().toString() + QUILL_EXTENSION);         try (OutputStream os = new FileOutputStream(notebookFile)) {             os.write(preview.getDescription().getBytes());         } catch (IOException e) {             Log.e(TAG, "Failed to backup notebook: " + preview.getTitle(), e);         }     } }
public void insert(Constant dataval, RID datarid) {     int leafLoc = search(datarid);     LeafPage leaf = LeafPage.getLeafPage(tx, leafLoc, leafTi);     if (leaf.getFlag() == LeafPage.INDEX) {         leaf.close();         throw new UnsupportedOperationException();     }     if (leaf.getSlotCnt() == leafTi.getNumSlots()) {         LeafPage newLeaf = leaf.split();         Constant firstKey = newLeaf.getFirst(dataval.getType());         int newLeafLoc = newLeaf.getBlock().getBlkNum();         newLeaf.close();         insertEntry(firstKey, newLeafLoc);     }     leaf.insert(datarid);     leaf.close(); } private void insertEntry(Constant key, int blkNum) {     DirectoryPage dp = DirectoryPage.getDirectoryPage(tx, rootblk, dirTi);     if (dp.getFlag() == IndexPage.LEAF) {         DirectoryPage newRoot = dp.split();         Constant firstKey = newRoot.getFirst(key.getType());         int newRootLoc = newRoot.getBlock().getBlkNum();         newRoot.close();         insertEntry(firstKey, newRootLoc);     }     int slot = dp.findSlotBefore(key);     int childBlkNum = dp.getChildNum(slot);     Block childBlk = new Block(fileName, childBlkNum);     BTreePage child = BTreePage.getBTreePage(tx, childBlk, leafTi);     if (child.getFlag() == IndexPage.LEAF) {         LeafPage childLeaf = (LeafPage) child;         if (childLeaf.getSlotCnt() == leafTi.getNumSlots()) {             LeafPage newChildLeaf = childLeaf.split();             Constant firstKey = newChildLeaf.getFirst(key.getType());             int newChildLoc = newChildLeaf.getBlock().getBlkNum();             newChildLeaf.close();             dp.insertEntry(firstKey, newChildLoc);         }     }     child.close();     dp.insertEntry(key, blkNum);     dp.close(); }
public static Map<Class<?>, String> getClassShortNames() {     Map<Class<?>, String> shortNames = new HashMap<>();     for (Class<?> type : TYPES_BY_NAME.values()) {         String shortestName = asShortestName(type);         shortNames.put(type, shortestName);     }     return shortNames; }
public void setReturnEntropy(boolean returnEntropy) {     this.returnEntropy = returnEntropy; }
public String getOriginalPath() {     return request.getRequestURI(); }
public int getGeneratedClassSerial() {     return generatedClassSerial; }
public int use_count() {     return _use_count; }
public String selectFolder(String defaultFolder, String title) {     JFileChooser folderChooser = new JFileChooser(defaultFolder);     folderChooser.setDialogTitle(title);     folderChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);     int userSelection = folderChooser.showOpenDialog(null);     if (userSelection == JFileChooser.APPROVE_OPTION) {         return folderChooser.getSelectedFile().getAbsolutePath();     } else {         return null;     } }
public String getHttpElementCharset(final HttpParams params) {     if (params == null) {         throw new IllegalArgumentException("HTTP parameters may not be null");     }     String charset = (String) params.getParameter(CoreProtocolPNames.HTTP_ELEMENT_CHARSET);     if (charset == null) {         charset = HTTP.DEFAULT_PROTOCOL_CHARSET.name();     }     return charset; }
public void processUnicodeAlternateSkipCount(int parameter) {     if (parameter < 0) {         skipBytes = -parameter;     } else {         int count = 0;         while (count < parameter) {             byte[] data = new byte[2];             if (source.read(data) != data.length) {                 // Handle unexpected end of input                 break;             }             char c = (char) ((data[1] & 0xff) << 8 | data[0] & 0xff);             listener.processCharacter(c);             count++;         }     } }
@Test(expected = NullPointerException.class) public void testRegisterUserSessionWithNullServerSessionThrowsException() {     activityController.registerUserSession(null, mockServerMessage); }
void writeRef(MessageWriter writer) {     writeAttribute(writer, SOAP_ENCODING_REF_1_1, ""); }
public String getFullContent() {     try {         HttpClient httpClient = HttpClientBuilder.create().build();         HttpGet getRequest = new HttpGet(uri);         HttpResponse response = httpClient.execute(getRequest);         HttpEntity entity = response.getEntity();         if (entity != null) {             content = EntityUtils.toString(entity);         }     } catch (IOException e) {         warningList.add("Error while fetching data from CGDS server: " + e.getMessage());     }     return content; }
public void setConfig(Config value) {     this.config = value; }
public String getDescription() {     return _description; } public String getLink() {     return _link; } public String getTitle() {     return _title; } public String getRSSLink() {     return _rss_link; } public String getImage() {     return _image; }
public BrowseOffersResponse.Return createBrowseOffersResponseReturn() {     return new BrowseOffersResponse.Return(); }
public Builder setObjectType(String objectType) {     this.objectType = objectType;     return this; }
public Script createP2SHOutputScript(Script redeemScript) {     byte[] scriptHash = redeemScript.getSHA256Hash().reverse().getBytes();     ScriptChunk opHash160 = new ScriptChunk(OP_HASH160, null);     ScriptChunk data = new ScriptChunk(scriptHash);     ScriptChunk opEqual = new ScriptChunk(OP_EQUAL, null);     List<ScriptChunk> chunks = Arrays.asList(opHash160, data, opEqual);     return new Script(chunks); }
public String getAccessTokenValidatorClassName() {     return OAuthServerConfiguration.getInstance().getAccessTokenValidator().getClass().getName(); }
public static ResourceTypeHandler getResourceType(final String name) {     if (name == null) {         return FILE;     }     try {         return valueOf(name.toUpperCase());     } catch (IllegalArgumentException e) {         return FILE;     } }
public void addToPendingQueue(Double value) {     mPendingQueue.add(value); }
public JPanel getCurrentPanel() {     return uiStack.getCurrentPanel(); }
public static LinearSolver<DenseMatrix64F> qrPivot(int numRows, int numCols, boolean computeQ) {     return new SolvePseudoInverseQrp(computeQ); } private static class SolvePseudoInverseQrp extends BaseLinearSolverQrp {     public SolvePseudoInverseQrp(boolean computeQ) {         super(computeQ);     }     @Override     public void setA(DenseMatrix64F A) {         decompose(A);     }     @Override     public double quality() {         return specialMaxResidual();     } }
public List<String> getAcceptedC14nAlgorithms() {     return acceptedC14nAlgorithms; }
public BigDecimal getSuccessorId() {     return successorId; }
public String getFeedId() {     return this.feedId; }
public ArrayList<NotationName> getAllNotations() {     return notations; }
public void getByteArrayInternal(int itemLen, byte[] dest, int off, int len) {     int length = Math.min(len, itemLen);     System.arraycopy(value, valueOff, dest, off, length); }
public Card getCardFromEnemy(String string) {     for (Card card : enemyHandCards) {         if (card.getName().equals(string)) {             return card;         }     }     return null; }
public String getReceiptDateType() {     return this.receiptDateType; }
public void blockFxThreadWithSemaphore() {     final Semaphore semaphore = new Semaphore(0);     Platform.runLater(() -> {         try {             semaphore.acquire();         } catch (InterruptedException e) {             Thread.currentThread().interrupt();         }     });     for (int i = 0; i < SEMAPHORE_LOOPS_COUNT; i++) {         if (semaphore.tryAcquire()) {             break;         }         sleep(SEMAPHORE_SLEEP_IN_MILLIS, TimeUnit.MILLISECONDS);     } }
public long getLifetimeInSeconds() {     return TimeUnit.MILLISECONDS.toSeconds(lifetime); }
public Object get(String key) {     if (json != null) {         return json.get(key);     }     return null; }
public void draw() {     GraphicsContext gc = canvas.getGraphicsContext2D();     gc.setFill(color);     gc.fillOval(xPosition, yPosition, diameter, diameter); }
public void initializeEUML() {     initializeModelImplementation(DEFAULT_MODEL_IMPLEMENTATION); } public ModelImplementation initializeModelImplementation(String name) {     ModelImplementation modelImpl = null;     try {         Class<?> modelImplClass = Class.forName(name);         modelImpl = (ModelImplementation) modelImplClass.newInstance();     } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) {         e.printStackTrace();     }     return modelImpl; } public void initializeDefault() {     initializeEUML(); }
private int permute(int x) {     x ^= salt;     x = (x ^ (x >>> 16)) * 0x85ebca6b;     x ^= x >>> 13;     x *= 0xc2b2ae35;     x ^= x >>> 16;     return x; } public synchronized int next() {     return permute(gen.getAndIncrement()); }
public synchronized void setParameter(String name, Object value) {     parameters.put(name, value); }
public synchronized String getCreatedBy() {     return createdBy; }
public boolean isBuilding() {     return (taskMode == 2 || taskMode == 4 || taskMode == 6 || taskMode == 8); }
public int getOpNValue() {     if (isOpCode() && opcode >= 0x50 && opcode <= 0x60) {         return opcode - 0x50 + 1;     }     return -1; }
public void save(Book book) {     bookRepository.save(book);     log.info("Book saved with ID: " + book.getId()); }
public void startStream() {     String streamType = "video";     String urlStr = composeURL(streamType);     String command = "play";     runUrl(command + " " + urlStr); }
public void registerRule(TreeModel rule) {     rules.add(rule); }
public void setResultMessage(String resultMessage) {     this.resultMessage = resultMessage; }
public long getSessionId() {     checkReady();     return mSessionId; }
void testToString() {   Mode mode = new Mode();   mode.setOwnerBits(Mode.Bits.READ | Mode.Bits.WRITE | Mode.Bits.EXECUTE);   mode.setGroupBits(Mode.Bits.READ | Mode.Bits.EXECUTE);   mode.setOtherBits(Mode.Bits.READ | Mode.Bits.EXECUTE);   String expected = "rwxr-xr-x";   String actual = mode.toString();   assertEquals(expected, actual); }
public void outerProd(D1Matrix64F x, D1Matrix64F y, RowD1Matrix64F A) {     double gamma = 1.0;     int numRows = A.getNumRows();     int numCols = A.getNumCols();     for (int i = 0; i < numRows; i++) {         double a_i = A.get(i);         for (int j = 0; j < numCols; j++) {             A.set(i, j, a_i + gamma * x.get(i) * y.get(j));         }     } }
@Test public void testHDMSentenceRead() {     String sentence = "$GPHDT,123.4,T*32";     SentenceEvent evt = factory.createParser(sentence).parse();     instance.sentenceRead(evt);     assertNotNull(event);     assertEquals(123.4, event.getHeading(), 0.001); }
public void setC14nAlgorithm(String c14nAlgorithm) {     this.c14nAlgorithm = c14nAlgorithm; }
public static Response createErrorResponse(String message) {     JsonObject error = Json.createObjectBuilder()             .add("error", message)             .build();     return Response.status(Response.Status.BAD_REQUEST)             .entity(error)             .build(); }
public List<E> asList(Iterable<E> i) {     List<E> list = new ArrayList<>();     for (E e : i) {         list.add(e);     }     return list; }
public Map<String, Object> getResponseContext() {     return this.responseContext; }
public Sha256Hash hashContents(byte[] contents) {     MessageDigest digest = null;     try {         digest = MessageDigest.getInstance("SHA-256");     } catch (NoSuchAlgorithmException e) {         // Handle the exception appropriately     }     byte[] hash = digest.digest(contents);     return new Sha256Hash(hash); }
public <T extends Service> T getService(Class<T> clazz) {     Service service = services.get(clazz);     if (service == null) {         throw new ServiceException(ServiceException.ErrorCode.E0010, clazz.getName());     }     return clazz.cast(service); }
public int getRow() {     return row; }
public String getZip() {     return address.getPostalZone(); }
public void popupError(String str) {     JOptionPane.showMessageDialog(null, "Error occurred while executing SQL query:\n" + str, appName + " Error", JOptionPane.ERROR_MESSAGE);     if (logger != null) {         logger.error(str);     } }
public void addCondition(String lang) {     Condition condition = new LangCondition(lang);     addCondition(condition); } private static class LangCondition implements Condition {     private String lang;     public LangCondition(String lang) {         this.lang = lang;     }     public boolean matches(Element e, AttributeResolver attRes, TreeResolver treeRes) {         String elementLang = e.getAttribute("lang");         if (elementLang != null) {             int hyphenIndex = elementLang.indexOf('-');             if (hyphenIndex != -1) {                 elementLang = elementLang.substring(0, hyphenIndex);             }             return elementLang.equalsIgnoreCase(lang);         }         return false;     }     public String toString() {         return ":lang(" + lang + ")";     } }
public static long getLong(JSONObject json, String name) {     return json.getLong(name); }
public void setExperimentTypes(String types) {     this.experimentTypes = types; }
public PasswordCredentials getPasswordCredentials() {     return passwordCredentials; }
public String getReason() {     return reason; }
public void checkInputInstance() {     if (a.numCols != b.numRows) {         throw new IllegalArgumentException("The number of columns of matrix A must equal the number of rows of matrix B.");     } }
public void revertToDefault() {     for(AbstractSettings setting : PROPS) {         setting.setDefault();     } }
void handleFireDiagramAppearanceEvent(ArgoDiagramAppearanceEvent event, ArgoDiagramAppearanceEventListener listener) {     doFireEvent(event);     if (listener != null) {         listener.diagramAppearanceChanged(event);     } }
public boolean isOffDiagonalElementZero(int i, int j, double eps) {     double absAii = Math.abs(diag[i]);     double absAjj = Math.abs(diag[j]);     double absAij = Math.abs(off[i]);     if (absAii > absAjj) {         double t = absAjj / absAii;         t = 1.0 + t * t;         return absAij * absAij <= eps * eps * absAii * absAjj * t;     } else {         double t = absAii / absAjj;         t = 1.0 + t * t;         return absAij * absAij <= eps * eps * absAii * absAjj * t;     } }
public class S3Sample {     // member variables     // member function headers     public File createSampleFile() {         // implementation here     }     public static void main(String[] args) {         // implementation here     }     // Displays the contents of the specified input stream as text.     public void displayText(InputStream inputStream) throws IOException {         BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));         String line;         while ((line = reader.readLine()) != null) {             System.out.println(line);         }         reader.close();     } }
public boolean isEmptyPartialResponse(Message message) {     boolean isPartial = false;     try {         isPartial = message.getExchange().isOneWay() && !isOutbound(message);     } catch (Exception ex) {         // handle exception as per your requirements     }     return isPartial; }
public void registerOutputFieldNames() {     String[] outputFields = getOutputFields();     if (outputFields != null) {         for (String field : outputFields) {             putOutputBinding(field, field);         }     } }
@Test public void getDirViewBadIndex() throws Exception {     mThrown.expect(IndexOutOfBoundsException.class);     mTestTierView.getDirView(TEST_TIER_LEVEL - 1); } @Test public void getDirViews() throws Exception {     File testDir = mTestFolder.newFolder();     mTestTierView.initializePath(testDir.getAbsolutePath());     List<String> dirNames = Arrays.asList("dir1", "dir2", "dir3");     for (String dirName : dirNames) {         mTestTierView.createDirWithCheck(dirName);     }     List<StorageDirView> dirViews = mTestTierView.getDirViews();     assertEquals(dirNames.size(), dirViews.size());     for (int i = 0; i < dirNames.size(); i++) {         StorageDirView dirView = dirViews.get(i);         assertEquals(dirNames.get(i), dirView.getName());     } } @Test public void getTierViewAlias() {     assertEquals(mTestTier.getTierAlias(), mTestTierView.getTierViewAlias()); } @Test public void getTierViewOrdinal() {     assertEquals(mTestTier.getTierOrdinal(), mTestTierView.getTierViewOrdinal()); } @Before public void before() throws Exception {     mTestFolder.create();     mTestTier = new StorageTier(TEST_TIER_LEVEL, null, null);     mTestTierView = new StorageTierView(mTestTier); }
public Document transformToDocument() throws TransformerException {     DOMResult result = new DOMResult();     transformTo(result);     return (Document) result.getNode(); }
public URI getURI() {     return this.uri; }
public T acquire() throws InterruptedException {   mLock.lock();   try {     while (mResourceAvailable.isEmpty()) {       mNotEmpty.await();     }     ResourceInternal<T> resourceInternal = mResourceAvailable.pollFirst();     T resource = resourceInternal.mResource;     mResources.remove(resource);     mLastAccessTimeMs = mClock.millis();     return resource;   } finally {     mLock.unlock();   } }
public void closeStreams() throws IOException {     if (mIn != null) {         mIn.close();     }     if (mOut != null) {         mOut.close();     } }
public int getColumn() {    return column != null ? column : UNKNOWN; }
public void finaliseAndVerify(byte[] number, byte[] hash) {     byte[] hashOfNumber = hashByteArr(number);     if (Arrays.equals(hash, hashOfNumber)) {         for (int i = 0; i < 32; i++) {             mixednumber[i] ^= number[i];         }     } else {         throw new RuntimeException("Hash does not match the number");     }     finalise(); }
public double computeMetricForOperation(QualifiedName qname, String operationName, String metricName) {     ClassStats classStats = getClassStats(qname, false);     if (classStats != null) {         OperationStats operationStats = classStats.getOperationStats(operationName);         if (operationStats != null) {             return operationStats.computeMetric(metricName);         }     }     return -1; }
public class YahooSearchTest {     private static final Logger LOG = LoggerFactory.getLogger(YahooSearchTest.class);     // other member variables and member functions     /**      * Tests the method for handling an input stream from Yahoo.      */     public void testJsonInputStream() {         // Implementation goes here         // You can use the "LOG" member variable to log messages         // and handle the input stream from Yahoo as needed         // Use try-with-resources to properly handle the input stream     } }
public class LocalCertificateStore {     private String FILE_PREFIX = "certificate-";     private String ALIAS_PREFIX = "local:";     private Pattern ALIAS_PATTERN = Pattern.compile("^" + ALIAS_PREFIX + "[0-9a-f]{40}$");     private Map<String, X509Certificate> certificates = new HashMap<>();     public Date getCreationDate(String alias) {         // Implementation here     }     public boolean addCertificate(Certificate cert) {         // Implementation here     }     public ArrayList<String> aliases() {         // Implementation here     }     public String getCertificateAlias(Certificate cert) {         // Implementation here     }     public X509Certificate getCertificate(String alias) {         // Implementation here     }     public String getKeyId(Certificate cert) {         // Implementation here     }     public boolean containsAlias(String alias) {         // Implementation here     }     public boolean deleteCertificate(String alias) {         // Implementation for deleting a certificate with the given alias         if (certificates.containsKey(alias)) {             certificates.remove(alias);             return true;         } else {             return false;         }     } }
public User login() {     if (sLoginUser == null) {         // Check if Alluxio is running in secure mode         if (AuthType.SIMPLE.equals(AuthType.get())) {             // Alluxio is running in SIMPLE authentication mode             // Perform login logic here             // ...             // Set sLoginUser value after successful login             sLoginUser = new User(/* user details */);         } else if (AuthType.KERBEROS.equals(AuthType.get())) {             // Alluxio is running in KERBEROS authentication mode             // Perform login logic here             // ...             // Set sLoginUser value after successful login             sLoginUser = new User(/* user details */);         } else if (AuthType.CUSTOM.equals(AuthType.get())) {             // Alluxio is running in CUSTOM authentication mode             // Perform login logic here             // ...             // Set sLoginUser value after successful login             sLoginUser = new User(/* user details */);         } else {             // Alluxio is not running in a secure mode             // Throw an exception or handle the case appropriately             throw new RuntimeException("Alluxio is not running in secure mode");         }     }     return sLoginUser; }
public class RemoteControlClientCompat {     private int METADATA_KEY_ARTWORK = 100;     private Object mActualRemoteControlClient;     private boolean HAS_REMOTE_CONTROL_APIS = Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH;     private Object mActualMetadataEditor;          // ... other member variables and functions          public void setTransportControlFlags(int transportControlFlags) {         // Implementation goes here     }          public void setPlaybackState(int state) {         // Implementation goes here     }          public MetadataEditorCompat putBitmap(int key, Bitmap bitmap) {         // Implementation goes here     }          public MetadataEditorCompat putString(int key, String value) {         // Implementation goes here     }          public Object getActualRemoteControlClientObject() {         // Implementation goes here     }          public MetadataEditorCompat putLong(int key, long value) {         // Implementation goes here     }          public MetadataEditorCompat editMetadata(boolean startEmpty) {         // Implementation goes here     }          public void apply() {         // Implementation goes here     }          public void removeFromMediaRouter(MediaRouter router) {         // Implementation goes here     }          public void clear() {         // Implementation goes here     }          // Implementation of the natural language description     public void addToMediaRouter(MediaRouter router) {         // Implementation goes here     } }
public ModelImplementation initializeModelImplementation(String name) {     ModelImplementation implementation = new ModelImplementation(name);     implementation.initializeSubsystem(DEFAULT_MODEL_IMPLEMENTATION);     return implementation; } public void initializeDefault() {     initializeModelImplementation(DEFAULT_MODEL_IMPLEMENTATION); }
public boolean isBuilding() {     return mob != null && mob.isEntityAlive() && buildingSpot.distanceTo(new Vec3(x, y, z)) < 2.0; }
public class ReceiverLossListEntry {     private long lastFeedbacktime;     private long k = 2;     private long sequenceNumber;          public void feedback() {         k++;     }          public long getSequenceNumber() {         return sequenceNumber;     }          @Override     public int hashCode() {         return Objects.hash(lastFeedbacktime, k, sequenceNumber);     }          @Override     public boolean equals(Object obj) {         if (this == obj)             return true;         if (!(obj instanceof ReceiverLossListEntry))             return false;         ReceiverLossListEntry other = (ReceiverLossListEntry) obj;         return lastFeedbacktime == other.lastFeedbacktime && k == other.k && sequenceNumber == other.sequenceNumber;     }          @Override     public String toString() {         return "ReceiverLossListEntry [lastFeedbacktime=" + lastFeedbacktime + ", k=" + k + ", sequenceNumber="                 + sequenceNumber + "]";     }          @Override     public int compareTo(ReceiverLossListEntry o) {         if (this.lastFeedbacktime < o.lastFeedbacktime)             return -1;         else if (this.lastFeedbacktime > o.lastFeedbacktime)             return 1;         else             return Long.compare(this.sequenceNumber, o.sequenceNumber);     }          public long getLastFeedbackTime() {         return lastFeedbacktime;     } }
public int size() {     return _size; }
public class SysUtil {     private byte[] cachedBuffer = null;     public void reliablyCopyExecutable(InputStream is, File destination, long expectedSize, long time) {         // Implementation goes here     }     public void freeCopyBuffer() {         // Implementation goes here     }     public File createLibsDirectory(Context context) {         // Implementation goes here     }     public File getLibsDirectory(Context context) {         // Implementation goes here     }     public void fallocateIfSupported(FileDescriptor fd, long length) {         // Implementation goes here     }     public void fallocate(FileDescriptor fd, long length) {         // Implementation goes here     }     public void deleteOrThrow(File file) {         // Implementation goes here     }     public FileLocker lockLibsDirectory(Context context) {         // Implementation goes here     }     public int findAbiScore(String[] supportedAbis, String abi) {         // Implementation goes here     }     public void dumbDeleteRecursive(File file) {         // Implementation goes here     }     // Inner class for version-dependent call     private static class AbiPreference {         public static String[] getSupportedAbis() {             // Implementation goes here         }     }     public String[] getSupportedAbisOrderedByPreference() {         // Implementation goes here     } }
public void pausarServidor() {     // Pausing server implementation code goes here     server.pausar(); }
/** * Returns the connection headers as a {@link Map}. * * @return the connection headers as a {@link Map}. */ public Map<String, String> getConnectionHeaders() {     Map<String, String> headersMap = new HashMap<>();     if (connection != null) {         Map<String, List<String>> connectionHeaders = connection.getHeaderFields();         for (Map.Entry<String, List<String>> entry : connectionHeaders.entrySet()) {             if (entry.getKey() != null) {                 headersMap.put(entry.getKey(), String.join(",", entry.getValue()));             }         }     }     return headersMap; }
/**  * This method removes an extension from the list of known extensions.  *  * @param extension the extension to remove from the list of known extensions  */ public void removeResourceExtension(String extension) {     resourceExtensions.remove(extension); }
/**  * Provides access to the factory. Implemented with lazy instantiation.  *  * @return the instance of the factory  */ public static SearchFactory getInstance() {     if (instance == null) {         instance = new SearchFactory();     }     return instance; }
/**  * Test of listComPorts method, of class ComPortController.  */ public void testListComPorts() {     // TODO: Implement test code     // ... }
@Test(expected = IllegalArgumentException.class) public void classNotFound() {     CustomAuthenticationProvider provider = new CustomAuthenticationProvider("InvalidProvider"); }
public class OAuthError {     private String errorUri;     private String errorDescription;     private String state;     private String error;     public String getError() {         return error;     }     public String getErrorDescription() {         return errorDescription;     }     public String getState() {         return state;     }     public void setError(String error) {         this.error = error;     }     public void setState(String state) {         this.state = state;     }     public String getErrorUri() {         return errorUri;     }     public void setErrorUri(String errorUri) {         this.errorUri = errorUri;     }     public void setErrorDescription(String errorDescription) {         this.errorDescription = errorDescription;     } }
public class MultiBufferProductScan {     private int filesize;     private Scan prodscan;     private Scan rhsscan = null;     private Transaction tx;     private TableInfo ti;     private int nextblknum;     private Scan lhsscan;     private int chunksize;     public Constant getVal(String fldname) {         // Implementation not provided since it is not relevant to the task     }     public boolean useNextChunk() {         // Implementation not provided since it is not relevant to the task     }     public void beforeFirst() {         // Implementation not provided since it is not relevant to the task     }     public String getString(String fldname) {         // Implementation not provided since it is not relevant to the task     }     public void close() {         // Implementation not provided since it is not relevant to the task     }     public boolean next() {         // Implementation not provided since it is not relevant to the task     }     public int getInt(String fldname) {         return (prodscan.hasField(fldname) || (rhsscan != null && rhsscan.hasField(fldname)))                 ? prodscan.getInt(fldname)                 : rhsscan.getInt(fldname);     } }
null
public void testPasswordProtected() {     // Implementation of the test for non-password protectedness     // ... }
public void setPosition(String loc, double x, double y) {     Point2D referencePoint = locationPositions.get(loc);     if (referencePoint == null) {         return;     }     double refX = referencePoint.getX();     double refY = referencePoint.getY();     double deltaX = x - refX;     double deltaY = y - refY;          // update the position of the specified location     locationPositions.put(loc, new Point2D.Double(x, y));          // update the position of all the other locations relative to the reference location     for (String otherLoc : locationPositions.keySet()) {         if (!otherLoc.equals(loc)) {             Point2D otherPoint = locationPositions.get(otherLoc);             double otherX = otherPoint.getX();             double otherY = otherPoint.getY();             double distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);             double angle = Math.atan2(deltaY, deltaX) - Math.atan2(otherY - refY, otherX - refX);             double newX = refX + distance * Math.cos(angle);             double newY = refY + distance * Math.sin(angle);             locationPositions.put(otherLoc, new Point2D.Double(newX, newY));         }     } }
public byte[] getMnemonicAsBytes() {     return mnemonicCode != null ? MnemonicCode.toSeed(mnemonicCode, "") : null; }
public int offset(String fieldName) {     if (!offsets.containsKey(fieldName)) {         throw new IllegalArgumentException("Field name not found in offsets");     }     return offsets.get(fieldName); }
public void stop(BundleContext context) throws Exception {     // do nothing, as the framework will automatically unregister any registered services }
public Lineage getLineageOfOutputFile(long fileId) {     if (mOutputFileIndex.containsKey(fileId)) {         Lineage lineage = mOutputFileIndex.get(fileId);         if (lineage.getOutputFileIds().contains(fileId)) {             return lineage;         }     }     return null; }
null
int findLastVisibleItemPosition() {     final View lastVisibleChild = findOneVisibleChild(getChildCount() - 1, -1, false, true);     return lastVisibleChild == null ? RecyclerView.NO_POSITION : getPosition(lastVisibleChild); }
public String getString(ConfigurationKey key, String defaultValue) {     if (key == null) {         throw new IllegalArgumentException("key cannot be null");     }     String value = getConfigurationHandler().getString(key.toString(), defaultValue);     return value; }
LSN writeSetStringRecord(String filename, int offset, String val) {     if (isTempBlock(new Block(filename, offset))) {         return LogMgr.dummyLSN;     } else {         byte[] rec = LogMgr.setStringRecord(filename, offset, val);         LSN lsn = logMgr.append(rec);         return lsn;     } }
null
public DiffBuilder removeComments() {     nodeFilter = (node) -> {         return !(node.getNodeType() == Node.COMMENT_NODE);     };     return this; }
@DeleteMapping("/dish-collections/{id}") public ResponseEntity<Void> deleteDishCollection(@PathVariable String id) {     log.debug("REST request to delete DishCollection : {}", id);     dishCollectionService.deleteDishCollection(id);     return ResponseEntity.noContent().build(); }
public CategoricalDistribution ask(final RandomVariable[] X, final AssignmentProposition[] observedEvidence,                                     final BayesianNetwork bn, int N) {     Map<RandomVariable, Integer> Ns = new HashMap<>();     Map<RandomVariable, CategoricalDistribution> distributions = new HashMap<>();     for (RandomVariable Xi : bn.getVariablesInTopologicalOrder()) {         Ns.put(Xi, 0);         distributions.put(Xi, new CategoricalDistribution(Xi));     }     for (int j = 1; j <= N; j++) {         Pair<Map<RandomVariable, Object>, Double> weightedSample = weightedSample(bn, observedEvidence);         Map<RandomVariable, Object> sample = weightedSample.getFirst();         double weight = weightedSample.getSecond();         for (RandomVariable Xi : bn.getVariablesInTopologicalOrder()) {             if (sample.containsKey(Xi)) {                 CategoricalDistribution dist = distributions.get(Xi);                 dist.increment(sample.get(Xi), weight);                 Ns.put(Xi, Ns.get(Xi) + 1);             }         }     }     for (RandomVariable Xi : bn.getVariablesInTopologicalOrder()) {         CategoricalDistribution dist = distributions.get(Xi);         if (observedEvidence != null) {             for (AssignmentProposition e : observedEvidence) {                 if (dist.contains(e.getTermVariable())) {                     dist.renormalize(e.getValue());                 }             }         }         if (X != null && !Arrays.asList(X).contains(Xi)) {             dist.clear();         } else if (Ns.get(Xi) > 0) {             dist.normalize();         }     }     if (X == null) {         return new CategoricalDistribution(distributions.values());     } else {         return CategoricalDistribution.multiply(distributions.values());     } }
/**  * Puts a new value in the property table with the appropriate flags.  * @param key the key to associate with the value  * @param value the value to store  * @param isReplace if true, replace the existing value for the given key  * @return the previous value associated with the key, or IntMap.NULL if none existed  */ public int put(Object key, int value, boolean isReplace) {     int index = hashCode(key) % _prime;     Object existingKey = _keys[index];     int existingValue = _values[index];          // check for collision     if (existingKey != null && !existingKey.equals(key)) {         int i = 1;         int j = (index + PRIMES[i++]) % _prime;         while (_keys[j] != null && !_keys[j].equals(key)) {             j = (j + PRIMES[i++]) % _prime;         }         existingKey = _keys[j];         existingValue = _values[j];     }          if (existingKey != null && existingKey.equals(key)) {         if (isReplace) {             _values[index] = value;             return existingValue;         } else {             return existingValue;         }     } else {         _keys[index] = key;         _values[index] = value;         _size++;         if (_size > _keys.length / 2) {             resize(_prime * 2);         }         return NULL;     } }
/**  * Retrieves a byte array field from the stream. Creates a new byte array that is the size of the object being retrieved.  *  * @return byte array field  * @throws IOException if an I/O error occurs while reading the stream  */ public byte[] getValue() throws IOException {     byte[] result = new byte[valueLen];     getByteArrayInternal(valueLen, result, valueOff, result.length);     return result; }
public void invalidateSSOSession(String sessionId) {     // Implement session invalidation logic here }
void addElementListener(PropertyChangeListener listener, Object element, String[] properties) {     if (element != null && listener != null) {         for (String property : properties) {             PropertyChangeSupport pcs = getPropertyChangeSupport(element, property);             pcs.addPropertyChangeListener(listener);         }     } }
public long getTStart() {     return tStart; }
public RegistrationRequest createRegistrationRequest() {     return new RegistrationRequest(); }
public static boolean filenameMatchesSuffixes(String filename, String[] suffixes) {     for (String suffix : suffixes) {         if (filename.endsWith(suffix)) {             return true;         }     }     return false; }
public Crypto getSignatureCrypto() {     return signatureCrypto; }
public void resetMaxMemory() {     maxMemory = 0; }
public void setSourceCodeFile(File file) {     this.sourceCodeFile = file; }
public void removeFromClosed(Node node) {     closed.removeValue(node, true); }
public String getBodyAsString() {     try {         return new String(_messageBody, _encoding).trim();     } catch (UnsupportedEncodingException e) {         return "Invalid message body encoding";     } }
public void moveAndTrigger(Path path) {     if (model != null && viewer != null) {         // Send move command to model         WalkDirection direction = getDirection(path);         model.moveCharacter(direction);                  // Trigger interactive event if possible         triggerEvent();     } } private WalkDirection getDirection(Path path) {     // Determine the direction based on the path     // This implementation assumes that the first tile in the path is the next destination     // and the current location of the character is already known.     Tile nextTile = path.get(0);     int dx = nextTile.getX() - model.getCharacterX();     int dy = nextTile.getY() - model.getCharacterY();     return WalkDirection.fromDelta(dx, dy); }
public boolean getIgnoreExceptions() {     return ignoreExceptions; }
public int booleanIfFirst(int reps) {     int dummy = 0;     for (int i = 0; i < reps; i++) {         StringBuilder builder = new StringBuilder();         boolean first = true;         for (String component : components) {             if (first) {                 first = false;             } else {                 builder.append(DELIMITER_STRING);             }             builder.append(component);         }         dummy ^= builder.length();     }     return dummy; }
public void merge(Map<String, SortedSet<String>> map) {     for (Map.Entry<String, SortedSet<String>> entry : map.entrySet()) {         String key = entry.getKey();         SortedSet<String> value = entry.getValue();         if (wrappedMap.containsKey(key)) {             wrappedMap.get(key).addAll(value);         } else {             wrappedMap.put(key, new TreeSet<>(value));         }     } }
@Override public int hashCode() {     int result = 0;     for (Constant val : vals.values()) {         result += val.hashCode();     }     return result; }
public int nextAvailableTile(int lane, int player) {     int tileIndex = tiles.get(lane).size - 1;     for (int i = tileIndex; i >= 0; i--) {         if (tiles.get(lane).get(i).isEmpty()) {             tileIndex = i;         } else {             break;         }     }     return tileIndex; }
public String getTransformedTokenIdentifier() {     return transformedTokenIdentifier; }
public void setLoadedInCats(String loadedInCats) {     this.loadedInCats = loadedInCats; }
public int getDecisions() {     return decisions; }
public String formatUTCtoSqlUTC(Date date) {     SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");     sdf.setTimeZone(TimeZone.getTimeZone("UTC"));     String utcDateTime = sdf.format(date);          sdf.setTimeZone(TimeZone.getDefault());     String localDateTime = sdf.format(date);          return localDateTime.replace(" ", "T"); }
public int getSize() {     return mSize; }
public void setLastVersion() {     double currentVersion = getVersion();     setLastVersion(currentVersion); }
public String getHost() {     if (host == null) {         try {             InetAddress localHost = InetAddress.getLocalHost();             host = localHost.getHostName();         } catch (UnknownHostException ex) {             // Handle exception             host = "unknown";         }     }     return host; }
public void addCommit(RepositoryCommit commit) {     if (!commits.contains(commit)) {         commits.add(commit);     } }
public void testGetMonth() {     // Create a new Date instance with a specific month value     Date date = new Date(2023, 3, 24);          // Get the month value from the Date instance using the getMonth() function     int month = date.getMonth();          // Verify that the returned month value matches the expected value     assertEquals(3, month); }
public int traversalCost(Object searchkey) {     // Estimate the size of the index file and the number of index records per block     int fileSize = si.recordSize() * si.numRecords();     int recordsPerBlock = ti.blockSize() / si.recordSize();     // Compute the number of blocks that need to be accessed to find all index records with the search key     int numBlocks = (int) Math.ceil(si.numRecords() / (double) recordsPerBlock);     int blocksToAccess = numBlocks;     // Estimate the traversal cost by calling traversalCost method of the appropriate index type     Index idx = open();     int cost = idx.traversalCost(searchkey, blocksToAccess);     // Close the index     idx.close();     return cost; }
public void apply(Node rootNode, RuleContext ruleContext, Language language) {     // Get the RuleChainVisitor for the given Language     RuleChainVisitor ruleChainVisitor = languageToRuleChainVisitor.get(language);     // If no RuleChainVisitor is found for the given Language, throw an exception     if (ruleChainVisitor == null) {         throw new IllegalArgumentException("No RuleChainVisitor found for Language: " + language);     }     // Create a new RuleChainExecutor with the RuleChainVisitor and RuleContext     RuleChainExecutor ruleChainExecutor = new RuleChainExecutor(ruleChainVisitor, ruleContext);     // Add all the RuleSets to the RuleChainExecutor     for (RuleSet ruleSet : ruleSets) {         if (ruleSet.getLanguage() == language) {             ruleChainExecutor.add(ruleSet);         }     }     // Add all the Rules to the RuleChainExecutor that belong to the given Language     for (RuleSet ruleSet : ruleSets) {         if (ruleSet.getLanguage() == language) {             for (Rule rule : ruleSet.getRules()) {                 ruleChainExecutor.add(ruleSet, rule);             }         }     }     // Traverse the Node tree and apply the RuleChainExecutor to each Node     rootNode.traverse(ruleChainExecutor); }
public Builder configuredAs() {     return new Builder().macAddress(this.macAddress).ipAddress(this.ipAddress); }
/**  * Sets an error number with a custom message.  *  * @param errorNumber The error number to set.  * @param errorMessage The custom error message to set.  */ public void setError(int errorNumber, String errorMessage) {     errorElement.setAttribute("number", String.valueOf(errorNumber));     errorElement.setTextContent(errorMessage); }
public void setInstanceName(final String instanceName) {     this.instanceName = instanceName; }
public boolean shouldRebuild(Run<?, ?> run, Combination combination) {     Boolean reuse = configurations.get(combination.toString());     if (reuse != null) {         return reuse.booleanValue();     } else {         return true;     } }
public void setConsoleModeAndParseShowProgress(String[] args) {     for (String arg : args) {         if (arg.startsWith("-console")) {             this.consoleMode = true;         }         else if (arg.startsWith("-showProgress")) {             this.showProgress = true;         }     } }
/**  * Find the raw query string parameter indicated and append it to the string builder.  * The appended value will be in the form 'paramName=paramValue' (minus the quotes).  *  * @param queryString the query string to search for the parameter  * @param paramName the name of the parameter to look for  * @param sb the string builder to append the parameter value to  */ private void appendParamValue(String queryString, String paramName, StringBuilder sb) {     String[] params = queryString.split("&");     for (String param : params) {         String[] parts = param.split("=", 2);         if (parts.length == 2 && parts[0].equals(paramName)) {             sb.append(parts[0]).append("=").append(parts[1]);             break;         }     } }
@Override public Object get(String name, Scriptable start) {     if (name.equals("dim")) {         return dim;     } else {         return NOT_FOUND;     } }
public List getNewFeaturesList() {     List<Object> allFeatures = getAllFeatures();     List<Object> sourceFeatures = getSource().getNewFeaturesList();     List<Object> newFeatures = new ArrayList<>();     for (Object feature : allFeatures) {         if (!sourceFeatures.contains(feature)) {             newFeatures.add(feature);         }     }     return newFeatures; }
public ClassStats getDirectNestedClass(String name) {     return nestedClasses.get(name); }
public void setGene(String gene) {     this.gene = gene; }
public void addResourceLocation(String location) {     if (!resourceLocations.contains(location)) {         resourceLocations.add(location);     } }
/**  * Writes an entry to the checkpoint file. The entry should not have its sequence number set.  * This method will add the proper sequence number to the passed in entry.  *   * @param entry the entry to write to the checkpoint file  */ public synchronized void writeCheckpointEntry(Entry entry) throws IOException {     // Set the sequence number for the entry     entry.setSequenceNumber(mNextEntrySequenceNumber++);     // Write the entry to the checkpoint output stream     mCheckpointOutputStream.writeEntry(entry);     // Flush the checkpoint output stream to ensure the data is written to disk     mCheckpointOutputStream.flush(); }
public boolean isHttpControl(final byte b) {     return (b >= 0 && b <= 31) || b == 127; }
public void registerCookieSpecFactory(String identifier, CookieSpecFactory factory) {     registeredSpecs.put(identifier, factory); } public void unregister(String identifier) {     registeredSpecs.remove(identifier); } public CookieSpec getCookieSpec(String name) {     return getCookieSpec(name, null); } public CookieSpec getCookieSpec(String name, HttpParams params) {     CookieSpecFactory factory = registeredSpecs.get(name);     if (factory != null) {         return factory.newInstance(params);     } else {         throw new IllegalStateException("Unsupported cookie spec: " + name);     } } public List<String> getSpecNames() {     return new ArrayList<>(registeredSpecs.keySet()); } public void setItems(Map<String, CookieSpecFactory> map) {     registeredSpecs.putAll(map); }
public void adjust(Collection<MapNode> nodes) {     BoundingBox bb = new BoundingBox(Float.MAX_VALUE, -Float.MAX_VALUE, Float.MAX_VALUE, -Float.MAX_VALUE);     for (MapNode node : nodes) {         bb.lonMin = Math.min(bb.lonMin, node.getLon());         bb.latMin = Math.min(bb.latMin, node.getLat());         bb.lonMax = Math.max(bb.lonMax, node.getLon());         bb.latMax = Math.max(bb.latMax, node.getLat());     }     this.lonMin = Math.max(this.lonMin, bb.lonMin);     this.latMin = Math.max(this.latMin, bb.latMin);     this.lonMax = Math.min(this.lonMax, bb.lonMax);     this.latMax = Math.min(this.latMax, bb.latMax); }
public ExtensionMechanismsHelper getImpl() {     return impl; }
public GeneralRange<T> upTo(Comparator<? super T> comparator, @Nullable T endpoint, BoundType boundType) {     Objects.requireNonNull(comparator);     BoundType newLowerBoundType = this.lowerBoundType;     T newLowerEndpoint = this.lowerEndpoint;     if (this.hasLowerBound() && comparator.compare(endpoint, this.lowerEndpoint) < 0) {         newLowerBoundType = boundType;         newLowerEndpoint = endpoint;     }     BoundType newUpperBoundType = boundType;     T newUpperEndpoint = endpoint;     if (this.hasUpperBound() && comparator.compare(endpoint, this.upperEndpoint) > 0) {         newUpperBoundType = this.upperBoundType;         newUpperEndpoint = this.upperEndpoint;     }     return new GeneralRange<>(newLowerBoundType, newLowerEndpoint, newUpperBoundType, newUpperEndpoint, this.comparator); }
public void processSource(Reader sourceCode, RuleSets ruleSets, RuleContext ctx) {     try {         Node rootNode = parse(ctx, sourceCode, configuration.getLanguageVersionHandler().getParser());         symbolFacade(rootNode, configuration.getLanguageVersionHandler());         determineLanguage(ctx);         usesTypeResolution(configuration.getLanguageVersion(), rootNode, ruleSets, configuration.getLanguage());         usesDFA(configuration.getLanguageVersion(), rootNode, ruleSets, configuration.getLanguage());         usesMetrics(configuration.getLanguageVersion(), rootNode, ruleSets, configuration.getLanguage());         for (Rule rule : ruleSets.getAllRules()) {             if (ctx.getLanguageVersion().supports(rule.getMinimumLanguageVersion())) {                 rule.apply(rootNode, ctx);             }         }     } catch (IOException e) {         throw new RuntimeException("Error processing source code", e);     } }
public void clearApprovedSitesForClient_success() {     // prepare test data     List<ApprovedSite> approvedSites = new ArrayList<>();     approvedSites.add(site1);     approvedSites.add(site2);     repository.saveAll(approvedSites);     // clear approved sites for client with no approved sites     service.clearApprovedSitesForClient(clientId);     // verify that remove() method is never called     verify(repository, never()).remove(any(ApprovedSite.class)); } public void prepare() {     // initialize test data     client = new ClientDetailsEntity();     client.setClientId(clientId);     site1 = new ApprovedSite();     site1.setClientId(clientId);     site1.setScope("read");     site2 = new ApprovedSite();     site2.setClientId(clientId);     site2.setScope("write");     site3 = new ApprovedSite();     site3.setClientId("anotherClient");     site3.setScope("read");     // set up mock repository     repository = mock(ApprovedSiteRepository.class);     when(repository.findByClientId(anyString())).thenAnswer((Answer<List<ApprovedSite>>) invocation -> {         String clientId = invocation.getArgument(0);         List<ApprovedSite> result = new ArrayList<>();         for (ApprovedSite site : approvedSites) {             if (site.getClientId().equals(clientId)) {                 result.add(site);             }         }         return result;     });     doNothing().when(repository).delete(any(ApprovedSite.class));     doNothing().when(repository).deleteAll(anyIterable()); }
void startPrefixMapping(String prefix, String uri) throws XMLStreamException {     writer.setPrefix(prefix, uri); }
private ClassLoader getClassLoader(ClassLoader loader, Class<?>[] interfaces) {     boolean canSeeAll = canSeeAllInterfaces(loader, interfaces);     if (canSeeAll) {         return loader;     } else {         List<ClassLoader> interfaceLoaders = new ArrayList<>();         for (Class<?> interf : interfaces) {             ClassLoader interfLoader = interf.getClassLoader();             if (interfLoader != null) {                 interfaceLoaders.add(interfLoader);             }         }         if (interfaceLoaders.isEmpty()) {             return null;         } else if (interfaceLoaders.size() == 1) {             return interfaceLoaders.get(0);         } else {             return new CombinedClassLoader(interfaceLoaders.toArray(new ClassLoader[interfaceLoaders.size()]));         }     } } public Class<?> getProxy(ClassLoader loader, Class<?>[] interfaces, InvocationHandler handler) {     ClassLoader classLoader = getClassLoader(loader, interfaces);     if (classLoader != null) {         return Proxy.getProxyClass(classLoader, interfaces);     } else {         return null;     } }
@Before public void setUp() throws Exception {     mTestStream = new TestBufferedBlockOutStream(BLOCK_LENGTH);     mThrown = ExpectedException.none(); }
public Constant getVal(String fldname) {     int fieldIndex = sch.fieldNumber(fldname);     if (fieldIndex < 0) {         throw new RuntimeException("Invalid field name");     }     Type fieldType = sch.type(fieldIndex);     if (fieldType == Type.INTEGER) {         return new IntegerConstant(getInt(fldname));     } else {         return new StringConstant(getString(fldname));     } }
public NodeVisitor begin() {     enter(n);     return this; }
public ThreadFactoryBuilder setThreadFactory(ThreadFactory backingThreadFactory) {     this.backingThreadFactory = backingThreadFactory;     return this; }
public List<ClassdiagramNode> getDownNodes() {     return downlinks; }
public Long getTestId() {     return testId; }
public class UUIDHelper {     public String getNewUUID() {         return UUID.randomUUID().toString();     } }
public long getFileSize(String sizeString) {     long multiplier = 1;     String size = sizeString.trim().toLowerCase();     if (size.endsWith("tb")) {         multiplier = 1024L * 1024L * 1024L * 1024L;         size = size.substring(0, size.length() - 2).trim();     } else if (size.endsWith("gb")) {         multiplier = 1024L * 1024L * 1024L;         size = size.substring(0, size.length() - 2).trim();     } else if (size.endsWith("mb")) {         multiplier = 1024L * 1024L;         size = size.substring(0, size.length() - 2).trim();     } else if (size.endsWith("kb")) {         multiplier = 1024L;         size = size.substring(0, size.length() - 2).trim();     }     if (size.matches("\\d+")) {         return Long.parseLong(size) * multiplier;     } else if (size.matches("\\d+\\.\\d+")) {         return (long) (Double.parseDouble(size) * multiplier);     } else {         throw new IllegalArgumentException("Invalid file size string: " + sizeString);     } }
void append(StringBuffer sbuf, int ch) {   if (ch >= 'A' && ch <= 'Z') {     sbuf.append((char)ch);   } else if (ch >= 'a' && ch <= 'z') {     sbuf.append((char)ch);   } else if (ch >= '0' && ch <= '9') {     sbuf.append((char)ch);   } else if (ch == ' ') {     sbuf.append('+');   } else if (ch == '-' || ch == '_' || ch == '.' || ch == '!' || ch == '~' || ch == '\'' || ch == '(' || ch == ')') {     sbuf.append((char)ch);   } else if (ch <= 0x7F) {     sbuf.append(hex[ch]);   } else if (ch <= 0x7FF) {     sbuf.append(hex[0xC0 | (ch >> 6)]);     sbuf.append(hex[0x80 | (ch & 0x3F)]);   } else {     sbuf.append(hex[0xE0 | (ch >> 12)]);     sbuf.append(hex[0x80 | ((ch >> 6) & 0x3F)]);     sbuf.append(hex[0x80 | (ch & 0x3F)]);   } }
public Timestamp getCreatedDate() {     return this.createdDate; }
public ELEvaluator createELEvaluatorUsingActionCreationTime(Date actionCreationTime, Configuration conf) {     ELEvaluator evaluator = new ELEvaluator();     evaluator.setVariable("actualTime", actionCreationTime);     evaluator.setVariable("nominalTime", actionCreationTime);     evaluator.setVariable("HOUR", 60 * MINUTE);     evaluator.setVariable("MINUTE", 1);     evaluator.setFunction("make2Digits", CoordELEvaluator.class, "make2Digits");     // Set configuration properties     setConfigToEval(evaluator, conf);     return evaluator; }
public QName getQName() {   return this.qname; }
public void setTraXFactory(TransformerFactory factory) {     this.factory = factory; }
public int nextIdentifier() {     int id = gen.getAndIncrement();     id = mix(salt, id);     return id; }
public class NullConduitSelector {     private Endpoint endpoint;     public Endpoint getEndpoint() {         return endpoint;     }     public Conduit selectConduit(Message message) {         // Implementation logic here     }     public void setEndpoint(Endpoint ep) {         this.endpoint = ep;     }     public void prepare(Message message) {         // Implementation logic here     }     // Member function implementation based on natural language description     public void onComplete() {         // Implementation logic here     } }
@Override protected Executor executor() {     return MoreExecutors.renameThreadExecutor(         MoreExecutors.directExecutor(),         new Supplier<String>() {             @Override             public String get() {                 return serviceName();             }         }     ); }
public void testSetOriginId() {     String expected = "MYSHIP";     rmb.setOriginId(expected);     assertEquals(expected, rmb.getOriginId()); }
public Object getFeature(String name) {     Object classifier = this.classifier;     while (classifier != null && !(classifier instanceof Class)) {         classifier = ((ClassifierContext) classifier).getClassifier();     }     if (classifier != null) {         Collection features = ((Class) classifier).getFeatures();         for (Object feature : features) {             if (feature instanceof StructuralFeature && ((StructuralFeature) feature).getName().equals(name)) {                 return feature;             }         }     }     return null; }
public void testGetVersion(AbstractDosPlugin instance) {     // Arrange     String expectedVersion = "1.0.0";     // Act     String actualVersion = instance.getVersion();     // Assert     assertEquals(expectedVersion, actualVersion); }
public Object getAttribute(String attributeName) {     if (this.classifier != null) {         // Check if the current classifier has the requested attribute         try {             return this.classifier.getAttributeValue(attributeName);         } catch (AttributeNotFoundException e) {             // Attribute not found, continue to the next classifier         }     }     // If the attribute is not found in the current classifier, search for it in the parent classifiers     Object parentClassifier = this.getParentClassifier();     while (parentClassifier != null) {         try {             return parentClassifier.getAttributeValue(attributeName);         } catch (AttributeNotFoundException e) {             // Attribute not found, continue to the next parent classifier             parentClassifier = ((ParseState) parentClassifier).getParentClassifier();         }     }     // If the attribute is not found in any classifier, return null     return null; }
public Timestamp getEndDate() {     return this.endDate; }
public String createMergeWithQuery(String graphName, String sdd, String user, String commitMessage, String branchNameA, String branchNameB, String triples) {     String query = "MERGE-WITH";     query += " GRAPH <" + graphName + "> ";     query += "USING <" + sdd + "> ";     query += "USER \"" + user + "\" ";     query += "COMMIT \"" + commitMessage + "\" ";     query += "BRANCH \"" + branchNameA + "\" ";     query += "BRANCH \"" + branchNameB + "\" ";     query += triples;     return query; }
public String getApplicationDescription() {     return applicationDescription; }
/**  * Test method for {@link net.sf.marineapi.nmea.parser.GSAParser#getVerticalDOP()}.  */ void testGetVerticalDOP() {     double expected = 1.2; // replace with expected vertical DOP value     GSASentence gsa = new GSASentence(EXAMPLE);     gsa.setVerticalDOP(expected);     double actual = gsa.getVerticalDOP();     assertEquals(expected, actual, 0.0); }
/**  * Gets the authorization code.  */ public String getCode() {     return this.code; }
/**  * Test method for {@link net.sf.marineapi.nmea.util.Time#setMinutes(int)}.  */ void testSetMinutes() {     int expected = 30; // replace with expected minutes value     Time t = new Time();     t.setMinutes(expected);     int actual = t.getMinutes();     assertEquals(expected, actual); }
/**  * Get the SignatureProperties to use.  */ SignatureProperties getSignatureProperties() {     if (signatureProperties == null && signaturePropertiesFile != null) {         try (InputStream is = Files.newInputStream(Paths.get(signaturePropertiesFile))) {             signatureProperties = new SignatureProperties();             signatureProperties.load(is);         } catch (IOException | SignatureException ex) {             LOG.log(Level.WARNING, "Failed to load signature properties from file: " + signaturePropertiesFile, ex);         }     }     return signatureProperties; }
public long accumulateAndGet(K key, long x, LongBinaryOperator accumulatorFunction) {     Objects.requireNonNull(accumulatorFunction, "accumulatorFunction cannot be null");     Long oldValue, newValue;     do {         oldValue = map.get(key);         newValue = (oldValue == null) ? x : accumulatorFunction.applyAsLong(oldValue, x);     } while (!map.replace(key, oldValue, newValue));     return (oldValue == null) ? x : oldValue; }
null
null
public void e(String tag, String msg) {     if (sIsLogEnabled) {         String content = getContent(getCurrentStackTraceElement());         Log.e(getTagContentPrint(), content + " " + tag + ": " + msg);     } }
null
public void setSrcFileName(String srcFileName) {     this.srcFileName = srcFileName; }
public ConfigurationHandler getConfigurationHandler() {    return SINGLETON.handler; }
public boolean next() {     if (s2.next()) {         return true;     }     else {         s1.next();         if (s1.hasNext()) {             s2.beforeFirst();             return s2.next();         }         else {             return false;         }     } }
public V getValue() {     return value; }
public int getXPosition() {     return xPosition; }
public long calculateChecksum() {     long sum = 0;     byte[] headerBytes = header.getHeaderBytes();     for (byte b : headerBytes) {         sum += (b & 0xff);     }     return sum; }
private void checkForNullBuffers(Collection buffers) {     for (ByteBuffer buffer : buffers) {         if (buffer == null) {             throw new NullPointerException("Buffer in collection cannot be null.");         }     } }
@Test(expected = IllegalArgumentException.class) public void testNegativeOffsetConstructor() {     new RPCFileReadRequest(TEMP_UFS_FILE_ID, -OFFSET, LENGTH); }
public void eatDelim(char d) {     if (tok.ttype == d) {         nextToken();     } else {         throw new RuntimeException("Expected delimiter: " + d);     } }
public static void isTrue(boolean expression, String message) {     if (!expression) {         throw new IllegalArgumentException(message);     } }
public static void resetLoginUser() {     LoginUser.resetInstance(); }
public static <T> List<T> list(T... elements) {     if (elements == null) {         return new ArrayList<>();     }     return Arrays.asList(elements); }
public static URI rewriteURIKeepingFragment(final URI uri, final HttpHost target, final boolean dropFragment) throws URISyntaxException {     return URIUtils.rewriteURI(uri, target, dropFragment, true); }
public void removeListener(SpringSystemListener listenerToRemove) {     mListeners.clear(); }
private static JavascriptRuntime instance; public static JavascriptRuntime getInstance() {     if(instance == null) {         instance = new JavascriptRuntime();     }     return instance; }
public Date getBootDate() {     return serverStatus.getBootDate(); }
public void setName(String name) {     this.name = name; }
public void testGetVariation() {     // Create a new HDGParser object     HDGParser parser = new HDGParser();     // Set the EXAMPLE sentence as the input sentence     parser.parse(EXAMPLE);     // Assert that the value returned by getVariation() matches the expected value     assertEquals(1.2, parser.getVariation(), 0.01); }
/**  * Returns this extension from the given wallet, or null if no such extension was added.  *  * @param containingWallet The wallet from which to retrieve the extension.  * @return The stored payment channel client states extension, or null if not found.  */ public static StoredPaymentChannelClientStates getFromWallet(Wallet containingWallet) {     return (StoredPaymentChannelClientStates) containingWallet.getExtensions().get(EXTENSION_ID); }
public void clearCache() {     getOpenIDCache().clear(); }
/**  * Sets the optional login name.  *   * @param loginName the login name to be set.  */ public void setLoginName(String loginName) {     this.loginName = loginName; }
void testGetDatum() {     // Initialize test data     Datum datum = Datum.WGS84;     instance.setDatum(datum);          // Test getDatum() method     assertEquals(datum, instance.getDatum()); }
public void ensureSourceHasSystemId(Source source) {     if (source.getSystemId() == null) {         source.setSystemId(PWD.getAbsolutePath());     } }
public List<Object> getFeaturesNotInSource() {     List<Object> featuresNotInSource = new ArrayList<Object>();     for(Object feature : newFeatures) {         if(!mClassifier.equals(feature)) {             featuresNotInSource.add(feature);         }     }     return featuresNotInSource; }
public void updateToken(OpenIDRememberMeDO rememberMe, String newToken) {     if (rememberMe == null || newToken == null) {         throw new IllegalArgumentException("Null argument provided");     }     rememberMe.setToken(newToken);     dao.updateToken(rememberMe);     cache.removeToken(rememberMe.getUsername()); }
public void closeServerSocket() {     try {         if (serverSocket != null && !serverSocket.isClosed()) {             serverSocket.close();             log.info("Server socket closed.");         }     } catch (IOException e) {         log.error("Error while closing server socket: " + e.getMessage());     } }
public void setLane_id(int lane_id) {     this.lane_id = lane_id; }
public void addNode(long id, MapNode node) {     nodes.put(id, node); }
public void saveCommitInformation(String commitInfo) {     // save the commit information     commitModel.addCommitInformation(commitInfo); } public void outputCommitInformation() {     // output the commit information     String commitReport = commitModel.getCommitReport();     logger.info(commitReport); }
/**  * Test method for {@link com.sqa.em.util.helper.RequestInput#getChar(java.lang.String)}.  */ public void testGetCharString() {     // Test input string     String input = "a";     // Set input stream to the input string     System.setIn(new ByteArrayInputStream(input.getBytes()));     // Get the char from user input     char result = RequestInput.getChar("Enter a character: ");     // Check if the result is equal to the expected output     assertEquals('a', result); }
public void loadFromFile(String filename) {     try {         config.load(new FileInputStream(filename));     } catch (IOException e) {         logger.warning("Failed to load configuration from file: " + filename);     } }
public void setInInterceptors(List<Interceptor<? extends Message>> interceptors) {     inInterceptors = interceptors; }
public void setBoolean(ConfigurationKey key, boolean newValue) {     Objects.requireNonNull(key, "key must not be null");     setString(key, Boolean.toString(newValue)); }
public String getSubjectSecondary() {     String subject = mCert.getSubjectX500Principal().getName();     String[] subjectParts = subject.split(",");     for (String part : subjectParts) {         if (part.startsWith("OU=")) {             return part.substring(3);         }         if (part.startsWith("CN=")) {             return part.substring(3);         }     }     return ""; }
/**  * Returns the object that originated this event (not the object that originated the wrapped event).  * This is generally an {@link EventBus}.  */ public Object getEventSource() {     return source; }
null
public void setTenantDomain(String tenantDomain) {     this.tenantDomain = tenantDomain; }
@Test public void getCapacityBytes() throws Exception {     long expectedCapacity = mTestDir.getCapacityBytes();     long actualCapacity = mTestDirView.getCapacityBytes();     Assert.assertEquals(expectedCapacity, actualCapacity); }
public String getUniqueDiagramName() {     String extension = getZipFileExtension();     if (extension.isEmpty()) {         return project.getBaseName() + "_" + uniqueName;     } else {         return project.getBaseName() + "_" + uniqueName + "." + extension;     } }
public void setPeakStart(int peakStart) {     this.peakStart = peakStart; }
@Test public void lockBlockTest() throws Exception {     // Write your code here     // Call the lockBlock method from the BlockLockManager class     // Use the member variables TEST_BLOCK_ID, TEST_SESSION_ID, and BlockLockType.WRITE to lock the block     mLockManager.lockBlock(TEST_BLOCK_ID, TEST_SESSION_ID, BlockLockType.WRITE);     // Assert that the block is locked     assertTrue(mLockManager.isBlockLocked(TEST_BLOCK_ID));     // Call the unlockBlock method from the BlockLockManager class to unlock the block     mLockManager.unlockBlock(TEST_BLOCK_ID, TEST_SESSION_ID); }
public class ShaUtils {          private static final char[] CHARS = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};          public static String sha1(String data) {         try {             MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");             byte[] hash = messageDigest.digest(data.getBytes());             StringBuilder sb = new StringBuilder();             for (byte b : hash) {                 int high = (b >> 4) & 0x0F;                 int low = b & 0x0F;                 sb.append(CHARS[high]);                 sb.append(CHARS[low]);             }             return sb.toString();         } catch (NoSuchAlgorithmException e) {             throw new RuntimeException(e);         }     } }
void testSetTrue() {     // set true value     mwv.setTrue(true);     assertTrue(mwv.isTrue());     // set false value     mwv.setTrue(false);     assertFalse(mwv.isTrue()); }
public int getMaxUpdateRetries() {     return maxUpdateRetries; }
void runPlayer(int player, PlayerTickEvent event) {     int[] ticks = playerList.get(player);     if (ticks == null) {         // Player is not being ticked, add them to the tick         ticks = new int[]{0};         playerList.put(player, ticks);     }     // Increment the tick count for this player     ticks[0]++; }
public void setDeliveryTag(long deliveryTag) {     this.deliveryTag = deliveryTag; }
public StoredClientChannel getUsableChannelForServerID(Sha256Hash id) {     lock.lock();     try {         Collection<StoredClientChannel> channels = mapChannels.get(id);         for (StoredClientChannel channel : channels) {             if (channel.active() && !channel.expired()) {                 return channel;             }         }         return null;     } finally {         lock.unlock();     } }
@Override public void destroyItem(ViewGroup container, int position, Object object) {     container.removeView((View) object); }
public void setExceptionListener(ExceptionListener listener) {     this.exceptionListener = listener; }
public void triggerCommand() {     // Method body goes here     // Call a method in the model to trigger the command     model.triggerCommand(); }
public String getCaseId() {     return this.caseId; }
public int getFileMode(File file) {     int mode = 0;     if (isUnix()) {         UnixFileStat fileStat = unixlibc.lstat(file.getPath());         mode = fileStat.mode();     } else {         LOGGER.warn("getFileMode() is not implemented for this OS.");     }     return mode; }
public String getTextOfEmojiIcon() {     return this.emojiText; }
public int getDimension() {     return dimension; }
public void setChecksumType(String checksumType) {     this.checksumType = checksumType; }
public <T> Set<T> getSubsetOfNodes(Class<T> clazz) {     Set<T> subset = new HashSet<T>();     for (Object node : allNodes) {         if (clazz.isInstance(node)) {             subset.add((T) node);         }     }     return subset; }
public void testSetSentenceCountWithNegativeValue() {     try {         rte.setSentenceCount(-1);         fail("Expected IllegalArgumentException was not thrown");     } catch (IllegalArgumentException e) {         // expected exception     } }
public void setEncryptionCrypto(Crypto encryptionCrypto) {     this.encryptionCrypto = encryptionCrypto; }
public int getRemainingUtility(int row, int column) {     int remainingUtility = 0;     for (int i = 0; i < positions.size(); i++) {         MatrixPosition pos = positions.get(i);         if (pos.getRow() == row && pos.getColumn() == column) {             remainingUtility += originalMatrix.getValue(pos.getRow(), pos.getColumn());         }     }     return remainingUtility; } public int getLocalSequenceUtility(MatrixPosition position) {     return originalMatrix.getValue(position.getRow(), position.getColumn()); }
public void addIndividualStructure(String identifier, IndividualStructure individualStructure) {     individualStructures.put(identifier, individualStructure); }
public Context getContext() {     context.setFunctions(functions);     context.setVariables(vars);     return context; }
public SDDTripleStateEnum getTripleStateA() {     return tripleStateA; }
public void addUserStoreManager(String domainName, Map<String, String> userStoreManager) {     userStoreManagers.put(domainName, userStoreManager); }
public void setMailSender(JavaMailSender mailSender) {     this.mailSender = mailSender; }
public void associateWithTopLevelScope(Scriptable scope) {     String scopeKey = "ClassCache_" + System.identityHashCode(scope);     Object existingCache = ScriptableObject.getProperty(scope, scopeKey);     if (existingCache != null && existingCache instanceof ClassCache) {         // ClassCache object already associated with the scope         return;     }     ScriptableObject.putProperty(scope, scopeKey, this); }
public void setBus(Bus bus) {     this.bus = bus; }
void testConstructorSingleArray() {     // Initialize the number of columns and rows     int numCols = 5;     int numRows = 4;     // Create a new DenseMatrix64F object using the constructor to be tested     DenseMatrix64F matrix = new DenseMatrix64F(numCols, numRows);     // Verify that the matrix has the expected dimensions     assertEquals(numCols, matrix.getNumCols());     assertEquals(numRows, matrix.getNumRows());     // Verify that all elements in the matrix are initialized to 0.0     for (int i = 0; i < numCols; i++) {         for (int j = 0; j < numRows; j++) {             assertEquals(0.0, matrix.get(i, j), 1e-8);         }     } }
public void testGetYear() {     String sentence = "$GPRMC,120044.567,A,6011.552,N,02501.941,E,000.0,360.0,160705,006.1,E,A*0B";     try {         rmc.parse(sentence);         assertEquals(5, rmc.getYear());     } catch (Exception e) {         fail("Unexpected exception: " + e.getMessage());     } }
public void setGeneList(String geneList) {     this.geneList = geneList; }
/**  * Gets the value of the roles property.  * This accessor method returns a reference to the live list, not a snapshot.  * Therefore any modification you make to the returned list will be present  * inside the JAXB object. This is why there is not a set method for the roles property.  * For example, to add a new item, do as follows: getRoles().add(newItem);  * Objects of the following type(s) are allowed in the list {@link Role }.  *  * @return the value of the roles property  */ public List<Role> getRoles() {     return this.roles; }
public void setReferencedRevisionA(String referencedRevisionA) {     this.referencedRevisionA = referencedRevisionA; }
public void processUpr() {     boolean hasData = false;     StringBuilder sb = new StringBuilder();     while (!state.isGroupFinished()) {         IParserEvent event = getNextEvent();         if (event instanceof TextEvent) {             TextEvent textEvent = (TextEvent) event;             sb.append(textEvent.getText());             hasData = true;         }     }     if (hasData) {         String unicodeText = sb.toString();         listener.processText(unicodeText);     } }
public BigDecimal getDownloadSize() {     return downloadSize; }
public void testMatrix0() {     int n = 4;     DenseMatrix64F A = new DenseMatrix64F(n,n);     // Set all diagonal elements to 0 and all other elements to 1     for (int i = 0; i < n; i++) {         for (int j = 0; j < n; j++) {             if (i == j) {                 A.set(i, j, 0);             } else {                 A.set(i, j, 1);             }         }     }     // Create a hessenberg matrix     DenseMatrix64F H = new DenseMatrix64F(n, n);     CommonOps_DDRM.multTransA(A, A, H);     CommonOps_DDRM.hessenberg(H, n - 2, n - 1, H);     // Compute eigenvalues and eigenvectors     EigenDecomposition<DenseMatrix64F> eig = DecompositionFactory_DDRM.eig(n, true);     eig.decompose(H);     // Check if all eigenvalues were found     int numFailed = checkEigenvalues(A, eig);     // Check if all eigenvectors were found     int numFailedVector = numCantFindEigenvector;     // If all eigenvalues and eigenvectors were found, the test passes     assertTrue(numFailed == 0);     assertTrue(numFailedVector == 0); }
public void addSettings(AbstractSettings setting) {     PROPS.add(setting); }
void removeLastEvent() {     if (events.size() >= 2) {         IParserEvent lastEvent = events.removeLast();         IParserEvent newEvent = events.removeLast();         String mergedString = newEvent.getStringData() + lastEvent.getStringData();         IParserEvent mergedEvent = new StringEvent(mergedString);         events.addLast(mergedEvent);     } }
public boolean hasApprovalExpired() {     Date currentTime = new Date();     return currentTime.after(timeoutDate); }
public NameValuePair createNameValuePair(final String name, final String value) {     if (name == null) {         throw new IllegalArgumentException("Name may not be null");     }     return new BasicNameValuePair(name, value); }
public static String toString(final byte[] bytes, final Charset charset) throws IOException {     return new String(bytes, charset); } public static String toString(final byte[] bytes, final String charsetName) throws IOException {     return toString(bytes, Charset.forName(charsetName)); } public static String toString(final InputStream input, final Charset charset) throws IOException {     ByteArrayOutputStream output = new ByteArrayOutputStream();     copy(input, output);     return output.toString(charset.name()); } public static String toString(final InputStream input, final String charsetName) throws IOException {     return toString(input, Charset.forName(charsetName)); } public static String toString(final InputStream input, final int bufferSize, final Charset charset) throws IOException {     ByteArrayOutputStream output = new ByteArrayOutputStream();     copy(input, output, bufferSize);     return output.toString(charset.name()); } public static String toString(final InputStream input, final int bufferSize, final String charsetName) throws IOException {     return toString(input, bufferSize, Charset.forName(charsetName)); }
public void addShort(short value) {     byte[] shortBuf = new byte[2];     shortBuf[0] = (byte) (value >> 8);     shortBuf[1] = (byte) value;     packed.write(shortBuf, 0, 2); }
public EmailTemplateDTO getEmailTemplate(int index) {     if (templates == null || index < 0 || index >= templates.length) {         return null;     }     return templates[index]; }
public JSONArray toJSONArray(List<Node> nodes) {     JSONArray jsonArray = new JSONArray();     for (Node node : nodes) {         JSONObject jsonObject = new JSONObject();         jsonObject.put("id", node.getId());         jsonObject.put("name", node.getName());         jsonObject.put("type", node.getType());         jsonArray.put(jsonObject);     }     return jsonArray; }
public Class<?> getCollectionTypeByShortName(String shortName) {     if (shortName == null || shortName.isEmpty()) {         return null;     }     switch (shortName.toLowerCase()) {         case "list":             return List.class;         case "arraylist":             return ArrayList.class;         case "linkedlist":             return LinkedList.class;         case "vector":             return Vector.class;         case "set":             return Set.class;         case "hashset":             return HashSet.class;         case "linkedhashset":             return LinkedHashSet.class;         case "treeset":             return TreeSet.class;         case "map":             return Map.class;         case "hashmap":             return HashMap.class;         case "linkedhashmap":             return LinkedHashMap.class;         case "treemap":             return TreeMap.class;         case "hashtable":             return Hashtable.class;         default:             return null;     } }
public EndpointReferenceType resolve(EndpointReferenceType logical) {     for (EndpointResolver resolver : resolvers) {         EndpointReferenceType physical = resolver.resolveEndpoint(logical);         if (physical != null) {             return physical;         }     }     return null; }
/**  * A utility class for reading and writing bytes.  */ public class ByteIOUtils {     // member variables not shown     // member function headers not shown     /**      * Writes a specific integer value (4 bytes) to the output byte array at the given offset.      *      * @param buf the byte array to write to      * @param pos the position in the byte array to start writing at      * @param v   the integer value to write      */     public void writeInt(byte[] buf, int pos, int v) {         buf[pos] = (byte) (v >>> 24);         buf[pos + 1] = (byte) (v >>> 16);         buf[pos + 2] = (byte) (v >>> 8);         buf[pos + 3] = (byte) v;     } }
public void spin90Left() {     cmd.hover();     waitFor(hoverTime);     cmd.spinLeft(spin90Speed);     waitFor(spinTime);     cmd.hover();     waitFor(spin90Time);     cmd.stop(); }
public static Measurements getSingleton() {     if (singleton == null) {         synchronized (Measurements.class) {             if (singleton == null) {                 singleton = new Measurements();             }         }     }     return singleton; }
public void setMarshaller(Marshaller marshaller) {     this.marshaller = marshaller; }
public void setAcceptedKeyWrapAlgorithms(List<String> acceptedKeyWrapAlgorithms) {     this.acceptedKeyWrapAlgorithms = acceptedKeyWrapAlgorithms; }
public static boolean verifyAuthentication(String username, String password) {     // Your authentication logic here     // Return true if the username and password are valid, false otherwise }
public boolean needPersistence(long fileId) {     synchronized (mLock) {         return !mPersistedFiles.contains(fileId) && !mPersistingInProgressFiles.containsKey(fileId);     } }
public LinearSolver<DenseMatrix64F> incremental(int matrixSize) {     return new LinearSolverWithCache<>(new LUDecompositionAlt()); }
public EndpointImpl newEndpointImpl(Bus bus, Service service, EndpointInfo endpointInfo) {     if (service == null) {         throw new IllegalArgumentException("Service cannot be null");     }     if (endpointInfo == null) {         throw new IllegalArgumentException("EndpointInfo cannot be null");     }     return new EndpointImpl(bus, service, endpointInfo); }
@Test public void getDirView() {     mThrown.expect(IndexOutOfBoundsException.class);     mTestTierView.getDirView(TEST_TIER_LEVEL + 1); }
public static <K, V> boolean isEmpty(Map<K, V> map) {     return map == null || map.isEmpty(); }
public <T extends Node> T getFirstParentOfType(Class<T> parentType) {     Node parent = jjtGetParent();     while (parent != null && !parentType.isInstance(parent)) {         parent = parent.jjtGetParent();     }     return parentType.cast(parent); }
public static int toUnsignedInt(long value) {     return (int) (value & INT_MASK); }
public static void solveL(double[] L, double[] b, int n) {     for (int i = 0; i < n; i++) {         for (int j = 0; j < i; j++) {             b[i] -= L[i * n + j] * b[j];         }         b[i] /= L[i * n + i];     } }
/**  * Returns true if the given line is not null or if it is not a comment.  *  * @param line the line to be checked  * @return true if the line is not null or if it is not a comment, false otherwise  */ public boolean isLineValid(String line) {     if (line == null) {         return false;     }     line = line.trim();     if (line.isEmpty() || line.startsWith("#")) {         return false;     }     return true; }
public DeterministicKey getRootKey() {     return get(rootPath, false, false); }
public TriConsumer<X, Y, Z> andThen(TriConsumer<? super X, ? super Y, ? super Z> after) {     Objects.requireNonNull(after);     return (x, y, z) -> {         accept(x, y, z);         try {             after.accept(x, y, z);         } catch (Exception e) {             throw new RuntimeException(e);         }     }; }
public static <T> Function<T, T> identity() {     return t -> t; }
public void setChallenge(byte[] value) {     this.challenge = value; }
public void addType(String name, Named namedObject) {     table.put(name, namedObject); }
public void executeHeartbeatAndWait(String threadName) {     ScheduledTimer timer = new ScheduledTimer(threadName);     addTimer(timer);     schedule(threadName);     await(threadName);     clearTimer(threadName); }
public static <T extends Comparable<T>> Matcher<T> lessThan(T value) {     return new OrderingComparison<T>("less than") {         @Override         public int compare(T actual, T expected) {             return actual.compareTo(expected);         }         @Override         public boolean test(T actual) {             return actual.compareTo(value) < 0;         }     }; }
public void queueCommand(XCommand<?> command) {     try {         lock.lock();         if (!used) {             used = true;             List<XCommand<?>> commandList = commandQueue.get(Thread.currentThread().getId());             if (commandList == null) {                 commandList = new ArrayList<>();                 commandQueue.put(Thread.currentThread().getId(), commandList);             }             commandList.add(command);         } else {             LOG.debug("Command [{0}] is not queued as it was already used", command.getName());         }     } finally {         lock.unlock();     } }
public void await(String name) throws InterruptedException {     sLock.lock();     try {         while (!sTimers.containsKey(name)) {             sCondition.await();         }     } finally {         sLock.unlock();     } }
public void setInvalid() {     valid = false;     invalidationMessage = "Invalid value"; }
public String getCollisionString(int i, int n) {     int hash = DJBX33A(Integer.toString(i));     return Integer.toString((hash % n + n) % n); } private int DJBX33A(String str) {     int hash = 5381;     for (int i = 0; i < str.length(); i++) {         hash = ((hash << 5) + hash) + str.charAt(i);     }     return hash; }
public String getDestination() {     return destination; }
public void waitFor(int millis) {     try {         Thread.sleep(millis);     } catch (InterruptedException e) {         e.printStackTrace();     } }
public String[] getIssuerList() {     try {         return stub.getIssuerList();     } catch (RemoteException e) {         log.error("Error occurred while getting issuer list", e);     }     return new String[0]; }
public void removeAttribute(String name) {     attributes.remove(name); }
public void doAction() {     if (canGoNext()) {         int oldStep = step;         step++;         doAction(oldStep);     } }
public void testEquals() {     Date d1 = new Date(2022, 3, 23);     Date d2 = new Date(2022, 3, 23);     Date d3 = new Date(2023, 3, 23);     assertTrue(d1.equals(d2));     assertFalse(d1.equals(d3)); }
public void addNode(int data) {     Node newNode = new Node(data);     if (head == null) {         head = newNode;     } else {         Node lastNode = head;         while (lastNode.next != null) {             lastNode = lastNode.next;         }         lastNode.next = newNode;     } }
public Array<Asset> soundsToLoad() {     return null; }
@Override protected void starting() {     // Put code here for actions to be taken when the service is starting     // and transitions to running state }
public double getPower() {     return power; }
public String getReferencedRevisionLabelB() {     return referencedRevisionLabelB; }
public String getGraphSource() {     return graph.toString(); }
public void registerListener(SentenceListener listener, String type) {     if (!listeners.containsKey(type)) {         listeners.put(type, new ArrayList<SentenceListener>());     }     listeners.get(type).add(listener); }
public void incrementTotalValue(long amount) {     Protos.TwoWayChannelMessage.Builder messageBuilder = Protos.TwoWayChannelMessage.newBuilder()             .setType(Protos.TwoWayChannelMessage.MessageType.INCREASE_PAYMENT)             .setAmount(amount);     channelClient.sendMessage(messageBuilder.build()); }
public static String getPackageName(String name) {     int lastDotIndex = name.lastIndexOf('.');     if (lastDotIndex == -1) {         return "";     } else {         return name.substring(0, lastDotIndex);     } }
@Test public void loadByUsername_admin_success() {     // Arrange     String username = "admin";     String clientId = "publicClient-1-313124";     UserInfo expectedUserInfo = new UserInfo(username, "admin@test.com", true,             Arrays.asList(new SimpleGrantedAuthority("ROLE_USER"), new SimpleGrantedAuthority("ROLE_ADMIN")));     // Act     UserDetails userDetails = service.getByUsernameAndClientId(username, clientId);     // Assert     assertNotNull(userDetails);     assertEquals(expectedUserInfo.getUsername(), userDetails.getUsername());     assertEquals(expectedUserInfo.getEmail(), userDetails.getUsername());     assertEquals(expectedUserInfo.isEnabled(), userDetails.isEnabled());     assertEquals(expectedUserInfo.getAuthorities(), userDetails.getAuthorities()); }
public boolean evaluate(Scan scan) {     for (int i = 0; i < terms.size(); i++) {         if (!terms.get(i).evaluate(scan)) {             return false;         }     }     return true; }
public void release(int port) {     if (hasPort(port)) {         int index = port - basePort;         allocated[index] = false;     } }
public XHTMLPanel getPanel() {     return panel; }
public void applyKnownMutationsData(File knownMutationsFile, Map<String,String> mutationsMap) {     // Do nothing since no mutation data is applied }
void onServiceAdd(long xid, int retval, ServiceInfo[] info) {     // Implementation goes here } void onServiceRemove(long xid, int retval, ServiceInfoStat[] info) {     // Implementation goes here } void onServiceUnregistration(ServiceID id, int flags, int prefixBits, InetAddress addr) {     // Implementation goes here } void onServiceDelayed(long xid, long pktId, ServiceID service) {     // Implementation goes here } void onServiceModify(long xid, int retval, ServiceInfoStat[] info) {     // Implementation goes here } void onFlowStatUpdate(long xid, int retval, FlowStat[] stats, boolean more) {     // Implementation goes here } String getRetvalString(int retval) {     // Implementation goes here } void onServiceRegistration(ServiceID id, int flags, int prefixBits, InetAddress addr, InetAddress oldAddr) {     // Implementation goes here }
void processGroupStart() {     try {         writer.writeStartElement("group");     } catch (XMLStreamException e) {         // Handle exception     } }
double computeEigenValue(DenseMatrix64F A, DenseMatrix64F eigenVector) {     DenseMatrix64F temp = new DenseMatrix64F(A.numCols, 1);     CommonOps.mult(A, eigenVector, temp);     double numerator = CommonOps.dot(eigenVector, temp);     double denominator = CommonOps.dot(eigenVector, eigenVector);     return numerator / denominator; }
public void validateConfiguration(ActivityRequest activityRequest) {     if (activityRequest == null) {         throw new IllegalArgumentException("ActivityRequest cannot be null");     }     if (activityRequest.getParameters() == null || activityRequest.getParameters().isEmpty()) {         throw new IllegalArgumentException("ActivityRequest parameters cannot be null or empty");     }     if (!activityRequest.getParameters().containsKey("param1")) {         throw new IllegalArgumentException("Missing mandatory parameter: param1");     }     if (!activityRequest.getParameters().containsKey("param2")) {         throw new IllegalArgumentException("Missing mandatory parameter: param2");     } }
public void build() {     Set<String> moduleNames = moduleConfiguration.keySet();     for (String moduleName : moduleNames) {         ModuleConfiguration moduleConfig = getModuleConfigurations(moduleName);         Properties moduleProps = getModuleProperties(moduleName);         List<Subscription> subscriptionList = buildSubscriptionList(moduleName, moduleProps);         moduleConfig.setSubscriptionList(subscriptionList);     } }
@Test public void testSubscribe() {     RedisRegistry registry = new RedisRegistry(registryUrl);     registry.register(serviceUrl);     try {         RedisRegistry registry2 = new RedisRegistry(registryUrl);         final AtomicReference<URL> atomicReference = new AtomicReference<>();         registry2.subscribe(consumerUrl, new NotifyListener() {             @Override             public void notify(List<URL> urls) {                 atomicReference.set(urls.get(0));             }         });         registry.register(serviceUrl2);         Thread.sleep(500);         URL url = atomicReference.get();         Assert.assertEquals(serviceUrl2.toFullString(), url.toFullString());     } catch (Exception e) {         Assert.fail(e.getMessage());     } finally {         registry.unregister(serviceUrl);         registry.destroy();     } }
public int getDistanceToClosestBlock() {     int distance = 9999;     BlockPos currentBlock = nextBlock;     for (int i = -range; i <= range; i++) {         for (int j = -range; j <= range; j++) {             for (int k = -range; k <= range; k++) {                 BlockPos blockPos = currentBlock.add(i, j, k);                 if (isCorrectBlock(i, j, k, 0) || isCorrectBlock(i, j, k, 1)) {                     int blockDistance = (int) mob.getDistanceSq(blockPos);                     if (blockDistance < distance) {                         distance = blockDistance;                     }                 }             }         }     }     return distance; }
public List<Playlist> getPlaylists() {     List<Playlist> playlists = new ArrayList<>();     try {         ResultSet rs = db.executeQuery("SELECT * FROM playlists");         while (rs.next()) {             int id = rs.getInt("id");             String name = rs.getString("name");             int size = rs.getInt("size");             Playlist playlist = new Playlist(id, name, size);             playlists.add(playlist);         }     } catch (SQLException e) {         logger.log(Level.SEVERE, "Failed to read playlists from database.", e);     }     return playlists; }
void rollback() {     // Flush all modified buffers     myBuffers.flushAll(txnum);     // Rollback all uncommitted transactions     while (recoveryMgr.uncommittedTransactions().contains(txnum)) {         LogRecord record = recoveryMgr.lastLogRecord(txnum);         if (record == null) {             break;         }         if (record.getType() == LogRecord.CHECKPOINT) {             break;         }         recoveryMgr.undo(record);     }     // Write a quiescent checkpoint record to the log     recoveryMgr.writeCheckpoint(myBuffers.getBuffers());     // Reset transaction state     myBuffers = new BufferList();     concurMgr.endTransaction(txnum); }
public void setPassword(String password) {     this.password = password; }
public String getSignatureUsername() {     return signatureUsername; }
/**  * Delete the ingredient by id.  *  * @param id the id of the ingredient to delete  */ public void deleteById(String id) {     ingredientRepository.deleteById(id); }
public void startLoadingAssets() {     if (textureRegions == null || textures == null || sounds == null || rpgMaps == null) {         throw new IllegalStateException("Assets to load have not been set");     }     createTextureAtlas();     loadTextures();     loadSounds();     loadMaps(); }
public int depth() {     if (children == null || children.length == 0) {         return 1;     }     int maxDepth = 0;     for (KDTree child : children) {         maxDepth = Math.max(maxDepth, child.depth());     }     return maxDepth + 1; }
public void createRangeMap() {     throw new UnsupportedOperationException("createRangeMap() is not supported"); }
public double[] getGammasV() {     return gammasV; }
public Properties getTestProperties() {     // Return the properties for the test     Properties props = new Properties();     props.setProperty("testName", "OverallTest");     props.setProperty("loggerName", "OverallTestLogger");     props.setProperty("engineName", "FuriaChanEngine");     return props; }
@Override protected void doStart() {     // Called when the service transitions from NEW to STARTING     // Perform necessary operations here     // ...     // Transition to STARTING state     notifyStarted(); }
public ToStringHelper add(Object value) {     ValueHolder valueHolder = addHolder();     valueHolder.value = value;     return this; }
null
public void checkGameOver() {     // Check if the snake has collided with a game element or hit the border     if (snake.collidesWith(gameElements) || snake.hitsBorder(border)) {         gui.showGameOverDialog();     } }
public Node extractMinNode() {     int size = allNodes.size() - 1;     Node minNode = new Node();     if (size >= 0) {         minNode.key = allNodes.get(0).key;         minNode.weight = allNodes.get(0).weight;         Node lastNode = allNodes.get(size);         nodePosition.remove(lastNode.key);         allNodes.set(0, lastNode);         allNodes.remove(size);         int currentIndex = 0;         size--;         while (true) {             int left = 2 * currentIndex + 1;             int right = 2 * currentIndex + 2;             if (left > size) {                 break;             }             if (right > size) {                 right = left;             }             int smallerIndex = allNodes.get(left).weight <= allNodes.get(right).weight ? left : right;             if (allNodes.get(currentIndex).weight > allNodes.get(smallerIndex).weight) {                 swap(allNodes.get(currentIndex), allNodes.get(smallerIndex));                 updatePositionMap(allNodes.get(currentIndex).key, allNodes.get(smallerIndex).key, currentIndex, smallerIndex);                 currentIndex = smallerIndex;             } else {                 break;             }         }     }     return minNode; }
@Test public void testGetFqdnHost() throws Exception {     InetSocketAddress address1 = new InetSocketAddress("localhost", 12345);     InetSocketAddress address2 = new InetSocketAddress("127.0.0.1", 54321);     WorkerNetAddress netAddress = new WorkerNetAddress("localhost", 8080, 12345);     assertEquals(NetworkAddressUtils.getFqdnHost(address1), "localhost");     assertEquals(NetworkAddressUtils.getFqdnHost(address2), "127.0.0.1");     assertEquals(NetworkAddressUtils.getFqdnHost(netAddress), "localhost"); }
public double populationCovariance() {     checkNonEmpty();     if (Double.isNaN(sumOfProductsOfDeltas)) {         double xMean = xStats.mean();         double yMean = yStats.mean();         int n = (int) count();         double c = sumOfProductsOfDeltas / n;         return ensureNonNegative(StatsTools.calculatePopulationCovariance(xStats.populationVariance(), yStats.populationVariance(), c));     }     return ensureNonNegative(sumOfProductsOfDeltas / count()); } private void checkNonEmpty() {     if (count() == 0) {         throw new IllegalStateException("PairedStats instance must not be empty.");     } } private double ensureNonNegative(double value) {     return Double.isNaN(value) || value < 0.0 ? 0.0 : value; }
public int[] getFrequencies(SortOrder sortBy) {     List<Map.Entry<String, Integer>> entries = new ArrayList<>(_wordFrequency.entrySet());     int[] frequencies = new int[_wordFrequency.size()];     int index = 0;     // Sort the entries based on the provided sort order     if (sortBy == SortOrder.ALPHABETICAL) {         entries.sort(SORT_ALPHABETICALLY);     } else {         entries.sort(SORT_BY_FREQUENCY);     }     // Populate the frequencies array with the sorted values     for (Map.Entry<String, Integer> entry : entries) {         frequencies[index++] = entry.getValue();     }     return frequencies; }
public ThreadFactoryBuilder setPriority(int priority) {     this.priority = priority;     return this; }
public String getContextURL(String servletPath) {     String protocol = "http";     String host = this.host != null ? this.host : "localhost";     int port = this.port != -1 ? this.port : server.getURI().getPort();     String contextPath = this.contextPath != null ? this.contextPath : "";     String url = String.format("%s://%s:%d%s%s", protocol, host, port, contextPath, servletPath);     return url; }
public void setAttributes(Attributes newAttributes) {     this.attributes = newAttributes; }
public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {     Object hint = args.length > 0 ? args[0] : null;     if (hint == null || hint == ScriptRuntime.ScriptableClass || hint == ScriptRuntime.FunctionClass) {         return this;     }     return obj.call(cx, scope, thisObj, args); }
public byte[] getByteArray() {     byte[] result = new byte[valueLen];     format.getByteArrayInternal(valueLen, result, 0, valueLen);     return result; }
public InputStream resolveAndOpenStream(String uri) {     String resolvedUri = uri;     try {         URI absoluteUri = new URI(uri);         if (!absoluteUri.isAbsolute()) {             String baseUrl = getBaseURL();             if (baseUrl != null) {                 URI baseUri = new URI(baseUrl);                 absoluteUri = baseUri.resolve(uri);                 resolvedUri = absoluteUri.toString();             }         }     } catch (URISyntaxException e) {         // handle exception     }     return _uriResolver.resolveAndOpenStream(resolvedUri); }
public String getSource() {     return this.source; }
public Document getCopyTransformation(String select) throws Exception {     XPathExpression expr = getXPathExpression(select);     NodeList nodes = (NodeList) expr.evaluate(document, XPathConstants.NODESET);     DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();     DocumentBuilder docBuilder = docFactory.newDocumentBuilder();     Document doc = docBuilder.newDocument();     Element root = doc.createElement("root");     doc.appendChild(root);     for (int i = 0; i < nodes.getLength(); i++) {         Node node = nodes.item(i);         Node importedNode = doc.importNode(node, true);         root.appendChild(importedNode);     }     return doc; }
public void writeGraphToFile(String filename, String dot_source, String type) {     File out = new File(TEMP_DIR, filename);     byte[] img = getGraph(dot_source, type);     try (OutputStream outStream = new FileOutputStream(out)) {         outStream.write(img);     } catch (IOException e) {         e.printStackTrace();     } }
public void testGetTrueCourse() {     vtg.setTrueCourse(50.0);     assertEquals(50.0, vtg.getTrueCourse(), 0.1);          vtg.setTrueCourse(360.0);     assertEquals(0.0, vtg.getTrueCourse(), 0.1);          vtg.setTrueCourse(390.0);     assertEquals(30.0, vtg.getTrueCourse(), 0.1); }
public int getScaledValue(int dimension) {     double scaled = Math.ceil((double) dimension / (double) num * denom);     return (int) scaled; }
public Scriptable getScope() {     return scope; }
public void setFiles(File dir) {     if (!dir.isDirectory()) {         setError(EN_UKNOWN, "File is not a directory");         return;     }     filesElement = document.createElement("files");     for (File file : dir.listFiles()) {         Element fileElement = document.createElement("file");         fileElement.setAttribute("name", file.getName());         fileElement.setAttribute("size", String.valueOf(file.length()));         fileElement.setAttribute("lastModified", String.valueOf(file.lastModified()));         filesElement.appendChild(fileElement);     } }
public HashMap<String, GeneticProfile> getDefaultMutationMap() {     HashMap<String, GeneticProfile> map = new HashMap<String, GeneticProfile>();     GeneticProfile defaultMutationProfile = getDefaultMutationProfile();     if (defaultMutationProfile != null) {         map.put(GISTIC, defaultMutationProfile);     }     return map; }
public String checkAndModifyPath(String path) {     // Check if the path is null or empty     if (path == null || path.isEmpty()) {         return null;     }          // Replace backslashes with forward slashes     path = path.replaceAll("\\\\", "/");          // Check if the path ends with a slash and remove it if it does     if (path.endsWith("/")) {         path = path.substring(0, path.length() - 1);     }          return path; }
public List<DishCollection> getAll() {     return dishCollectionRepository.findAll(); }
public GetPriceResponse createGetPriceResponse() {     return new GetPriceResponse(); }
public int getKeyIdentifierType() {     return keyIdentifierType; }
public long getDataUnitId() {     return dataUnitId; }
public void applyQTran(BlockMatrix64F B) {     int minDimension = Math.min(B.numCols, B.numRows);     // Compute Q^T B     for (int i = 0; i < minDimension; i += blockLength) {         A.col0 = i;         A.row1 = B.numRows;         A.col1 = Math.min(B.numCols, i + blockLength);         Y.col0 = i;         CommonOps_DDRM.fill(temp, 0);         temp[0] = 1;         W.set(dataW.reshape(1, A.col1 - A.col0));         QrHelperFunctions_DDRM.rank1UpdateMultR(A, gammas, W, WTA, temp);         QrHelperFunctions_DDRM.rank1UpdateMultR(A, gammas, W, WTA, temp);         QrHelperFunctions_DDRM.rank1UpdateMultR(A, gammas, W, WTA, temp);         QrHelperFunctions_DDRM.rank1UpdateMultR(A, gammas, W, WTA, temp);         QrHelperFunctions_DDRM.rank1UpdateMultR(A, gammas, W, WTA, temp);         QrHelperFunctions_DDRM.rank1UpdateMultR(A, gammas, W, WTA, temp);         QrHelperFunctions_DDRM.rank1UpdateMultR(A, gammas, W, WTA, temp);         QrHelperFunctions_DDRM.rank1UpdateMultR(A, gammas, W, WTA, temp);         QrHelperFunctions_DDRM.rank1UpdateMultR(A, gammas, W, WTA, temp);         QrHelperFunctions_DDRM.rank1UpdateMultR(A, gammas, W, WTA, temp);     }     // Compute B - Q^T B     for (int i = 0; i < minDimension; i += blockLength) {         A.col0 = i;         A.row1 = B.numRows;         A.col1 = Math.min(B.numCols, i + blockLength);         Y.col0 = i;         W.set(dataW.reshape(1, A.col1 - A.col0));         QrHelperFunctions_DDRM.rank1UpdateMultR(A, gammas, W, WTA, null);     } }
public void remove(lalr_item itm) {     _all.remove(itm);     hashcode_cache = null; }
public TreeNode findElement(TreeNode root, int key) {     if (root == null || root.val == key) {         return root;     }     if (key < root.val) {         return findElement(root.left, key);     }     return findElement(root.right, key); }
public double elementProductDiag(D1Matrix64F m) {     int N = Math.min(m.numRows(), m.numCols());     double product = 1.0;     for (int i = 0; i < N; i++) {         product *= m.get(i, i);     }     return product; }
public class WebFileConnect {     private String TAB = "\t";     private String NEW_LINE = "\n";     public String[][] retrieveMatrix(File file) {         String content = retrieveDocument(file);         return parseMatrix(content);     }     public String retrieveDocument(File file) {         StringBuilder stringBuilder = new StringBuilder();         try (BufferedReader br = new BufferedReader(new FileReader(file))) {             String line;             while ((line = br.readLine()) != null) {                 stringBuilder.append(line).append(NEW_LINE);             }         } catch (IOException e) {             e.printStackTrace();         }         return stringBuilder.toString();     }     public String[][] parseMatrix(String content) {         String[] rows = content.trim().split(NEW_LINE);         String[][] matrix = new String[rows.length][];         for (int i = 0; i < rows.length; i++) {             matrix[i] = rows[i].split(TAB);         }         return matrix;     }     public String[][] prepareMatrix(String content) {         return parseMatrix(content);     } }
@Nullable public static String emptyToNull(@Nullable String string) {     return (string == null || string.isEmpty()) ? null : string; }
public Expression targetField() {     return newval; }
public class BufferedByteWriter {     private ByteBuffer mWriter;     private byte[] mBuffer;          // other member functions and variables          public BufferedByteWriter put64(long value) {         ensureCapacity(8);         mWriter.put((byte) (value >> 56));         mWriter.put((byte) (value >> 48));         mWriter.put((byte) (value >> 40));         mWriter.put((byte) (value >> 32));         mWriter.put((byte) (value >> 24));         mWriter.put((byte) (value >> 16));         mWriter.put((byte) (value >> 8));         mWriter.put((byte) value);         return this;     }          // other member functions }
public String getContentType() {     return contentType; }
public boolean isParseLazyMode() {     return parseLazy; }
public void setValidateUseKey(boolean validateUseKey) {     signatureProperties.setValidateUseKey(validateUseKey); }
public void setDataSetId(Long dataSetId) {     this.dataSetId = dataSetId; }
/**  * Class for transforming coordinates between different systems.  */ public class CoordTransformer {     private float originLat;     private float dotsPerDeg;     private float originLon;     private float lonCorr;     private float unitsPerInch = 92f;     private float dotsPerInch = unitsPerInch;     /**      * Adjusts the transformation based on the provided bounding box, view width, and view height.      *      * @param bb         The bounding box      * @param viewWidth  The view width      * @param viewHeight The view height      */     public void adjustTransformation(BoundingBox bb, int viewWidth, int viewHeight) {         // Implementation logic goes here     }     /**      * Sets the screen resolution in dots per inch.      *      * @param dotsPerInch The dots per inch value to set      */     public void setScreenResolution(int dotsPerInch) {         // Implementation logic goes here     }     /**      * Returns the x-coordinate on the screen based on the given longitude value.      *      * @param lon The longitude value      * @return The x-coordinate on the screen      */     public int x(double lon) {         // Implementation logic goes here     }     /**      * Zooms the transformation by the given factor around the specified focus point.      *      * @param factor  The zoom factor      * @param focusX  The x-coordinate of the focus point      * @param focusY  The y-coordinate of the focus point      */     public void zoom(float factor, int focusX, int focusY) {         // Implementation logic goes here     }     /**      * Returns the latitude value based on the given y-coordinate on the screen.      *      * @param y The y-coordinate on the screen      * @return The latitude value      */     public float lat(int y) {         // Implementation logic goes here     }     /**      * Adjusts the transformation based on the given delta x and delta y values.      *      * @param dx The delta x value      * @param dy The delta y value      */     public void adjust(double dx, double dy) {         // Implementation logic goes here     }     /**      * Returns the y-coordinate on the screen based on the given latitude value.      *      * @param lat The latitude value      * @return The y-coordinate on the screen      */     public int y(double lat) {         // Implementation logic goes here     }     /**      * Returns the current dots per unit value.      *      * @return The current dots per unit value      */     public float getDotsPerUnit() {         // Implementation logic goes here     }     /**      * Returns the longitude value based on the given x-coordinate on the screen.      *      * @param x The x-coordinate on the screen      * @return The longitude value      */     public float lon(int x) {         // Implementation logic goes here     }     /**      * Computes the scale value based on the current transformation.      *      * @return The computed scale value      */     public float computeScale() {         // Implementation logic goes here     }     /**      * Returns the current dots per degree value.      *      * @return The current dots per degree value      */     public float dotsPerDeg() {         // Implementation logic goes here     } }
public boolean contains(Object o) {     if (o instanceof Type) {         Type type = (Type) o;         for (Type t : v) {             if (ts.isSubtype(type, t)) {                 return true;             }         }     }     return false; }
void onServiceUnregistration (ServiceID id) {     // Your code here }
public String getJobOwner() {     WorkflowJobBean workflow = getWorkflow();     return workflow.getUser(); }
public static ProjectBrowser getInstance() {     if (instance == null) {         instance = new ProjectBrowser();     }     return instance; }
public void setWordMultiplicity(O word, int multiplicity) {     DocumentElement<O> element = data.get(word);     if (element != null) {         element.setMultiplicity(multiplicity);     } }
public Image getSWTFSImage() {     if (_image == null || _image.isDisposed()) {         _image = new Image(_uac.getDevice(), _uac.getImageData(_uri));     }     return _image; }
/**  * Test method for {@link net.sf.marineapi.nmea.parser.RMCParser#getCourse()}.  */ void testGetCourse() {     // Create a new RMCParser instance and set the example data     RMCParser rmc = new RMCParser(EXAMPLE);     // Verify that the course value is correct     assertEquals(360.0, rmc.getCourse(), 0.1); }
public View getActionView() {     if (mMenuItem != null) {         return mMenuItem.getActionView();     }     return null; }
/**  * Test method for {@link net.sf.marineapi.nmea.parser.GSAParser#setHorizontalDOP(double)}.  */ public void testSetHorizontalDOP() {     GSATest gsaTest = new GSATest();     gsaTest.empty.setHorizontalDOP(1.2);     assertEquals(1.2, gsaTest.empty.getHorizontalDOP(), 0.0); }
public Character createCharacter() {     return new Character(sprite, actions, layer, height, x, width, y, id, triggerType, map, collidable); }
public class Checksum {     // member variables          // member function headers          public String calculate(String nmea) {         int checksum = 0;         for (int i = 0; i < nmea.length(); i++) {             checksum ^= nmea.charAt(i);         }         String hex = Integer.toHexString(checksum).toUpperCase();         if (hex.length() == 1) {             hex = "0" + hex;         }         return hex;     }          // implementation of other member functions }
void addToClosed(Node node) {     closed.add(node); }
/**  * Sleeps for the given number of milliseconds.  *  * @param millis the number of milliseconds to sleep  */ public void waitFor(long millis) {     try {         Thread.sleep(millis);     } catch (InterruptedException e) {         LOG.error("Error while waiting for {} milliseconds: {}", millis, e.getMessage());         Thread.currentThread().interrupt();     } }
/**  * Read a writable from a byte array.  *  * @param writable the writable object to read from the byte array  * @return the byte array representation of the writable object  * @throws IOException if an I/O error occurs  */ public static byte[] toByteArray(Writable writable) throws IOException {     ByteArrayOutputStream out = new ByteArrayOutputStream();     DataOutputStream dataOut = new DataOutputStream(out);     writable.write(dataOut);     dataOut.flush();     byte[] bytes = out.toByteArray();     dataOut.close();     out.close();     return bytes; }
public ConfigurationKey createConfigurationKey(String first, String second, String third) {     return new ConfigurationKey(first, second, third); }
public void disposeAndCleanImageCache() {     for (Iterator<Map.Entry<String, ImageResource>> it = _imageCache.entrySet().iterator(); it.hasNext(); ) {         Map.Entry<String, ImageResource> entry = it.next();         entry.getValue().dispose();         it.remove();     } }
@Test public void testDelete() throws IOException {     // Create a test file     String testFilePath = BUCKET_PREFIX + "/" + PATH;     OutputStream os = mOSSUnderFileSystem.create(testFilePath);     os.write(1);     os.close();     // Verify that the test file exists     assertTrue(mOSSUnderFileSystem.exists(testFilePath));     // Delete the test file     mOSSUnderFileSystem.delete(testFilePath, false);     // Verify that the test file no longer exists     assertFalse(mOSSUnderFileSystem.exists(testFilePath)); }
public Node parse(int kind, String fmt, Object... subst) {     List<?> substList = Arrays.asList(subst);     String formattedString = String.format(fmt, substList.toArray());     Position pos = new Position(FILE, 0, 0, 0);     Lexer lexer = lexer(formattedString, pos);     QQParser parser = parser(lexer, ext.typeSystem(), ext.nodeFactory(), ext.compiler().errorQueue());     Node result = null;     try {         switch (kind) {             case EXPR:                 result = parser.parseExpr();                 break;             case STMT:                 result = parser.parseStmt();                 break;             case TYPE:                 result = parser.parseType();                 break;             case MEMB:                 result = parser.parseClassMember();                 break;             case DECL:                 result = parser.parseClassDecl();                 break;             default:                 throw new RuntimeException("Unsupported kind " + kind);         }     } catch (PolyglotParseException e) {         e.printStackTrace();     }     return result; }
public int bucketOffset(ByteBuffer key, PayloadReader reader) {     int fingerprint = fingerprintHash(key);     int index = Math.abs(INDEX_HASHER.hashInt(fingerprint).asInt()) % mNumBuckets;     int offset = index * BUCKET_SIZE_BYTES;     mBuf.position(offset);     for (int i = 0; i < MAX_PROBES; i++) {         int bucketFingerprint = mBuf.getInt();         if (bucketFingerprint == 0) {             return offset;         }         if (bucketFingerprint == fingerprint && reader.equals(key, mBuf)) {             return offset;         }         offset = (offset + BUCKET_SIZE_BYTES) % mHashTableBuf.limit();         mBuf.position(offset);     }     return -1; }
public String getRelativeFullPath() {     return this.relativeFullPath; }
public boolean usesTypeResolution(Language language) {     for (RuleSet ruleSet : ruleSets) {         if (ruleSet.usesTypeResolution(language)) {             return true;         }     }     return false; }
public void setBuild(String build) {     this.build = build; }
public Bitmap rescale(Bitmap img) {     int maxWidth = 1024;     int maxHeight = 1024;     int imgWidth = img.getWidth();     int imgHeight = img.getHeight();     if (imgWidth <= maxWidth && imgHeight <= maxHeight) {         return img;     }     float aspectRatio = (float) imgWidth / (float) imgHeight;     int idealWidth = (int) (maxHeight * aspectRatio);     int idealHeight = (int) (maxWidth / aspectRatio);     if (imgWidth > imgHeight) {         return Bitmap.createScaledBitmap(img, idealWidth, maxHeight, true);     } else {         return Bitmap.createScaledBitmap(img, maxWidth, idealHeight, true);     } }
public List<JWSAlgorithm> getAsJwsAlgorithmList(JsonObject o, String member) {     JsonArray array = o.getAsJsonArray(member);     if (array == null) {         return null;     }     List<JWSAlgorithm> algorithms = new ArrayList<>();     for (JsonElement element : array) {         JWSAlgorithm algorithm = JWSAlgorithm.parse(element.getAsString());         if (algorithm != null) {             algorithms.add(algorithm);         }     }     return algorithms; }
public byte[] toSeed(List<String> words) {     String joinedWords = String.join(" ", words);     byte[] salt = BIP39_ENGLISH_SHA256.getBytes(StandardCharsets.UTF_8);     byte[] mnemonic = joinedWords.getBytes(StandardCharsets.UTF_8);     byte[] seed = null;     try {         SecretKeyFactory f = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA512");         KeySpec ks = new PBEKeySpec(new String(mnemonic, StandardCharsets.UTF_8).toCharArray(), salt, PBKDF2_ROUNDS, 512);         seed = f.generateSecret(ks).getEncoded();     } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {         // Handle the exception     }     return seed; }
public void setTestData(String value) {     this.testData = value; }
public void connectToCandidate(IceCandidate candidate) {     if (candidate.getType() != CandidateType.RELAY) {         throw new IllegalArgumentException("Candidate must be of type RELAY");     }     if (m_turnClient != null && m_turnClient.isConnected()) {         m_turnClient.close();     }     try {         m_turnClient = new TcpTurnClient(candidate.getAddress(), candidate.getPort(), m_controlling, m_offerAnswerListener);         m_turnClient.connect();     } catch (IOException e) {         m_log.error("Failed to connect to TURN server at " + candidate.getAddress() + ":" + candidate.getPort(), e);     } }
null
@Test public void testSetVelocity() {     double expectedVelocity = 10.5;     rmb.setVelocity(expectedVelocity);     assertEquals(expectedVelocity, rmb.getVelocity(), 0.01); }
public void implementLater() {   // Implementation will be added later }
@Test public void getCapacityBytesOnTiers() {     long[] capacityBytesOnTiers = mBlockStoreMeta.getCapacityBytesOnTiers();     long[] expectedCapacityBytesOnTiers = new long[mBlockStoreMeta.getNumTiers()];     // Set expected capacity bytes for each tier based on block size and committed block count     for (int i = 0; i < expectedCapacityBytesOnTiers.length; i++) {         expectedCapacityBytesOnTiers[i] = COMMITTED_BLOCKS_NUM * TEST_BLOCK_SIZE * mBlockStoreMeta.getTierCapacityRatio(i);     }     // Assert that capacity bytes on tiers are equal to the expected values     assertArrayEquals(expectedCapacityBytesOnTiers, capacityBytesOnTiers); }
public String getExitSignal() {   String exitSignal = null;   try {     cn.waitFor(ClientChannelEvent.CLOSED, 0);     exitSignal = cn.getExitSignal();   } catch (IOException e) {     // Handle exception   }   return exitSignal; }
public Proxy createProxy(HTTPClientPolicy policy, URI currentUrl) {     Proxy proxy = null;     String proxyHost = policy.getProxyServer();     int proxyPort = policy.getProxyServerPort();     if (proxyHost != null && proxyPort > 0) {         // Check if the current URL should bypass the proxy         String nonProxyHosts = System.getProperty(HTTP_NON_PROXY_HOSTS);         if (nonProxyHosts != null) {             String[] nonProxyHostList = nonProxyHosts.split("\\|");             for (String nonProxyHost : nonProxyHostList) {                 if (nonProxyHost.trim().isEmpty()) {                     continue;                 }                 if (currentUrl.getHost().matches(nonProxyHost.trim().replace(".", "\\.").replace("*", ".*"))) {                     // The current URL should bypass the proxy                     return Proxy.NO_PROXY;                 }             }         }         // Create the proxy using the specified host and port         proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));     }     return proxy; }
public void partialDeserialize(TBase tb, byte[] bytes, TFieldIdEnum fieldIdPathFirst, TFieldIdEnum... fieldIdPathRest) throws TException {     try {         // Set up the input transport and protocol         trans_.reset(bytes);         protocol_.reset(trans_);                  // Locate the field to deserialize         TField field = locateField(bytes, fieldIdPathFirst, fieldIdPathRest);         if (field == null) {             return;         }                  // Deserialize the field into the Thrift object         tb.read(protocol_);     } catch (TException e) {         throw e;     } catch (Exception e) {         throw new TException(e);     } }
void e(String tag, String msg) {     if (sIsLogEnabled) {         Log.e(getContents(getCurrentStackTraceElement()), String.format(TAG_CONTENT_PRINT, sApplicationTag, tag, msg, Thread.currentThread().getId()));     } }
public String getSignatureAlias() {     return signatureAlias; }
@Test(expected = IllegalArgumentException.class) public void testHandleEventThrowsIllegalArgumentExceptionOnEmptyTitle() {     // Arrange     String emptyTitle = "";     Event event = mock(Event.class);     when(event.getProperty(Notification.NOTIFICATION_KEY_TITLE)).thenReturn(emptyTitle);     // Act     notificationController.handleEvent(event); }
public static String formatKeyStroke(KeyStroke keyStroke) {     int modifiers = keyStroke.getModifiers();     int keyCode = keyStroke.getKeyCode();     String modifiersText = getModifiersText(modifiers);     String keyText = getKeyText(keyCode);     return modifiersText.isEmpty() ? keyText : modifiersText + MODIFIER_JOINER + keyText; }
public void setCharset(String charset) {     this.charset = charset;     if (headers != null) {         headers.put(CONTENT_TYPE, DEFAULT_CONTENT_TYPE + "; charset=" + charset);     } }
public RegisteredClient parseRegistered(String jsonString) {     JsonElement jsonEl = parser.parse(jsonString);     return parseRegistered(jsonEl); }
public Builder portId(String portId) {     return toBuilder().portId(portId); }
public void testIsActiveRoute() {     // create RTEParser instance and parse example sentence     RTEParser parser = new RTEParser();     parser.parse(EXAMPLE);     // set RTE sentence to RTETest's RTE sentence     rte = parser.getSentence();     // create new RTETest with empty RTE sentence     empty = new RTESentence(0);     // assert that empty RTE sentence is not active     assertFalse(empty.isActiveRoute());     // assert that RTE sentence is active     assertTrue(rte.isActiveRoute()); }
public void updateActions() {     if (evaluateConditions()) {         for (Action action : actions) {             action.updateState();         }     } }
@Override public int hashCode() {     final int prime = 31;     int result = 1;     result = prime * result + id;     result = prime * result + ((description == null) ? 0 : description.hashCode());     result = prime * result + ((testNodeDetail == null) ? 0 : testNodeDetail.hashCode());     result = prime * result + ((controlNodeDetail == null) ? 0 : controlNodeDetail.hashCode());     result = prime * result + (recoverable ? 1231 : 1237);     return result; }
public HexDigest getHexDigest() {     byte[] digestBytes = digestInstance.digest();     if (isDigest256) {         return new HexDigest(digestBytes, TOR_DIGEST256_SIZE);     } else {         return new HexDigest(digestBytes, TOR_DIGEST_SIZE);     } }
public Proctor determineTestBuckets(final String clientId) {     final TestMatrixArtifact matrix = getArtifact();     final ProctorLoadResult loadResult = getLoadResult();     final FunctionMapper functionMapper = new FunctionMapper(loadResult.getFunctions());     final Map<String, ConsumableTestDefinition> testDefs = Maps.newLinkedHashMap(testDefinitions);     final Map<String, TestBucket> testBuckets = Maps.newHashMap();     for (final String testName : matrix.getTests().keySet()) {         final TestChooser<?> testChooser = testChoosers.get(testName);         if (testChooser == null) {             throw new IllegalStateException("Test " + testName + " not found in TestChoosers");         }         final String testDefinitionName = matrix.getTests().get(testName).getTestDefinition();         final ConsumableTestDefinition testDefinition = testDefs.get(testDefinitionName);         if (testDefinition == null) {             throw new IllegalStateException("Test definition " + testDefinitionName + " not found in matrix or loaded definitions");         }         final String bucketName = testChooser.chooseBucket(functionMapper, clientId, testDefinition.getSalt());         final TestBucket bucket = testDefinition.getBuckets().get(bucketName);         if (bucket == null) {             throw new IllegalStateException("Bucket " + bucketName + " not found in test definition " + testDefinitionName);         }         testBuckets.put(testName, bucket);     }     return new Proctor(new TestMatrix(matrix.getVersion(), testBuckets), loadResult); }
public static Date parseIsoDate(String string) throws ParseException {     SimpleDateFormat isoFormat = new SimpleDateFormat(FORMAT_ISO);     isoFormat.setTimeZone(TIMEZONE);     return isoFormat.parse(string); }
public boolean isKO() {     return errorLevel > errorLevelFolder; }
public void testGetTimeToCPA() {     ttm.set(11, 25.3, 13.7, "T", 7.0, 20.0, "T", 10.1, 20.2, "N", "NAME", "", 175550.24, true);     assertEquals(0.0, ttm.getTimeToCPA(), 0.01);     ttm.set(11, 25.3, 13.7, "T", 7.0, 20.0, "T", 10.1, 20.2, "N", "NAME", "", 175550.24, false);     assertEquals(Double.NaN, ttm.getTimeToCPA(), 0.01); }
public static void copyChannels(FileChannel source, FileChannel destination, int bufferSize) throws IOException {     ByteBuffer buffer = ByteBuffer.allocate(bufferSize);     while (source.read(buffer) != -1) {         buffer.flip();         while (buffer.hasRemaining()) {             destination.write(buffer);         }         buffer.clear();     } }
public String getAttributeValue(Object e, String attribute) {     if (e instanceof Element) {         Element element = (Element) e;         return element.getAttribute(attribute);     }     return null; }
public void setAlbum(String album) {     this.album = album; }
public FiltersType getCipherSuitesFilter() {     return cipherSuiteFilters; }
public static MemoryLogger getInstance() {     return instance; }
public void testSetMagneticCourse() {     double course = 123.45;     vtg.setMagneticCourse(course);     assertEquals(course, vtg.getMagneticCourse(), 0.01); }
/**  * It might seem odd to return 'true' if a property == FALSE, but it is required sometimes.  */ public boolean isTrue(Map<String, Object> props, String key) {     Object value = props.get(key);     if (value instanceof Boolean) {         return (Boolean) value;     } else if (value instanceof String) {         return Boolean.parseBoolean((String) value);     } else {         return false;     } } /**  * It might seem odd to return 'true' if a property == FALSE, but it is required sometimes.  */ public boolean isTrue(Object property) {     if (property instanceof Boolean) {         return (Boolean) property;     } else if (property instanceof String) {         return Boolean.parseBoolean((String) property);     } else {         return false;     } }
public void setUp() {     // Initialize test class     graphName = "testGraph";     user = "xinyu";     ep.setHost("localhost");     ep.setProtocol("http");     ep.setPort(8080); }
@Override public String toString() {     return val; }
public void setValue(String value) {     PROPS.setProperty(KEY, value);     if (_alwaysSave) {         save();     } }
public String getId(Fig f) {     if (f.getEnclosingFig() != null) {         return getId(f.getEnclosingFig());     } else {         return f.getId();     } }
public static Sha256Hash hashFileContents(File file) throws IOException {     byte[] contents = Files.readAllBytes(file.toPath());     return create(contents); }
public boolean isMySqlDriver(Connection conn) {     try {         String driverName = conn.getMetaData().getDriverName();         return driverName.contains("MySQL");     } catch (SQLException e) {         // handle exception         return false;     } }
public interface UUIDServiceInterface {     String generateId(ApplicationType type);     String generateChildId(String id, String childName);     String getChildName(String childId);     String getId(String childId); }      public UUIDServiceInterface getPublicInterface() {     return new UUIDServiceInterface() {         @Override         public String generateId(ApplicationType type) {             return UUIDService.this.generateId(type);         }                      @Override         public String generateChildId(String id, String childName) {             return UUIDService.this.generateChildId(id, childName);         }                      @Override         public String getChildName(String childId) {             return UUIDService.this.getChildName(childId);         }                      @Override         public String getId(String childId) {             return UUIDService.this.getId(childId);         }     }; }
public void ProxyConnect() {     // Set the system properties to use the direct connection     System.setProperty("http.proxyHost", "");     System.setProperty("http.proxyPort", "");     // Open a connection to the specified URI     try {         urlConn = new URL(URI).openConnection();     } catch (IOException e) {         // Handle the exception     } }
public Date parseUTC(String date, DateTimeFormat format) throws ParseException {     SimpleDateFormat sdf = new SimpleDateFormat(format.getPattern());     sdf.setTimeZone(TimeZone.getTimeZone("UTC"));     return sdf.parse(date); }
public void setName(String name) {     this.name = name; }
@Test public void writeByte() throws Exception {     mStream.write('a');     mStream.flush();     byte[] data = new byte[1];     try (InputStream inputStream = openInputStream()) {         IOUtils.readFully(inputStream, data);     }     assertEquals('a', data[0]); }
@Test public void testCreateParser() {     String sentence = "$GPGGA,082751.000,2447.1881,N,12100.4265,E,1,10,0.8,15.4,M,14.4,M,,*6B";     Parser p = instance.createParser(sentence);     assertNotNull(p);     assertTrue(p instanceof GPGGAParser);     GPGGAParser gga = (GPGGAParser) p;     assertEquals(82751.0, gga.getTime().getSecondsSinceMidnight(), 0.1);     assertEquals(24.786468333333333, gga.getPosition().getLatitude(), 0.0001);     assertEquals(121.00710833333333, gga.getPosition().getLongitude(), 0.0001);     assertEquals(10, gga.getSatelliteCount());     assertEquals(0.8, gga.getHDOP(), 0.001);     assertEquals(15.4, gga.getAltitude(), 0.001); }
public void addListener(StateListener listener) {     listeners.add(listener); }
public void removeProject() {     Project oldProject = currentProject;     currentProject = null;     setSaveEnabled(false);     firePropertyChanged(CURRENT_PROJECT_PROPERTY_NAME, oldProject, currentProject); }
public boolean isConnectionReset() {     return content.contains("Read timed out") && content.contains("Connection reset"); }
public ReplacedElement lookupImageReplacedElement(Element e, String uri) {     ReplacedElement replacedElement = lookupImageReplacedElement(e, uri, width, height);     if (replacedElement == null) {         Element elem = imageComponents.get(uri);         if (elem != null) {             replacedElement = replaceImage(imageResourceLoader, new LayoutContext(), elem, width, height);             if (replacedElement != null) {                 lookup.put(new LookupKey(e, uri, width, height), replacedElement);             }         }     }     return replacedElement; }
public void setErrorMsg(String errorMsg) {     this.errorMsg = errorMsg; }
public String getFederationToken(FederationToken type) {     switch (type) {         case FEDERATION_TOKEN:             return settings.getString(Keys.federation.token, "");         case REGISTRATION_TOKEN:             return settings.getString(Keys.federation.registration.token, "");         default:             logger.error("Invalid federation token type: " + type);             return "";     } }
/**  * Saves a contact to the database.  *  * @param user the user to save  */ public void saveContact(User user) {     SQLiteDatabase db = dbHelper.getWritableDatabase();     ContentValues values = new ContentValues();     values.put(COLUMN_NAME_ID, user.getUsername());     values.put(COLUMN_NAME_NICK, user.getNick());     values.put(COLUMN_NAME_AVATAR, user.getAvatar());     db.insert(TABLE_NAME, null, values);     db.close(); }
public int getP2SHHeader() {     return acceptableAddressCodes[ScriptType.P2SH.ordinal()]; }
public int getY(int index) {     return steps.get(index).getY(); }
public List<String> getDefaultSchemePriority() {     return DEFAULT_SCHEME_PRIORITY; }
public void destroy() {     if (log != null) {         log.destroy();         log = null;     } }
public void start() {     return; }
public CSSName getCSSName() {     return cssName; }
public void setExchangeProperties(Exchange exchange, Message m) {     for (Endpoint endpoint : endpoints) {         Binding binding = endpoint.getBinding();         if (binding != null) {             binding.setExchangeProperties(exchange, m);         }     } }
public Filters getFilters() {     return filters; }
public NodeList getMatchingNodes(String select, Document document) throws XPathExpressionException {     XPathFactory xpathFactory = XPathFactory.newInstance();     XPath xpath = xpathFactory.newXPath();     xpath.setNamespaceContext(engine);     XPathExpression expr = xpath.compile(select);     return (NodeList) expr.evaluate(document, XPathConstants.NODESET); }
public void clear() {     links.clear();     locationPositions.clear(); }
public static ChangeableKind forName(String name) throws IllegalArgumentException {     if (name == null) {         throw new IllegalArgumentException("Name cannot be null");     }     for (ChangeableKindEnum ck : values()) {         if (ck.name().equalsIgnoreCase(name)) {             return ck;         }     }     throw new IllegalArgumentException("No enum constant " + ChangeableKindEnum.class.getSimpleName() + "." + name); }
public void addDifferenceGroup(String identifier, DifferenceGroup group) {     differenceGroups.put(identifier, group); }
public JSONWriter arrayBegin() throws JSONException {     beforeValue();     mStack.push(new State(ARRAY));     mWriter.write('[');     return this; }
public void testGetHorizontalDOP() {     GSASentence gsa = new GSASentence(EXAMPLE);     double expected = 1.6;     double actual = gsa.getHorizontalDOP();     assertEquals(expected, actual, 0.0); }
public void checkNoDuplicateKeys(ResourceBundle bundle) {     Set<String> keys = new HashSet<>();     Enumeration<String> bundleKeys = bundle.getKeys();     while (bundleKeys.hasMoreElements()) {         String key = bundleKeys.nextElement();         if (keys.contains(key)) {             throw new IllegalStateException("Duplicate key: " + key);         }         keys.add(key);     } }
public String getAppLogPath() {     String logPath = this.logPath;     if (logPath.isEmpty()) {         logPath = this.appPath + File.separator + "logs" + File.separator + "JaMuz.log";     }     return logPath; }
public int decode(String data, OutputStream out) throws IOException {     int length = data.length();     int outCount = 0;     int nibble = -1;     for (int i = 0; i < length; i++) {         char c = data.charAt(i);         if (Character.isWhitespace(c)) {             continue;         }         int value;         if (c >= '0' && c <= '9') {             value = c - '0';         } else if (c >= 'A' && c <= 'F') {             value = c - 'A' + 10;         } else if (c >= 'a' && c <= 'f') {             value = c - 'a' + 10;         } else {             throw new IllegalArgumentException("Invalid hexadecimal character: " + c);         }         if (nibble == -1) {             nibble = value;         } else {             out.write((nibble << 4) | value);             outCount++;             nibble = -1;         }     }     if (nibble != -1) {         throw new IllegalArgumentException("Invalid hexadecimal encoding: odd number of characters");     }     return outCount; }
public boolean isTrue(Object property) {     if (property == null) {         return false;     }     if (property instanceof Boolean) {         return (Boolean) property;     }     String stringValue = property.toString();     if (stringValue.equalsIgnoreCase("false")) {         return false;     }     return !Boolean.FALSE.toString().equalsIgnoreCase(stringValue); }
public int size() {     return _all.size(); }
public void flushEvents() {     if (dataStore != null) {         dataStore.flushEvents();     } }
public Thread obtainThread() {     if (waiter != null) {         return waiter;     } else {         return null;     } }
public void unsafeManageInputStream(InputStream is) {     if (is != null) {         try {             is.close();         } catch (IOException e) {             e.printStackTrace();         }     } }
/**  * Tests the constructor with a negative offset.  */ public void assertInvalid(RPCFileWriteRequest req) {     long negativeOffset = -1 * OFFSET;     RPCFileWriteRequestTest test = new RPCFileWriteRequestTest();     test.mBuffer = Unpooled.buffer();     test.mBuffer.writeLong(TEMP_UFS_FILE_ID);     test.mBuffer.writeLong(negativeOffset);     test.mBuffer.writeLong(LENGTH);     try {         req.decode(test.mBuffer);         fail("Expected exception to be thrown");     } catch (Exception e) {         assertThat(e).isInstanceOf(IllegalArgumentException.class)             .hasMessageContaining("offset must be non-negative");     } }
public class AggregationKindEnum {     private static final AggregationKindEnum AK_NONE = new AggregationKindEnum("ak_none");     private static final AggregationKindEnum AK_COMPOSITE = new AggregationKindEnum("ak_composite");     private static final AggregationKindEnum AK_AGGREGATE = new AggregationKindEnum("ak_aggregate");     private String typeName;     private String literalName;     // Constructor     public AggregationKindEnum(String literalName) {         this.literalName = literalName;     }     // Member function: readResolve()     public Object readResolve() {         // Add implementation here         // Returns fully qualified name of the enumeration type.         // ...     }     // Member function: forName()     public static AggregationKindEnum forName(String name) {         // Add implementation here         // Returns fully qualified name of the enumeration type.         // ...     }     // Member function: hashCode()     public int hashCode() {         // Add implementation here         // Returns fully qualified name of the enumeration type.         // ...     }     // Member function: equals()     public boolean equals(Object o) {         // Add implementation here         // Returns fully qualified name of the enumeration type.         // ...     }     // Member function: toString()     public String toString() {         // Add implementation here         // Returns fully qualified name of the enumeration type.         // ...     } }
public class BoxRenderer {     // member variables     int width, height;     LayoutContext layoutContext;     int NO_HEIGHT = -1;     int DEFAULT_HEIGHT = 1000;     int DEFAULT_DOTS_PER_POINT = 1;     Java2DOutputDevice outputDevice;     Document doc;     boolean rendered;     Box root;     float dotsPerPoint;     String sourceDocumentBase, sourceDocument;     SharedContext sharedContext;     int DEFAULT_DOTS_PER_PIXEL = 1;     Map renderingHints;          // member function implementation for natural language description     public BufferedImage getBufferedImage(int width, int height) {         ColorModel colorModel = new DirectColorModel(32, 0xff0000, 0xff00, 0xff);         WritableRaster raster = colorModel.createCompatibleWritableRaster(width, height);         BufferedImage image = new BufferedImage(colorModel, raster, false, null);         Graphics2D graphics = image.createGraphics();         graphics.setBackground(java.awt.Color.WHITE);         graphics.clearRect(0, 0, width, height);         graphics.dispose();         return image;     }     // other member functions     // ... }
public File createTempDirectory() throws IOException {     File tempDir = Files.createTempDirectory("tempDir").toFile();     LOG.info("Temporary directory created at " + tempDir.getAbsolutePath());     return tempDir; }
public void setFetcherStartTimeStamp(Date fetcherStartTimeStamp) {     this.fetcherStartTimeStamp = fetcherStartTimeStamp; }
public float getNaiveScoreMSet() {     if (mSetFragmentsCount == 0) {         return 0;     }     return (float) mSetFoundFragments / mSetFragmentsCount; }
public int getYPosition() {     return yPosition; }
public void setId(String id) {     this.id = id; }
public boolean containsKey(T key) {     return nodePosition.containsKey(key); }
public static String extractSentByHostFromViaHeader(final String viaHeaderValue) {     String sentByHost = "";     try {         ViaHeader viaHeader = (ViaHeader) SipMessageFactory.getInstance().createHeader(viaHeaderValue);         sentByHost = viaHeader.getSentBy().getHost();     } catch (ParseException e) {         LOG.warn("Failed to parse Via header value: {}", viaHeaderValue, e);     }     return sentByHost; }
public String getElem2() {     return this.elem2; }
@Test public void testSetTime() {     // create a new GLLParser instance     GLLParser parser = new GLLParser();          // create a new Time instance with the specified values     Time time = new Time(12, 1, 45.0);          // set the time property of the parser instance     parser.setTime(time);          // get the time property of the parser instance and assert that it's equal to the expected value     assertEquals(time, parser.getTime()); }
public static UInt getChecksum(final ByteBuffer bb) {     int checksum = 0;     while (bb.hasRemaining()) {         checksum += (bb.get() & 0xff) << 8;         checksum += bb.get() & 0xff;     }     return UInt.valueOf(~checksum & 0xffff); }
public List<Vertice> obterVerticesOrdenados(Grafo grafo) {     List<Vertice> verticesOrdenados = new ArrayList<>(grafo.getVertices());     verticesOrdenados.sort(Comparator.comparing(Vertice::getRotulo));     return verticesOrdenados; }
public void setEquippedItem(ItemStack item) {     mob.setHeldItem(Hand.MAIN_HAND, item); }
public void setLoadMetadataType(LoadMetadataType loadMetadataType) {     this.mLoadMetadataType = loadMetadataType; }
public AbstractPlugin getByName(String pluginName) {     for (AbstractPlugin plugin : plugins) {         if (plugin.getName().equals(pluginName)) {             return plugin;         }     }     return null; }
public boolean run() {     if (inclusive_time == 0) {         inclusive_time = System.nanoTime();         exclusive_time = inclusive_time;         return true;     } else {         inclusive_time = 0;         exclusive_time = 0;         return false;     } }
public void getBlockMeta() throws Exception {     mThrown.expect(BlockDoesNotExistException.class);     mThrown.expectMessage("Failed to get metadata");     mMetaManagerView.getBlockMeta(TEST_BLOCK_ID); }
public Permission applyUMask(Mode umask) {     Mode mode = mMode.applyFileUMask(umask);     return new Permission(mOwner, mGroup, mode); }
private String percentEncodeValue(String value) {     try {         String encoded = URLEncoder.encode(value, UTF8_CHARSET);         encoded = encoded.replace("+", "%20")                          .replace("*", "%2A")                          .replace("%7E", "~");         return encoded;     } catch (UnsupportedEncodingException ex) {         throw new RuntimeException("UTF-8 encoding not supported", ex);     } }
public void createFileAndDirs(String filePath) throws IOException {     Path path = Paths.get(filePath);     if (!Files.exists(path)) {         Files.createDirectories(path.getParent());         Files.createFile(path);     } }
public void testGetMonth() {     assertEquals(7, rmc.getMonth());     assertEquals(0, empty.getMonth()); }
public void setDocument(Document document) {     this.doc = document; }
public USAddress getBillTo() {     return this.billTo; }
@Test public void testCloseError() throws Exception {     // Set up mocks     when(mHttpConMock.getOutputStream()).thenThrow(new IOException());     // Create SwiftOutputStream     SwiftOutputStream sos = new SwiftOutputStream(mHttpConMock);     // Verify that IOException is thrown when closing the stream     mThrown.expect(IOException.class);     sos.close(); }
public byte[] getSecret() {     return secret; }
public symbol onSymbol() {     return _on_symbol; }
null
@Override public boolean equals(Object obj) {     if (this == obj) {         return true;     }     if (!(obj instanceof Decision)) {         return false;     }     Decision other = (Decision) obj;     return Objects.equals(name, other.name); }
public static AddressingProperties retrieveAddressingProperties(Message message) {     if (message == null) {         return null;     }     AddressingProperties maps = (AddressingProperties) message.get("javax.xml.ws.addressing.context.inbound");     if (maps == null) {         maps = new AddressingProperties();         message.put("javax.xml.ws.addressing.context.inbound", maps);     }     return maps; }
public GetOfferDetailsResponse.Return.DetailOfferData.Products createGetOfferDetailsResponseReturnDetailOfferDataProducts() {     return new GetOfferDetailsResponse.Return.DetailOfferData.Products.Product(); }
@Test(expected = NullPointerException.class) public void testDeregisterUserSessionWithNullServerSessionThrowsException() {     acitivityController.deregisterUserSession(null, mockServerMessage); }
public void settle() {     if (channelClient != null) {         channelClient.connectionClosed();     }     state = PaymentChannelClientState.CLOSED;     wireParser.close(); }
@Override public Set<String> getGrantedAuthorities(Authentication authentication) {     throw new UnsupportedOperationException("This method is not supported"); }
public static void main(String[] args) {     double screenWidth = 0.0;     double screenSize = 0.0;     for (String arg : args) {         if (arg.startsWith("-screenwidth=")) {             screenWidth = Double.parseDouble(arg.substring("-screenwidth=".length()));         } else if (arg.startsWith("-screensize=")) {             screenSize = Double.parseDouble(arg.substring("-screensize=".length()));         }     }     if (screenWidth > 0.0) {         int screenWidthInPixels = (int) (screenWidth * Toolkit.getDefaultToolkit().getScreenResolution());         System.setProperty("osmv.screenWidth", Integer.toString(screenWidthInPixels));     }     if (screenSize > 0.0) {         int screenSizeInPixels = (int) (screenSize * Toolkit.getDefaultToolkit().getScreenResolution() / Math.sqrt(2.0));         System.setProperty("osmv.screenSize", Integer.toString(screenSizeInPixels));     }     OsmViewerPlusApp app = new OsmViewerPlusApp();     app.showFrame(); }
public void testGetSpeed() {     try {         double expectedSpeed = 7.0;         TTMParser ttm = new TTMParser(EXAMPLE);         ttm.setSpeed(expectedSpeed);         double actualSpeed = ttm.getSpeed();         assertEquals(expectedSpeed, actualSpeed, 0.01);     } catch (Exception e) {         fail("Unexpected exception: " + e.getMessage());     } }
public void testGetCapabilities() {     Capability cap1 = new Capability("Cap1");     Capability cap2 = new Capability("Cap2");     dev.addCapability(cap1);     dev.addCapability(cap2);     Set<Capability> expectedCapabilities = new HashSet<>(Arrays.asList(cap1, cap2));     Set<Capability> actualCapabilities = dev.getCapabilities();     assertEquals(expectedCapabilities, actualCapabilities); }
public static Position last(Position pos1, Position pos2) {     if (!isComparable(pos1, pos2)) {         return null;     }     if (pos1.endOffset() > pos2.endOffset()) {         return pos1;     } else {         return pos2;     } }
public void setTransformedTokenIdentifier(String transformedTokenIdentifier) {     this.transformedTokenIdentifier = transformedTokenIdentifier; }
public List<VertexLabelType> getVertexLabels() {     List<VertexLabelType> labels = new ArrayList<>();     for(VertexLabelType v : vertexLabels) {         if(isVertexLabel(v)) {             labels.add(v);         }     }     return labels; }
public void testIsActiveRoute() {     RTEParser parser = new RTEParser();     boolean isActive = parser.isActiveRoute();     assertTrue(isActive); }
public float getLatDistKM() {     float latDist = Math.abs(latMax - latMin);     float latDistKM = latDist * 111.12f; // 1 degree of latitude is approximately 111.12 km     return latDistKM; }
/**  * Sets the deviation of the compass heading in degrees.  *  * @param deviation the deviation to set  */ public void setDeviation(double deviation) {     hdg.setDeviation(deviation); }
public boolean isConnected() {     return mConnected; }
public static Calendar getCalendarInstanceForUTC(Date date) {     Calendar cal = Calendar.getInstance(getTimeZone("UTC"));     cal.setTime(date);     return cal; }
public void getLengthTest() {     mBuffer = Unpooled.buffer(LENGTH);     DataNettyBuffer buffer = new DataNettyBuffer(mBuffer);     assertEquals(LENGTH, buffer.getLength()); }
public void setTestId(String testId) {     this.testId = testId; }
void testGetDeviation() {     // create a new HDGParser instance with EXAMPLE sentence     HDGParser parser = new HDGParser(EXAMPLE);          // set deviation value and test if getDeviation() returns the same value     double deviation = 1.2;     parser.setDeviation(deviation);     assertEquals(deviation, parser.getDeviation(), 0.001); }
// import necessary classes and packages public void testGetNumberRequests() {     LogEntryInterval instance = new LogEntryInterval();     int expResult = 0;     int result = instance.getNumberRequests();     assertEquals(expResult, result); }
public static void reverseCharArray(char[] arr) {     if (arr == null || arr.length == 0) {         return;     }          int left = 0;     int right = arr.length - 1;          while (left < right) {         char temp = arr[left];         arr[left] = arr[right];         arr[right] = temp;                  left++;         right--;     } }
public void andOperation() {     Mode.Bits bits1 = Mode.Bits.A;     Mode.Bits bits2 = Mode.Bits.C;     Mode.Bits result = bits1.and(bits2);     assertEquals(Mode.Bits.C, result); }
/**  * Start an activity. This method is defined to allow different methods of activity starting  * for newer versions of Android and for compatibility library.  *  * @param intent Intent to start.  * @param code Request code for the activity  * @param options Additional options for the activity (optional, may be null).  */ public void startActivityForResult(Intent intent, int code, Bundle options) {     if (activity != null) {         activity.startActivityForResult(intent, code, options);     } else if (fragment != null) {         fragment.startActivityForResult(intent, code, options);     } else if (supportFragment != null) {         supportFragment.startActivityForResult(intent, code, options);     } }
public double computeCost(DenseMatrix64F param, DenseMatrix64F x, DenseMatrix64F y) {     int N = x.numRows;     double cost = 0.0;     for (int i = 0; i < N; i++) {         double fx = func.compute(param, x.data, i);         double diff = fx - y.get(i, 0);         cost += diff * diff;     }     return cost / N; }
public DAVResource getResource(URI uri) throws IOException {     if (!uri.isAbsolute()) {         uri = base.resolve(uri);     }     String path = uri.getPath();     if (!path.startsWith(root.getPath())) {         throw new IOException("Invalid path: " + path);     }     path = path.substring(root.getPath().length());     if (path.isEmpty() || !ACCEPTABLE.contains(path.substring(0, 1))) {         throw new IOException("Invalid path: " + path);     }     File file = new File(root, path);     return factory.createResource(file.toURI(), this); }
public void logMessage(String message) {     logger.info(message);     log.append(message).append("\n"); }
public List<Pattern> compilePatternsFromList(List<String> list) {     List<Pattern> patterns = new ArrayList<>();     for (String regex : list) {         patterns.add(Pattern.compile(regex));     }     return patterns; }
/**  * Updates/writes a complete user object.  *  * @param userModel the user model to update/write  * @return true if the user model was updated/written successfully, false otherwise  */ public boolean updateUserModel(UserModel userModel) {     if (userModel == null) {         logger.error("User model is null");         return false;     }     try {         if (userService != null) {             userService.updateUser(userModel);         } else {             logger.error("User service is null");             return false;         }         return true;     } catch (Exception e) {         logger.error("Error updating/writing user model: " + e.getMessage());         return false;     } }
public void deleteAlternateUfsDirectory() throws Exception {     String alternateUfsDir = createAlternateUfs();     UnderFileSystem ufs = UnderFileSystem.Factory.get(alternateUfsDir);     ufs.deleteDirectory(alternateUfsDir, DeleteOptions.defaults()); }
public String[][] retrieveMatrix(File file) throws IOException {     StringBuilder sb = new StringBuilder();     BufferedReader reader = new BufferedReader(new FileReader(file));     String line;     while ((line = reader.readLine()) != null) {         sb.append(line);         sb.append(NEW_LINE);     }     reader.close();     String content = sb.toString();     return parseMatrix(content); }
@Test(expected = IllegalArgumentException.class) public void testHandleEventThrowsIllegalArgumentExceptionOnEmptyMessage() {     // Arrange     String userId = "user1";     String application = "app1";     long timestamp = System.currentTimeMillis();     String eventId = "event1";     String message = "";     Map<String, Object> properties = new HashMap<>();     properties.put(ActivityEvent.ID_KEY, eventId);     properties.put(ActivityEvent.USER_ID_KEY, userId);     properties.put(ActivityEvent.APPLICATION_KEY, application);     properties.put(ActivityEvent.TIMESTAMP_KEY, timestamp);     properties.put(ActivityEvent.MESSAGE_KEY, message);     Event event = new Event(ActivityEvent.TOPIC, properties);     // Act     activityController.handleEvent(event);     // Assert     // IllegalArgumentException should have been thrown }
/**  * Return the name of the type in its short form if its known to us otherwise  * return its name fully packaged.  *  * @param type the Class object representing the type  * @return the short name of the type, or the fully packaged name if unknown  */ public static String getShortTypeName(Class<?> type) {     String typeName = SHORT_NAMES_BY_TYPE.get(type);     return (typeName != null) ? typeName : type.getName(); }
public static AccessibilityRecordCompat getRecord(AccessibilityEvent event, int index) {     if (event == null || index < 0) {         return null;     }     AccessibilityRecordCompat record = new AccessibilityRecordCompat(IMPL.getRecord(event, index));     return record; }
public QRPDecomposition<DenseMatrix64F> qrp(int numRows, int numCols) {     return new QRColPivDecompositionHouseholderColumn_D64(numRows, numCols); }
public void setBodyAsString(String value) throws UnsupportedEncodingException {     if (value == null) {         _messageBody = null;     } else {         _messageBody = value.getBytes(_utf8);         _encoding = _utf8;     } }
public MenuItem setOnMenuItemClickListener(MenuItem.OnMenuItemClickListener listener) {     mMenuItem.setOnMenuItemClickListener(listener);     return this; }
public void testConstructorTalkerId() {     // Create a new instance of VHWParser using EXAMPLE string as input     vhw = new VHWParser(EXAMPLE);          // Check if the instance is not null     assertNotNull(vhw);          // Check if the talker ID is correct     assertEquals("VW", vhw.getTalkerId());          // Check if the sentence ID is correct     assertEquals("VHW", vhw.getSentenceId()); }
public void read() {     int bytesRead = 0;     try {         while (m_readBuffer.hasRemaining() && (bytesRead = m_socketChannel.read(m_readBuffer)) > 0) {             // do nothing, just read the bytes into the buffer         }         m_protocolHandler.processBuffer(m_readBuffer);     } catch (IOException e) {         LOG.error("Error reading data from " + m_inetSocketAddress, e);     } }
public double sampleVariance() {     if (count < 2) {         throw new IllegalArgumentException("Sample variance requires at least two values");     }     double variance = sumOfSquaresOfDeltas / (count - 1);     return Double.isFinite(variance) ? variance : Double.NaN; }
public Object getOperation(String name) {     Object classifier = getClassifier();     if (classifier instanceof Class) {         Class<?> clazz = (Class<?>) classifier;         for (Method method : clazz.getDeclaredMethods()) {             if (method.getName().equals(name)) {                 return method;             }         }     }     return null; }
public void setTcpNoDelay(final HttpParams params, boolean value) {     params.setBooleanParameter(CoreConnectionPNames.TCP_NODELAY, value); }
/**  * Just a wrapper to {@link #check(String)}.  */ public float getBrowserVersion(final String userAgent, final String regex) {     return check(userAgent) ? extractBrowserVersion(userAgent, regex) : -1.0f; }
public void add(AbstractReportNode child) {     if (child != null) {         childNodes.add(0, child);         child.setParentNode(this);     } }
public boolean isEmpty() {     return bufferSize == 0; }
public static <T> Function<T, V> constant(Supplier<V> supplier) {     return (T t) -> supplier.get(); }
public void testSetHeading() {     double expectedHeading = 123.4; // set the expected heading value     hdg.setHeading(expectedHeading); // set the heading value using the method being tested     double actualHeading = hdg.getHeading(); // get the actual heading value     assertEquals(expectedHeading, actualHeading, 0.001); // assert that the expected and actual heading values are equal with a tolerance of 0.001 }
public StorageTierView getNextTierView() {     int index = mTierViews.indexOf(mCurrentTierView);     if (index == -1 || index == mTierViews.size() - 1) {         return null;     } else {         return mTierViews.get(index + 1);     } }
public RestResults<YouTubeGDataVideo> processResults(final InputStream is) {     // For debugging purposes, log the raw XML feed     try {         m_log.debug(IOUtils.toString(is, StandardCharsets.UTF_8));     } catch (IOException e) {         m_log.error("Error while reading InputStream", e);     }     // Process the results using the RestSearcher     try {         Document doc = m_documentBuilder.parse(is);         return m_searcher.processSearchResults(doc);     } catch (Exception e) {         m_log.error("Error while processing XML feed", e);         return new RestResults<>();     } }
public void addWhitelist(THashSet<String> whitelist) {     if (whitelist == null) {         return;     }     mWhitelist.addAll(whitelist);     compileList(); }
public int distinctValues() {     // Get the schema for both plans     Schema schema1 = p1.schema();     Schema schema2 = p2.schema();     // Get the field index for the join field in each schema     int joinFieldIndex1 = schema1.fieldIndex(fldname1);     int joinFieldIndex2 = schema2.fieldIndex(fldname2);     // Estimate the distinct number of field values in the join     int distinctValues1 = p1.distinctValues();     int distinctValues2 = p2.distinctValues();     int minDistinctValues = Math.min(distinctValues1, distinctValues2);     // Return the estimate     return minDistinctValues; }
public static String getExactFilePath(File file) {     String exactPath;     try {         exactPath = file.getCanonicalPath();     } catch (IOException e) {         exactPath = file.getAbsolutePath();     }     return exactPath; }
public int getPref_group_len() {     return pref_group_len; }
/**  * Computes the Frobenius norm of the given DenseMatrix64F A in a straight forward manner.  * This implementation can be susceptible to overflow/underflow issues.  * For a more resilient implementation, use {@link #normF}.  *  * @param A the input matrix.  * @return the Frobenius norm of A.  */ public static double normP2(DenseMatrix64F A) {     double total = 0;     for (int i = 0; i < A.getNumRows(); i++) {         for (int j = 0; j < A.getNumCols(); j++) {             double val = A.get(i, j);             total += val * val;         }     }     return Math.sqrt(total); }
public double diffNormF_fast(D1Matrix64F a, D1Matrix64F b) {     double total = 0;     int length = a.getNumElements();     for (int i = 0; i < length; i++) {         double diff = a.get(i) - b.get(i);         total += diff * diff;     }     return total; }
public boolean isRequestor(Message message) {     Exchange exchange = message.getExchange();     if (exchange == null) {         return false;     }     Endpoint endpoint = exchange.getEndpoint();     if (endpoint == null) {         return false;     }     return exchange.getOutMessage() == null || message == exchange.getOutMessage(); }
public String fieldName() {     return fldname; }
/**  * Takes in a list of file locations instead of actual files and renames/saves them.  * @param rename the new name for the file  * @param file the file location  */ void saveFile(String rename, String file) {     File originalFile = new File(file);     String newFilename = myLocation + "/" + rename + suffix;     File newFile = new File(newFilename);     boolean success = originalFile.renameTo(newFile);     if (!success) {         throw new RuntimeException("Failed to rename file.");     } } /**  * Takes in a list of file locations instead of actual files and renames/saves them.  * @param type the type of file  * @param unit the unit of the file  * @param images the list of file locations  */ void saveFiles(String type, String unit, List<String> images) {     int i = 1;     for (String image : images) {         String filename = type + "_" + unit + "_" + i;         saveFile(filename, image);         i++;     } }
public boolean validateRequest(Map<String, Object> request) {     // Check if all the mandatory parameters are present in the request     if (!request.containsKey("param1") || !request.containsKey("param2")) {         // If any of the mandatory parameters are missing, return false         return false;     }     // All mandatory parameters are present in the request     return true; }
@Override public String toString() {     return "LZ4FastDecompressor"; }
public void splitCount(String text) {     String[] words = text.split("\\s+");     for (String word : words) {         incrementTermCount(word);     } }
public AdaptableHeuristicFunction modifyHeuristicFunction(Object newGoal, Map newMap) {     this.goal = newGoal;     this.map = newMap;     return this; }
public int getEmptyAnnotationRejects() {     return emptyAnnotationRejects; }
@Test public void remaining() throws IOException {     before();     assertEquals(BLOCK_LENGTH, mTestStream.remaining());     mTestStream.write(INCREASING_BYTES, 0, (int) BLOCK_LENGTH);     assertEquals(BLOCK_LENGTH, mTestStream.remaining());     mTestStream.write(INCREASING_BYTES, 0, 1);     assertEquals(BLOCK_LENGTH - 1, mTestStream.remaining());     mTestStream.write(INCREASING_BYTES, 0, (int) BLOCK_LENGTH - 1);     assertEquals(0, mTestStream.remaining());     mTestStream.write(INCREASING_BYTES, 0, 1);     assertEquals(-1, mTestStream.remaining());     doubleFlush();     mThrown.expect(IOException.class);     mTestStream.remaining(); }
public List<StorageTierView> getTierViewsBefore(String tierAlias) {     StorageTierView targetTierView = mAliasToTierViews.get(tierAlias);     if (targetTierView == null) {         throw new IllegalArgumentException("Tier alias not found: " + tierAlias);     }     List<StorageTierView> tierViewsBefore = new ArrayList<>();     for (StorageTierView tierView : mTierViews) {         if (tierView.equals(targetTierView)) {             break;         }         tierViewsBefore.add(tierView);     }     return tierViewsBefore; }
public DeterministicKey dropPrivate() {     if (!hasPrivate()) {         return this;     }     final DeterministicKey parent = getParent();     final ImmutableList<ChildNumber> childNumberPath = getChildNumberPath();     final byte[] chainCode = getChainCode();     final ECPoint publicAsPoint = getPubPoint();     final BigInteger privateAsFieldElement = getPrivAsFieldElement();     return new DeterministicKey(parent, childNumberPath, chainCode, publicAsPoint, privateAsFieldElement, /*hasPrivate=*/false); }
public Future<Void> heartbeat() {     return mRecomputeLauncherService.submit(() -> {         mPlanner.heartbeat();         mFileSystemMaster.persistFile(mPlan.getPlanFile());         return null;     }); }
public void removePropertyChangeListener(PropertyChangeListener listener) {     m_PropertyChangeSupport.removePropertyChangeListener(listener); } public void removePropertyChangeListener(String propertyName, PropertyChangeListener listener) {     m_PropertyChangeSupport.removePropertyChangeListener(propertyName, listener); }
public R transform() {     try {         // Create a new instance of the TransformerFactory class         TransformerFactory transformerFactory = TransformerFactory.newInstance();         // Create a new Source object with the transformation specified in the constructor         Source xsltSource = new StreamSource(transformation);         // Create a new Transformer object with the Source object         Transformer transformer = transformerFactory.newTransformer(xsltSource);         // Set the parameters         for (Map.Entry<String, Object> entry : parameters.entrySet()) {             transformer.setParameter(entry.getKey(), entry.getValue());         }         // Set the output properties         Properties outputProperties = new Properties();         outputProperties.setProperty(OutputKeys.INDENT, "yes");         setOutputProperties(outputProperties);         // Perform the transformation         DOMResult result = new DOMResult();         transformTo(result);         // Return the result         return (R) result.getNode();     } catch (TransformerException e) {         // Handle the exception         return withExceptionHandling(e);     } }
public void getAllParameters() {    Enumeration<String> parameterNames = request.getParameterNames();    while (parameterNames.hasMoreElements()) {       String paramName = parameterNames.nextElement();       String[] paramValues = request.getParameterValues(paramName);       for (String paramValue : paramValues) {          addParameter(1, paramName, paramValue);       }    } }
public BigDecimal getFileSize() {     return this.fileSize; }
public class CSS {     private HashMap<String, String> properties;     private Component component;     public boolean addBackgroundColor(String value) {         properties.put("background-color", value);         return true;     }     public boolean addWidth(String value) {         properties.put("width", value);         return true;     }     public HashMap<String, String> getProperties() {         return properties;     } }
public class Machine {     String description;     HashMap<Integer,StatSource> statSources;     HashMap<Integer,Device> devices;     ArrayList<Option> options;     String name;     // ... (other member functions and variables)     public StatSource getLinkedStatSource() {         // Return linked stat source         // Implementation based on description:         // - Iterate through each stat source in statSources HashMap         // - Check if the stat source's device ID matches with any of the device IDs in devices HashMap         // - If found, return the stat source         for (StatSource statSource : statSources.values()) {             if (devices.containsKey(statSource.getDeviceId())) {                 return statSource;             }         }         // If no linked stat source found, return null         return null;     } }
public void handleUnexpectedResponse(int statusCode, HttpResponse response) {     // Perform any necessary cleanup or resource freeing here }
private void indexNode(Node node, RuleContext ctx) {     List<Node> nodes = nodeNameToNodes.computeIfAbsent(node.getName(), k -> new ArrayList<>());     nodes.add(node);     List<Rule> rules = ruleSetRules.get(ctx.getCurrentRuleSet());     if (rules != null) {         for (Rule rule : rules) {             rule.indexNode(node);         }     } }
public class RegPCLTestResultDetailsEntityPK {     private long testId;     private long serialVersionUID = 1L;     private long seqId;          // other member functions          public boolean equals(Object other) {         // implementation     }          public void setTestId(long testId) {         this.testId = testId;     }          public long getSeqId() {         return this.seqId;     }          public int hashCode() {         // implementation     }          public void setSeqId(long seqId) {         this.seqId = seqId;     }          public long getTestId() {         return this.testId;     } }
public void addShort(short value) {     int intValue = (int) value;     intBuf[0] = (byte) ((intValue >>> 8) & 0xFF);     intBuf[1] = (byte) (intValue & 0xFF);     format.packInt(intBuf, 0, 2); }
public TransactionOutputChanges getTransactionOutputChanges() {     if(txOutChanges != null) {         return txOutChanges;     } else {         return null;     } }
public void setCallbackHandlerClass(String callbackHandlerClass) {     this.callbackHandlerClass = callbackHandlerClass; }
public int calculateROISize() {     if(genes_in_ROI == null) {         return 0;     }     return genes_in_ROI.size(); }
private void updateTreeFromString(String s) {     if (s == null || s.isEmpty()) {         return;     }     String[] tokens = s.split("\\s+");     MTDFragmentAST current = tree;     for (String token : tokens) {         if (current == null) {             break;         }         if (!current.children.containsKey(token)) {             current.children.put(token, new MTDFragmentAST());         }         current = current.children.get(token);     } }
public void addBlacklist(THashSet<String> blacklist) {     if (blacklist != null) {         if (mBlacklist == null) {             mBlacklist = new THashSet<String>();         }         mBlacklist.addAll(blacklist);     } }
public BigDecimal getExpDataSetId() {     return this.expDataSetId; }
public void setErrorMsg(String errorMsg) {     this.errorMsg = errorMsg; }
public MetadataEditorCompat setAlbumArtwork(Bitmap albumArt) {     if (HAS_REMOTE_CONTROL_APIS) {         if (mActualMetadataEditor != null) {             mActualMetadataEditor.putBitmap(METADATA_KEY_ARTWORK, albumArt);         }     } else {         if (mActualRemoteControlClient != null) {             try {                 Method method = mActualRemoteControlClient.getClass().getMethod("setArtwork", Bitmap.class);                 method.invoke(mActualRemoteControlClient, albumArt);             } catch (Exception e) {                 // Do nothing             }         }     }     return this; }
public String wf_externalId(String actionName) {     WorkflowActionBean action = getAction();     if (action != null && action.getName().equals(actionName)) {         return action.getExternalId();     }     return null; }
public String getString(ConfigurationKey key) {     Object value = getConfigurationHandler().getProperty(key);     if (value instanceof String) {         return (String) value;     }     return null; }
public int getByteArrayLength() {     if (format.readUnsignedByte() == PackFormatInputStream.ARRAY) {         int len = format.readUnsignedInt();         if (len < 0) {             throw new RuntimeException("Negative array length found: " + len);         }         return len;     } else {         return format.available();     } }
public String getClassNameFromNumber(int classNum) {     switch(classNum) {         case 1:             return "Class1";         case 2:             return "Class2";         case 3:             return "Class3";         default:             return null;     } }
public void testSetHeading() {     double expected = 90.0;     hdm.setHeading(expected);     assertEquals(expected, hdm.getHeading(), 0.01); }
public void addEntry(T entry) {     if (circularArray.size() == max) {         circularArray.set(position, entry);         position = (position + 1) % max;         haveOverflow = true;     } else {         circularArray.add(entry);     } }
public void start() {     if (mMasterThread == null) {         mMasterThread = new Thread(() -> {             try {                 mAlluxioMaster.start();             } catch (Exception e) {                 LOG.error("Failed to start Alluxio master", e);                 throw new RuntimeException(e);             }         });         mMasterThread.start();     } }
public void setIdentifier(String identifier) {     this.identifier = identifier; }
public static void ensureCapacity(byte[] buf, int offset, int requiredCapacity) {     if (buf.length < offset + requiredCapacity) {         byte[] newBuf = new byte[offset + requiredCapacity];         System.arraycopy(buf, 0, newBuf, 0, buf.length);         buf = newBuf;     } }
@Test public void testTryLock() throws InterruptedException {     // Acquire the write lock     assertTrue(mClientRWLock.tryLock());     // Release the write lock     mClientRWLock.unlockWrite();     // Acquire the read lock     assertTrue(mClientRWLock.tryLock());     // Release the read lock     mClientRWLock.unlockRead();     // Acquire the write lock     assertTrue(mClientRWLock.tryLock());     // Release the write lock     mClientRWLock.unlockWrite();     // Acquire the read lock     assertTrue(mClientRWLock.tryLock());     // Release the read lock     mClientRWLock.unlockRead(); }
public Long getTestId() {     return testId; }
public List<String> representation() {     return new ArrayList<String>(log); }
public void testGetVariation() {     String rmcString = "$GPRMC,120044.567,A,6011.552,N,02501.941,E,000.0,360.0,160705,006.1,E,A*0B";     RMCParser rmc = new RMCParser(rmcString);     double expected = 6.1;     double actual = rmc.getVariation();     assertEquals(expected, actual, 0.01); }
public int differenceInMinutes(Date date) {     long now = System.currentTimeMillis();     long diffInMillis = Math.abs(now - date.getTime());     long diffInMinutes = TimeUnit.MILLISECONDS.toMinutes(diffInMillis);     return (int)diffInMinutes; }
public File getLibsDirectory(Context context) {     File dir = new File(context.getApplicationInfo().nativeLibraryDir, "extracted_libs");     if (!dir.exists()) {         if (!dir.mkdirs()) {             throw new RuntimeException("Could not create libs directory: " + dir.getAbsolutePath());         }     }     return dir; }
public Set<String> getExtensionsDenied(final ResourceTypeHandler type) {     return extensionsDenied.getOrDefault(type, Collections.emptySet()); }
public void validate() {     RPCFileReadResponse resp = new RPCFileReadResponse(TEMP_UFS_FILE_ID, OFFSET, LENGTH, STATUS, mBuffer);     long expectedLength = RpcUtils.encodeVarintFieldLength(1, RpcUtils.encodeVarint(OFFSET))             + RpcUtils.encodeVarintFieldLength(2, RpcUtils.encodeVarint(LENGTH))             + RpcUtils.encodeVarintFieldLength(3, RpcUtils.encodeVarint(STATUS.getValue()))             + RpcUtils.encodeVarintFieldLength(4, RpcUtils.encodeVarint(TEMP_UFS_FILE_ID))             + RpcUtils.encodeBufferLengthFieldLength(5, mBuffer.readableBytes());     Assert.assertEquals(expectedLength, resp.getEncodedLength()); }
public static String format(String template, Object... args) {     StringBuilder sb = new StringBuilder(template.length() + 16 * args.length);     int templateStart = 0;     int i = 0;     while (i < args.length) {         int placeholderStart = template.indexOf("%s", templateStart);         if (placeholderStart == -1) {             break;         }         sb.append(template, templateStart, placeholderStart);         sb.append(args[i++]);         templateStart = placeholderStart + 2;     }     sb.append(template, templateStart, template.length());     if (i < args.length) {         sb.append(" [");         sb.append(args[i++]);         while (i < args.length) {             sb.append(", ");             sb.append(args[i++]);         }         sb.append(']');     }     return sb.toString(); }
public static <T> List<T> list(T o1, T o2, T o3) {     List<T> result = new ArrayList<>();     result.add(o1);     result.add(o2);     result.add(o3);     return result; }
public static void instanceOf(Class<?> expectedClass, Object object) {     if (!expectedClass.isInstance(object)) {         fail(String.format("Expected object of type %s, but was %s", expectedClass.getName(), object.getClass().getName()));     } }
public Document getWSDLDocument(Server server) {     ServiceInfo serviceInfo = server.getService().getServiceInfos().get(0);     Definition def = new WSDLFactoryImpl().newDefinition();     def.setTargetNamespace(serviceInfo.getTargetNamespace());     Service service = def.createService();     service.setQName(new QName(serviceInfo.getTargetNamespace(), serviceInfo.getName()));     for (EndpointInfo endpointInfo : serviceInfo.getEndpoints()) {         String address = endpointInfo.getAddress();         String bindingID = endpointInfo.getBinding().getBindingID();         // Build endpoint         Endpoint endpoint = def.createEndpoint();         endpoint.setBinding(new QName(serviceInfo.getTargetNamespace(), bindingID));         endpoint.setAddress(address);         // Add endpoint to service         service.addEndpoint(endpoint);     }     def.addService(service);     WSDLWriter wsdlWriter = WSDLFactory.newInstance().newWSDLWriter();     Document doc = wsdlWriter.getDocument(def);     return doc; }
public String readSingleData(String dataPath, HSSFSheet sheet) {     Map<String, Integer> columnIndexes = initializeColumnIndex(dataPath, sheet);     int rowIndex = -1;     for (Row row : sheet) {         rowIndex++;         if (rowIndex == 0) {             continue; // Skip header row         }         Object reportObject = report;         String[] path = dataPath.split(MAP_SEPARATOR);         for (int i = 0; i < path.length - 1; i++) {             String propertyName = translateAsterix(path[i], sheet);             try {                 reportObject = PropertyUtils.getProperty(reportObject, propertyName);             } catch (Exception e) {                 // Ignore any exception when getting property value             }         }         String propertyName = translateAsterix(path[path.length - 1], sheet);         Integer columnIndex = columnIndexes.get(propertyName);         if (columnIndex == null) {             throw new RuntimeException(ILLEGAL_DATAPATH);         }         Cell cell = row.getCell(columnIndex);         if (cell == null || cell.getCellType() == CellType.BLANK) {             continue;         }         return getCellToStringValue(cell);     }     throw new RuntimeException(NO_DATA_FOUND); }
public boolean validateSentences() {     // Check the age of each sentence     for (Sentence sentence : events) {         if (!sentence.isFresh()) {             return false;         }     }          // Check if the provider is valid     if (!isValid()) {         return false;     }          // If no validation criteria exists, return true     return true; }
void addedFile(int fileCount, File file) {     if (file != null && file.exists() && !file.isDirectory() && fileCount <= expectedFilesCount) {         try {             // Get the canonical file path and the base test resource path             String filePath = file.getCanonicalPath();             String baseTestPath = new File(BASE_TEST_RESOURCE_PATH).getCanonicalPath();             // Check if the file path is within the base test resource path and not a symlink             if (filePath.startsWith(baseTestPath) && (!canTestSymLinks || filePath.equals(file.getAbsolutePath()))) {                 // Add the file to CPD for processing                 cpd.add(file);                 files++;             }         } catch (IOException e) {             // Handle any IO exceptions             e.printStackTrace();         }     } }
public Method findBridgedMethod(Method bridgeMethod) {     Class<?> declaringClass = bridgeMethod.getDeclaringClass();     for (Method candidateMethod : declaringClass.getDeclaredMethods()) {         if (isBridgeMethodFor(bridgeMethod, candidateMethod, declaringClass.getTypeParameters())) {             return candidateMethod;         }     }     return null; }
public static <V extends Parcelable> void writeHashMapStringKey(Map<String, V> map, Parcel out, int flags) {     if (map == null) {         out.writeInt(-1);         return;     }     Set<Map.Entry<String, V>> entries = map.entrySet();     out.writeInt(entries.size());     for (Map.Entry<String, V> entry : entries) {         out.writeString(entry.getKey());         out.writeParcelable(entry.getValue(), flags);     } }
public String getTitle() {     return title; }
public void setModifiedDate(Timestamp modifiedDate) {     this.modifiedDate = modifiedDate; }
// Currently unused public void unused() {     // no code needed as it is currently unused }
public boolean hasKey(String key) {     return false; }
public ListenableFuture<PaymentChannelClientConnection> getChannelOpenFuture() throws PaymentChannelCloseException {     if (channelOpenFuture.isDone()) {         try {             channelOpenFuture.get();         } catch (InterruptedException e) {             throw new PaymentChannelCloseException("Interrupted while waiting for channel to open", e);         } catch (ExecutionException e) {             throw new PaymentChannelCloseException("Error occurred while opening channel", e.getCause());         }     }     return channelOpenFuture; }
public String end_subgraph() {     return "}"; }
public Timestamp getModifiedDate() {     return modifiedDate; }
void short2leb(final short x, final OutputStream os) {     try {         os.write(x & 0xFF);         os.write((x >> 8) & 0xFF);     } catch (IOException e) {         // Handle the exception as needed     } }
@Deprecated public void request(String graphPath, Bundle parameters, String httpMethod, RequestListener listener, Object state) {     String method = (httpMethod != null) ? httpMethod : "GET";     parameters.putString("format", "json");     parameters.putString("method", method);     AsyncFacebookRunner.Request request = new AsyncFacebookRunner.Request(this.fb, graphPath, parameters, method, listener, state);     this.executeRequest(request); }
public ServiceBuilder configureApi(Api api) {     this.api = api;     return this; }
public boolean isNumber(short cssPrimitiveType) {     switch (cssPrimitiveType) {         case CSSPrimitiveValue.CSS_NUMBER:         case CSSPrimitiveValue.CSS_PX:         case CSSPrimitiveValue.CSS_CM:         case CSSPrimitiveValue.CSS_MM:         case CSSPrimitiveValue.CSS_IN:         case CSSPrimitiveValue.CSS_PT:         case CSSPrimitiveValue.CSS_PC:             return true;         default:             return false;     } }
public boolean isMac() {     String osName = System.getProperty("os.name").toLowerCase();     return osName.contains("mac"); }
public void testGetLongitude() {     // Arrange     double expectedLongitude = 12.3456;     instance.setLongitude(expectedLongitude);     // Act     double longitude = instance.getLongitude();     // Assert     assertEquals(expectedLongitude, longitude, 0.0); }
void assertValid(long tempUfsFileId, long offset, long length, RPCFileReadRequest req) {     assertEquals(tempUfsFileId, req.getTempUfsFileId());     assertEquals(offset, req.getOffset());     assertEquals(length, req.getLength()); }
public boolean isMoreChainWorkThan(StoredBlock other) {     return this.chainWork.compareTo(other.chainWork) > 0; }
public void init() {     LOGGER.debug("Initializing FetcherTesterDataSetVerifier");     fetcherContext.init();     fetcherRegDataUnitVerifier.init(); }
public void closeConnection() {     try {         if (connection != null) {             connection.close();         }     } catch (IOException e) {         handleException("Error closing RabbitMQ connection.", e);     } }
public Sha256Hash getTransactionHash() {     return hash; }
null
@Override public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {     try {         writer.writeCharacters(new String(ch, start, length));     } catch (XMLStreamException e) {         throw new SAXException(e);     } }
public HashCodeBuilder append(Object[] array) {     if (array == null) {         iTotal = iTotal * iConstant;     } else {         for (Object element : array) {             if (element == null) {                 iTotal = iTotal * iConstant;             } else {                 if (element.getClass().isArray()) {                     append(element);                 } else {                     iTotal = iTotal * iConstant + element.hashCode();                 }             }         }     }     return this; }
public void setFilepath(String value) {     this.filepath = value; }
void dispose() {     if (_sharedContext != null) {         _sharedContext.dispose();         _sharedContext = null;     } }
public String getMemberNameWithExtension() {     String extension = getZipFileExtension();     String nameWithoutProject = uniqueName.substring(project.getName().length() + 1);     return nameWithoutProject + "." + extension; }
/**  * Returns the number of satoshis of this monetary value.  * It's deprecated in favour of accessing {@link #value} directly.  */ @Deprecated public long getValue() {     return value; }
public boolean isThisOrSuper() {     return image.equals(THIS) || image.equals(SUPER); }
@Test public void testGetTime() {     TTMParser parser = new TTMParser(EXAMPLE);     assertEquals(175550.24, parser.getTime(), 0.01); }
public String getString1() {     return string1; }
public void setUserName(String userName) {     this.userName = userName; }
/**  * Marks this directory as one that has been removed, indicating we should also remove all the directory contents.  */ public void setRemoved() {     m_removed = true; }
public boolean isVisited(Object e) {     return getAttributeValue(e, "visited") != null; }
public void executeScript(String script) {     webEngine.executeScript(script); }
public Result filterOut(List<String> sources) {     Result result = new Result();     for (ResultEntry entry : log) {         if (!sources.contains(entry.getSource())) {             result.add(entry);         }     }     return result; }
public double computeMetric(OperationNode node, String code) {     return calculator.compute(node, code); }
public void updateListeners(PropertyChangeEvent event) {     // Remove all listeners     listeners.clear();          // Re-initialize completely     for (Object element : model) {         initialiseListener(listener, element);     }          // Alternative implementation (method 2) that dissects the propertyChangeEvent     /*     Object element = event.getSource();     String propertyName = event.getPropertyName();     PropertyChangeListener listener = event.getPropertyChangeListener();          if (propertyName != null) {         // Adapt only the listeners that need to be adapted         for (Object[] listenerInfo : listeners) {             Object listenerElement = listenerInfo[0];             PropertyChangeListener listenerListener = (PropertyChangeListener) listenerInfo[1];             String[] listenerProperties = (String[]) listenerInfo[2];                          if (element.equals(listenerElement) && contains(propertyName, listenerProperties)) {                 listenerElement.removePropertyChangeListener(listenerListener);                 listenerElement.addPropertyChangeListener(listenerProperties, listenerListener);             }         }     } else {         // Re-initialize completely         listeners.clear();         for (Object element : model) {             initialiseListener(listener, element);         }     }     */ }
public LinearSolver<DenseMatrix64F> linear(int matrixSize) {     return LinearSolverFactory_DDRM.linear(matrixSize); }
public Long getDataSetId() {     return this.dataSetId; }
public void setModifiedDate(Timestamp modifiedDate) {     this.modifiedDate = modifiedDate; }
private void initInternal(String s) {     if (!initialized) {         systemDefaultLocale = Locale.getDefault();         bundles = new HashMap<String, ResourceBundle>();         addClassLoader(this.getClass().getClassLoader());         initialized = true;     }     init(s); }
public long getLongLittleEndianWithPadding(byte[] input, int offset) {     if (offset + 8 > input.length) {         byte[] paddedInput = new byte[8];         int remaining = input.length - offset;         System.arraycopy(input, offset, paddedInput, 0, remaining);         return load64(paddedInput, 0);     } else {         return load64(input, offset);     } }
public double getDouble(ConfigurationKey key) {     String valueStr = getString(key);     double defaultValue = 0.0; // Change this to set the default value     double value;     try {         value = Double.parseDouble(valueStr);     } catch (NumberFormatException e) {         value = defaultValue;     }     return value; }
public void incrementCurValue() {     curValue++;     if (showProgress) {         double percent = getPercentComplete() * 100;         System.out.printf("Progress: %.2f%%\n", percent);     } }
public Collection<Node> getNodes(Edge edge) {     Set<Node> connectedNodes = new HashSet<>();     if (graph.containsEdge(edge)) {         Pair<Node> endpoints = graph.getEndpoints(edge);         connectedNodes.add(endpoints.getFirst());         connectedNodes.add(endpoints.getSecond());     }     return connectedNodes; }
public void tearDown() {     String address = localServer.getBaseUrl();     // Use the address of the local test server as needed }
public String getNamespaceURI() {     return namespaceURI; }
void removeDevice(@PathVariable long device_id) {     TerminalDevice device = repository.findById(device_id);     if (device != null) {         repository.delete(device);     } }
public int distinctFieldValues() {     StatsManager statsManager = new StatsManager();     return statsManager.getDistinctFieldValues(ti.tableName()); }
public void waitForAcknowledge(long sequenceNumber) throws InterruptedException {     while(!haveAcknowledgementFor(sequenceNumber)) {         synchronized(sendLock) {             sendLock.wait();         }     } }
public void encodeDecode() {     RPCFileWriteRequest req = new RPCFileWriteRequest(TEMP_UFS_FILE_ID, OFFSET, LENGTH, mBuffer);     ByteBuf encodedBuf = Unpooled.buffer();     req.encode(encodedBuf);     RPCFileWriteRequest decodedReq = RPCFileWriteRequest.decode(encodedBuf);     assertValid(TEMP_UFS_FILE_ID, OFFSET, LENGTH, decodedReq); }
public static SpringChain create() {     SpringChain chain = new SpringChain();     chain.mMainSpringConfig = SpringConfig.fromOrigamiTensionAndFriction(         DEFAULT_MAIN_TENSION, DEFAULT_MAIN_FRICTION);     chain.mAttachmentSpringConfig = SpringConfig.fromOrigamiTensionAndFriction(         DEFAULT_ATTACHMENT_TENSION, DEFAULT_ATTACHMENT_FRICTION);     return chain; }
public boolean checkFileExists(String filePath) {     File file = new File(filePath);     return file.exists(); }
public String getChecksumType() {     return this.checksumType; }
/**  * Test of getName method, of class TestDosAttack.  */ @Test public void testGetName() {     AbstractDosPlugin instance = new TestDosAttack();     String expResult = "TestDosAttack";     String result = instance.getName();     assertEquals(expResult, result); }
public Long getInactivityTimeoutTime() {     return inactivityTimeout; }
public ELEvaluator createSLAEvaluator(Element eJob, Configuration conf, String actionId) {     ELEvaluator eval = createELEvaluatorForGroup(conf, "SLA");     setConfigToEval(eval, conf);     eval.setVariable("nominal_time", "${coord:nominalTime()}");     eval.setVariable("actual_time", "${coord:actualTime()}");     eval.setVariable("max_duration", "${sla:maxDuration()}");     eval.setVariable("alert_events", "${sla:alertEvents()}");     eval.setVariable("alert_contact", "${sla:alertContact()}");     eval.setVariable("notification_msg", "${sla:notificationMsg()}");     eval.setVariable("upstream_apps", "${sla:upstreamApps()}");     eval.setVariable("app_name", eJob.getAttribute("name"));     eval.setVariable("app_path", eJob.getAttribute("action"));     eval.setVariable("sla_id", actionId);     return eval; }
public Sentence createParserImpl(String sid, Object param) {     if (!hasParser(sid)) {         return null;     }     try {         Class<? extends SentenceParser> parserClass = parsers.get(sid);         Constructor<? extends SentenceParser> constructor = parserClass.getConstructor();         SentenceParser parser = constructor.newInstance();         parser.parse(param.toString());         if (parser instanceof GGA) {             return (GGA) parser;         } else if (parser instanceof RMC) {             return (RMC) parser;         } else if (parser instanceof GSA) {             return (GSA) parser;         } else {             return parser;         }     } catch (Exception e) {         throw new RuntimeException("Error creating parser for sentence: " + sid, e);     } }
public TimestampService getTimestampService() {     // TODO: Implement the code for returning the timestamp service. }
public void setLastVersion(String versionName) {     lastVersion = versionName; }
public void initialize(InputStream is) {     if (_is != null) {         throw new IllegalStateException("Input already initialized");     }     _is = is;     initBuffer(); }
public void setProofOfPossessionRequired(boolean required) {     this.verifyProofOfPossession = required; }
public PolicyPublisher getPolicyPublisher() {     return policyPublisher; }
public Options getKeys() {     return this.options; }
public void initialize() {     // Implementation goes here }
void onLoadStarted(T container, String uri, BitmapDisplayConfig config) {     // Your implementation for the onLoadStarted callback when loading goes here. }
public void setErrorsQueue(ErrorQueue eq) {     this.eq = eq; }
public void setStylesheet(Stylesheet stylesheet) {     this.stylesheet = stylesheet; }
public void setAuth(Auth value) {     this.auth = value; }
/**  * Puts the specified name/value pair in the specified JSON object.  *   * @param json the JSON object to modify  * @param key the name of the value to add  * @param value the value to add  */ public static void put(JSONObject json, String key, Object value) {     try {         json.put(key, value);     } catch (JSONException e) {         LOG.error("Error putting JSON value", e);     } }
public void sendAccessibilityEventUnchecked(View host, AccessibilityEvent event) {     IMPL.sendAccessibilityEventUnchecked(DEFAULT_DELEGATE, host, event);     if (mBridge != null) {         AccessibilityDelegateCompat bridge = (AccessibilityDelegateCompat) mBridge;         bridge.dispatchPopulateAccessibilityEvent(host, event);         for (View child : host.getAccessibilityTraversalBefore()) {             if (child.getVisibility() == View.VISIBLE) {                 AccessibilityEvent childEvent = AccessibilityEvent.obtain();                 child.onInitializeAccessibilityEvent(childEvent);                 child.dispatchPopulateAccessibilityEvent(childEvent);                 bridge.dispatchPopulateAccessibilityEvent(child, childEvent);                 event.getText().addAll(childEvent.getText());             }         }         for (View child : host.getAccessibilityTraversalAfter()) {             if (child.getVisibility() == View.VISIBLE) {                 AccessibilityEvent childEvent = AccessibilityEvent.obtain();                 child.onInitializeAccessibilityEvent(childEvent);                 child.dispatchPopulateAccessibilityEvent(childEvent);                 bridge.dispatchPopulateAccessibilityEvent(child, childEvent);                 event.getText().addAll(childEvent.getText());             }         }     } else {         host.dispatchPopulateAccessibilityEvent(event);     } }
public String getClosestNamedColor(String hexString) {     Color color = Color.decode(hexString);     double minDistance = Double.MAX_VALUE;     String closestNamedColor = null;     for (Map.Entry<RGB, String> entry : namedColors.entrySet()) {         Color namedColor = new Color(entry.getKey().r, entry.getKey().g, entry.getKey().b);         double distance = calculateColorDistSq(color, namedColor);         if (distance < minDistance) {             minDistance = distance;             closestNamedColor = entry.getValue();         }     }     return closestNamedColor; }
public Schema getIndexJoinSchema() {    Schema indexJoinSchema = new Schema();    Schema p1Schema = p1.getSchema();    Schema p2Schema = p2.getSchema();    for (String fieldName : p1Schema.getFieldNames()) {        Type fieldType = p1Schema.getFieldType(fieldName);        String fullFieldName = "p1." + fieldName;        indexJoinSchema.add(fullFieldName, fieldType);    }    for (String fieldName : p2Schema.getFieldNames()) {        if (!fieldName.equals(joinfield)) {            Type fieldType = p2Schema.getFieldType(fieldName);            String fullFieldName = "p2." + fieldName;            indexJoinSchema.add(fullFieldName, fieldType);        }    }    for (String fieldName : ii.getSchema().getFieldNames()) {        Type fieldType = ii.getSchema().getFieldType(fieldName);        indexJoinSchema.add(fieldName, fieldType);    }    return indexJoinSchema; }
public Long getBatchId() {     return this.batchId; }
public void addUnidirectionalLink(String fromLocation, String toLocation, Double distance) {     links.addEdge(fromLocation, toLocation, distance); }
public void addStringField(String fldname, int length) {     info.put(fldname, new FieldInfo(Schema.TYPE_STRING, length)); }
public static void notEmpty(Collection<?> collection, String message) {     if (collection == null || collection.isEmpty()) {         throw new IllegalArgumentException(message);     } }
null
public int getBlockSize() {     return blockSize; }
public boolean hasPropertyDefined(CSSName cssName) {     PropertyDeclaration decl = propertyByName(cssName);     return decl != null; }
public boolean isSPErrorOut() {     return errorCode != null && errorCode != 0; }
public void writeResponseBody(OutputStream outputStream, byte[] responseBody) throws IOException {     outputStream.write(responseBody);     outputStream.flush();     outputStream.close(); }
public String getListAsString() {     StringBuilder sb = new StringBuilder();     for (String message : log) {         sb.append(message).append("\n");     }     return sb.toString(); }
@Override public int hashCode() {     int prime = 31;     int result = 1;     result = prime * result + y;     result = prime * result + x;     return result; }
public void updateMaxValue(Scan scan) {     Constant fieldValue = scan.getFieldValue(fldname);     if (fieldValue.compareTo(val) > 0) {         val = fieldValue;     } }
public boolean isConnectionReset() {     return content.contains("Connection reset"); }
public static U2FService getInstance() {     return u2FService; }
@GetMapping("/dish-collections/{id}") public ResponseEntity<DishCollection> getDishCollection(@PathVariable String id) {     DishCollection dishCollection = dishCollectionService.getDishCollectionById(id);     if (dishCollection == null) {         return new ResponseEntity<>(HttpStatus.NOT_FOUND);     }     return new ResponseEntity<>(dishCollection, HttpStatus.OK); }
public Script createPayToPubKeyScriptSig(List<TransactionSignature> signatures) {     ScriptBuilder builder = new ScriptBuilder();     for (TransactionSignature signature : signatures) {         builder.data(signature.encodeToBitcoin());     }     return builder.build(); }
public void checkIssuerNotKnownBehavior() {     // Mocking the client and server configuration     RegisteredClient mockClient = new RegisteredClient();     ServerConfiguration mockServerConfig = new ServerConfiguration();     mockServerConfig.setIssuer("https://www.example.com/");     // Set the issuer to an unknown value     String unknownIssuer = "https://unknown-issuer.com/";     mockClient.setIssuer(unknownIssuer);     // Set up the service with the mock client and server configuration     StaticClientConfigurationService service = new StaticClientConfigurationService();     service.setRegisteredClient(mockClient);     service.setServerConfiguration(mockServerConfig);     // Call the getClientConfiguration method to check the behavior when issuer is not known     service.getClientConfiguration();     // Add assertions or checks for the expected behavior     // ... } public void prepare() {     // Perform any necessary setup or initialization     // ... }
public Builder toBuilder() {     return new Builder()             .id(this.id)             .optionName(this.optionName)             .optionValue(this.optionValue); } public Builder id(String id) {     this.id = id;     return this; } public static class Builder {     // Builder class implementation     // ... }
public void setAccountNonExpired(boolean accountNonExpired) {     this.accountNonExpired = accountNonExpired; }
public String getAttributeValue(Object e, String attrName) {     return ((Element) e).getAttribute(attrName); } public String getAttributeValue(Object e, String namespaceURI, String attrName) {     return ((Element) e).getAttributeNS(namespaceURI, attrName); }
public AbstractAction getRedoAction() {     return redoAction; }
public Collection<Device> getDevices() {     return devices.values(); }
public void setAccountNonLocked(boolean accountNonLocked) {     this.accountNonLocked = accountNonLocked; }
public List<Station> getStations() {     List<Station> allStations = new ArrayList<>();     for (String city : stationCache.keySet()) {         allStations.addAll(getStations(city, null, null));     }     return allStations; }
public void unpin(Block blk) {     Buffer buffer = buffers.get(blk);     if (buffer != null) {         bufferMgr.unpin(buffer);     } }
public void log(String message) {     if (debug && context != null) {         context.log(servletName + " (DEBUG): " + message);     } } public void log(String message, Throwable throwable) {     if (debug && context != null) {         context.log(servletName + " (DEBUG): " + message, throwable);     } } public void doLog(String message, Throwable throwable) {     if (context != null) {         context.log(servletName + ": " + message, throwable);     } }
public boolean isDebugMode() {     return logger.isDebugEnabled(); } public ServerStatus getStatus() {     return serverStatus; } public ServerSettings getSettingsModel() {     return settingsModel; } public IStoredSettings getSettings() {     return settings; } public File getBaseFolder() {     return baseFolder; } public TimeZone getTimezone() {     return timezone; } public void logTimezone(String type, TimeZone zone) {     logger.info("Timezone " + type + ": " + zone.getID()); } public RuntimeManager start() {     // Implementation for starting the RuntimeManager } public RuntimeManager stop() {     // Implementation for stopping the RuntimeManager } public boolean updateSettings(Map<String, String> updatedSettings) {     // Implementation for updating settings based on the provided map } public Date getBootDate() {     // Implementation for getting the boot date } public File getFileOrFolder(String key, String defaultFileOrFolder) {     // Implementation for getting a file or folder based on the key and default value } public File getFileOrFolder(String fileOrFolder) {     // Implementation for getting a file or folder based on the provided value } public void setBaseFolder(File folder) {     // Implementation for setting the base folder }
public void addByte(byte value) {     packed.write(value); } public void addRecord(long value) {     packed.write(PackFormatInputStream.packLong(value)); } public void reset() {     packed.reset(); } public String getFormat() {     return format.getFormat(); } public void addInt(int value) {     intBuf[0] = (byte) (value >> 24);     intBuf[1] = (byte) (value >> 16);     intBuf[2] = (byte) (value >> 8);     intBuf[3] = (byte) value;     packed.write(intBuf, 0, 4); } public void addLong(long value) {     format.writeLong(value, packed); } public void addString(String value) {     byte[] bytes = value.getBytes(StandardCharsets.UTF_8);     addInt(bytes.length);     packed.write(bytes, 0, bytes.length); } public byte[] getValue() {     return packed.toByteArray(); } public void packLong(long x, boolean signed) {     format.packLong(x, packed, signed); } public void addShort(short value) {     intBuf[0] = (byte) (value >> 8);     intBuf[1] = (byte) value;     packed.write(intBuf, 0, 2); }
public HashMap<String, GeneticProfile> getDefaultMutationProfileMap() {     HashMap<String, GeneticProfile> mutationProfileMap = new HashMap<>();     for (GeneticProfile profile : mutationProfileList) {         if (profile.isDefault()) {             mutationProfileMap.put(profile.getId(), profile);         }     }     return mutationProfileMap; }
public String getExecutionEndDateTime() {     return executionEndDateTime; }
public void testGetNumber() {     // Test implementation code here }
public Mode createNewModeWithUmask(Bits umask) {     // Implementation code here }
public class ReceiverLossListEntry {     private long sequenceNumber;     private long lastFeedbackTime;     private long k = 2;     public long getK() {         return k;     }     public int hashCode() {         // Implementation code here     }     public boolean equals(Object obj) {         // Implementation code here     }     public String toString() {         // Implementation code here     }     public long getLastFeedbackTime() {         // Implementation code here     }     public void feedback() {         // Implementation code here     }     public long getSequenceNumber() {         // Implementation code here     }     // Method to order by increasing sequence number     public int compareTo(ReceiverLossListEntry entry) {         // Implementation code here     } }
public class AbstractConnPool {     private Lock poolLock;     private boolean isShutDown;     private Set<BasicPoolEntryRef> issuedConnections;     private IdleConnectionHandler idleConnHandler;     private Log log;     private int numConnections;     private ReferenceQueue<Object> refQueue;     private Set<BasicPoolEntry> leasedConnections;     public BasicPoolEntry getEntry(HttpRoute route, Object state, long timeout, TimeUnit tunit) {         // Implementation code here     }     public PoolEntryRequest requestPoolEntry(HttpRoute route, Object state) {         // Implementation code here     }     public void deleteClosedConnections() {         // Implementation code here     }     public void shutdown() {         // Implementation code here     }     public void freeEntry(BasicPoolEntry entry, boolean reusable, long validDuration, TimeUnit timeUnit) {         // Implementation code here     }     public void closeExpiredConnections() {         // Implementation code here     }     public void closeConnection(final OperatedClientConnection conn) {         // Implementation code here     }     public void enableConnectionGC() {         // Implementation code here     }     public void handleReference(Reference<?> ref) {         // Implementation code here     }     public void handleLostEntry(HttpRoute route) {         // Implementation code here     }     // Method to close idle connections     public void closeIdleConnections() {         // Implementation code here     } }
public class BinaryBytesEvent {     private byte[] data;     public ParserEventType getType() {         // Implementation code here     }     public String toString() {         // Implementation code here     }     // Method to pass the event to the listener     public void passEventToListener() {         // Implementation code here     } }
public class TTMTest {     private String EXAMPLE = "$RATTM,11,25.3,13.7,T,7.0,20.0,T,10.1,20.2,N,NAME,Q,,175550.24,A*34";     private TTMParser ttm;     private TTMParser empty;     // Test method for TTMParser.getBearing()     public void testGetBearing() {         // Implementation code here     }     // Other member function headers and implementations     // ... }
public class PluginContainer {     private SortedUniqueList<AbstractPlugin> plugins;     private long serialVersionUID = 1L;     // Implementation of the member function to remove a plugin by its index     public AbstractPlugin removeByIndex(int index) {         // Implementation code here     }     // Other member function headers and implementations     // ... }
public class ClasspathScanner {     private String WILDCARD = "*";     private String[] PACKAGES_TO_SKIP = {"org.apache.cxf"};     private ClasspathScanner HELPER;     private String ALL_CLASS_FILES = ALL_FILES + ".class";     private String CLASSPATH_URL_SCHEME = "classpath:";     private String ALL_FILES = "**/*";     // Implementation of the member function to scan base packages for classes with specific annotations     public Map<Class<? extends Annotation>, Collection<Class<?>>> findClassesInternal(Collection<String> basePackages, List<Class<? extends Annotation>> annotations, ClassLoader loader) {         // Implementation code here     }     // Other member function headers and implementations     // ... }
public class AtomicDoubleArray {     private AtomicLongArray longs;     private long serialVersionUID = 0L;     // Implementation of the member function to save the state to a stream (serialize)     void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {         // Implementation code here     }     // Other member function headers and implementations     // ... }
public class TestResultDTO {     private Date lastModifiedTimeStamp;     private Date fetcherStartTimeStamp;     private Date createTimeStamp;     private Long testId;     private Long runId;     private Date fetcherEndTimeStamp;     private OutcomeType outcome;     private Long feedId;     private String createdBy;     private List<TestResultDetailsDTO> regTestResultDetailsLst;     private RunStatusType runStatus;     private String errorMsg;     // Implementation of the member function to set the fetcher end time stamp     void setFetcherEndTimeStamp(Date fetcherEndTimeStamp) {         this.fetcherEndTimeStamp = fetcherEndTimeStamp;     }     // Other member function headers and implementations     // ... }
public class BaseEngine {     private String authToken;     private String user;     // Implementation of the member function to return the user name     String getUserName() {         return user;     }     // Other member function headers and implementations     // ... }
public class UnderFileSystemUtils {     // Member variables     // Implementation of the member function to create an empty file     void createEmptyFile(final String path) {         // Logic to create an empty file at the given path     }     // Other member function headers and implementations     // ... }
public class BiAdAdapterSwitcher {     // Member variables     boolean auto_disable_loadmore = false;     int page_now = 1;     EASY noad;     ADMOB withad;     onLoadMore loading_more;     boolean with_the_ad;     int layoutLoadMoreResId = 0;     RecyclerView.LayoutManager mManager;     Runnable refresh_default = new Runnable() {         @Override         public void run() {             reset();             if (loading_more != null) {                 final boolean success_onStart = loading_more.request_start(1, 0, 0, BiAdAdapterSwitcher.this, true);                 if (success_onStart) {                     page_now = 2;                     max_pages = 3;                 } else {                     if (auto_disable_loadmore)                         listview.disableLoadmore();                 }             }             listview.setRefreshing(false);         }     };     int max_pages = 3;     int container_data_items;     UltimateRecyclerView listview;     // Member functions     boolean request_start(int current_page_no, int itemsCount, final int maxLastVisiblePosition,                           final BiAdAdapterSwitcher this_module, final boolean onRefresh) {         // Implementation of request_start method         // ...     }     BiAdAdapterSwitcher onEnableLoadmore(final @LayoutRes int layoutResId, final int delay_trigger,                                          final onLoadMore loading_more_trigger_interface) {         // Implementation of onEnableLoadmore method         // ...     }     void run() {         // Implementation of run method         // ...     }     void setMaxPages(final int n) {         // Implementation of setMaxPages method         // ...     }     BiAdAdapterSwitcher EnableAutoDisableLoadMoreByMaxPages() {         // Implementation of EnableAutoDisableLoadMoreByMaxPages method         // ...     }     void emptyViewControl() {         // Implementation of emptyViewControl method         // ...     }     void scrollToTop() {         // Implementation of scrollToTop method         // ...     }     void maximum_size(LinearLayout l, V suppose_tobe_Adview, Activity activity) {         // Implementation of maximum_size method         // ...     }     void load_more_data_at_zero(final List<T> new_data_list) {         // Implementation of load_more_data_at_zero method         // ...     }     void load_more_data(final List<T> new_data_list) {         // Implementation of load_more_data method         // ...     }     BiAdAdapterSwitcher setCustomOnFresh(Runnable h) {         // Implementation of setCustomOnFresh method         // ...     }     View getV(final @LayoutRes int layoutResId) {         // Implementation of getV method         // ...     }     void reset() {         // Implementation of reset method         // ...     }     void init(final boolean adenabled) {         // Implementation of init method         // ...     }     BiAdAdapterSwitcher onEnableRefresh(final int delay_trigger) {         // Implementation of onEnableRefresh method         // ...     }     void removeALL() {         // Implementation of removeALL method         // ...     }     void insert_default(EASY sd, List<T> list) {         // Implementation of insert_default method with EASY parameter         // ...     }     void insert_default(ADMOB sd, List<T> list) {         // Implementation of insert_default method with ADMOB parameter         // ...     }          // Other member functions     // ... }
public class Cover {     private BufferedImage image;     private CoverArtImage coverArtImage;     private String name;     private List<MbImage> coverArtArchiveList;     private CoverType type;     private String value;     private String hash = "";     private String msg;     // ... other member variables and methods     /**      * Get image.      *      * @return BufferedImage object representing the image.      */     public BufferedImage getImage() {         return image;     } }
public class ObjectFactory {     private QName _Access_QNAME = new QName("http://platformlayer.org/auth/v1.0", "access");     private QName _CheckServiceAccessResponse_QNAME = new QName("http://platformlayer.org/auth/v1.0", "checkServiceAccessResponse");     private QName _RegistrationRequest_QNAME = new QName("http://platformlayer.org/auth/v1.0", "registrationRequest");     private QName _CheckServiceAccessRequest_QNAME = new QName("http://platformlayer.org/auth/v1.0", "checkServiceAccessRequest");     private QName _SignCertificateResponse_QNAME = new QName("http://platformlayer.org/auth/v1.0", "signCertificateResponse");     private QName _CertificateChainInfo_QNAME = new QName("http://platformlayer.org/auth/v1.0", "certificateChainInfo");     private QName _User_QNAME = new QName("http://platformlayer.org/auth/v1.0", "user");     private QName _AuthenticateRequest_QNAME = new QName("http://platformlayer.org/auth/v1.0", "authenticateRequest");     private QName _Auth_QNAME = new QName("http://platformlayer.org/auth/v1.0", "auth");     private QName _AuthenticateResponse_QNAME = new QName("http://platformlayer.org/auth/v1.0", "authenticateResponse");     private QName _RegistrationResponse_QNAME = new QName("http://platformlayer.org/auth/v1.0", "registrationResponse");     private QName _Roles_QNAME = new QName("http://platformlayer.org/auth/v1.0", "roles");     private QName _SignCertificateRequest_QNAME = new QName("http://platformlayer.org/auth/v1.0", "signCertificateRequest");     private QName _ValidateTokenResponse_QNAME = new QName("http://platformlayer.org/auth/v1.0", "validateTokenResponse");     private QName _ValidateAccess_QNAME = new QName("http://platformlayer.org/auth/v1.0", "validateAccess");     // ... other member variables and methods     /**      * Create an instance of {@link CertificateInfo}.      *      * @return JAXBElement<CertificateInfo> object representing the created CertificateInfo instance.      */     public JAXBElement<CertificateInfo> createCertificateInfo() {         return new JAXBElement<>(_CertificateInfo_QNAME, CertificateInfo.class, null, new CertificateInfo());     } }
public class Graphics2DRenderer {     private Dimension dim;     private XHTMLPanel panel;     // Other member variables and functions     /**      * Gets the SharedContext for layout and rendering.      *       * @return The SharedContext object used for layout and rendering.      */     public SharedContext getSharedContext() {         return panel != null ? panel.getSharedContext() : null;     } }
public class ApplicationManagementService {     // Member variables and other member functions     /**      * Get ApplicationManagementService instance.      *       * @return An instance of ApplicationManagementService.      */     public static ApplicationManagementService getInstance() {         // Implement your logic to get or create an instance of ApplicationManagementService         // Return the instance         return new ApplicationManagementService();     } }
public class MemoryLocksService {     private static final String INSTRUMENTATION_GROUP = "locks";     private MemoryLocks locks;     // Member functions and other member variables     /**      * Destroy the memory locks service.      */     public void destroy() {         // Implement your logic to destroy the memory locks service         // Cleanup resources, release locks, etc.     } }
public class BufferedByteWriter {     private ByteBuffer mWriter;     private byte[] mBuffer;     // Member functions and other member variables     /**      * Write the 16-bit length of the given data followed by the data itself.      *      * @param value The data to be written.      * @return The instance of BufferedByteWriter for method chaining.      */     public BufferedByteWriter put16(byte value) {         // Convert byte value to short and write to buffer         mWriter.putShort((short) value);         return this;     }     /**      * Write the 16-bit length of the given data followed by the data itself.      *      * @param value The data to be written.      * @return The instance of BufferedByteWriter for method chaining.      */     public BufferedByteWriter put16(short value) {         // Write short value to buffer         mWriter.putShort(value);         return this;     }     // Other member functions and implementation details }
public class VarInt {     private int originallyEncodedSize;     private long value;     // Member functions and other member variables     /**      * Gets the minimum encoded size of the given value.      *      * @return The encoded value as a byte array.      */     public byte[] encode() {         // Implementation of encoding logic to obtain the minimum encoded size of the given value         // and return it as a byte array         // ...     }     /**      * Gets the size in bytes of the encoded value.      *      * @return The size in bytes of the encoded value.      */     public int getSizeInBytes() {         // Implementation to calculate and return the size in bytes of the encoded value         // ...     }     /**      * Gets the originally encoded size of the value.      *      * @return The originally encoded size of the value.      */     public int getOriginallyEncodedSize() {         // Return the originally encoded size of the value         return originallyEncodedSize;     }     // Other member functions and implementation details }
public class CoordinatorEngineService {     // Member variables     // Member functions and other member variables     /**      * Return a Coordinator engine.      *      * @return The Coordinator engine object.      */     public CoordinatorEngine getSystemCoordinatorEngine() {         // Implementation to obtain and return the Coordinator engine object         // ...     }     /**      * Initialize the CoordinatorEngineService with the provided Services object.      *      * @param services The Services object to initialize with.      */     public void init(Services services) {         // Implementation of initialization logic using the provided Services object         // ...     }     /**      * Get the interface class of the CoordinatorEngineService.      *      * @return The interface class of the CoordinatorEngineService.      */     public Class<? extends Service> getInterface() {         // Implementation to obtain and return the interface class of the CoordinatorEngineService         // ...     }     /**      * Destroy the CoordinatorEngineService.      */     public void destroy() {         // Implementation of destruction logic for the CoordinatorEngineService         // ...     }     // Other member functions and implementation details }
public class Coin {     // Member variables     public static final Coin MICROCOIN = MILLICOIN.divide(1000);     public static final Coin FIFTY_COINS = COIN.multiply(50);     public static final Coin ZERO = Coin.valueOf(0);     public static final int SMALLEST_UNIT_EXPONENT = 8;     public static final Coin COIN = Coin.valueOf(COIN_VALUE);     public static final Coin NEGATIVE_SATOSHI = Coin.valueOf(-1);     public static final long MAX_SATOSHIS = COIN_VALUE * NetworkParameters.MAX_COINS;     public static final MonetaryFormat PLAIN_FORMAT = MonetaryFormat.BTC.minDecimals(0).repeatOptionalDecimals(1,8).noCode();     public static final long COIN_VALUE = LongMath.pow(10, SMALLEST_UNIT_EXPONENT);     public static final MonetaryFormat FRIENDLY_FORMAT = MonetaryFormat.BTC.minDecimals(2).repeatOptionalDecimals(1,6).postfixCode();     public static final Coin CENT = COIN.divide(100);     public static final Coin SATOSHI = Coin.valueOf(1);     public static final Coin MILLICOIN = COIN.divide(1000);     // Member functions     /**      * Convert an amount expressed in the way humans are used to into satoshis.      *      * @param str The amount to convert as a string in human-readable format.      * @return The amount converted to satoshis as a Coin object.      */     public static Coin parseCoin(final String str) {         // Implementation to parse the input string and convert it to satoshis as a Coin object         // ...     }     // Other member functions and implementation details }
public class StartBrowser {     // Member variable     private static final Logger LOG = Logger.getLogger(StartBrowser.class.getName());     // Member function     /**      * Open an URL in the system's default browser.      *      * @param url The URL to be opened in the default browser.      * @throws IOException        If an I/O error occurs while opening the URL.      * @throws URISyntaxException If the given URL is not a valid URI.      */     public static void openUrlInBrowser(String url) throws IOException, URISyntaxException {         // Implementation to open the URL in the default browser         if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {             Desktop.getDesktop().browse(new URI(url));         } else {             LOG.log(Level.SEVERE, "Opening URL in system's default browser is not supported.");         }     } }
public class QQ {     // Member variables     private static final int TYPE = 2;     private static final int FILE = 5;     private ExtensionInfo ext;     private static final int EXPR = 0;     private static final int DECL = 4;     private Position pos;     private static final int MEMB = 3;     private static final int STMT = 1;     // Member functions     /**      * Return a position for a type object. Generate one if the type doesn't have one.      *      * @param fmt    The format string for generating the type object.      * @param os     The objects to be used for substitution in the format string.      * @return       The generated or existing position for the type object.      */     public Position getTypePosition(String fmt, Object... os) {         // Implementation to return the position for a type object         return pos != null ? pos : Position.COMPILER_GENERATED;     }     public Stmt parseStmt(String fmt, Object... os) {         // Implementation for parseStmt with format string and objects     }     public Stmt parseStmt(String fmt, List<?> subst) {         // Implementation for parseStmt with format string and list of objects     }     public ClassDecl parseDecl(String fmt, Object... os) {         // Implementation for parseDecl with format string and objects     }     public ClassDecl parseDecl(String fmt, List<?> subst) {         // Implementation for parseDecl with format string and list of objects     }     public Expr parseExpr(String fmt, Object... os) {         // Implementation for parseExpr with format string and objects     }     public Expr parseExpr(String fmt, List<?> subst) {         // Implementation for parseExpr with format string and list of objects     }     public TypeNode parseType(String fmt, Object... os) {         // Implementation for parseType with format string and objects     }     public TypeNode parseType(String fmt, List<?> subst) {         // Implementation for parseType with format string and list of objects     }     public ClassMember parseMember(String fmt, Object... os) {         // Implementation for parseMember with format string and objects     }     public ClassMember parseMember(String fmt, List<?> subst) {         // Implementation for parseMember with format string and list of objects     }     public SourceFile parseFile(String fmt, Object... os) {         // Implementation for parseFile with format string and objects     }     public SourceFile parseFile(String fmt, List<?> subst) {         // Implementation for parseFile with format string and list of objects     }     public Node parse(int kind, String fmt, Object... subst) {         // Implementation for parse with kind, format string, and objects     }     public Lexer lexer(String fmt, Position pos, Object... subst) {         // Implementation for lexer with format string, position, and objects     } }
public class SPResponse {     private Integer errorCode;     private String errorMsg;     public boolean isSPErrorOut() {         // Implementation of isSPErrorOut         // Return true if errorCode is not null, false otherwise         return errorCode != null;     }     public void setErrorMsg(String errorMsg) {         // Implementation of setErrorMsg         this.errorMsg = errorMsg;     }     public String toString() {         // Implementation of toString         // Return a string representation of SPResponse object         return "SPResponse [errorCode=" + errorCode + ", errorMsg=" + errorMsg + "]";     }     public void setErrorCode(Integer errorCode) {         // Implementation of setErrorCode         this.errorCode = errorCode;     }     public String getErrorMsg() {         // Implementation of getErrorMsg         return errorMsg;     } }
public class SecurityToken {     private String tokenType;     private Element unattachedReference;     private String issuerAddress;     private X509Certificate x509cert;     private Element token;     private Principal principal;     private String encrKeySha1Value;     private Map<String,Object> properties;     private Key key;     private Date expires;     private byte[] secret;     private SecurityContext securityContext;     private String BOOTSTRAP_TOKEN_ID="bootstrap_security_token_id";     private Element attachedReference;     private byte[] data;     private int tokenHash;     private long serialVersionUID=3820740387121650613L;     private String wsuId;     private String id;     private String transformedTokenIdentifier;     private Date created;     private Crypto crypto;     // Implementation of setTokenHash     public void setTokenHash(int tokenHash) {         this.tokenHash = tokenHash;     } }
public class DiffBuilder {     private ComparisonResult[] CHECK_FOR_IDENTICAL = new ComparisonResult[]{ComparisonResult.SIMILAR,ComparisonResult.DIFFERENT};     private Predicate<Attr> attributeFilter;     private NodeMatcher nodeMatcher;     private EnumSet<ComparisonResult> comparisonResultsToCheck;     private ComparisonResult[] comparisonResultsToCheck = CHECK_FOR_IDENTICAL;     private List<ComparisonListener> differenceListeners = new ArrayList<ComparisonListener>();     private List<ComparisonListener> comparisonListeners = new ArrayList<ComparisonListener>();     private Source testSource;     private boolean normalizeWhitespace;     private DifferenceEvaluator differenceEvaluator = DifferenceEvaluators.Default;     private Source controlSource;     private ComparisonResult[] CHECK_FOR_SIMILAR = new ComparisonResult[]{ComparisonResult.DIFFERENT};     private boolean ignoreComments;     private List<Difference> results;     private Map<String, String> namespaceContext;     private Predicate<Node> nodeFilter;     private boolean ignoreWhitespace;     private ComparisonController comparisonController = ComparisonControllers.Default;     // Implementation of setTestSource     public DiffBuilder setTestSource(Object object) {         this.testSource = Input.from(object).build();         return this;     } }
public class SatelliteInfo {     private int elevation;     private int noise;     private int azimuth;     private String id;     // Implementation of setId     public void setId(String id) {         this.id = id;     }     // Implementation of getId     public String getId() {         return id;     } }
public class AbstractObservable {     private MessageObserver incomingObserver;     // Implementation of getMessageObserver     public MessageObserver getMessageObserver() {         return incomingObserver;     }     // Implementation of setMessageObserver     public void setMessageObserver(MessageObserver observer) {         this.incomingObserver = observer;     }     // Implementation of getLogger     public Logger getLogger() {         // TODO: Return the appropriate logger based on your implementation         return null;     }     // Implementation of deactivate     public void deactivate() {         // TODO: Implement the deactivate method based on your requirements     }     // Implementation of activate     public void activate() {         // TODO: Implement the activate method based on your requirements     } }
public class ObjectFactory {     private QName _User_QNAME = new QName("http://platformlayer.org/auth/v1.0", "user");     private QName _AuthenticateRequest_QNAME = new QName("http://platformlayer.org/auth/v1.0", "authenticateRequest");     private QName _Roles_QNAME = new QName("http://platformlayer.org/auth/v1.0", "roles");     private QName _CheckServiceAccessResponse_QNAME = new QName("http://platformlayer.org/auth/v1.0", "checkServiceAccessResponse");     private QName _SignCertificateRequest_QNAME = new QName("http://platformlayer.org/auth/v1.0", "signCertificateRequest");     private QName _CertificateChainInfo_QNAME = new QName("http://platformlayer.org/auth/v1.0", "certificateChainInfo");     private QName _CheckServiceAccessRequest_QNAME = new QName("http://platformlayer.org/auth/v1.0", "checkServiceAccessRequest");     private QName _RegistrationResponse_QNAME = new QName("http://platformlayer.org/auth/v1.0", "registrationResponse");     private QName _RegistrationRequest_QNAME = new QName("http://platformlayer.org/auth/v1.0", "registrationRequest");     private QName _AuthenticateResponse_QNAME = new QName("http://platformlayer.org/auth/v1.0", "authenticateResponse");     private QName _ValidateTokenResponse_QNAME = new QName("http://platformlayer.org/auth/v1.0", "validateTokenResponse");     private QName _Auth_QNAME = new QName("http://platformlayer.org/auth/v1.0", "auth");     private QName _ValidateAccess_QNAME = new QName("http://platformlayer.org/auth/v1.0", "validateAccess");     private QName _SignCertificateResponse_QNAME = new QName("http://platformlayer.org/auth/v1.0", "signCertificateResponse");     private QName _Access_QNAME = new QName("http://platformlayer.org/auth/v1.0", "access");     // Implementation of createRoles     public JAXBElement<RoleList> createRoles(RoleList value) {         return new JAXBElement<>(_Roles_QNAME, RoleList.class, null, value);     }     // TODO: Implement other member functions based on their descriptions }
public class PrivilegedAccessor {     // ... member variables ...     public static void setValue(Object instance, String fieldName, Object value) throws NoSuchFieldException, IllegalAccessException {         Field field = getFieldImpl(instance.getClass(), fieldName);         field.setAccessible(true);         field.set(instance, value);     }     // ... other member functions ... }
public class StoredTransactionOutput {     private Sha256Hash hash;     private int height;     private static final int NONCOINBASE_HEIGHT = -200;     private static final long serialVersionUID = -8744924157056340509L;     private long index;     private BigInteger value;     private byte[] scriptBytes;     public byte[] getScriptBytes() {         return scriptBytes;     }     // ... other member functions ...     @Override     public int hashCode() {         return Objects.hash(hash, height, index, value, scriptBytes);     }     @Override     public boolean equals(Object o) {         if (this == o) return true;         if (!(o instanceof StoredTransactionOutput)) return false;         StoredTransactionOutput other = (StoredTransactionOutput) o;         return Objects.equals(hash, other.hash) &&                 height == other.height &&                 index == other.index &&                 Objects.equals(value, other.value) &&                 Arrays.equals(scriptBytes, other.scriptBytes);     }     @Override     public String toString() {         return "StoredTransactionOutput{" +                 "hash=" + hash +                 ", height=" + height +                 ", index=" + index +                 ", value=" + value +                 ", scriptBytes=" + Arrays.toString(scriptBytes) +                 '}';     }     public void serializeToStream(OutputStream bos) throws IOException {         bos.write(scriptBytes);     }     // ... other member functions ... }
public class StandardAttributeResolver {     private NamespaceHandler nsh;     private UserInterface ui;     private UserAgentCallback uac;     // ... other member functions ...     public String getAttributeValue(Object e, String attrName) {         return getAttributeValue(e, null, attrName);     }     public String getAttributeValue(Object e, String namespaceURI, String attrName) {         // Implementation to get the active attribute based on the provided description         // ...         return null; // Placeholder return statement     }     // ... other member functions ... }
public class Stockfish {     private BufferedReader processReader;     private String PATH = "build/resources/main/engine/stockfish";     private Process engineProcess;     private OutputStreamWriter processWriter;     // ... other member functions ...     public void stopEngine() {         // Implementation to stop the engine based on the provided description         // ...     }     public String getOutput(int waitTime) {         // Implementation to get output from the engine based on the provided description         // ...         return null; // Placeholder return statement     }     public float getEvalScore(String fen, int waitTime) {         // Implementation to get evaluation score based on the provided description         // ...         return 0.0f; // Placeholder return statement     }     public String getLegalMoves(String fen) {         // Implementation to get legal moves based on the provided description         // ...         return null; // Placeholder return statement     }     public boolean startEngine() {         // Implementation to start the engine based on the provided description         // ...         return false; // Placeholder return statement     }     public void drawBoard(String fen) {         // Implementation to draw the board based on the provided description         // ...     }     public String getBestMove(String fen, int waitTime) {         // Implementation to get the best move based on the provided description         // ...         return null; // Placeholder return statement     }     // ... other member functions ... }
null
null
public class ModelUtils {     private String userRepoPrefix = Constants.DEFAULT_USER_REPOSITORY_PREFIX;     // Other member variables     // Member function implementations     /**      * Test if a repository path is for a personal repository.      *      * @param username The username to check.      * @param name     The name of the repository to check.      * @return true if the repository path is for a personal repository, false otherwise.      */     public boolean isUsersPersonalRepository(String username, String name) {         // Implementation logic to test if repository path is for a personal repository         // ...     }     /**      * Get the username from a repository path.      *      * @param path The repository path to extract the username from.      * @return The username extracted from the repository path.      */     public String getUserNameFromRepoPath(String path) {         // Implementation logic to extract username from repository path         // ...     }     /**      * Set the prefix for the user repository.      *      * @param prefix The prefix to set for the user repository.      */     public void setUserRepoPrefix(String prefix) {         // Implementation logic to set the user repository prefix         // ...     }     /**      * Get the personal path for a user.      *      * @param username The username to get the personal path for.      * @return The personal path for the user.      */     public String getPersonalPath(String username) {         // Implementation logic to get the personal path for a user         // ...     }     /**      * Get the user repository prefix.      *      * @return The user repository prefix.      */     public String getUserRepoPrefix() {         // Implementation logic to get the user repository prefix         // ...     } }
public class RegexUtils {     private Pattern mTcpdumpHostnamePattern;     private Matcher mIPv4Matcher;     private String WHITELIST_HOSTNAME_REGEX="[a-zA-Z0-9\\*\\?]|[a-zA-Z0-9\\*\\?][a-zA-Z0-9\\-\\_\\.\\*\\?]{0,61}[a-zA-Z0-9\\*\\?]";     private String HOSTS_PARSER="^\\s*((?:" + IPV4_REGEX + ")|(?:"+ SIMPLE_IPV6_REGEX+ "))\\s+("+ HOSTNAME_REGEX+ ")\\s*(?:\\#.*)*\\s*$";     private Matcher mWhitelistHostnameMatcher;     private String IPV6_REGEX="(((?=(?>.*?::)(?!.*::)))(::)?([0-9A-F]{1,4}::?){0,5}|([0-9A-F]{1,4}:){6})(\2([0-9A-F]{1,4}(::?|$)){0,2}|((25[0-5]|(2[0-4]|1\\d|[1-9])?\\d)(\\.|$)){4}|[0-9A-F]{1,4}:[0-9A-F]{1,4})(?<![^:]:|\\.)";     private Pattern mHostnamePattern;     private Pattern hostsParserPattern;     private Matcher mTcpdumpHostnameMatcher;     private Matcher mIPv6Matcher;     private String IPV4_REGEX="(?:25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}";     private Matcher mHostnameMatcher;     private String HOSTS_PARSER_WHITELIST_IMPORT="^\\s*((?:" + IPV4_REGEX + ")|(?:"+ SIMPLE_IPV6_REGEX+ ")|(?:"+ Constants.WHITELIST_ENTRY+ "))\\s+("+ WHITELIST_HOSTNAME_REGEX+ ")\\s*(?:\\#.*)*\\s*$";     private Pattern hostsParserWhitelistImportPattern;     private String SIMPLE_IPV6_REGEX="[0-9A-F\\:\\.]+";     private String TCPDUMP_HOSTNAME_REGEX="(A\\?|AAAA\\?)\\s(\\S+)\\.\\s";     private Pattern mIPv6Pattern;     private Pattern mIPv4Pattern;     private String HOSTNAME_REGEX="[a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-\\_\\.]{0,61}[a-zA-Z0-9]";     private Pattern mWhitelistHostnamePattern;     public boolean isValidIPv6(String input) {         return Pattern.matches(IPV6_REGEX, input);     } }
public class MapMaker {     private boolean useCustomMap;     private Strength valueStrength;     private int initialCapacity = UNSET_INT;     private Equivalence<Object> keyEquivalence;     private int UNSET_INT = -1;     private int concurrencyLevel = UNSET_INT;     private Strength keyStrength;     private int DEFAULT_INITIAL_CAPACITY = 16;     private int DEFAULT_CONCURRENCY_LEVEL = 4;     // ... other member variables and functions     /**      * Specifies that each key (not value) stored in the map should be wrapped in a {@link WeakReference}      * (by default, strong references are used).      * Warning: when this method is used, the resulting map will use identity ( {@code ==}) comparison to      * determine equality of keys, which is a technical violation of the  {@link Map} specification, and      * may not be what you expect.      *      * @return This MapMaker instance for method chaining.      */     public MapMaker weakKeys() {         this.keyStrength = Strength.WEAK;         this.useCustomMap = true;         return this;     }     // ... other member functions }
public class TestHessenbergSimilarDecomposition_D64 {     private Random rand = new Random(5745784);     // ... other member variables and functions     /**      * Decomposes the matrix, extracts H and Q, then sees if it can recompute A using similar matrix stuff.      */     public void testInputUnmodified() {         // implementation here     }     /**      * Decomposes the matrix, extracts H and Q, then sees if it can recompute A using similar matrix stuff.      */     public void testH() {         // implementation here     }     /**      * Decomposes the matrix, extracts H and Q, then sees if it can recompute A using similar matrix stuff.      */     public void testHouseholderVectors() {         // implementation here     }     /**      * Decomposes the matrix, extracts H and Q, then sees if it can recompute A using similar matrix stuff.      *      * @param A The DenseMatrix64F input matrix to be decomposed and recomputed.      */     public void checkItAll(DenseMatrix64F A) {         // implementation here     } }
public class Interaction {     private long geneB;     private String pmids;     private long geneA;     private String source;     private String interactionType;     private String experimentTypes;     // ... other member variables and functions     /**      * Gets the PMIDs.      *      * @return The PMIDs as a String.      */     public String getPmids() {         return pmids;     }     // ... other member functions }
public class Result {     private Map<ResultObserver, ResultObserverSettings> observers;     private Result globalLog = new Result();     private List<ResultEntry> log;     // ... other member variables and functions     /**      * Get by index.      *      * @return An array of objects representing the elements in this result.      */     public Object[] toArray() {         return log.toArray();     }     /**      * Get by index.      *      * @param arg0 An array into which the elements of this result are to be stored.      * @return An array of objects representing the elements in this result.      */     public <T> T[] toArray(T[] arg0) {         return log.toArray(arg0);     }     // ... other member functions }
public class Configuration {     private static final String URL_LOADED = "configuration.load.url";     private ConfigurationHandler config = getFactory().getConfigurationHandler();     private static final String FILE_LOADED = "configuration.load.file";     private static final String URL_SAVED = "configuration.save.url";     private static final String FILE_SAVED = "configuration.save.file";     // ... other member variables and functions     /**      * Create a four-component configuration key.      *      * @param key The key to be created.      */     public void setString(ConfigurationKey key, String newValue) {         config.setString(key.toString(), newValue);     }     /**      * Create a four-component configuration key.      *      * @param key The key to be created.      * @param newValue The new value to set for the key.      */     public void setInteger(ConfigurationKey key, int newValue) {         config.setInteger(key.toString(), newValue);     }     /**      * Create a four-component configuration key.      *      * @param key The key to be created.      * @param newValue The new value to set for the key.      */     public void setDouble(ConfigurationKey key, double newValue) {         config.setDouble(key.toString(), newValue);     }     /**      * Create a four-component configuration key.      *      * @param key The key to be created.      * @param newValue The new value to set for the key.      */     public void setBoolean(ConfigurationKey key, boolean newValue) {         config.setBoolean(key.toString(), newValue);     }     /**      * Create a four-component configuration key.      *      * @param key The key to be created.      * @param pcl The property change listener to add for the key.      */     public void addListener(ConfigurationKey key, PropertyChangeListener pcl) {         config.addListener(key.toString(), pcl);     }     /**      * Create a four-component configuration key.      *      * @param key The key to be created.      * @param pcl The property change listener to remove for the key.      */     public void removeListener(ConfigurationKey key, PropertyChangeListener pcl) {         config.removeListener(key.toString(), pcl);     }     // ... other member functions }
public class MaxFn {     private Constant val;     private String fldname;     // ... other member variables and functions     /**      * Returns the field's name, prepended by "maxof".      *      * @return The field's name prepended by "maxof".      */     public String value() {         return "maxof" + fldname;     }     /**      * Process the first scan.      *      * @param s The scan to be processed.      */     public void processFirst(Scan s) {         // Implementation of processFirst() method     }     /**      * Process the next scan.      *      * @param s The scan to be processed.      */     public void processNext(Scan s) {         // Implementation of processNext() method     } }
public class DefaultTcpUdpSocket {     private OfferAnswer m_offerAnswer;     private int m_relayWaitTime;     private long m_startTime = System.currentTimeMillis();     private Socket m_socket;     private boolean m_finishedWaitingForSocket;     private boolean m_gotAnswer;     private Offerer m_offerer;     private Object m_socketLock = new Object();     private Logger m_log = LoggerFactory.getLogger(getClass());     private Object m_answerLock = new Object();     private long offerTimeoutTime;     // ... other member variables and functions     /**      * Returns the elapsed time from the start time. This method assumes that the start time was previously set.      *      * @return The elapsed time from the start time.      */     public long getElapsedTime() {         return System.currentTimeMillis() - m_startTime;     }     /**      * Processed the socket.      *      * @param sock The socket to be processed.      * @return True if the socket was processed successfully, false otherwise.      */     public boolean processedSocket(final Socket sock) {         // Implementation of processedSocket() method     }     /**      * Creates a new socket for the given URI.      *      * @param uri The URI to create the socket for.      * @return The created socket.      */     public Socket newSocket(final URI uri) {         // Implementation of newSocket() method     }     /**      * Notifies the socket lock.      */     public void notifySocketLock() {         // Implementation of notifySocketLock() method     }     /**      * Handles UDP socket.      *      * @param sock The UDP socket to be handled.      */     public void onUdpSocket(final Socket sock) {         // Implementation of onUdpSocket() method     }     /**      * Handles failed offer/answer.      *      * @param offerAnswer The failed offer/answer.      */     public void onOfferAnswerFailed(final OfferAnswer offerAnswer) {         // Implementation of onOfferAnswerFailed() method     }     /**      * Handles failed transaction response.      *      * @param response The failed transaction response.      */     public void onTransactionFailed(final OfferAnswerMessage response) {         // Implementation of onTransactionFailed() method     }     /**      * Waits for a socket to be available for the given SIP URI.      *      * @param sipUri The SIP URI to wait for the socket.      * @return The socket when available.      */     public Socket waitForSocket(final URI sipUri) {         // Implementation of waitForSocket() method     }     /**      * Handles TCP socket.      *      * @param sock The TCP socket to be handled.      */     public void onTcpSocket(final Socket sock) {         // Implementation of onTcpSocket() method     }     /**      * Handles succeeded transaction response.      *      * @param response The succeeded transaction response.      */     public void onTransactionSucceeded(final OfferAnswerMessage response) {         // Implementation of onTransactionSucceeded() method     } }
public class TimeTest {     private Time time;     public void setUp() {         // Set up test environment     }     public void testSetInvalidMinutes() {         // Test method for Time.getMinutes() with invalid minutes     }     public void testFormatTimeWithDecimals() {         // Test method for Time.formatTimeWithDecimals()     }     public void testParseTimeWithDecimals() {         // Test method for Time.parseTimeWithDecimals()     }     public void testSetInvalidSeconds() {         // Test method for Time.setSeconds() with invalid seconds     }     public void testSetSeconds() {         // Test method for Time.setSeconds()     }     public void testSetTime() {         // Test method for Time.setTime()     }     public void testGetMilliseconds() {         // Test method for Time.getMilliseconds()     }     public void testFormatTimeNoDecimals() {         // Test method for Time.formatTimeNoDecimals()     }     public void testEquals() {         // Test method for Time.equals()     }     public void testParseTimeWithOneDecimal() {         // Test method for Time.parseTimeWithOneDecimal()     }     public void testSetNegativeMinutes() {         // Test method for Time.setMinutes() with negative minutes     }     public void testFormatTimeWithOneDecimal() {         // Test method for Time.formatTimeWithOneDecimal()     }     public void testSetMinutes() {         // Test method for Time.setMinutes()     }     public void testSetNegativeHour() {         // Test method for Time.setHour() with negative hour     }     public void testGetHour() {         // Test method for Time.getHour()     }     public void testSetNegativeSeconds() {         // Test method for Time.setSeconds() with negative seconds     }     public void testDateRoundTrip() {         // Test method for Time.toDate() round trip     }     public void testToDate() {         // Test method for Time.toDate()     }     public void testGetSeconds() {         // Test method for Time.getSeconds()     }     public void testSetHour() {         // Test method for Time.setHour()     }     public void testSetInvalidHour() {         // Test method for Time.setHour() with invalid hour     }     public void testParseTimeWithoutDecimals() {         // Test method for Time.parseTimeWithoutDecimals()     } }
public class JedisIndex {     private Jedis jedis;     public void deleteAllKeys() {         // Delete all keys in Redis     }     public Map<String, Integer> getCounts(String term) {         // Get counts for a given term across all indexed URLs     }     public Set<String> termSet() {         // Get the set of all terms in the index     }     public boolean isIndexed(String url) {         // Check if a given URL is indexed     }     public List<Object> pushTermCounterToRedis(TermCounter tc) {         // Push TermCounter object to Redis     }     public Integer getCount(String url, String term) {         // Get count of a given term for a specific URL     }     public void indexPage(String url, Elements paragraphs) {         // Index a webpage by storing its URL and term counts to Redis     }     public Set<String> getURLs(String term) {         // Get the set of URLs that contain a given term     }     public void add(String term, TermCounter tc) {         // Add a term and its TermCounter to the index     }     public Set<String> urlSetKeys() {         // Get the set of all URL set keys in Redis     }     public String termCounterKey(String url) {         // Get the Redis key for a TermCounter of a given URL     }     public void deleteTermCounters() {         // Delete all TermCounter keys in Redis     }     public String urlSetKey(String term) {         // Get the Redis key for a URL set of a given term     }     public void main(String[] args) {         // Entry point for the main program     }     public void printIndex() {         // Print the entire index for development and testing     }     public void loadIndex(JedisIndex index) {         // Load the index from Redis     }     public void deleteURLSets() {         // Delete all URL set keys in Redis     }     public Map<String, Integer> getCountsFaster(String term) {         // Get counts for a given term across all indexed URLs faster (not suitable for production)     } }
@Service public class SiteService {     @Autowired     private SiteRepository siteRepository;     private Logger log = LoggerFactory.getLogger(SiteService.class);     public Site save(Site site) {         // Save a site object to the repository     }     public Site findOneByHost(String host) {         // Find and return a site object by host from the repository     }     public Page<Site> findAll(Pageable pageable) {         // Find and return all site objects with pagination from the repository     }     public void delete(String id) {         // Delete a site object by id from the repository     }     public Site getWebNauAn() {         // Get a site object with the id "webNauAn" from the repository     } }
public class Problem {     private ResultFunction resultFunction;     private ActionsFunction actionsFunction;     private StepCostFunction stepCostFunction;     private GoalTest goalTest;     private Object initialState;     //... other member variables and constructors     public boolean isGoalState(Object state) {         // Check if the given state is a goal state according to the goal test     }     public GoalTest getGoalTest() {         // Return the goal test used in this problem     }     public Object getInitialState() {         // Return the initial state of this problem     }     public StepCostFunction getStepCostFunction() {         // Return the step cost function used in this problem     }     public ActionsFunction getActionsFunction() {         // Return the actions function used in this problem     }     //... other member functions }
public class TimeUtils {     private static final long MIN = 1000 * 60L;     private static final long ONEYEAR = ONEDAY * 365L;     private static final long ONEHOUR = HALFHOUR * 2;     private static final long HALFHOUR = MIN * 30L;     private static final long ONEDAY = ONEHOUR * 24L;     private TimeZone timezone;     private ResourceBundle translation;     //... other member variables and constructors     public int minutesAgo(Date date, long endTime, boolean roundup) {         // Calculate the number of minutes between the given date and the end time,         // rounding up if specified, and return as an integer     }     public int minutesAgo(Date date, boolean roundup) {         // Calculate the number of minutes between the given date and now,         // rounding up if specified, and return as an integer     }     public String timeAgoCss(Date date) {         // Return the string representation of the CSS class for the time ago         // relative to the given date     }     public String duration(int days) {         // Return the string representation of the duration in days     }     public String yesterday() {         // Return the string representation of "yesterday"     }     public boolean isYesterday(Date date, TimeZone timezone) {         // Check if the given date is "yesterday" relative to the specified timezone     }     public int convertFrequencyToMinutes(String frequency) {         // Convert the frequency string to minutes and return as an integer     }     public String inFuture(Date date) {         // Return the string representation of the duration between now and the date     }     public String translate(String key, String defaultValue) {         // Translate the given key using the default value     }     public String translate(int val, String key, String defaultPattern) {         // Translate the given key using the default pattern and value     }     public int daysAgo(Date date) {         // Calculate the number of days between the given date and now, and return as an integer     }     public String today() {         // Return the string representation of "today"     }     public boolean isToday(Date date, TimeZone timezone) {         // Check if the given date is "today" relative to the specified timezone     }     public int hoursAgo(Date date, boolean roundup) {         // Calculate the number of hours between the given date and now,         // rounding up if specified, and return as an integer     }     //... other member functions }
public class InternalErrorHandler {     // ... member variables     // ... constructor and other member functions     public void handleUnexpectedCondition(int errorCode) {         // Handle an unexpected condition by printing the error code     } }
public static void resetStaticMembers() {     parentScope = 0;     functionBracePositions.clear();     funcObjects.clear();     functionNum = 0;     functionVarMappings.clear();     lastTokenCount = 0;     replacedTokens.clear(); }
public class UserInfo {     private static final String EMAIL="email_address";     public boolean isUserAuthenticated(HttpServletRequest request) {         //implementation     }     public void loginUser(String emailAddress, HttpServletRequest request) {         //implementation     }     public String getEmailId(HttpServletRequest request) {         //implementation     }     public void logoutUser(HttpServletRequest request) {         // implementation     }          private void clearSession(HttpServletRequest request) {         // implementation     }          private void invalidateSession(HttpServletRequest request) {         // implementation     }     // Logs out the User.     public void logoutUser(HttpServletRequest request) {         clearSession(request);         invalidateSession(request);     } }
public class DataTypesFactoryEUMLImpl {     EUMLModelImplementation modelImpl;     // Other member variables and functions     public int convertMultiplicityRangeBoundToInt(String str) {         // Implementation of converting a MultiplicityRange bound string to an integer         // TODO: Implement the logic for converting the bound string to an integer         // and return the integer value.     } }
public String getMainMethodClassName() {     return mainMethodClassName; }
public static byte getBitfieldWithSetBit(int bitIndex) {     return (byte) (1 << bitIndex); }
public Class getNotationProvider(int type, NotationName notationName) {     Map<Integer, Class> providersMap = allLanguages.get(notationName);     if (providersMap != null) {         Class providerClass = providersMap.get(type);         if (providerClass != null) {             return providerClass;         }     }     LOG.warning("No notation provider found for type " + type + " and notation " + notationName);     return null; }
public void saveFileFromByteArray(String name, byte[] arrFile) {     try {         this.fos = new FileOutputStream(name);         this.fos.write(arrFile);         this.fos.close();     } catch (IOException e) {         e.printStackTrace();     } }
public void removeChild(DirectedAcyclicGraphNode<T> child) {     mChildren.remove(child); }
public Object invokeMethod(Object instance, String methodName, Class[] classTypes, Object[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {     Method method = instance.getClass().getMethod(methodName, classTypes);     return method.invoke(instance, args); }
public void addOperation(String name, OperationSignature sig) {     OperationStats stats = operations.computeIfAbsent(sig, k -> new HashMap<>()).computeIfAbsent(name, k -> new OperationStats()); }
public Script createMultiSigInputScript(List<TransactionSignature> signatures) {     ScriptBuilder inputScriptBuilder = new ScriptBuilder();     inputScriptBuilder.smallNum(signatures.size());     for (TransactionSignature signature : signatures) {         inputScriptBuilder.data(signature.encodeToBitcoin());     }     inputScriptBuilder.smallNum(chunks.size());     for (ScriptChunk chunk : chunks) {         inputScriptBuilder.addChunk(chunk);     }     inputScriptBuilder.smallNum(chunks.size());     for (ScriptChunk chunk : chunks) {         if (chunk.isPushData()) {             inputScriptBuilder.data(chunk.data);         } else {             inputScriptBuilder.op(chunk.opcode);         }     }     inputScriptBuilder.op(OP_CHECKMULTISIG);     return inputScriptBuilder.build(); }
/**  * Test method for {@link net.sf.marineapi.nmea.util.Time#setHour(int)}.  */ void testSetHour() {     Time time = new Time(23, 59, 59, 0);     // Set the hour to a valid value and check that it was set correctly     time.setHour(12);     assertEquals(12, time.getHour());     // Set the hour to an invalid value and check that an exception is thrown     try {         time.setHour(24);         fail("Expected IllegalArgumentException was not thrown");     } catch (IllegalArgumentException e) {         // Expected exception, do nothing     } }
public <T extends TypedItem> List<T> listItems(Class<T> clazz, boolean includeDeleted) {     return platformLayerClient.listItems(clazz, includeDeleted); }      public <T extends TypedItem> List<T> listItems(Class<T> clazz) {     return platformLayerClient.listItems(clazz); }      public <T extends TypedItem> List<T> listItems(Class<T> clazz, PlatformLayerKey parent) {     return platformLayerClient.listItems(clazz, parent); }      public <T extends TypedItem> List<T> listItems(Class<T> clazz, Filter filter) {     return platformLayerClient.listItems(clazz, filter); }
public void testGetEncodedLength() {     RPCBlockReadRequest req = new RPCBlockReadRequest(mBuffer, LENGTH, OFFSET, LOCK_ID, SESSION_ID, BLOCK_ID);     long encodedLength = req.getEncodedLength();     assertEquals(33, encodedLength); }
public int getDataOffset() {     return offset; }
public ArrayList<String> evaluateAndSort() {     Map<String, Double> evaluation = evaluate();     ArrayList<Map.Entry<String, Double>> entries = new ArrayList<>(evaluation.entrySet());     entries.sort(Map.Entry.comparingByValue());     ArrayList<String> sortedOutputs = new ArrayList<>();     for (Map.Entry<String, Double> entry : entries) {         sortedOutputs.add(entry.getKey() + " = " + entry.getValue());     }     return sortedOutputs; }
public String readAttributeValue(MessageReader reader, QName name) throws IOException {     if (name.equals(SOAP_ENCODING_REF_1_1) || name.equals(SOAP_ENCODING_REF_1_2)) {         return reader.getAttributeValue(name);     }     return null; }
public String getRandomLocation() {     List<String> locations = getLocations();     if (locations.isEmpty()) {         return null;     }     Random rand = new Random();     int randomIndex = rand.nextInt(locations.size());     return locations.get(randomIndex); }
public Object get(String key) {     if (key == null) {         throw new IllegalArgumentException("Key cannot be null");     }     return bundle.get(key); }
public void clearConnectedHandler() {     if (connectedHandler != null) {         connectedHandler.close();         connectedHandler = null;     } }
public class Helper {     private static final String SHORT_FORMAT = "yyyy-MM-dd";     private static final String FULL_FORMAT = "E, MMMM dd, yyyy hh:mm a";     private static final String NORMAL_DAY_OF_WEEK_FORMAT = "E, MMMM dd, yyyy";     private static final String NORMAL_FORMAT = "yyyy-MM-dd HH:mm:ss";     // Convert String date to Date type     public static Date stringToDate(String dateString) throws ParseException {         SimpleDateFormat sdf = new SimpleDateFormat(SHORT_FORMAT);         return sdf.parse(dateString);     } }
public class Book {     private String comment;     private boolean selected;     private String rating;     private String tagStr;     private List<String> tags;     private String path;     private String author_sort;     private String title;     private FileSizeComparable length;     private String language;     private String uuid;     private String filenameWithoutExtension;     private String pubdate;     private List<String> formats;     private String author;     private String title_sort;     // is selected ?     public boolean isSelected() {         return selected;     } }
public class JSONArray {     private List<Object> mArray = new ArrayList<Object>();     // add item     public void addItem(Object item) {         mArray.add(item);     } }
public boolean renameRepositoryRole(String oldRole, String newRole) {     // Check if the oldRole exists in the legacyBackingServices map     if (legacyBackingServices.containsKey(oldRole)) {         // Retrieve the value associated with the oldRole         String value = legacyBackingServices.remove(oldRole);         // Add the value to the legacyBackingServices map with the newRole as the key         legacyBackingServices.put(newRole, value);         return true;     } else {         return false; // Return false if oldRole doesn't exist     } }
public void stop(BundleContext context) {     // Empty implementation, as the framework will automatically unregister any registered services     // No action needed in this method }
public void unifiedBreak() {     allowBreak(1, 0, " ", 1); }
public int hashForwardFirst7Chars(String s) {     int hash = 5381;     for (int i = 0; i < Math.min(s.length(), 7); i++) {         hash = ((hash << 5) + hash) + s.charAt(i);     }     return hash; }
public void clearMarkersAndTracks() {     markers.clear();     tracks.clear();     pois.clear();     nextTrackId = 0; }
public boolean isEmpty() {     return results.isEmpty(); }
public void setManualFramingRect(int width, int height) {     if (initialized) {         Point screenResolution = configManager.getScreenResolution();         if (width > screenResolution.x) {             width = screenResolution.x;         }         if (height > screenResolution.y) {             height = screenResolution.y;         }         int leftOffset = (screenResolution.x - width) / 2;         int topOffset = (screenResolution.y - height) / 2;         framingRect = new Rect(leftOffset, topOffset, leftOffset + width, topOffset + height);         framingRectInPreview = null;         autoFocusManager.setManualParameters(framingRect, screenResolution);         Log.d(TAG, "Calculated framing rect: " + framingRect);     } else {         requestedFramingRectWidth = width;         requestedFramingRectHeight = height;     } }
public String getToken() {     return token; }
public Map<String, String> getGroupAttributesById(String id) {     Map<String, String> attributes = new HashMap<>();     try {         String groupName = getGroupName(id);         String groupAttributes = getGroupAttributes(groupName);         JSONParser parser = new JSONParser();         JSONObject groupObject = (JSONObject) parser.parse(groupAttributes);         JSONObject scimAttributes = (JSONObject) groupObject.get("scimAttributes");         if (scimAttributes != null) {             for (Object key : scimAttributes.keySet()) {                 String attribute = (String) key;                 String value = (String) scimAttributes.get(attribute);                 attributes.put(attribute, value);             }         }     } catch (ParseException | IdentitySCIMException e) {         logger.error("Error occurred while getting group attributes by ID", e);     }     return attributes; } private String getGroupAttributes(String groupName) throws IdentitySCIMException {     SCIMProvider provider = SCIMCommonUtils.getSCIMProvider();     SCIMGroupHandler groupHandler = (SCIMGroupHandler) provider.getGroupHandler();     try {         Group group = groupHandler.getGroupWithAttributes(null, groupName);         return group.getAttributesJsonString();     } catch (IdentitySCIMException e) {         logger.error("Error occurred while getting group attributes for group: " + groupName, e);         throw new IdentitySCIMException("Error occurred while getting group attributes for group: " + groupName, e);     } }
/**  * Calculates how many milliseconds have passed since the last frame.  * @return The number of milliseconds since the last frame.  */ public long getTimeElapsed() {     long time = getTime();     long timeElapsed = time - lastFrame;     lastFrame = time;     return timeElapsed; }
public boolean modifiesA() {     blockA.reshape(alg.numRows(), alg.numRows(), false);     blockA.set(0, 0, alg.getA());     return true; }
public boolean isHealthy(T resource) {     while (true) {         ResourceInternal<T> internal = mResources.get(resource);         if (internal == null) {             return false;         }         synchronized (internal) {             if (!internal.isHealthy()) {                 if (!mResources.containsKey(resource)) {                     return false;                 }                 internal.decrementRefCount();                 if (!add(internal)) {                     internal.incrementRefCount();                     return false;                 }                 try {                     internal.wait();                 } catch (InterruptedException e) {                     Thread.currentThread().interrupt();                     return false;                 }                 continue;             }         }         return true;     } }
public void testGetSpeedUnit() {     // Create a new MWV sentence object     MWVSentence mwv = new MWVSentence(EXAMPLE);     // Test the getSpeedUnit method     assertEquals(SpeedUnit.METERS_PER_SECOND, mwv.getSpeedUnit()); }
@Test(expected = IllegalArgumentException.class) public void testUpdate_nullId() {     ResourceSet resourceSet = new ResourceSet();     resourceSet.setId(null);     resourceSetService.saveNew(resourceSet); }
/**  * Prints input in console for debugging.  */ public void printInput() {     System.out.println("Input values:");     for (Variable variable : fis.getVariables()) {         System.out.println(variable.getName() + " = " + fis.getVariable(variable.getName()).getInputValue());     } }
public void addIntegerField(String fldname) {     info.put(fldname, new FieldInfo(FieldType.INTEGER, 4)); }
@Override public int hashCode() {     int result = 17; // any prime number can be used as the initial value     result = 31 * result + type.hashCode(); // multiply by a prime number and add the hash code of the type field     result = 31 * result + url.hashCode(); // multiply by a prime number and add the hash code of the url field     return result; }
public Set<String> getIds() {     return instances.keySet(); }
@Override public void before() throws Exception {     mFile = folder.newFile();     mLocalOutputStream = new BufferedOutputStream(new FileOutputStream(mFile));     mStream = new S3AOutputStream(new Configuration(), new Path("s3a://" + BUCKET_NAME + "/" + KEY),             mLocalOutputStream, null); }
null
public static Class getClassImpl(Class parent, String name) {     try {         return Class.forName(parent.getPackage().getName() + "." + name);     } catch (ClassNotFoundException e) {         throw new RuntimeException("Class not found: " + name, e);     } }
public void createLocalAlluxioMaster() throws Exception {     // Choose an available port for the master to bind to     ServerSocket serverSocket = new ServerSocket(0);     int port = serverSocket.getLocalPort();     serverSocket.close();     // Create the master with the isolated port     String masterHostname = NetworkAddressUtils.getLocalHostName();     String uri = Constants.HEADER + masterHostname + ":" + port;     mAlluxioMaster = new AlluxioMaster(uri);     // Set the bind host and web bind host to localhost to ensure local access only     Configuration.set(PropertyKey.MASTER_BIND_HOST, "localhost");     Configuration.set(PropertyKey.MASTER_WEB_BIND_HOST, "localhost");     // Set the RPC port and web port to the isolated port     Configuration.set(PropertyKey.MASTER_RPC_PORT, Integer.toString(port));     Configuration.set(PropertyKey.MASTER_WEB_PORT, Integer.toString(port));     // Start the master thread and wait for it to be ready     mMasterThread = new Thread(new Runnable() {         @Override         public void run() {             try {                 mAlluxioMaster.start();             } catch (Exception e) {                 LOG.error("Failed to start Alluxio master", e);             }         }     });     mMasterThread.start();     mAlluxioMaster.waitForReady(); }
null
public ConditionsProvider getConditionsProvider() {     return conditionsProvider; }
public void close() {     tx.unpin(blk); }
public void setTokenId(String tokenId) {     this.tokenId = tokenId; }
public String getState() {     if (address != null && address.getCountrySubentity() != null) {         return address.getCountrySubentity();     } else {         return "";     } }
void unlockBlock(long lockId) {   synchronized (mSharedMapsLock) {     LockRecord lockRecord = mLockIdToRecordMap.get(lockId);     if (lockRecord == null) {       throw new RuntimeException("No lock found for lock ID " + lockId);     }     long sessionId = lockRecord.sessionId;     long blockId = lockRecord.blockId;     ClientRWLock blockLock = mLocks.get(blockId);     if (blockLock == null) {       throw new RuntimeException("No block lock found for block ID " + blockId);     }     blockLock.unlockWrite();     lockRecord.removeLockId(lockId);     if (lockRecord.getLockIds().isEmpty()) {       mLockIdToRecordMap.remove(lockId);       Set<Long> lockIds = mSessionIdToLockIdsMap.get(sessionId);       lockIds.remove(lockId);       if (lockIds.isEmpty()) {         mSessionIdToLockIdsMap.remove(sessionId);       }       releaseBlockLockIfUnused(blockId);     }   } }
public double getLastVersion() {     if (running()) {         return 0.00;     } else {         // implement the logic for getting the version number from some source         // and return the appropriate value     } }
@Test public void testUnlockBlockNotLocked() throws Exception {     mThrown.expect(LockNotHeldException.class);     mThrown.expectMessage("Session " + TEST_SESSION_ID + " does not hold the lock for block " + TEST_BLOCK_ID);     // Call unlockBlock() for a block that hasn't been locked     mLockManager.unlockBlock(TEST_SESSION_ID, TEST_BLOCK_ID); }
public String getChecksumType() {     return checksumType; }
void zoom(String direction) {     String command = "zoom " + direction;     runUrl(command); }
public void testGetAddress() {     String expectedAddress = "192.168.1.1"; // Replace with expected address     String actualAddress = dev.getAddress(); // Call the getAddress method from the Device class     assertEquals(expectedAddress, actualAddress); // Compare the expected and actual values }
/**  * Returns the maximum lifetime in seconds for issued SAML token if requestor specifies lifetime element.  * @return the maximum lifetime in seconds  */ public long getMaxLifetime() {     return maxLifetime; }
protected RouteCalculator createRouteCalculator() {     return new RouteCalculator(); }
public void changeLocalFilePermission(String filePath, String permission) {     try {         Files.setPosixFilePermissions(Paths.get(filePath), PosixFilePermissions.fromString(permission));     } catch (IOException e) {         LOG.error("Failed to change permission for file: " + filePath, e);     } }
public void setInputStream(InputStream inputStream) {     if (thread != null && thread.isAlive()) {         stop();     }     reader = new DataReader(inputStream); }
public void disconnect() {     try {         if (connection != null) {             connection.close();         }     } catch (SQLException e) {         // handle the exception appropriately     } finally {         connection = null;     } }
public List<Date> getDates() {     return this.dates; }
public void renderWalls() {     // implementation code here     // ... }
public void initInternal(String s) {     if (initialized) {         return;     }     systemDefaultLocale = Locale.getDefault();     if (s == null || s.length() == 0) {         s = BUNDLES_PATH;     }     String[] bundleNames = s.split(",");     for (String bundleName : bundleNames) {         loadBundle(bundleName.trim());     }     initialized = true; } public void loadBundle(String name) {     ResourceBundle bundle = null;     for (ClassLoader classLoader : classLoaders) {         try {             bundle = ResourceBundle.getBundle(name, systemDefaultLocale, classLoader);             break;         } catch (MissingResourceException e) {             // try next classloader         }     }     if (bundle == null) {         LOG.warning("Bundle '" + name + "' not found.");     } else {         bundles.put(name, bundle);     } }
public static String getParent(String path) {     if (path == null) {         return null;     }     String normalizedPath = normalizePath(path, "/");     int lastSeparatorIndex = normalizedPath.lastIndexOf('/');     if (lastSeparatorIndex <= 0) {         return "/";     }     return normalizedPath.substring(0, lastSeparatorIndex); }
public void setTrustManagers(TrustManager[] trustManagers) {     this.trustManagers = trustManagers; }
public void setReplyTo(EndpointReferenceType replyTo) {     this.replyTo = replyTo; }
public static String getUTCW3CDateTime() {     SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");     sdf.setTimeZone(TimeZone.getTimeZone("UTC"));     return sdf.format(new Date()); }
public void cells(RowHeaderType r, ColumnHeaderType c, ValueType v) {     if (r == null || c == null || v == null) {         throw new IllegalArgumentException("Row, column, and value cannot be null.");     }     Hashtable<ColumnHeaderType, ValueType> row = rows.get(r);     if (row == null) {         row = new Hashtable<>();         rows.put(r, row);     }     row.put(c, v); }
public void setAcceptedSignatureAlgorithms(List<String> acceptedSignatureAlgorithms) {     this.acceptedSignatureAlgorithms = acceptedSignatureAlgorithms; }
@Test public void testSetResponseString() {     LogEntryRequest instance = new LogEntryRequest();     String responseString = "Test response string";     instance.setResponseString(responseString);     assertEquals(responseString, instance.getResponseString()); }
/**  * Provide explicit mappings to ReflectionServiceFactory.   * {@inheritDoc}  */ @Override public XmlSchema addSchemaDocument(ServiceInfo serviceInfo, SchemaCollection col, Document d, String systemId) {     // Implementation code here } @Override public XmlSchema addSchemaDocument(ServiceInfo serviceInfo, SchemaCollection col, Document d, String systemId, Collection<String> ids) {     // Implementation code here }
public void testGetMode() {     rmc.setMode('A');     assertEquals('A', rmc.getMode());          rmc.setMode('D');     assertEquals('D', rmc.getMode());          rmc.setMode('E');     assertEquals('E', rmc.getMode());          rmc.setMode('N');     assertEquals('N', rmc.getMode());          rmc.setMode('R');     assertEquals('R', rmc.getMode());          rmc.setMode('S');     assertEquals('S', rmc.getMode());          rmc.setMode('V');     assertEquals('V', rmc.getMode()); }
public void testGetSteerTo() {     String steerTo = "V";     rmb.setSteerTo(steerTo);     assertEquals(steerTo, rmb.getSteerTo()); }
public int distinctValues(String fldname) {     try {         // get the index info for the specified field         IndexInfo indexInfo = ii.getIndexInfo(fldname);         // calculate the number of distinct values for the index         int distinctValues = (int) Math.ceil((double) p.recordsOutput() / (double) indexInfo.recordsOutput());         return distinctValues;     } catch (Exception e) {         // handle any exceptions that may occur         e.printStackTrace();         return -1;     } }
public String getMsg() {     return this.msg; }
public int getPriority() {     return priority; }
public String getPrefix(String uri) {     if (top != null) {         for (NSDecl decl : top) {             if (decl.uri.equals(uri)) {                 return decl.prefix;             }         }     }     String prefix = NS_PREFIX_PREFIX + nsPrefixCount++;     declare(prefix, uri);     return prefix; } private void declare(String prefix, String uri) {     if (top == null) {         top = new ArrayList<>();         stack.add(top);     }     top.add(new NSDecl(prefix, uri)); }
public Type substType(Type t) {     Type result = cacheGet(t);     if (result != null) {         return result;     }     if (t instanceof Formal) {         result = subst.get(t);         if (result == null) {             result = t;         }         cachePut(t, result);         return result;     }     if (t instanceof ArrayType) {         ArrayType at = (ArrayType) t;         Type elemType = substType(at.elemType);         result = ts.getArrayType(elemType, at.dimensions());         cachePut(t, result);         return result;     }     if (t instanceof PClass) {         PClass<?, ?> pc = (PClass<?, ?>) t;         PClass<Formal, Actual> substPClass = substPClass(pc);         result = substPClass;         cachePut(t, result);         return result;     }     if (t instanceof ClassType) {         ClassType ct = (ClassType) t;         ClassType substClassType = substClassType(ct);         result = substClassType;         cachePut(t, result);         return result;     }     if (t instanceof ReferenceType) {         ReferenceType rt = (ReferenceType) t;         ReferenceType substContainer = substContainer(rt);         result = substContainer;         cachePut(t, result);         return result;     }     if (t instanceof WildcardType) {         WildcardType wt = (WildcardType) t;         Type extendsBound = wt.extendsBound() != null ? substType(wt.extendsBound()) : null;         Type superBound = wt.superBound() != null ? substType(wt.superBound()) : null;         result = ts.getWildcardType(extendsBound, superBound);         cachePut(t, result);         return result;     }     if (t instanceof TypeVariable) {         TypeVariable tv = (TypeVariable) t;         TypeVariable newTypeVar = ts.getTypeVariable(tv.getName());         Type[] bounds = tv.bounds();         Type[] newBounds = new Type[bounds.length];         for (int i = 0; i < bounds.length; i++) {             newBounds[i] = substType(bounds[i]);         }         newTypeVar.setBounds(newBounds);         result = newTypeVar;         cachePut(t, result);         return result;     }     return t; }
public BrowseOffersResponse.Return.OfferData.OfferMedia.OfferImage.Entry.Value          createBrowseOffersResponseReturnOfferDataOfferMediaOfferImageEntryValue() {     return new BrowseOffersResponse.Return.OfferData.OfferMedia.OfferImage.Entry.Value(); }
public void testSetSentenceIndex() {     // create a new RTEParser instance     RTEParser parser = new RTEParser();     // set the sentence index to 3     parser.setSentenceIndex(3);     // assert that the sentence index is 3     assertEquals(3, parser.getSentenceIndex()); }
public void stepBack() {     if (step > 0) {         step--;     } }
float getX(MotionEvent event, int pointerIndex) {     try {         return event.getX(pointerIndex);     } catch (IndexOutOfBoundsException e) {         if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.HONEYCOMB) {             throw e;         }     }     return 0; }
public long getCommittedBytes() {     List<BlockMeta> blocks = mManagerView.getCommittedBlocks(mDir.toBlockStoreLocation());     long committedBytes = 0L;     for (BlockMeta block : blocks) {         committedBytes += block.getBlockSize();     }     return committedBytes; }
public void fields() {     // TODO: Implement conversion to thrift representation test }
public static ClassLoader getDefaultClassLoader() {     ClassLoader cl = null;     try {         cl = Thread.currentThread().getContextClassLoader();     } catch (Throwable ex) {         // Cannot access thread context ClassLoader - falling back...     }     if (cl == null) {         // No thread context class loader -> use class loader of this class         cl = ClassHelper.class.getClassLoader();         if (cl == null) {             // getClassLoader() returning null indicates the bootstrap ClassLoader             try {                 cl = ClassLoader.getSystemClassLoader();             } catch (Throwable ex) {                 // Cannot access system ClassLoader - oh well, maybe the caller can live with null...             }         }     }     return cl; }
public static Wrapper getWrapper(Class<?> c) {     if (c == null || c.isPrimitive()) {         return OBJECT_WRAPPER;     }     Wrapper wrapper = WRAPPER_MAP.get(c);     if (wrapper != null) {         return wrapper;     }     return makeWrapper(c); }
public ProjectScan createScan(Transaction tx) {     Plan plan = p.open(tx);     return new ProjectScan(plan, schema); }
public void setGrado(int grado) {     this.grado = grado;     if (coef.length <= grado) {         coef = Arrays.copyOf(coef, grado + 1);     } }
public Response callRestCallable(RestCallable restCallable) {     try {         // Call the RestCallable         Object result = restCallable.call();         // Create a response with the result         return createResponse(result);     } catch (Exception e) {         // Log the exception         LOG.error("Error occurred while calling RestCallable: " + e.getMessage(), e);         // Create an error response with the exception message         return createErrorResponse(e.getMessage());     } }
public void testSetYear() {     int year = 2023;     instance.setYear(year);     assertEquals(year, cal.get(Calendar.YEAR)); }
public QualifiedName buildConstructorName(String className) {     String[] classParts = className.split("\\$");     String operationName = classParts[classParts.length-1];     return new QualifiedName(this.packages, this.classes, operationName); }
protected void unsetApplicationMgtService(ApplicationManagementService applicationMgtService) {     log.debug("Unsetting Application management service implementation.");     OAuth2ServiceComponent.applicationMgtService = null; }
public List<String> getSubjectConstraints(CertificateConstraintsType certConstraints) {     List<String> subjectConstraints = new ArrayList<String>();     if (certConstraints != null) {         SubjectConstraintsType subject = certConstraints.getSubject();         if (subject != null && subject.getRegularExpression() != null) {             for (String regex : subject.getRegularExpression()) {                 subjectConstraints.add(regex);             }         }     }     return subjectConstraints; }
@Test(expected = NullPointerException.class) public void testDeregisterUserSessionWithNullServerSessionThrowsException() {     notificationController.deregisterUserSession(null, mockServerMessage); }
null
public static <T> boolean containsAny(Collection<T> source, Collection<T> candidates) {     for (T candidate : candidates) {         if (source.contains(candidate)) {             return true;         }     }     return false; }
public void testGetLatHemisphere() {     // Create a new position object     Position position = new Position();     // Set the latitude hemisphere to North     position.setLatitudeNorth();     // Assert that the latitude hemisphere is North     assertEquals("Latitude hemisphere should be North", 'N', position.getLatHemisphere()); }
public PasswordCredentials createPasswordCredentials() {     return new PasswordCredentials(); }
void testEqualsNodeWithTwoDifferentViolationsDifferentBeginColumn() {     final String filename = "file1";     final int beginLine = 1;     final int endLine = 2;     final int beginColumn1 = 3;     final int beginColumn2 = 4;     final int endColumn = 5;     final String variableName = "var1";     final ViolationNode node1 = createViolationNode(filename, beginLine, endLine, beginColumn1, endColumn, variableName);     final ViolationNode node2 = createViolationNode(filename, beginLine, endLine, beginColumn2, endColumn, variableName);     assertFalse(node1.equals(node2)); }
public BigDecimal getExpDataUnitId() {     return expDataUnitId; }
/**  * Test method for {@link net.sf.marineapi.nmea.util.Date#equals(java.lang.Object)}.  */ public void testEqualsAfterInit() {     Date d1 = new Date();     Date d2 = new Date();     assertTrue(d1.equals(d2)); }
public void setRegPclTestResultDetails(List<RegPCLTestResultDetailsEntity> regPclTestResultDetails) {     this.regPclTestResultDetails = regPclTestResultDetails; }
public void testSetMinutes() {     // Set the minutes of the Time object to a valid value     Time time = new Time(12, 30, 0);     time.setMinutes(45);          // Assert that the minutes were set correctly     assertEquals(45, time.getMinutes());          // Try setting an invalid value for the minutes     try {         time.setMinutes(60);         fail("Expected IllegalArgumentException not thrown");     } catch (IllegalArgumentException e) {         // Exception thrown as expected     } }
public T extractMin() {     if (allNodes.isEmpty()) {         return null;     }     Node minNode = allNodes.get(0);     return minNode.key; }
public String getNotationNameString(String k1, String k2) {     NotationName notation = findNotation(k1, k2);     if (notation != null) {         return notation.getName();     } else {         return "";     } }
null
public void put(String key, XKMSCacheToken value) {     Element element = new Element(key, value);     cache.put(element); }
public Bundle getValuesAsBundle() {     return bundle; }
public int getQuality() {     return this.quality; }
public String getAlbum() {     return this.album; }
public void setOffsetHours(int hours) {     int totalMinutes = hours * 60;     this.offsetHours = hours;     this.offsetMinutes = totalMinutes % 60; }
null
public void addSource(Source source) {     sources.add(source); }
public void setTextureRegion(final TextureRegion pTextureRegion) {     this.mTextureRegion = pTextureRegion;     int globalTileID = this.getGlobalTileID();     TMXTiledMap tiledMap = (TMXTiledMap) this.getParent();     TiledTextureRegion tiledTextureRegion = tiledMap.getTextureRegionFromGlobalTileID(globalTileID);     tiledTextureRegion.setTexturePosition(this.mTextureRegion.getTexturePositionX(), this.mTextureRegion.getTexturePositionY()); }
public void ejecutarTurno(Piloto piloto) {     try {         semaforo.acquire();         Comando comando = piloto.getComando(partida);         partida.ejecutarComando(piloto, comando);         semaforo.release();         notificarObservadoresRondaTerminada(rondas.get());     } catch (Exception e) {         exception(this, rondas.get(), piloto, piloto.getComando(partida), e);     } }
public void enableTimeout(boolean enable) {     timeoutEnabled = enable;     if (enable) {         resetTimeout();     } else {         if (timeoutTask != null) {             timeoutTask.cancel();         }     } }
public Coin getValue() {     return value; }
public Items getItems() {     return items; }
public String sign(String requestUrl) {     String canonicalQS = canonicalize(createParameterMap(requestUrl));     String toSign = REQUEST_METHOD + "\n" + endpoint + "\n" + REQUEST_URI + "\n" + canonicalQS;     String hmac = hmac(toSign);     String sig = percentEncodeRfc3986(hmac);     return requestUrl + "&Signature=" + sig; }
public Node getNode() {     return node; }
@Test public void validateLockIdWithWrongSessionId() throws Exception {     long wrongSessionId = 5;     mThrown.expect(IllegalArgumentException.class);     mThrown.expectMessage("Lock for block " + TEST_BLOCK_ID + " with session id " + wrongSessionId + " is not held.");     mLockManager.validateLock(TEST_BLOCK_ID, wrongSessionId, TEST_SESSION_ID); }
public ServiceBuilder callback(String callback) {     this.callback = callback;     return this; }
public void generateFactoryMapping(ClassType ct) {     String className = ct.getName();     String factoryClassName = className + "Factory";     String packageName = packageName();     StringBuilder sb = new StringBuilder();     sb.append("package ").append(packageName).append(";\n\n");     sb.append("public interface ").append(factoryClassName).append(" {\n\n");     sb.append("\tpublic ").append(className).append(" create").append(className).append("();\n");     sb.append("}\n");     EfgClassInfo efgClassInfo = new EfgClassInfo(ct, sb.toString());     factoryMappings.put(ct, efgClassInfo); }
public String getId() {     return id; }
public void removeAll(RangeSet<C> other) {     for (Range<C> range : other.asRanges()) {         remove(range);     } }
public String getTestId() {     return testId; }
public boolean isDownloadingState(MoverDState<DsT> state) {     return state instanceof DownloadingState; }
public SessionFactory createSessionFactory() {     try {         StandardServiceRegistryBuilder serviceRegistryBuilder = new StandardServiceRegistryBuilder();         serviceRegistryBuilder.applySettings(m_config.getProperties());         if (m_createTables) {             SchemaExport schemaExport = new SchemaExport(m_config);             schemaExport.create(false, true);         }         ServiceRegistry serviceRegistry = serviceRegistryBuilder.build();         Metadata metadata = new MetadataSources(serviceRegistry).getMetadataBuilder().build();         return metadata.getSessionFactoryBuilder().build();     } catch (Throwable ex) {         LOG.error("Error creating session factory.", ex);         throw new ExceptionInInitializerError(ex);     } }
public void setUri(String uri) {     this.uri = uri; }
public Texture getTextureFromFileSystem(String fileName) {     FileHandle fileHandle = Gdx.files.internal(fileName);     return new Texture(fileHandle); }
public boolean hasExpired() {     return new Date().after(expiration); }
public String getString(String fldname) {     if (s1.hasField(fldname)) {         return s1.getString(fldname);     } else if (s2.hasField(fldname)) {         return s2.getString(fldname);     } else {         throw new IllegalArgumentException("Field " + fldname + " does not exist in either Scan.");     } }
public void setNamespaceURI(String namespaceURI) {     this.namespaceURI = namespaceURI; }
public String name() {     return this._stack_type; }
public String getPath() {     return mUri.getPath(); }
/**  * Returns true if the block height is either not a checkpoint, or is a checkpoint and the hash matches.  *   * @param height the block height to check  * @param hash the hash to check against the checkpoint (if applicable)  * @return true if the block height is either not a checkpoint, or is a checkpoint and the hash matches  */ public boolean isCheckpoint(int height, Sha256Hash hash) {     if (checkpoints.containsKey(height)) {         return checkpoints.get(height).equals(hash);     } else {         return false;     } }
/**  * Handle event from the RawRtfParser.  *  * @param event The event to be handled.  */ public void handleEvent(IParserEvent event) {     if (event == null) {         return;     }     if (event instanceof GroupStartEvent) {         processGroupStart();     } else if (event instanceof GroupEndEvent) {         processGroupEnd();     } else if (event instanceof DocumentStartEvent) {         processDocumentStart();     } else if (event instanceof DocumentEndEvent) {         processDocumentEnd();     } else {         handleCommand(((CommandEvent) event).getCommand(), ((CommandEvent) event).getParameter(),                 ((CommandEvent) event).hasParameter(), ((CommandEvent) event).isOptional());     } }
public int getInt(int defaultValue) {     int result;     try {         result = Integer.parseInt(currentValue);     } catch (NumberFormatException e) {         result = defaultValue;     }     return result; }
public void addParent(DirectedAcyclicGraphNode<T> parent) {     mParents.add(parent); }
public void setHeader(String name, String value) {     response.setHeader(name, value); }
public String getTestId() {     return this.testId; }
public void setStyleSheet(Source styleSheet) {     factory.setURIResolver(uriResolver);     Templates templates;     try {         templates = factory.newTemplates(styleSheet);         transformer = templates.newTransformer();         transformer.setErrorListener(errorListener);         transformer.setOutputProperties(output);         for (Map.Entry<String, Object> entry : params.entrySet()) {             transformer.setParameter(entry.getKey(), entry.getValue());         }         transformer.setURIResolver(uriResolver);     } catch (TransformerConfigurationException e) {         // Handle exception     } }
private void generateOutputFile() {     File outputFolder = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM), DIR_NAME);     if (!outputFolder.exists()) {         outputFolder.mkdirs();     }     String dateTimeString = getDateTimeString();     mOutputPath = new File(outputFolder, "VID_" + dateTimeString + ".mp4").getAbsolutePath(); }
public static String readResponseString(InputStream inputStream) throws IOException {     BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));     StringBuilder responseBuilder = new StringBuilder();     String line;     while ((line = reader.readLine()) != null) {         responseBuilder.append(line);     }     return responseBuilder.toString(); }
public void removePropPanelFactory(PropPanelFactory factory) {     ppfactories.remove(factory); } // usage example: // PropPanelFactory myFactory = new MyPropPanelFactory(); // ppfactories.add(myFactory); // ... // ppfactories.remove(myFactory);
public void enableWrite() {     m_selectorManager.enableWrite(this); }
void convertToClockTimeWithOneMinute() {     long oneMinute = 60 * 1000; // One minute in milliseconds     String expected = "00:01:00";     String actual = WebUtils.convertMsToClockTime(oneMinute);     assertEquals(expected, actual); }
void addTerminal(@ModelAttribute TerminalDevice device) {     repository.save(device); }
public boolean isNotValid() {     return errorLevel > 0; }
public void setUp() {     // Initialize the OSS client     mClient = new OSSClient("endpoint", "accessKeyId", "accessKeySecret");          // Create the OSSUnderFileSystem object     mOSSUnderFileSystem = new OSSUnderFileSystem(mClient, BUCKET_NAME, BUCKET_PREFIX); }
public void close() {     try {         BufferMgr.getInstance().unpin(currentblk);     } catch (Exception e) {         // handle exception     } }
public EndpointReferenceType getFrom() {     return this.from; }
@Override public String toString() {     return String.format("(%s, %s) -> %s", _from_state, _on_symbol, _to_state); }
/**  * Accesses a float attribute from a tag name and an attribute name within the element identified by that tag.  *  * @param element the XML element to search for the attribute  * @param tagName the name of the tag that contains the attribute  * @param attribute the name of the attribute to get the value from  * @return the float value of the attribute, or 0.0 if it does not exist or cannot be parsed as a float  */ public static float getFloatAttribute(final Element element, final String tagName, final String attribute) {     if (element == null || tagName == null || attribute == null) {         return 0.0f;     }     NodeList nodeList = element.getElementsByTagName(tagName);     if (nodeList.getLength() == 0) {         return 0.0f;     }     Node node = nodeList.item(0);     if (node == null || node.getNodeType() != Node.ELEMENT_NODE) {         return 0.0f;     }     Element tagElement = (Element) node;     String attributeValue = tagElement.getAttribute(attribute);     if (attributeValue == null || attributeValue.isEmpty()) {         return 0.0f;     }     try {         return Float.parseFloat(attributeValue);     } catch (NumberFormatException e) {         return 0.0f;     } }
public Object newClassifier(String name) {     return mClassifier; }
public void setURL(String url) {     this.url = url; }
public int getTextLength() {     return text.length(); }
void launchServicesOnInternet() {     // Check if the peer is on the open internet     if (isOnOpenInternet()) {         // If on open internet, launch the TURN server         if (m_turnServer != null) {             m_turnServer.launch();         }         // Launch the SIP proxy         if (m_sipProxy != null) {             m_sipProxy.launch();         }     } else {         // If not on open internet, log a message         LOG.debug("Not on open internet. Skipping launching of TURN server and SIP proxy.");     } }
public void dataReceived(SshDataReceivedEvent ev) {     // Code to capture the SshDataReceivedEvent }
public Double probabilityOf(T key) {     if (counter.containsKey(key)) {         int count = counter.get(key);         int totalCount = 0;         for (int value : counter.values()) {             totalCount += value;         }         return (double) count / totalCount;     } else {         return 0.0;     } }
null
public XYLocation north() {     return new XYLocation(xCoOrdinate, yCoOrdinate - 1); }
public Collection<GrantedAuthority> getAuthorities() {     return grantedAuthorities; }
/**  * Sets the value of the vector to use in the start of the iterations.  *  * @param seed the seed vector to use in the iterations  */ public void setSeed(DenseMatrix64F seed) {     this.seed.set(seed); }
public GetOfferDetailsResponse.Return.DetailOfferData.OfferMedia.OfferImage.Entry.Value.Item createGetOfferDetailsResponseReturnDetailOfferDataOfferMediaOfferImageEntryValue() {     return new GetOfferDetailsResponse.Return.DetailOfferData.OfferMedia.OfferImage.Entry.Value.Item(); }
/**  * Find a type object by name.  *   * @param name The name of the type to find.  * @return The type object with the given name, or null if not found.  */ public Type findType(String name) {     TopLevelResolver resolver = head;     while (resolver != null) {         Type type = resolver.findType(name);         if (type != null) {             return type;         }         resolver = resolver.getNext();     }     return null; }
public void setExtensionsDenied(final ResourceTypeHandler type, final String extensionsList) {     Set<String> extensions = new HashSet<>();     if (extensionsList != null) {         String[] extensionArray = extensionsList.split(",");         for (String extension : extensionArray) {             extensions.add(extension.trim());         }     }     extensionsDenied.put(type, extensions);     extensionsAllowed.remove(type); }
public void addToCache(String identifier) {     Element element = new Element(identifier, identifier);     cache.put(element); }
@Override public boolean revise(Variable xi, Variable xj, Constraint constraint, CSP csp, DomainRestoreInfo info) {     // Create a binary constraint between xi and xj     BinaryConstraint binaryConstraint = new BinaryConstraint(xi, xj, constraint);          // Make the CSP arc-consistent using the AC-3 algorithm     ArcConsistency ac = new ArcConsistency();     ac.reduceDomains(csp, binaryConstraint, info);          // Return true if the domains of xi and/or xj were modified, false otherwise     return !xi.getDomain().isEmpty() || !xj.getDomain().isEmpty(); }
public double getAltitude() {     return altitude; }
public List<Object> getValues() {     return this.values; }
public boolean hasActivePen() {     return mHasPenDigitizer; }
/**  * Write boolean value to the given parcel.  *  * @param value boolean value to write  * @param out the parcel to write to  * @param flags flags for writing  */ public static void writeBoolean(boolean value, Parcel out, int flags) {     out.writeInt(value ? 1 : 0); }
public void unregister(EndpointResolver resolver) {     if (resolver != null) {         resolvers.remove(resolver);     } }
public PrintStream getErr() {     if (debugGui != null) {         return debugGui.getErr();     } else {         return System.err;     } }
public int getInterval() {     return interval; }
public RootNode createRootNode() {     return new ComplexNode(); }
public void setGenes_in_ROI(ArrayList<CanonicalGene> genes) {     this.genes_in_ROI = genes; }
public static void runInFXAndWait(Callable<?> callable) throws Exception {     if (Platform.isFxApplicationThread()) {         callable.call();         FXTestUtils.awaitEvents();     } else {         FutureTask<Void> task = new FutureTask<>(() -> {             callable.call();             return null;         });         Platform.runLater(task);         task.get();         FXTestUtils.awaitEvents();     } }
public void append(String str) {     log.add(str); }
@Override public int hashCode() {     int result = 17;     result = 31 * result + kind();     return result; }
public byte[] getByteArray() {     return m_byteArray; }
public void setFileCount(BigDecimal fileCount) {     this.fileCount = fileCount; }
public JPanel getCurrentPanel() {     int percentDone = step * 100 / panels.size();     ImageIcon icon;     if (percentDone == 0) {         icon = new ImageIcon("post-it-0.png");     } else if (percentDone >= 1 && percentDone <= 25) {         icon = new ImageIcon("post-it-25.png");     } else if (percentDone >= 26 && percentDone <= 50) {         icon = new ImageIcon("post-it-50.png");     } else if (percentDone >= 51 && percentDone <= 75) {         icon = new ImageIcon("post-it-75.png");     } else {         icon = new ImageIcon("post-it-100.png");     }     JPanel panel = panels.get(step);     JLabel label = new JLabel("Step " + (step + 1) + ": " + panel.getName(), icon, SwingConstants.LEFT);     JPanel wrapperPanel = new JPanel(new BorderLayout());     wrapperPanel.add(label, BorderLayout.NORTH);     wrapperPanel.add(panel, BorderLayout.CENTER);     return wrapperPanel; }
public BrowseOffersResponse.Return.OfferData.Geo.Region createBrowseOffersResponseReturnOfferDataGeoRegion() {     BrowseOffersResponse.Return.OfferData.Geo.Region region = new BrowseOffersResponse.Return.OfferData.Geo.Region();     return region; }
public int resolvePort(int port) {     if (port <= 0) {         return defaultPort;     } else {         return port;     } }
public void dumpAll() {     System.out.println("Inventory List:");     for (Map.Entry<Item, Integer> entry : invMap.entrySet()) {         System.out.println(entry.getValue() + "x " + entry.getKey().getName());     } }
public void setLength(FileSizeComparable length) {     this.length = length; }
public LanguageVersion getDefaultLanguageVersion(Language language) {     if (languageToLanguageVersion.containsKey(language)) {         return languageToLanguageVersion.get(language);     }     // Find the first language for the given file and return its default version     File file = new File(fileName);     List<Language> languages = getLanguagesForFile(file);     if (!languages.isEmpty()) {         Language firstLanguage = languages.get(0);         return languageToLanguageVersion.getOrDefault(firstLanguage, null);     }     return null; }
void testGetImage() {     // create a new image and set it as the device's image     ImageIcon image = new ImageIcon("device_image.png");     dev.setImage(image);     // call getImage and check that it returns the same image     assertEquals(image, dev.getImage()); }
public int op() {     // Checkpoint records have no associated transaction, so return a "dummy" negative txid     return -1; }
public Builder builder() {     return new Builder()         .physicalNetwork(this.physicalNetwork)         .networkType(this.networkType)         .segmentationId(this.segmentationId); }
@Test public void testSetNumberRequests() {     LogEntryInterval entry = new LogEntryInterval();     entry.setNumberRequests(10);     assertEquals(10, entry.getNumberRequests()); }
public static String getReaderAsString(Reader reader, int maxLen) throws IOException {     StringWriter writer = new StringWriter();     char[] buffer = new char[4096];     int charsRead;     while ((charsRead = reader.read(buffer, 0, buffer.length)) != -1) {         writer.write(buffer, 0, charsRead);         if (writer.getBuffer().length() > maxLen) {             throw new IOException("Resource is too large");         }     }     return writer.toString(); } public static Reader getResourceAsReader(String path, int maxLen) throws IOException {     InputStream is = getResourceAsStream(path, maxLen);     return new InputStreamReader(is, StandardCharsets.UTF_8); } public static InputStream getResourceAsStream(String path, int maxLen) throws IOException {     InputStream is = IOUtils.class.getResourceAsStream(path);     if (is == null) {         throw new FileNotFoundException("Resource not found: " + path);     }     if (maxLen > 0) {         is = new LimitedInputStream(is, maxLen);     }     return is; }
@Test public void getReadOnlyByteBuffer() {     byte[] bytes = new byte[LENGTH];     ByteBuf buffer = Unpooled.wrappedBuffer(bytes);     DataNettyBuffer dataBuffer = new DataNettyBuffer(buffer);          ByteBuffer readOnlyBuffer = dataBuffer.getReadOnlyByteBuffer();          assertNotNull(readOnlyBuffer);     assertEquals(0, readOnlyBuffer.position());     assertEquals(bytes.length, readOnlyBuffer.limit());     assertTrue(readOnlyBuffer.isReadOnly()); }
public String getBaseURL() {     return _baseURL; }
public static void read(Object object, Json json, JsonValue jsonValue, ArrayList<String> skipFields) {     if (jsonValue.isNull()) {         return;     }     Class<?> objectClass = object.getClass();     Field[] fields = objectClass.getDeclaredFields();     for (Field field : fields) {         if (Modifier.isStatic(field.getModifiers())) {             continue;         }         if (skipFields.contains(field.getName())) {             continue;         }         String fieldName = json.getPropertyName(field.getName());         if (fieldName == null) {             fieldName = field.getName();         }         JsonValue fieldValue = jsonValue.get(fieldName);         if (fieldValue != null) {             try {                 field.setAccessible(true);                 Object value = json.readValue(field.getType(), fieldValue);                 field.set(object, value);             } catch (ReflectionException e) {                 throw new SerializationException("Error reading field: " + field.getName(), e);             }         }     } }
public List<MeanValue> getMetrics() {     return Collections.unmodifiableList(metrics); }
null
private int findConsecutiveDigitCount(CharSequence msg, int start) {     int count = 0;     int len = msg.length();     int idx = start;     while (idx < len) {         char c = msg.charAt(idx);         if (!isDigit(c)) {             break;         }         count++;         idx++;     }     return count; }
public class Move {     int x;     int y;          //Other member function headers          public int getX() {         return x;     }          //Other member function implementations }
public void setTestId(Long testId) {     this.testId = testId; }
void onInitializeAccessibilityEvent(Object delegate, View host, AccessibilityEvent event) {     if (delegate == null && DEFAULT_DELEGATE != null) {         DEFAULT_DELEGATE.onInitializeAccessibilityEvent(host, event);     } else if (delegate instanceof AccessibilityDelegateCompat.AccessibilityDelegateImpl) {         ((AccessibilityDelegateCompat.AccessibilityDelegateImpl) delegate)                 .onInitializeAccessibilityEvent(host, event);     } }
public int getLengthFromFormat(boolean advance) {     int length = 0;     char currentChar = format.charAt(formatOff);     if (Character.isDigit(currentChar)) {         while (Character.isDigit(currentChar)) {             length = (length * 10) + Character.getNumericValue(currentChar);             formatOff++;             if (formatOff >= format.length()) {                 break;             }             currentChar = format.charAt(formatOff);         }         if (advance) {             formatOff++;         }     }     return length; }
public void setActValue(String actValue) {     this.actValue = actValue; }
public EaseUserProfileProvider getUserProfileProvider() {     return userProvider; }
public void setValue(int value) {    this.value = value; }
@Test(expected = IllegalArgumentException.class) public void testHandleEventThrowsIllegalArgumentExceptionOnNullTitle() {     // Create test event with null title     testEventProperties.put(Notification.NOTIFICATION_KEY_USER_ID, "testUserId");     testEventProperties.put(Notification.NOTIFICATION_KEY_TIMESTAMP, System.currentTimeMillis());     testEventProperties.put(Notification.NOTIFICATION_KEY_MESSAGE, "testMessage");     testEventProperties.put(Notification.NOTIFICATION_KEY_APPLICATION, "testApp");     testEventProperties.put(Notification.NOTIFICATION_KEY_TITLE, null);     Event testEvent = new Event(Notification.TOPIC_NOTIFICATION, testEventProperties);     // Call handleEvent method with test event     notificationController.handleEvent(testEvent); }
public String getModuleName() {     return this.moduleName; }
public class Primitives {     // member variables     private Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;     private Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;     // member functions     public void add(Map<Class<?>, Class<?>> forward, Map<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {         // implementation goes here     }     public Set<Class<?>> allWrapperTypes() {         // implementation goes here     }     public Set<Class<?>> allPrimitiveTypes() {         // implementation goes here     }     public Class<T> wrap(Class<T> type) {         // implementation goes here     }     public Class<T> unwrap(Class<T> type) {         // implementation goes here     }     public boolean isPrimitiveWrapperType(Class<?> type) {         return (type == Integer.class || type == Boolean.class || type == Character.class ||                 type == Byte.class || type == Short.class || type == Long.class ||                 type == Float.class || type == Double.class || type == Void.class);     } }
public static void normalizeFrobenius(DenseMatrix64F A) {     double norm = NormOps.normF(A);     if (norm == 0.0) {         // A is a zero matrix         return;     }     double invNorm = 1.0 / norm;     CommonOps_DDRM.scale(invNorm, A); }
void printTree() {     traverse(root, ""); } void traverse(TSTNode key, String str) {     if (key != null) {         traverse(key.left, str);         str += key.data;         if (key.is_End_Of_String) {             System.out.println(str);         }         traverse(key.middle, str);         str = str.substring(0, str.length() - 1);         traverse(key.right, str);     } }
public ExceptionListener getExceptionListener() {     return exceptionListener; }
public void setHostname(String hostname) {     mHostname = hostname;     LOG.info("Setting hostname to {}", hostname); }
public void execute() {     // implementation goes here     // this method will execute the card action }
public Map<String, String> getAttributes() {     // implementation goes here     // This method should return a map of attributes for the launched task     // The specific keys and values returned are dependent on the runtime where the task has been launched.     // This may include extra information such as execution location or specific error messages in the case of failure.     return attributes; }
public BigDecimal getFeedId() {     // implementation goes here     return feedId; }
public ComplexNumber getEigenvalue(int index) {     return eig.getEigenvalue(index); }
public WorkflowStore getWorkflowStoreWithTransaction() throws StoreException {     WorkflowStore store = null;     try {         store = Services.get().get(WorkflowStoreService.class).create();         store.beginTrx();     } catch (Exception e) {         if (store != null) {             store.rollbackTrx();         }         throw new StoreException("Could not get a workflow store instance with a fresh transaction", e);     }     return store; }
public long getIndex() {     return index; }
public Script createOpReturnScript(byte[] data) {     ScriptBuilder builder = new ScriptBuilder();     builder.op(OP_RETURN);     builder.data(data);     return builder.build(); }
/**  * Returns the public interface for the scheduler service.  */ public ScheduledExecutorService getScheduler() {     return scheduler; }
public void deleteIdP(String tenantDomain, String idPName) throws IdentityProviderMgtServiceIdentityProviderManagementException {     try {         idPMgtStub.deleteIdP(tenantDomain, idPName);     } catch (RemoteException e) {         String message = "Error occurred while deleting Identity Provider: " + idPName + " from tenant: " + tenantDomain;         log.error(message, e);         throw new IdentityProviderMgtServiceIdentityProviderManagementException(message, e);     } }
public boolean isDebugGuiVisible() {     return debugGui.isVisible(); }
public static Document stringToDom(String xmlString) throws ParserConfigurationException, IOException, SAXException {     DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();     factory.setNamespaceAware(true);     DocumentBuilder builder = factory.newDocumentBuilder();     InputStream is = new ByteArrayInputStream(xmlString.getBytes());     Document domDoc = builder.parse(is);     return domDoc; }
public static int nearestUnsignedInt(int value) {     if (value >= 0) {         return value;     } else {         return (int) (INT_MASK - ((long) (-value) & INT_MASK));     } }
@Override public String toString() {     return literalName; }
public void checkIssuerNotKnown() {     String unknownIssuer = "https://unknown.example.com/";     // Prepare the test data     prepare();     // Call the server configuration service with unknown issuer     service.getServerConfiguration(unknownIssuer);     // Perform assertion or validation for expected behavior     // based on the test requirements     // ... }
public void updateIdentityProvider(IdentityProvider identityProvider) {     // Call the Identity Provider Management Service to update the given identity provider     idPMgtStub.updateIdP(identityProvider);     // Perform any additional operations or validations based on the requirements     // ... }
public boolean getInterestOpsQueueing(final HttpParams params) {     // Obtain the value of NIOReactorPNames.INTEREST_OPS_QUEUEING parameter from the HttpParams     return params.getBooleanParameter(NIOReactorPNames.INTEREST_OPS_QUEUEING, false); }
public void setGlobalPolicyAlgorithm(String algorithm) {     // Set the policy combining algorithm globally in the EntitlementAdminServiceStub     stub.setGlobalPolicyAlgorithm(algorithm); }
public byte[] getPacketMagic() {     // Return the header bytes that identify the start of a packet on this network     return Utils.uint32ToByteArrayBE(packetMagic); }
public Map<String, String> getStrings() {     // Returns a map of strings from the current value     Map<String, String> resultMap = new HashMap<>();     if (currentValue != null && !currentValue.isEmpty()) {         String[] keyValuePairs = currentValue.split(spaceDelimited ? "\\s+" : ",");         for (String keyValuePair : keyValuePairs) {             String[] keyValue = keyValuePair.split(caseSensitive ? "=" : "=i", 2);             if (keyValue.length == 2) {                 String key = keyValue[0].trim();                 String value = keyValue[1].trim();                 resultMap.put(key, value);             }         }     }     return resultMap; }
public class StaticSingleIssuerService {     private String issuer;     public void afterPropertiesSet() {         // No-op     }     public void setIssuer(String issuer) {         this.issuer = issuer;     }     public String getIssuer() {         // Always returns the configured issuer URL         return issuer;     } }
public class Delegator {     private Scriptable obj = null;     public Scriptable construct(Context cx, Scriptable scope, Object[] args) {         // Create new Delegator instance         // The default implementation calls this.getClass().newInstance()         try {             return (Scriptable) this.getClass().newInstance();         } catch (InstantiationException | IllegalAccessException e) {             throw new RuntimeException("Failed to create new Delegator instance", e);         }     }     public Scriptable getPrototype() {         return null;     }     public void setPrototype(Scriptable prototype) {         // No-op     }     public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {         // No-op         return null;     }     public String getClassName() {         return null;     }     public Scriptable getParentScope() {         return null;     }     public Object[] getIds() {         return null;     }     public Scriptable getDelegee() {         return obj;     }     public void delete(String name) {         // No-op     }     public void delete(int index) {         // No-op     }     public void put(String name, Scriptable start, Object value) {         // No-op     }     public void put(int index, Scriptable start, Object value) {         // No-op     }     public Object getDefaultValue(Class<?> hint) {         return null;     }     public boolean hasInstance(Scriptable instance) {         return false;     }     public void setParentScope(Scriptable parent) {         // No-op     }     public Object get(String name, Scriptable start) {         return null;     }     public Object get(int index, Scriptable start) {         return null;     }     public boolean has(String name, Scriptable start) {         return false;     }     public boolean has(int index, Scriptable start) {         return false;     }     public void setDelegee(Scriptable obj) {         this.obj = obj;     } }
public class TorTapKeyAgreement {     private BigInteger P1024 = new BigInteger("00FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF", 16);     private KeyAgreement dh;     private BigInteger G = new BigInteger("2");     private KeyPair keyPair;     private int DH_SEC_LEN = 40;     private int PRIVATE_KEY_SIZE = 320;     private DHParameterSpec DH_PARAMETER_SPEC = new DHParameterSpec(P1024, G, PRIVATE_KEY_SIZE);     private int DH_LEN = 128;     private TorPublicKey onionKey;     // Other member functions     /**      * Return the generated public value for this key agreement operation as a BigInteger.      */     public BigInteger getGeneratedPublicValue() {         return keyPair.getPublic().getY();     }     // Other member functions }
public class Interaction {     private String interactionType;     private String experimentTypes;     private long geneB;     private String pmids;     private long geneA;     private String source;     // Constructor and other member functions     /**      * Gets Entrez Gene ID for Gene A.      * @return The Entrez Gene ID for Gene A as a long value.      */     public long getGeneA() {         return geneA;     }     // Other member functions }
public class BugtraqProcessor {     private IStoredSettings settings;     private Logger logger = LoggerFactory.getLogger(getClass());     private StringBuilder sb;     // Constructor and other member functions     /**      * Returns an HTML version of the commit message with any global or repository-specific      * regular expression substitution applied. This method assumes the commit message is plain text.      *       * @param repository     The repository where the commit was made.      * @param model          The repository model.      * @param text            The plain text commit message.      * @return                The HTML version of the commit message with substitutions applied.      */     public String processCommitMessage(Repository repository, RepositoryModel model, String text) {         // Implementation logic here     }     /**      * Returns an HTML version of the text with regular expression substitutions applied      * for a specific repository.      *       * @param repositoryName   The name of the repository.      * @param text              The plain text input.      * @return                  The HTML version of the text with substitutions applied.      */     public String processTextRegex(Repository repository, String repositoryName, String text) {         // Implementation logic here     }     /**      * Appends a link with a name and target to the StringBuilder.      *       * @param name      The name of the link.      * @param target    The target of the link.      */     public void appendLink(String name, String target) {         // Implementation logic here     }     /**      * Appends plain text to the StringBuilder.      *       * @param text      The plain text to append.      */     public void appendText(String text) {         // Implementation logic here     }     /**      * Returns an HTML version of the text with regular expression substitutions applied      * for a specific repository.      *       * @param repositoryName   The name of the repository.      * @param text              The plain text input.      * @return                  The HTML version of the text with substitutions applied.      */     public String processText(Repository repository, String repositoryName, String text) {         // Implementation logic here     } }
null
public class JsonUtils {     private static final Gson gson = new Gson();     private static final Logger logger = LoggerFactory.getLogger(JsonUtils.class);     // Other member functions implementations here...     /**      * Translate a set of strings to a JSON array, optionally preserving the empty array.      * Otherwise (default) empty array is returned as null.      *      * @param writer    The JsonWriter to write JSON data.      * @param items     The set of strings to be translated to a JSON array.      * @throws IOException If an I/O error occurs during writing JSON data.      */     void writeNullSafeArray(JsonWriter writer, Set<String> items) throws IOException {         if (items == null || items.isEmpty()) {             writer.nullValue();         } else {             writer.beginArray();             for (String item : items) {                 writer.value(item);             }             writer.endArray();         }     } }
public class SoftInputUtil {     // Other member variables here...     /**      * Show keyboard.      *      * @param context The context of the current activity or application.      * @param view    The view that currently has focus and needs the keyboard to be shown.      */     void showSoftInput(Context context, View view) {         InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);         if (imm != null) {             imm.showSoftInput(view, InputMethodManager.SHOW_IMPLICIT);         }     } }
public class PCLDataUnitEntity {     private BigDecimal feedId;     private String isFormatValid;     private String status;     private BigDecimal successorId;     private BigDecimal runId;     private String isPrepopulated;     private String isBulk;     private String isActive;     private String comments;     private BigDecimal fileSize;     private String isUpdate;     private String receiptDateType;     private String srcFileName;     private String inactivationReasonType;     private Long dataSetId;     private String destFileName;     private String isSystemDerived;     private String checksum;     private Timestamp receiptDate;     private Timestamp createdDate;     private Timestamp modifiedDate;     private BigDecimal predecessorId;     private String transmissionDatasetId;     private long dataUnitId;     private String loadedInCats;     private long serialVersionUID = 1L;     private String srcUniqueFileName;     private String checksumType;     // Other member functions here...     /**      * Gets the receipt date.      *      * @return The receipt date.      */     Timestamp getReceiptDate() {         return receiptDate;     } }
public ConduitSelector getConduitSelector() {     return this.conduitSelector; }
public static SpringChain createWithConfig(SpringConfig config) {     SpringChain springChain = new SpringChain();     springChain.mMainSpringConfig = config;     springChain.mAttachmentSpringConfig = config;     return springChain; }
public GenericJSONBuilder builder() {     // Implement the builder method as required     // Return the builder object } public void persist() {     // Implement the persist method as required }
public Map<Variable, Term> unifyVar(Variable var, FOLNode x, Map<Variable, Term> theta) {     // Implement the unifyVar method as required     // Return the updated theta map, or null if unification fails } public Map<Variable, Term> cascadeSubstitution(Map<Variable, Term> theta, Variable var, Term x) {     // Implement the cascadeSubstitution method as required     // Return the updated theta map } public Map<Variable, Term> unifyOps(String x, String y, Map<Variable, Term> theta) {     // Implement the unifyOps method as required     // Return the updated theta map, or null if unification fails } public boolean occurCheck(Map<Variable, Term> theta, Variable var, FOLNode x) {     // Implement the occurCheck method as required     // Return true if the occurrence check fails, false otherwise } public boolean isCompound(FOLNode x) {     // Implement the isCompound method as required     // Return true if x is a compound node, false otherwise } public List<? extends FOLNode> args(FOLNode x) {     // Implement the args method as required     // Return the list of arguments of x } public String op(FOLNode x) {     // Implement the op method as required     // Return the operator of x }
public class IO {     private Map<Path, String> map;     private boolean initialized = false;          public String getKeyAsString(@Nonnull Key key) {         // Implement the getKeyAsString method as required         // Return the key as a string     }     public PublicKey decodePublicKey(@Nonnull String encodedKey, @Nonnull String algorithm) {         // Implement the decodePublicKey method as required         // Return the decoded public key     }     public void init() {         // Implement the init method as required         // Perform initialization tasks     }     public String readFile(@Nonnull Path path) {         // Implement the readFile method as required         // Read the file at the given path and return its content as a string     }     public String readFileCached(@Nonnull Path path) {         // Implement the readFileCached method as required         // Read the file at the given path and cache its content, then return the content as a string     }     // Other methods and variables omitted for brevity }
null
public class Convert {     public Document tryExtractDocFromDOMSource(Source s) {         if (s instanceof DOMSource && ((DOMSource) s).getNode() instanceof Document) {             return (Document) ((DOMSource) s).getNode();         } else {             return toInputSource(s).getOwnerDocument();         }     }     public NamespaceContext toNamespaceContext(Map<String, String> prefix2URI) {         // Implement the logic to create a NamespaceContext using the provided prefix2URI map         // and return it     }     public Node toNode(Source s) {         return toNode(s, DocumentBuilderFactory.newInstance());     }     public Node toNode(Source s, DocumentBuilderFactory factory) {         if (s instanceof DOMSource && ((DOMSource) s).getNode() instanceof Node) {             return ((DOMSource) s).getNode();         } else {             return toInputSource(s, factory).getOwnerDocument();         }     }     public Node tryExtractNodeFromDOMSource(Source s) {         if (s instanceof DOMSource && ((DOMSource) s).getNode() instanceof Node) {             return ((DOMSource) s).getNode();         } else {             return toInputSource(s).getOwnerDocument();         }     }     public InputSource toInputSource(Source s) {         return toInputSource(s, TransformerFactory.newInstance());     }     public InputSource toInputSource(Source s, TransformerFactory fac) {         // Implement the logic to create an InputSource from the provided Source object         // and return it     } }
public class GraphViz {     private static final String TEMP_DIR = "/Users/wendellpbarreto/Downloads";     private StringBuilder graph = new StringBuilder();     private static final String DOT = "/usr/local/bin/dot";     public byte[] getGraph(String dot_source, String type) {         // Implement the logic to generate graph image from dot source using GraphViz library         // and return the image as byte array     }     public String start_graph() {         return "subgraph {";     }     public String end_graph() {         return "}";     }     public String getDotSource() {         return graph.toString();     }     public File writeDotSourceToFile(String str) {         File dotFile = null;         try {             dotFile = File.createTempFile("graph", ".dot", new File(TEMP_DIR));             try (OutputStream outputStream = new FileOutputStream(dotFile)) {                 outputStream.write(str.getBytes(StandardCharsets.UTF_8));             }         } catch (IOException e) {             e.printStackTrace();         }         return dotFile;     }     public String end_subgraph() {         return "}";     }     public void add(String line) {         graph.append(line);     }     public void addln(String line) {         graph.append(line).append("\n");     }     public void addln() {         graph.append("\n");     }     public int writeGraphToFile(byte[] img, String file) {         // Implement the logic to write the graph image to a file with the given filename         // and return the result code     }     public int writeGraphToFile(byte[] img, File to) {         // Implement the logic to write the graph image to the given file         // and return the result code     }     public void readSource(String input) {         graph.append(input);     }     public byte[] get_img_stream(File dot, String type) {         // Implement the logic to generate graph image from dot file using GraphViz library         // and return the image as byte array     } }
public class CoAPServiceActivator implements BundleActivator {     private IEnvironments environments = null;     private HashMap<String, CoAPConnectionFactory> factories = new HashMap<String, CoAPConnectionFactory>();     private AutoSIMCoAPConfig config = null;     @Override     public void start(BundleContext context) throws Exception {         // Implement BundleActivator.start() logic here         // This method is called by the OSGi framework when the bundle is started         // Perform any initialization or registration of services here     }     @Override     public void stop(BundleContext context) throws Exception {         // Implement BundleActivator.stop() logic here         // This method is called by the OSGi framework when the bundle is stopped         // Typically, this method is used for cleanup, unregistering services, etc.         // In this case, since the description mentions "Does nothing since the framework         // will automatically unregister any registered services", we can leave this method empty.     } }
public class PluginContainer {     private SortedUniqueList<AbstractPlugin> plugins;     private long serialVersionUID = 1L;     // Other member variables and functions     /**      * Remove a plugin from this container by its unique name.      *      * @param pluginName The unique name of the plugin to be removed.      * @return {@code true} if the plugin was removed successfully, {@code false} otherwise.      */     public boolean removeByName(String pluginName) {         // Implement removeByName() logic here         // Search for the plugin by name and remove it from the container         // Return true if removed successfully, false otherwise     } }
public class lr_item_core {     private production _the_production;     private int _core_hash_cache;     private symbol _symbol_after_dot = null;     private int _dot_pos;     // Other member variables and functions     /**      * Get the production for the item.      *      * @return The production object associated with this lr_item_core.      */     public production getProduction() {         // Implement getProduction() logic here         // Return the production object associated with this lr_item_core     } }
public class DeviceTest {     private Device dev;     // Other member variables and functions     /**      * Test of toString method, of class Device.      */     public void testToString() {         // Implement testToString() logic here         // Call the toString() method of the Device class and perform necessary assertions or validations     } }
public class RefLogEntry {     private UserModel user;     private Date date;     private int authorCount;     private Map<String, String> refIdChanges;     private Set<RepositoryCommit> commits;     private long serialVersionUID = 1L;     private String repository;     private Map<String, ReceiveCommand.Type> refUpdates;     // Other member variables and functions     /**      * Returns the list of tags changed by the push.      *      * @return List of tags changed by the push      */     public List<String> getChangedTags() {         // Implement getChangedTags() logic here         // Iterate through the refIdChanges Map and extract tags from keys that have "refs/tags/" prefix         // Add extracted tags to a List and return         List<String> changedTags = new ArrayList<>();         for (String ref : refIdChanges.keySet()) {             if (ref.startsWith("refs/tags/")) {                 changedTags.add(ref.substring("refs/tags/".length()));             }         }         return changedTags;     } }
public class Authentication {     private JsonTray parent;     private ClientCredential credential;     private JSONObject json;     // Other member variables and functions     /**      * Get a value from the internal JSONObject.      *      * @param key Key of the value to be retrieved      * @return Value associated with the given key      */     public String getString(String key) {         return json.getString(key);     }     /**      * Get a value from the internal JSONObject with a default value if not found.      *      * @param key     Key of the value to be retrieved      * @param defVal  Default value to be returned if the key is not found      * @return Value associated with the given key, or the default value if key not found      */     public String getString(String key, String defVal) {         return json.optString(key, defVal);     }     /**      * Get a boolean value from the internal JSONObject.      *      * @param key Key of the boolean value to be retrieved      * @return Boolean value associated with the given key      */     public boolean getBoolean(String key) {         return json.getBoolean(key);     }     /**      * Get a boolean value from the internal JSONObject with a default value if not found.      *      * @param key     Key of the boolean value to be retrieved      * @param defVal  Default boolean value to be returned if the key is not found      * @return Boolean value associated with the given key, or the default value if key not found      */     public boolean getBoolean(String key, boolean defVal) {         return json.optBoolean(key, defVal);     }     // Other member functions }
public class GeneralMotorConSchedule {     private int spinTime = 150;     private int MOVED_CYCLELEFT = 10;     private int MOVED_SPINLEFT = 8;     private int MOVED_LEFT = 4;     private int spin90Time = 4500;     private int speed = 10;     private int MOVED_FORWARD = 1;     private String TAG = "GMCS";     private int MOVED_SPINRIGHT = 7;     private ARDrone drone;     private boolean printToConsole = true;     private int spin90Speed = 50;     private int[] recordedMovement = new int[]{0, 0, 0, 0, 0};     private static GeneralMotorConSchedule ourInstance = new GeneralMotorConSchedule();     private int cycleSpinSpeed = 15;     private int altitudeSpeed = 15;     private int batLvl = 0;     private int MOVED_RAISEALT = 5;     private int runningThreads = 0;     private int hoverTime = 2000;     private int runningID = 0;     private CommandManager cmd;     private int cycleTime = 150;     private int MOVED_LOWERALT = 6;     private int altitudeTime = 100;     private int MOVED_RIGHT = 3;     private int cycleSpeed = 10;     private int MOVED_CYCLERIGHT = 9;     private int MOVED_BACKWARD = 2;     private int sideTime = 100;     private int spinSpeed = 15;     // Other member variables and functions     /**      * Add the last movement to the recorded movement array.      *      * @param movement Movement value to be added to the recorded movement array      */     public void addLastMovement(int movement) {         for (int i = recordedMovement.length - 1; i > 0; i--) {             recordedMovement[i] = recordedMovement[i - 1];         }         recordedMovement[0] = movement;     }     // Other member functions }
public class DataNettyBuffer {     private long mLength;     private ByteBuffer mBuffer;     private ByteBuf mNettyBuf;     // Other member variables and functions     /**      * Release the Netty ByteBuf.      */     public void releaseNettyBuf() {         if (mNettyBuf != null) {             mNettyBuf.release();             mNettyBuf = null;         }     }     // Other member functions }
public class UnderStoreBlockInStreamTest {     private static final long BLOCK_LENGTH = 100L;     private static final String TEST_FILENAME = "test_filename.txt";     private UnderStoreBlockInStream mEOFBlockStream;     private File mFile;     private UnderStoreBlockInStream mBlockStream;     private static final long FILE_LENGTH = 2 * BLOCK_LENGTH;     private TemporaryFolder mFolder = new TemporaryFolder();     // Other member variables and functions     /**      * Tests the {@link UnderStoreBlockInStream#skip(long)} method for the first block of the file.      */     public void testSkipFirstBlock() {         try {             InputStream inStream = create();             arrayReadInternal(mBlockStream, 0); // Perform necessary operations before skipping             long skipped = inStream.skip(BLOCK_LENGTH);             assertEquals("Skipped bytes should match BLOCK_LENGTH", BLOCK_LENGTH, skipped);             // Assert additional expectations after skipping             // ...         } catch (IOException e) {             fail("Exception occurred: " + e.getMessage());         }     }     // Other member functions }
public class Bookshelf {     private Book preview;     private static final String QUILL_EXTENSION = ".quill";     private static Bookshelf instance;     private Storage storage;     private LinkedList<BookPreview> data = new LinkedList<BookPreview>();     private static final String TAG = "BookPreview";     private static final String TAG = "Bookshelf";     private Book currentBook;     private UUID uuid;     // Other member variables and functions     /**      * Find the stored preview for the given book.      *      * @param book The book to find the stored preview for.      * @return The stored preview for the given book, or null if not found.      */     public BookPreview findStoredPreview(Book book) {         for (BookPreview preview : data) {             if (preview.getBook().equals(book)) {                 return preview;             }         }         return null;     }     // Other member functions }
public class Time {     private static final String TIME_PATTERN = "%02d:%02d:%02d%+03d:%02d";     private int offsetHours = 0;     private int offsetMinutes = 0;     private double seconds = 0.0;     private int minutes = 0;     private int hour = 0;     // Other member variables and functions     /**      * Returns the ISO 8601 representation of time (hh:mm:ss+hh:mm).      *      * @return The ISO 8601 representation of time.      */     public String toISO8601String() {         int totalOffsetMinutes = offsetHours * 60 + offsetMinutes;         String sign = totalOffsetMinutes >= 0 ? "+" : "-";         int absOffsetHours = Math.abs(offsetHours);         int absOffsetMinutes = Math.abs(offsetMinutes);         return String.format(TIME_PATTERN, hour, minutes, (int) seconds, sign, absOffsetHours, absOffsetMinutes);     }     // Other member functions }
public class FeedTestConfig {     private String feedId;     private Long testId;     private Long runId;     private Long batchId;     // Other member variables and functions     /**      * Sets the feed id.      *      * @param feedId The feed id to set.      */     public void setFeedId(String feedId) {         this.feedId = feedId;     }     // Other member functions }
public class DateTest {     private Date instance;     private GregorianCalendar cal;     // Other member variables and functions     /**      * Test method for {@link net.sf.marineapi.nmea.util.Date#equals(java.lang.Object)}.      */     public void testEqualsItself() {         // Implementation for testEqualsItself         // Add test logic here     }     /**      * Test method for {@link net.sf.marineapi.nmea.util.Date#equals(java.lang.Object)}.      */     public void testEqualsAfterInit() {         // Implementation for testEqualsAfterInit         // Add test logic here     }     /**      * Test method for {@link net.sf.marineapi.nmea.util.Date#equals(java.lang.Object)}.      */     public void testEqualsWhenChanged() {         // Implementation for testEqualsWhenChanged         // Add test logic here     }     // Other test methods }
public class AppStatus {     private Map<String, AppInstanceStatus> instances = new HashMap<String, AppInstanceStatus>();     private String deploymentId;     private AppStatus status;     // Other member variables and functions     /**      * Return a new instance of {@code AppStatus} based on the provided individual app instances via {@link #with(AppInstanceStatus)}.      *      * @param instance The app instance to be added      * @return A new instance of {@code AppStatus} with the provided app instance added      */     public AppStatus with(AppInstanceStatus instance) {         // Implementation for with(AppInstanceStatus)         // Add logic here to create a new instance of AppStatus with the provided app instance added     }     // Other member functions }
null
public class AbstractDataTypesHelperDecorator {     private DataTypesHelper impl;     // ... constructor, member variables, and other member functions     /**      * The component we are decorating.      */     public boolean equalsDeepHistoryKind(Object kind) {         // Implementation code here     }     /**      * The component we are decorating.      */     public boolean equalsShallowHistoryKind(Object kind) {         // Implementation code here     }     /**      * The component we are decorating.      */     public boolean equalsINITIALKind(Object kind) {         // Implementation code here     }     /**      * The component we are decorating.      */     public String multiplicityToString(Object multiplicity) {         // Implementation code here     }     /**      * The component we are decorating.      */     public void copyTaggedValues(Object from, Object to) {         // Implementation code here     }     /**      * The component we are decorating.      */     public String getLanguage(Object handle) {         // Implementation code here     }     /**      * The component we are decorating.      */     public boolean equalsCHOICEKind(Object kind) {         // Implementation code here     }     /**      * The component we are decorating.      */     public String getBody(Object handle) {         // Implementation code here     }     /**      * The component we are decorating.      */     public Object setLanguage(Object handle, String language) {         // Implementation code here     }     /**      * The component we are decorating.      */     public boolean equalsJUNCTIONKind(Object kind) {         // Implementation code here     }     /**      * The component we are decorating.      */     public Object setBody(Object handle, String body) {         // Implementation code here     }     /**      * The component we are decorating.      */     public boolean equalsFORKKind(Object kind) {         // Implementation code here     }     /**      * The component we are decorating.      */     public boolean equalsJOINKind(Object kind) {         // Implementation code here     } }
public class ReshapeMatrix64F {     private static final long serialVersionUID = 423423451942L;     private int numRows;     private int numCols;     // ... constructor, member variables, and other member functions     /**      * Sets the number of rows.      */     public void setNumRows(int numRows) {         // Implementation code here     }     /**      * Returns a MatrixIterator for iterating over the matrix elements.      */     public MatrixIterator iterator(boolean rowMajor, int minRow, int minCol, int maxRow, int maxCol) {         // Implementation code here     }     /**      * Returns the number of columns.      */     public int getNumCols() {         // Implementation code here     }     /**      * Sets the matrix to be the same as the given matrix.      */     public void set(ReshapeMatrix64F A) {         // Implementation code here     }     /**      * Sets the number of columns.      */     public void setNumCols(int numCols) {         // Implementation code here     }     /**      * Reshapes the matrix with the given number of rows and columns, optionally saving the values.      */     public void reshape(int numRows, int numCols, boolean saveValues) {         // Implementation code here     }     /**      * Reshapes the matrix with the given number of rows and columns.      */     public void reshape(int numRows, int numCols) {         // Implementation code here     }     /**      * Returns the number of rows.      */     public int getNumRows() {         // Implementation code here     }     /**      * Inner class for MatrixIterator implementation      */     public class MatrixIterator {         // Implementation code here     } }
public class RegPCLTestResultEntity {          private BigDecimal feedId;     private BigDecimal runId;     private Timestamp fetcherEndTimeStamp;     private String errorMsg;     private long testId;     private RunStatusType runStatus;     private OutcomeType outcomeType;     private BigDecimal batchId;     private Timestamp fetcherStartTimestamp;     private Timestamp createTimeStamp;     private long serialVersionUID = 1L;     private String createdBy;     private List<RegPCLTestResultDetailsEntity> regPclTestResultDetails;     private Timestamp lastModifiedTimeStamp;     // ... constructor, member variables, and other member functions     /**      * Sets the exp msg.      */     public void setExpMsg(String errorMsg) {         // Implementation code here     }     // ... other member functions }
public class CommonUtils {     private static final String ALPHANUM = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";     private static final Random RANDOM = new Random();     private static final Logger LOG = LoggerFactory.getLogger(Constants.LOGGER_TYPE);     // ... constructor, member variables, and other member functions     /**      * Common empty loop utility that serves the purpose of warming up the JVM before performance microbenchmarks.      */     public void warmUpJVM() {         for (int i = 0; i < 10000; i++) {             // Empty loop for warming up JVM         }     }     // ... other member functions }
null
public Instrumentation getInstrumentation() {     return instrumentation; }
public long mark() {     long currentTime = System.currentTimeMillis();     long elapsedMilliseconds = currentTime - lastMark;     lastMark = currentTime;     return elapsedMilliseconds; }
public String getPclFeedId() {     return pclFeedId; }
public int getElem3() {     return elem3; }
public String getOrder() {     return elementStylingOrder; }
public void reverse() {     head = reverse(head); } private Node reverse(Node current) {     if (current == null || current.next == null) {         return current;     }     Node nextNode = current.next;     current.next = null;     Node reversed = reverse(nextNode);     nextNode.next = current;     return reversed; }
public OpenFileOptions convertCreateFileOptionsToOpenFileOptions(CreateFileOptions createFileOptions) {     OpenFileOptions openFileOptions = new OpenFileOptions();     if (createFileOptions.isCache()) {         openFileOptions.setCache(createFileOptions.isCache());     }     if (createFileOptions.isCommonOptionsSet()) {         openFileOptions.setCommonOptions(createFileOptions.isCommonOptionsSet());     }     if (createFileOptions.getStorageType() != null) {         openFileOptions.setStorageType(createFileOptions.getStorageType());     }     return openFileOptions; }
public Element getKeyInfoElement() {     Element keyInfoElement = null;     if (m_EncryptedKeyElement != null) {         keyInfoElement = m_EncryptedKeyElement.getKeyInfo();     }     if (keyInfoElement == null && m_KeyInfoEl != null) {         keyInfoElement = m_KeyInfoEl;     }     return keyInfoElement; }
public void storeMAPs(Message message, AddressingProperties maps, boolean isProviderContext, boolean isOutbound) {     if (isProviderContext) {         if (isOutbound) {             message.put(AddressingProperties.OUTBOUNDMAP, maps);         } else {             message.put(AddressingProperties.INBOUNDMAP, maps);         }     } else {         if (isOutbound) {             message.put(AddressingProperties.CLIENTOUTBOUNDMAP, maps);         } else {             message.put(AddressingProperties.CLIENTINBOUNDMAP, maps);         }     } }
public void reloadJS(String action) {     Intent intent = new Intent(action);     intent.putExtra(RELOAD_APP_EXTRA_JS_PROXY, getHostForJSProxy());     LocalBroadcastManager.getInstance(mContext).sendBroadcast(intent); }
public void testGetString() {     // Test case for getString method in RequestInput class     // Add your test logic here     // ... }
public String wf_user() {     // Returns the job owner group name     // Add your implementation logic here     // ... }
public void setModuleName(String value) {     // Sets the value of the moduleName property     this.moduleName = value; }
public boolean free(T obj) {     // Frees the object. If the free list is full, the object will be garbage collected.     boolean success = false;     int top = _top.get();     while (top >= 0) {         if (_freeStack.compareAndSet(top, obj, null)) {             _top.decrementAndGet();             success = true;             break;         }         top = _top.get();     }     if (!success) {         obj = null; // Set the object to null for garbage collection     }     return success; }
public void setCorrelationId(String correlationId) {     // Set correlation id of the message.     this.correlationId = correlationId; }
public void testGetAuthorizationID() {     // Tests the PlainSaslServer#getAuthorizationID() to retrieve the correct user.     // Assert that the authorization ID returned matches the expected user.     PlainSaslServer plainSaslServer = new PlainSaslServer();     plainSaslServer.setUser("user");     plainSaslServer.setPassword("password");          byte[] userInfo = plainSaslServer.getUserInfo(plainSaslServer.getUser(), plainSaslServer.getPassword());     String authorizationId = new String(userInfo).split(":")[0];          assertEquals("user", authorizationId); }
public void handleEvent(IParserEvent event) {     // Handle event from the RawRtfParser.     // Process the given event based on its type and update the parser state accordingly.     if (event instanceof Command) {         Command command = (Command) event;         handleCommand(command, command.getParameter(), command.hasParameter(), command.isOptional());     } else if (event instanceof GroupStartEvent) {         processGroupStart();     } else if (event instanceof GroupEndEvent) {         processGroupEnd();     } else if (event instanceof DocumentStartEvent) {         processDocumentStart();     } else if (event instanceof DocumentEndEvent) {         processDocumentEnd();     } else if (event instanceof CharacterEvent) {         processCharacter(((CharacterEvent) event).getCharacter());     } else if (event instanceof BinaryBytesEvent) {         processBinaryBytes(((BinaryBytesEvent) event).getData());     } else if (event instanceof StringEvent) {         processString(((StringEvent) event).getString());     } else if (event instanceof UprEvent) {         processUpr((UprEvent) event);     } }
public List<TempTable> doAMergeIteration(List<TempTable> runs) {     // This method is where most of the action is.     // Up to 2 sorted temporary tables are created,     // and are passed into SortScan for final merging.     List<TempTable> mergedRuns = new ArrayList<>();     for (int i = 0; i < runs.size(); i += 2) {         TempTable p1 = runs.get(i);         TempTable p2 = i + 1 < runs.size() ? runs.get(i + 1) : null;         TempTable mergedTable = mergeTwoRuns(p1, p2);         mergedRuns.add(mergedTable);     }     return mergedRuns; }
public boolean commit() {     // Logs out the user     // The implementation removes the User associated with the Subject.     mSubject.getPrincipals().remove(mUser);     return true; }
public String getPostId() {     // Returns the post id, if available.     return postId; }
public boolean isValidAddressVersion(int version) {     // Check if a given address version is valid given the NetworkParameters.     for (int acceptableCode : acceptableAddressCodes) {         if (acceptableCode == version) {             return true;         }     }     return false; }
public void setAppendSemicolon(boolean appendSemicolon) {     // Set a flag indicating whether to print a ';' after certain statements.     // This is used when pretty-printing for loops.     this.appendSemicolon = appendSemicolon; }
public void testSetFaaMode() {     // Test method for RMCParser#setFaaMode()     // Add test cases here to validate the behavior of setFaaMode() method     // in the RMCParser class.     // ... }
public void setCurrentId(int id) {     // Sets the current record to be the record having the specified ID     // Implement the logic here to set the current record based on the provided ID     // ... }
public String equatesWithField(String fldname) {     // Determines if this term is of the form "F1=F2" where F1 is the specified field     // and F2 is another field. If so, the method returns the name of that field.     // If not, the method returns null.     // Implement the logic here to check if this term equates two fields and return     // the name of the second field if it does, or null if it doesn't.     // ... }
public void setActValue(String actValue) {     // Sets the act value     // Implement the logic here to set the act value to the given value     this.actValue = actValue; }
public DiffBuilder normalizeTextElements() {     // Normalize Text-Elements by removing all empty text nodes and normalizing the non-empty ones.     // "normalized" in this context means all whitespace characters are replaced by space characters     // and consecutive whitespace characters are collapsed.     // Implement the logic here to normalize text elements in the comparison result     // by removing empty text nodes and normalizing non-empty text nodes     return this; }
public ClaimDTO[] getDefaultClaims(String realmName) {     // Get default claims for given trusted service.          // Implement the logic here to retrieve default claims for the specified realmName from the trusted services     // and return them as an array of ClaimDTO objects.          return new ClaimDTO[]{}; // Placeholder return statement }
public boolean getBoolean(final String key) {     // Gets a boolean value out of the object.     // Implement the logic here to retrieve a boolean value from the member variable 'bundle' using the provided key,     // and return the boolean value.          return false; // Placeholder return statement }
public boolean isLogAccepted(String logLevel, String logMessage) {     if (noFilter) {         return true;     }     if (logLevel == null || logMessage == null) {         return false;     }     if (logLevels != null && !logLevels.containsKey(logLevel)) {         return false;     }     if (logFilter == null) {         return true;     }     Matcher matcher = filterPattern.matcher(logMessage);     if (matcher.matches()) {         String messageLogLevel = matcher.group(2);         if (messageLogLevel != null) {             if (logLevels != null && logLevels.containsKey(messageLogLevel)) {                 int messageLogLevelValue = logLevels.get(messageLogLevel);                 int currentLogLevelValue = logLevels.get(logLevel);                 if (messageLogLevelValue <= currentLogLevelValue) {                     return logFilter.isLoggable(logMessage);                 }             }         }     }     return false; }
/**  * Writes the given int value (32-bit) in big-endian order to the buffer.  *   * @param value the int value to be written to the buffer  * @return this BufferedByteWriter object  */ public BufferedByteWriter put32(int value) {     ensureCapacity(4);     mWriter.putInt(value);     return this; }
null
public void removeAllPlugins() {     for(AbstractPlugin plugin : allPlugins.getPlugins()) {         removePlugin(plugin);     } }
public void setWeight(float weight) {     this.weight = weight; }
public void releaseNettyChannel(Channel channel, InetSocketAddress address) {     if (channel == null || address == null) {         throw new IllegalArgumentException("Channel and address cannot be null");     }     NettyChannelPool channelPool = NETTY_CHANNEL_POOL_MAP.get(address);     if (channelPool != null) {         channelPool.release(channel);     } else {         // If channel pool not found, close the channel directly         channel.close();     } }
public String getSystemId() {     return conf.get(CONF_SYSTEM_ID); }
public <E> E putObjectArray(String key, E[] value) {     bundle.putParcelableArray(key, value);     return (E) this; }
public URIBuilder setFragment(final String fragment) {     this.fragment = (fragment != null) ? encodeFragment(fragment, StandardCharsets.UTF_8) : null;     this.encodedFragment = (fragment != null) ? fragment : null;     return this; } private String encodeFragment(final String fragment, final Charset charset) {     try {         return URLEncoder.encode(fragment, charset.name()).replace("+", "%20");     } catch (UnsupportedEncodingException e) {         throw new IllegalArgumentException(e);     } }
public void setKeySize(long keySize) {     this.keySize = keySize; }
public void setUpConfiguration() {     // Set session timeout to be 3 times the delta value     mSessionTimeoutMs = 3 * DELTA;     // Set up the configuration for Alluxio     // ...     // ...     // ... }
public Set<SpringConfig> getAllSpringConfigs() {     return mSpringConfigMap.keySet(); }
public class ELConstantsFunctions {          long PB=TB * 1024;     long TB=GB * 1024;     long GB=MB * 1024;     int SUBMIT_MINUTES=1;     long KB=1024;     long MB=KB * 1024;     int SUBMIT_DAYS=24 * 60;     int SUBMIT_HOURS=60;          public String trim(String input) {         return input.trim();     }          public String concat(String s1, String s2) {         return s1.concat(s2);     }          public Object firstNotNull(Object o1, Object o2) {         return o1 != null ? o1 : o2;     }          public String urlEncode(String input) {         // implementation of urlEncode function         return null;     }          public String getUTCCurrentDateTime() {         DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss'Z'");         ZonedDateTime utcDateTime = ZonedDateTime.now().withZoneSameInstant(java.time.ZoneOffset.UTC);         return formatter.format(utcDateTime);     } }
public class DirectoryUpdateTracker {     private Collection<File> m_newDirectoryContents;     private Collection<File> m_storedDirectoryContents;     private Logger m_log = LoggerFactory.getLogger(getClass());     private boolean m_removed;     private File m_directory;     private boolean m_markedForRemoval = false;     // Constructor     // Member functions     public Collection<File> getFiles(final File dir) {         // Implementation     }     public int hashCode() {         // Implementation     }     public boolean equals(final Object obj) {         // Implementation     }     public boolean markedForRemoval() {         // Implementation     }     public boolean shouldUpdate() {         // Implementation     }     public void setRemoved() {         // Implementation     }     public boolean removed() {         // Implementation     }     public File getDirectory() {         // Implementation     }     public void markForRemoval() {         // Implementation     }     // Member function to implement based on natural language description     public void synchronizeWithDiskCheck() {         // Implementation         // Lets this know the application has been updated with what's on disk,         // and this should synchronize with the last disk check.     } }
public void addRawSQL(String path, String rawSQL) {     SQLiteMatcherEntry matcherEntry = createMatcherEntry(path);     matcherEntry.setRawSQL(rawSQL);     addMatcherEntry(matcherEntry); }      public void addRawSQL(String path, SQLiteMatcherEntry.Type baseType, String subType, String rawSQL) {     SQLiteMatcherEntry matcherEntry = createMatcherEntry(path, baseType, subType);     matcherEntry.setRawSQL(rawSQL);     addMatcherEntry(matcherEntry); }      private void addMatcherEntry(SQLiteMatcherEntry matcherEntry) {     addSQLBuilderCallback(matcherEntry.getPath(), (cursor, selection, selectionArgs, sortOrder) ->             matcherEntry.buildSQL(cursor, selection, selectionArgs, sortOrder, mBaseContentUri, mAuthority, mUriMatcher)     );     addMatcherEntry(matcherEntry); }
public void clearIndividualModel() {     individualStructures.clear(); }
public LanguageVersion getLanguageVersion() {     return languageVersion; }
public void setSignaturePropertiesFile(String signaturePropertiesFile) {     signatureProperties.load(signaturePropertiesFile); } public SignatureProperties getSignatureProperties() {     return signatureProperties; }
public Predicate targetField() {     return this.pred; }
public int isValid(DenseMatrix64F cov) {     int numRows = cov.getNumRows();     int numCols = cov.getNumCols();     if (numRows != numCols) {         return -1; // invalid matrix dimensions     }     for (int i = 0; i < numRows; i++) {         if (cov.get(i, i) <= TOL) {             return i; // invalid diagonal element found         }     }     return 0; // covariance matrix is valid }
public void putUnsignedByte(ByteBuffer bb, int value) {     bb.put((byte)(value & 0xff)); } public void putUnsignedByte(ByteBuffer bb, int position, int value) {     bb.put(position, (byte)(value & 0xff)); }
public void setSubject(String loginName) {     this.subject = new UserSubject(loginName); }
public void setBreakOnException(boolean value) {     dim.setBreakOnException(value); }
public float lat(int y) {     float lat = originLat - ((y - originLat * dotsPerDeg) / dotsPerInch);     return lat; }
public USAddress createUSAddress() {     return new USAddress(); }
null
public JSONObject getJSONObject(int index) {     Object obj = get(index);     if (obj instanceof JSONObject) {         return (JSONObject) obj;     }     return null; }
public double recursive(DenseMatrix64F mat) {     int n = mat.numCols;     if (n == 1) {         return mat.get(0, 0);     }     double det = 0;     for (int i = 0; i < n; i++) {         DenseMatrix64F subMatrix = new DenseMatrix64F(n - 1, n - 1);         for (int j = 1; j < n; j++) {             for (int k = 0; k < n; k++) {                 if (k < i) {                     subMatrix.set(j - 1, k, mat.get(j, k));                 } else if (k > i) {                     subMatrix.set(j - 1, k - 1, mat.get(j, k));                 }             }         }         double sign = (i % 2 == 0) ? 1 : -1;         det += sign * mat.get(0, i) * recursive(subMatrix);     }     return det; }
public Dish findBySiteUrl(String siteUrl) {     return dishRepository.findBySiteUrl(siteUrl); }
public String generateUniqueID() {     String uniqueID = null;     try {         MessageDigest md = MessageDigest.getInstance("MD5");         byte[] bytes = md.digest(UUID.randomUUID().toString().getBytes("utf-8"));         StringBuilder sb = new StringBuilder();         for (int i = 0; i < bytes.length; i++) {             sb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));         }         uniqueID = sb.toString();     } catch (Exception e) {         LOG.error("Error generating unique ID: " + e.getMessage());     }     return uniqueID; }
public void flush() {     // Do any necessary cleanup or processing before flushing the queue     // ...     // Print summary information about the errors     System.out.println("Error queue summary for " + name);     System.out.println("Total errors: " + errorCount);     System.out.println("Flushed: " + flushed);     // Clear the queue and reset the error count and flushed flag     // Note: this assumes the queue is implemented as a List or similar data structure     queue.clear();     errorCount = 0;     flushed = true; }
void onServiceRegistration(ServiceID id, int flags, int prefixBits, InetAddress addr, InetAddress oldAddr) {     // implementation goes here     // called as a result of a previous service addition request }
public List<String> getRegisteredScopes() {     return registeredScopes; }
void deleteDirectory(File dir) throws IOException {     if (dir.isDirectory()) {         File[] files = dir.listFiles();         if (files != null) {             for (File file : files) {                 deleteDirectory(file);             }         }     }     if (!dir.delete()) {         throw new IOException("Failed to delete directory: " + dir);     } }
public String getOperationName(String methodName, ASTFormalParameters params) {     Matcher matcher = FORMAT.matcher(methodName);     if (!matcher.matches()) {         return null;     }     String operationName = matcher.group(7);     return operationName; }
public void declareValid() {     valid = true; }
public void ejecutarRonda() {     try {         semaforo.acquire(); // Acquire the semaphore to start the round         for (Piloto piloto : pilotos) { // Iterate over all the pilots             runTurno(piloto); // Execute a turn for the current pilot         }         rondaTerminada(this, rondas.incrementAndGet()); // Notify observers that the round has ended         semaforo.release(); // Release the semaphore to indicate that the round has ended     } catch (InterruptedException e) {         Thread.currentThread().interrupt();         exception(this, rondas.get(), null, null, e); // Notify observers of the exception     } }
public String getOriginalPath() {     if (request != null) {         return request.getRequestURI();     } else {         return null;     } }
@Test public void createRpcId() {     long id = IdUtils.createRpcId();     String idString = Long.toHexString(id);     assertNotNull(idString);     assertTrue(idString.length() == 16); }
public List<PropertyDescriptor<?>> getPropertyDescriptorsCopy() {     return new ArrayList<>(propertyDescriptors); }
public InputStream convertToInputStream() {     return new ReaderInputStream(reader); }
public void setFailedAttrib(String failedAttrib) {     this.failedAttrib = failedAttrib; }
void register(Profile profile) {     manager.registerProfile(profile); }
public Method searchForMatch(Class<?> type, Method bridgeMethod) {     Method[] candidates = type.getDeclaredMethods();     for (Method candidateMethod : candidates) {         if (isBridgedCandidateFor(candidateMethod, bridgeMethod)) {             return candidateMethod;         }     }     return null; }
/**  * Draw this ball at its current position onto the canvas.  */ public void draw() {     canvas.setColor(color);     canvas.fill(circle); }
/**  * Resolve a variable name. Used by the EL evaluator implementation.  *  * @param name the name of the variable to resolve  * @return the value of the variable, or null if it is not defined  */ public Object resolveVariable(String name) {     if (vars.containsKey(name)) {         return vars.get(name);     } else {         return null;     } }
public void testGetPathWithoutSchemaFromHDFSURI() {     URI uri = URI.create("hdfs://localhost:1234/foo/bar/baz?please=dont&amp;show=up");     String expectedPath = "/foo/bar/baz";     String actualPath = new Path(uri).toString();     assertEquals(expectedPath, actualPath); } public void testGetPathWithoutSchema() {     String uriString = "file:///foo/bar/baz";     String expectedPath = "/foo/bar/baz";     String actualPath = new Path(uriString).toString();     assertEquals(expectedPath, actualPath); } public void testGetPathWithoutSchemaThatContainsSchema() {     String uriString = "http://example.com/foo/bar?query=string";     String expectedPath = "/foo/bar";     String actualPath = new Path(uriString).toString();     assertEquals(expectedPath, actualPath); }
public int getYPosition() {     return yPosition; }
public float getFloatValue(short unitType) {     switch(unitType) {         case CSSPrimitiveValue.CSS_NUMBER:             return floatValue;         case CSSPrimitiveValue.CSS_PX:             return floatValue;         case CSSPrimitiveValue.CSS_MM:             return floatValue * 0.28346f;         case CSSPrimitiveValue.CSS_CM:             return floatValue * 0.28346f * 10;         case CSSPrimitiveValue.CSS_IN:             return floatValue * 0.28346f * 100;         case CSSPrimitiveValue.CSS_PT:             return floatValue * 0.28346f * (1.0f / 72.0f);         case CSSPrimitiveValue.CSS_PC:             return floatValue * 0.28346f * (1.0f / 6.0f);         default:             throw new DOMException(DOMException.NOT_SUPPORTED_ERR, "Unsupported unit type: " + unitType);     } }
public void markBlockMoveIn(long blockId, long blockSize) {     synchronized (mBlocksToMoveIn) {         mBlocksToMoveIn.add(blockId);         mBlocksToMoveInSize += blockSize;     } }
public static WSDLFactory newInstance() throws WSDLException {     String factoryImplName = findFactoryImplName();     try {         return (WSDLFactory) Class.forName(factoryImplName).newInstance();     } catch (ClassNotFoundException e) {         throw new WSDLException(WSDLException.CONFIGURATION_ERROR, "Provider " + factoryImplName + " not found", e);     } catch (Exception e) {         throw new WSDLException(WSDLException.CONFIGURATION_ERROR, "Provider " + factoryImplName + " could not be instantiated: " + e, e);     } } public static String findFactoryImplName() throws WSDLException {     String factoryImplName = null;     try {         factoryImplName = System.getProperty(PROPERTY_NAME);     } catch (SecurityException e) {         // Ignore     }     if (factoryImplName == null) {         try {             Properties properties = new Properties();             InputStream is = WSDLCorbaFactory.class.getClassLoader().getResourceAsStream(PROPERTY_FILE_NAME);             if (is != null) {                 properties.load(is);                 is.close();             }             factoryImplName = properties.getProperty(PROPERTY_NAME);         } catch (IOException e) {             // Ignore         }     }     if (factoryImplName == null) {         factoryImplName = DEFAULT_FACTORY_IMPL_NAME;     }     return factoryImplName; } public String getFullPropertyFileName() {     return fullPropertyFileName; } public WSDLWriter newWSDLWriter() throws WSDLException {     return new WSDLWriterImpl(); } public WSDLReader newWSDLReader() throws WSDLException {     return new WSDLReaderImpl(); } public Definition newDefinition() throws WSDLException {     return new DefinitionImpl(); } public ExtensionRegistry newPopulatedExtensionRegistry() throws WSDLException {     return new ExtensionRegistryImpl(); }
public List<String> getMentionedGroups() {     List<String> mentionedGroups = new ArrayList<String>();     if (atMeGroupList != null) {         mentionedGroups.addAll(atMeGroupList);     }     return mentionedGroups; }
public PropertyDescriptor[] propertyDescriptorsFor(Object fromObj, Class<Object> stopClass) {     BeanInfo info;     try {         info = Introspector.getBeanInfo(stopClass);     } catch (IntrospectionException e) {         return new PropertyDescriptor[0];     }     PropertyDescriptor[] props = info.getPropertyDescriptors();     List<PropertyDescriptor> filteredProps = new ArrayList<>();     for (PropertyDescriptor prop : props) {         if (prop.getReadMethod() != null && prop.getWriteMethod() != null) {             try {                 if (prop.getReadMethod().invoke(fromObj, NO_ARGUMENTS) != null) {                     filteredProps.add(prop);                 }             } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {                 // ignore and continue with other properties             }         }     }     return filteredProps.toArray(new PropertyDescriptor[0]); }
public void setMinutes(int minutes) {     if (minutes < 0 || minutes > 59) {         throw new IllegalArgumentException("Minutes must be between 0 and 59");     }     this.minutes = minutes; }
public String toPlainString() {     return BigDecimal.valueOf(value)         .divide(BigDecimal.valueOf(COIN_VALUE), SMALLEST_UNIT_EXPONENT, RoundingMode.DOWN)         .stripTrailingZeros()         .toPlainString(); }
public void add(JPanel panel) {     uiStack.add(panel); }
public boolean getNillableAttributeValue() {    return defaultNillable; }
public List<SAXParseException> getInstanceErrors(Source instance) {     List<ValidationProblem> problems = validator.validate(instance);     return problemToExceptionList(problems); } private List<SAXParseException> problemToExceptionList(Iterable<ValidationProblem> problems) {     List<SAXParseException> exceptions = new ArrayList<SAXParseException>();     for (ValidationProblem problem : problems) {         if (problem.getSeverity() == ValidationProblem.SEVERITY_ERROR) {             SAXParseException exception = new SAXParseException(problem.getMessage(), null, problem.getLineNumber(), problem.getColumnNumber());             exceptions.add(exception);         }     }     return exceptions; }
public DiffBuilder withComparisonListeners(final ComparisonListener... comparisonListeners) {     this.comparisonListeners.addAll(Arrays.asList(comparisonListeners));     return this; } public void comparisonPerformed(final Comparison comparison, final ComparisonResult outcome) {     if (outcome != ComparisonResult.EQUAL) {         for (ComparisonListener listener : comparisonListeners) {             listener.comparisonPerformed(comparison, outcome);         }     } }
public void setConduitSelector(ConduitSelector conduitSelector) {     this.conduitSelector = conduitSelector; }
public static boolean isFaultServer(Message message) {     Exchange exchange = message.getExchange();     if (exchange == null) {         return false;     }     Throwable ex = exchange.get(Exception.class);     if (ex != null) {         return true;     }     FaultMode faultMode = exchange.get(FaultMode.class);     if (faultMode != null && FaultMode.RUNTIME.equals(faultMode)) {         return true;     }     return false; }
public void hideSoftInput(Context context, View view) {     InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);     imm.hideSoftInputFromWindow(view.getWindowToken(), 0); }
public BigDecimal getRunId() {     return runId; }
public String getTenantDomain() {     return this.tenantDomain; }
null
public Collection<Playlist> getPlaylists() {     return playlists.values(); }
public void createDb() {     try {         // Load the JDBC driver         Class.forName("com.mysql.jdbc.Driver");         // Set up the database connection         String url = "jdbc:mysql://localhost/mydatabase";         String username = "root";         String password = "mypassword";         con = DriverManager.getConnection(url, username, password);         // Prepare the SQL statements         updateItemSQL = con.prepareStatement("UPDATE documents SET name=?, content=? WHERE id=?");         findByFileNameSQL = con.prepareStatement("SELECT * FROM documents WHERE name=?");         findByIDSQL = con.prepareStatement("SELECT * FROM documents WHERE id=?");         deleteItemSQL = con.prepareStatement("DELETE FROM documents WHERE id=?");         newItemSQL = con.prepareStatement("INSERT INTO documents (name, content) VALUES (?, ?)");         listSQL = con.prepareStatement("SELECT * FROM documents");     } catch (ClassNotFoundException | SQLException e) {         e.printStackTrace();     } }
public void setParamName(CString value) {     this.paramName = value; }
public boolean isVisited(String uri) {     return _uriResolver.isVisited(uri); }
public String getKey() {     return getServletContext().getInitParameter("repositoryKey"); }
/**  * Writes any object to the output stream.  *  * @param obj the object to write to the output stream  * @throws IOException if an I/O error occurs while writing to the output stream  */ public void writeObject(Object obj) throws IOException {     _out.writeObject(obj); }
public void addedFile(int fileCount, File file) {     if (fileCount == 1) {         cpd.add(file);     } else if (canTestSymLinks) {         try {             Path link = Paths.get(BASE_TEST_RESOURCE_PATH, "symlink");             Files.createSymbolicLink(link, file.toPath());             cpd.add(link.toFile());         } catch (IOException e) {             e.printStackTrace();         }     } }
@Test public void testSetNextContainerId() {     mGenerator.setNextContainerId(TEST_ID);     assertEquals(TEST_ID, mGenerator.getNewContainerId()); }
void testRankNUpdate() {     for (int i = 1; i <= N; i++) {         for (int j = 1; j <= N; j++) {             for (int k = 1; k <= N; k++) {                 int lengthA = i * 10;                 int heightB = j * 10;                 int widthB = k * 10;                 symmRankNMinus_U();                 checkSymmRankNMinus_U(lengthA, heightB);                 symmRankNMinus_L();                 checkRankNUpdate(lengthA, heightB);                 checkSymmRankNMinus_L(lengthA, widthB);             }         }     } }
@Test(expected = NullPointerException.class) public void testRegisterUserSessionWithNullServerSessionThrowsException() {     notificationController.registerUserSession(null, mockServerMessage); }
public BufferedImage renderToImageAutoSize(String url, int width) {     BufferedImage img = new BufferedImage(width, 1, BufferedImage.TYPE_INT_RGB);     Graphics2D g2 = img.createGraphics();     layout(g2, new Dimension(width, Integer.MAX_VALUE));     int height = panel.getPreferredSize().height;     img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);     g2 = img.createGraphics();     render(g2);     g2.dispose();     return img; }
public DenseMatrix64F getR(DenseMatrix64F R, boolean compact) {     if (compact) {         if (R == null) {             R = new DenseMatrix64F(minLength, numCols);         } else if (R.numRows != minLength || R.numCols != numCols)             throw new IllegalArgumentException("Unexpected matrix size");         for (int i = 0; i < minLength; i++) {             double[] row = QR.data[i];             for (int j = 0; j < i && j < numCols; j++) {                 R.data[i][j] = row[j];             }             R.data[i][i] = row[i];         }     } else {         if (R == null) {             R = new DenseMatrix64F(numRows, numCols);         } else if (R.numRows != numRows || R.numCols != numCols)             throw new IllegalArgumentException("Unexpected matrix size");         R.zero();         for (int i = minLength - 1; i >= 0; i--) {             double[] u = QR.data[i];             R.set(i, i, 1.0);             for (int j = i + 1; j < numCols; j++) {                 double[] colQ = QR.data;                 double r_ij = colQ[i][j];                 for (int k = i + 1; k < minLength; k++) {                     r_ij -= u[k] * colQ[k][j];                 }                 r_ij /= gamma;                 R.set(i, j, r_ij);             }         }     }     return R; }
public InputStream findResource(String fileName) throws IOException {     // Try to find the file as a regular file first     File file = new File(fileName);     if (file.exists()) {         return new FileInputStream(file);     }     // If the file was not found, try to find it as a URL     URL url = new URL(fileName);     try {         return url.openStream();     } catch (IOException e) {         // ignore and continue to classpath search     }     // If the file was not found as a URL, try to find it on the classpath     InputStream inputStream = getClass().getClassLoader().getResourceAsStream(fileName);     if (inputStream == null) {         throw new FileNotFoundException(fileName);     }     return inputStream; }
public int getQuantity() {     return lineItem.getQuantity(); }
public void setCytoband(String cytoband) {     this.cytoband = cytoband; }
public ValidateAccess createValidateAccess() {     return new ValidateAccess(); }
public static String getReturnFormat(HttpServletRequest request) {     String returnFormat = request.getParameter("returnFormat");     if(returnFormat == null) {         returnFormat = "json"; // default return format is json     }     return returnFormat; }
public DishCollection save(DishCollection dishCollection) {     log.debug("Saving DishCollection: {}", dishCollection);     return dishCollectionRepository.save(dishCollection); }
public Sha256Hash calculateDoubleHash(byte[] contents) {     MessageDigest digest;     try {         digest = MessageDigest.getInstance("SHA-256");     } catch (NoSuchAlgorithmException e) {         throw new RuntimeException(e); // Should never happen     }     byte[] firstHash = digest.digest(contents);     byte[] secondHash = digest.digest(firstHash);     return new Sha256Hash(secondHash); }
public void destroy() {     // Perform any necessary cleanup here     // ... }
public class ISO8601Date {     // member variables     private static final String TIMEZONE_MODE = "timezone_mode";     private String eventTimezone = "";     // member functions     public String getTimeZoneDateString(final Date date) {         SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");         if (!eventTimezone.isEmpty()) {             sdf.setTimeZone(TimeZone.getTimeZone(eventTimezone));         }         return sdf.format(date);     }     public Date getTimeZoneDate(final Date date) {         SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");         if (!eventTimezone.isEmpty()) {             sdf.setTimeZone(TimeZone.getTimeZone(eventTimezone));         }         return sdf.parse(sdf.format(date));     }     public String fromCalendar(final Calendar calendar) {         return getTimeZoneDateString(calendar.getTime());     }     public TimeZone getEventTimezone() {         return TimeZone.getTimeZone(eventTimezone);     }     public String dateFromCalendar(Calendar currentDate) {         return getTimeZoneDateString(currentDate.getTime());     }     public void setEventTimezone(String eventTimezone) {         this.eventTimezone = eventTimezone;     }     public String get12HourTime(final Date date) {         SimpleDateFormat sdf = new SimpleDateFormat("hh:mm:ss a");         if (!eventTimezone.isEmpty()) {             sdf.setTimeZone(TimeZone.getTimeZone(eventTimezone));         }         return sdf.format(date);     }     public Date getDateObject(final String iso8601String) {         SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");         Date date = null;         try {             date = sdf.parse(iso8601String);         } catch (Exception e) {             e.printStackTrace();         }         return date;     }     public String get24HourTime(final Date date) {         SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss");         if (!eventTimezone.isEmpty()) {             sdf.setTimeZone(TimeZone.getTimeZone(eventTimezone));         }         return sdf.format(date);     } }
public static DiffBuilder from(Object object) {     Source source = Input.from(object).build();     return new DiffBuilder(source, null, null); }
/**  * Puts the specified name/value pair in the specified JSON object.  *  * @param json the JSON object to add the name/value pair to  * @param key the name of the value to add  * @param value the value to add  */ public void putJsonNameValuePair(JSONObject json, String key, Object value) {     json.put(key, value); }
public T getV() {     return svd.getV(); }
public String getAlias() {     return mAlias; }
public void start() {     // Start the SIP and TURN servers     m_turnServer.start(); } public void stop() {     // Stop the SIP and TURN servers     m_turnServer.stop(); }
public void setProjectSecret(byte[] value) {     this.projectSecret = value; }
null
/**  * Counts the number of times the specified eigenvalue appears.  */ public void multipleEigenvalues() {     // TODO: implement the logic to count the number of times the specified eigenvalue appears }
public static BasicNameManager create(ServiceInfo service) {     BasicNameManager manager = new BasicNameManager();     manager.initialize(service, null);     return manager; }
public static IConfigurationFactory getInstance() {     if (SINGLETON == null) {         synchronized (ConfigurationFactory.class) {             if (SINGLETON == null) {                 SINGLETON = new ConfigurationFactory();                 SINGLETON.setHandler(new CustomConfigurationHandler());             }         }     }     return SINGLETON; } // Custom configuration handler private static class CustomConfigurationHandler implements ConfigurationHandler {     // implement the ConfigurationHandler interface methods here }
public FederationProposal getProposal(String token) {     for (FederationProposal proposal : getPendingFederationProposals()) {         if (proposal.token.equals(token)) {             return proposal;         }     }     return null; }
public void setStringValue(short stringType, String stringValue) {     throw new UnsupportedOperationException("Not supported, class is immutable."); }
public void moveToPreviousBlock() {     if (blk.getCurPage().prevBlk() == null) {         return;     }     pg.read(blk.getCurPage().prevBlk());     blk = new Block(pg, pg.getNumRecords() - 1);     currentrec = -1; }
private Object lookupTargetObjectByEjbLocalReference(String ejbLocalReference) throws NamingException {     InitialContext ctx = new InitialContext();     return ctx.lookup(ejbLocalReference); }
public List<String> getAcceptedEncryptionAlgorithms() {     if (acceptedEncryptionAlgorithms.isEmpty()) {         // Add default encryption algorithms if the list is empty         acceptedEncryptionAlgorithms.add(WSConstants.TRIPLE_DES);         acceptedEncryptionAlgorithms.add(WSConstants.AES_128);         acceptedEncryptionAlgorithms.add(WSConstants.AES_128_GCM);         acceptedEncryptionAlgorithms.add(WSConstants.AES_192);         acceptedEncryptionAlgorithms.add(WSConstants.AES_192_GCM);         acceptedEncryptionAlgorithms.add(WSConstants.AES_256);         acceptedEncryptionAlgorithms.add(WSConstants.AES_256_GCM);     }     return acceptedEncryptionAlgorithms; }
public void stop(BundleContext context) {     // This method does nothing, as the framework will automatically unregister any registered services. }
public static FlipTable newTable(String[] headers, Object[][] data) {     if (data == null || data.length == 0 || data[0].length == 0) {         return new FlipTable(new Object[][]{{EMPTY}});     }     int rowCount = data.length;     int columnCount = data[0].length;     Object[][] tableData = new Object[rowCount + 1][columnCount];     tableData[0] = headers;     for (int i = 0; i < rowCount; i++) {         tableData[i + 1] = data[i];     }     return new FlipTable(tableData); }
public Node getActualTarget() {     return target; }
// The component we are decorating. public Object getDecoratedComponent() {     return impl; }
public void convertToClockTimeWithOneSecond() {     long ms = 1000;     String expected = "00:00:01";     String actual = WebUtils.convertMsToClockTime(ms);     assertEquals(expected, actual); }
public class VisibilityKindEnum {     private static final VisibilityKindEnum VK_PACKAGE = new VisibilityKindEnum("vk_package");     private java.util.List<String> typeName;     private static final VisibilityKindEnum VK_PRIVATE = new VisibilityKindEnum("vk_private");     private static final VisibilityKindEnum VK_PUBLIC = new VisibilityKindEnum("vk_public");     private java.lang.String literalName;     private static final VisibilityKindEnum VK_PROTECTED = new VisibilityKindEnum("vk_protected");     public VisibilityKindEnum(String literalName) {         this.literalName = literalName;     }     public java.lang.Object readResolve() {         // Implement the readResolve() method here     }     public static VisibilityKindEnum forName(java.lang.String name) {         // Implement the forName() method here     }     public java.util.List<String> refTypeName() {         // Implement the refTypeName() method here     }     public int hashCode() {         // Implement the hashCode() method here     }     public boolean equals(java.lang.Object o) {         // Implement the equals() method here     }     public String toString() {         return literalName;     } }
/**  * Returns the list of downlinks for this node.  *  * @return List of ClassdiagramNode objects representing the downlinks of this node.  */ public List<ClassdiagramNode> getDownlinks() {     return downlinks; }
public class Services {     private static final String CONF_SERVICE_CLASSES = "oozie.services";     private static final String CONF_SERVICE_EXT_CLASSES = "oozie.services.ext";     private static final String OOZIE_HOME_DIR = "oozie.home.dir";     private static final String CONF_SYSTEM_MODE = "oozie.systemmode";     private static final String CONF_SYSTEM_ID = "oozie.system.id";     private static final String CONF_DELETE_RUNTIME_DIR = "oozie.delete.runtime.dir.on.shutdown";     private static final int MAX_SYSTEM_ID_LEN = 10;     private Configuration conf;     private String runtimeDir;     private Services SERVICES;     private Map<Class<? extends Service>, Service> services = new LinkedHashMap<Class<? extends Service>, Service>();     private String systemId;     private String oozieHome;     private SYSTEM_MODE systemMode;     // other member functions and variables     /**      * Return the runtime directory of the Oozie instance.      * The directory is created under TMP and it is always a new directory per Services initialization.      *      * @return the runtime directory of the Oozie instance      */     public String createRuntimeDir() {         String tmpDir = System.getProperty("java.io.tmpdir");         String runtimeDir = tmpDir + File.separator + "oozie-runtime-" + UUID.randomUUID().toString();         File dir = new File(runtimeDir);         if (!dir.exists()) {             dir.mkdirs();         }         return runtimeDir;     }     // other member functions }
public boolean getBoolean(boolean defaultValue) {     boolean result = defaultValue;     if (currentValue != null) {         String lowerCaseValue = currentValue.trim().toLowerCase();         if (lowerCaseValue.equals("true")) {             result = true;         } else if (lowerCaseValue.equals("false")) {             result = false;         }     }     return result; }
public void switchDims() {     int originalProgress = mSlider.getProgress();     mSlider.setProgress(originalProgress + 1);     mSlider.setProgress(originalProgress); }
/**  * Test method for {@link net.sf.marineapi.nmea.util.Time#getHour()}.  */ public void testGetHour() {     // Create a new Time object with a specific hour     Time time = new Time(10, 0, 0);          // Verify that the getHour() method returns the correct hour     assertEquals(10, time.getHour()); }
public Date getDateFromDatePicker(DatePicker datePicker) {     int day = datePicker.getDayOfMonth();     int month = datePicker.getMonth();     int year = datePicker.getYear();     Calendar calendar = Calendar.getInstance();     calendar.set(year, month, day, 0, 0, 0);     calendar.set(Calendar.MILLISECOND, 0);     return calendar.getTime(); }
public void setCreatedDate(Timestamp createdDate) {     this.createdDate = createdDate; }
public boolean containsAssertions(Collection<Assertion> outer, Collection<Assertion> inner) {     for (Assertion assertion : inner) {         boolean found = false;         for (Assertion outerAssertion : outer) {             if (assertion.equals(outerAssertion)) {                 found = true;                 break;             }         }         if (!found) {             return false;         }     }     return true; }
public NodeVisitor begin() {     // TODO: Implement any necessary changes to internal state     return this; }
public XsdStringType getParamValue() {     return paramValue; }
public String fromString(String input) {     // implementation code goes here }
public int getScaledPagingTouchSlop() {     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO) {         return IMPL.getScaledPagingTouchSlop();     } else {         return IMPL.getScaledTouchSlop();     } }
public TypeNode parseTypeNode(String fmt, Object... os) {     PolyglotParser parser = new PolyglotParser(ext);     TypeNode node = parser.parseTypeNode(fmt, os);     return node; }
public class RMBTest {     String EXAMPLE = "$GPRMB,A,0.00,R,,RUSKI,5536.200,N,01436.500,E,432.3,234.9,,V*58";     RMBSentence rmb;     RMBSentence empty;     // Test method for net.sf.marineapi.nmea.parser.RMBParser#setSteerTo(CompassPoint)     void testSetSteerTo() {         CompassPoint compassPoint = CompassPoint.NORTH;         rmb.setSteerTo(compassPoint);     }     // Rest of the test methods     void testSetBearingWithNegativeValue() {         // implementation     }     void testSetStatus() {         // implementation     }     void testGetBearing() {         // implementation     }     void testSetVelocityWithNegativeValue() {         // implementation     }     void testGetCrossTrackError() {         // implementation     }     void testArrivalStatus() {         // implementation     }     void testSetDestination() {         // implementation     }     void testGetDestination() {         // implementation     }     void testGetStatus() {         // implementation     }     void testGetRange() {         // implementation     }     void testSetRange() {         // implementation     }     void testSetVelocity() {         // implementation     }     void testSetCrossTrackError() {         // implementation     }     void testSetBearing() {         // implementation     }     void testSetOriginId() {         // implementation     }     void testConstructor() {         // implementation     }     void testSetBearingWithValueGreaterThanAllowed() {         // implementation     }     void testGetVelocity() {         // implementation     }     void testGetOriginId() {         // implementation     }     void setUp() {         // implementation     } }
public void closeHandlerIfConnected() {     if (connectedHandler != null) {         connectedHandler.close();         connectedHandler = null;     } }
public void addPropertyChangeListener(final PropertyChangeListener listener) {     m_PropertyChangeSupport.addPropertyChangeListener(listener); } public void addPropertyChangeListener(final String propertyName, final PropertyChangeListener listener) {     m_PropertyChangeSupport.addPropertyChangeListener(propertyName, listener); }
public Client getClient() {     return this.client; }
public static String getDescription(AccessibilityServiceInfo info) {     return info.loadDescription(ServiceLocator.getInstance().getPackageManager()); }
void initInternal(String s) {     Locale.setDefault(new Locale(s)); }
public Script createInputScript(Address from, byte[] sigBytes, Script pubKeyScript) {     if (sigBytes == null) {         // Incomplete scriptSig with OP_0 instead of signature         return new ScriptBuilder().op(OP_0).data(new byte[0]).build();     } else {         ECKey ecKey = ECKey.fromPrivate(sigBytes);         TransactionSignature txSig = new TransactionSignature(SIGHASH_ALL, null, ByteUtils.reverseBytes(sigBytes));         return new ScriptBuilder()                 .data(txSig.encodeToBitcoin())                 .data(ecKey.getPubKey())                 .build();     } }
public Timestamp getReceiptDate() {     return this.receiptDate; }
/**  * Enforce that the Issuer of the received Response/Assertion is known.  * The default is true.  *  * @param issuer the Issuer of the received Response/Assertion  * @throws SSOValidationException if the Issuer is not known  */ public void validateIssuer(org.opensaml.saml.saml2.core.Issuer issuer) throws SSOValidationException {     if (enforceKnownIssuer && !issuer.getValue().equals(issuerIDP)) {         LOG.error("Issuer " + issuer.getValue() + " does not match expected value " + issuerIDP);         throw new SSOValidationException("Issuer " + issuer.getValue() + " is not known");     } }
public ValidateAccess getAccess() {     return access; }
public class ArgoVersion {     public static String VERSION = "PRE-0.26.alpha1"; }
public void moveTo(int b) {     if (b < 0 || b >= currentblknum) {         throw new IllegalArgumentException("Invalid block number: " + b);     }     rp.read(currentblknum = b, tx); }
void updateModel() {    WalkDirection direction = model.getCharacterDirection();    viewer.updateCharacterSprite(direction); }
public BlockWorkerClientService.Client acquireBlockWorkerThriftClient(final InetSocketAddress address) {     BlockWorkerThriftClientPool clientPool = BLOCK_WORKER_THRIFT_CLIENT_POOL.get(address);     if (clientPool == null) {         clientPool = new BlockWorkerThriftClientPool(address);         BLOCK_WORKER_THRIFT_CLIENT_POOL.put(address, clientPool);     }     return clientPool.acquire(); }
public String getFailedAttrib() {     return failedAttrib; }
public void setAllHeaders(Map<String,Object> headers) {     this.headers = headers; }
@Override public int hashCode() {     final int prime = 31;     int result = 1;     result = prime * result + ((_core_hash_cache == 0) ? compute_core_hash() : _core_hash_cache);     return result; }
public boolean validateSAMLRequest(String samlRequest) {     try {         // create SAML request validator         SAMLRequestValidator requestValidator = new SAMLRequestValidator();                  // validate SAML request         requestValidator.validate(samlRequest);                  return true;     } catch (SAMLValidationException e) {         log.error("Error validating SAML request: " + e.getMessage(), e);         return false;     } }
public Sha256Hash getBlockDifficultyHash(Block block) {     return block.getDifficultyTargetAsInteger().toByteArray(); }
public void moveFile(String sourcePath, String destPath) throws IOException {     File sourceFile = new File(sourcePath);     File destFile = new File(destPath);          // Use Google Guava's Files.move() method for moving the file     Files.move(sourceFile, destFile); }
public JSONArray toJSONArray(List<? extends JsonCoordinatorAction> actions) {     JSONArray jsonArray = new JSONArray();     for (JsonCoordinatorAction action : actions) {         jsonArray.put(action.toJSONObject());     }     return jsonArray; }
public void cleanMd5Cache() {     md5Cache.clear(); }
public String getInactivationReasonType() {     return this.inactivationReasonType; }
/**  * Logs and wraps the given exception.  *  * @param e The exception to log and wrap.  */ private void logAndWrapException(Exception e) {     String errorMessage = "Error occurred: " + e.getMessage();     log.error(errorMessage, e);     throw new RuntimeException(errorMessage, e); }
public static ByteBuffer getIncreasingByteBuffer(int start, int len) {     ByteBuffer buffer = ByteBuffer.allocate(len * Integer.BYTES);     for (int i = 0; i < len; i++) {         buffer.putInt(start + i);     }     buffer.flip();     return buffer; }
public int getLane_id() {     return lane_id; }
public static boolean isLegalJavaIdentifier(String s) {     if (StringUtils.isBlank(s)) {         return false;     }     if (!Character.isJavaIdentifierStart(s.charAt(0))) {         return false;     }     for (int i = 1; i < s.length(); i++) {         if (!Character.isJavaIdentifierPart(s.charAt(i))) {             return false;         }     }     return true; }
private boolean isLoaded = false; public boolean load() {     if (isLoaded) {         return false;     }     boolean success = config.load(FILE_LOADED);     if (success) {         isLoaded = true;     }     return success; }
public void addUtilities(List<Double> utilities) {     if (itemsets.isEmpty()) {         throw new IllegalStateException("Cannot add utilities without adding itemsets first.");     }     if (utilities.size() != itemsets.get(itemsets.size() - 1).size()) {         throw new IllegalArgumentException("Number of utilities must match number of items in last added itemset.");     }     profits.add(utilities);     exactUtility += calculateExactUtility(utilities); } private double calculateExactUtility(List<Double> utilities) {     double sum = 0;     for (int i = 0; i < utilities.size(); i++) {         sum += utilities.get(i) * itemsets.get(itemsets.size() - 1).get(i);     }     return sum; }
public long getIndex() {     return index; }
public InStreamOptions setSeekBufferSizeBytes(long seekBufferSizeBytes) {     mSeekBufferSizeBytes = seekBufferSizeBytes;     return this; }
public String getCurrentUTCinSqlFormat() {     DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");     LocalDateTime dateTime = LocalDateTime.now(ZoneOffset.UTC);     return dateTime.format(formatter); }
public void increment(T key) {     counter.put(key, counter.getOrDefault(key, 0) + 1); }
public void setTestResultLst(List<TestResultDTO> testResultLst) {     this.testResultLst = testResultLst; }
public Scriptable wrapAsScriptable(Context cx, Scriptable scope, Object obj) {     if (obj == null) {         return null;     } else if (obj instanceof Scriptable) {         return (Scriptable) obj;     } else {         Class<?> clazz = obj.getClass();         Class<?> staticType = getStaticType(obj);         return wrap(cx, scope, obj, staticType);     } }
public String getTierAlias() {     return mTierAlias; }
public synchronized PaymentChannelServerState getOrCreateState() {     if (state == null) {         state = new PaymentChannelServerState(                 contract, clientOutput, myKey, bestValueSignature,                 bestValueToMe, refundTransactionUnlockTimeSecs);     }     return state; }
public String getJavascriptAttributeName(String attributeName) {     // Check if attribute name contains any special characters that need to be replaced     if (attributeName.contains(":") || attributeName.contains("-")) {         // Replace ':' and '-' with '_'         attributeName = attributeName.replace(':', '_').replace('-', '_');     }          // Check if the resulting attribute name is a valid Javascript identifier     // If it's not, prefix it with an underscore     if (!Character.isJavaIdentifierStart(attributeName.charAt(0)) || !Character.isJavaIdentifierPart(attributeName.charAt(0))) {         attributeName = "_" + attributeName;     }          return attributeName; }
public Scan createScan() {     TempTable tempTable = rhs.materialize();     int fileSize = tempTable.getNumRecords();     int chunkSize = Math.min(BufferPoolManager.DEFAULT_NUM_BUFFERS, fileSize);     List<Plan> chunkPlans = new ArrayList<>();     int numChunks = (int) Math.ceil((double) fileSize / chunkSize);     for (int i = 0; i < numChunks; i++) {         int startRecord = i * chunkSize;         int endRecord = Math.min(startRecord + chunkSize, fileSize);         Plan chunkPlan = new BlockNestedLoopPlan(lhs, new TableScan(tempTable), startRecord, endRecord);         chunkPlans.add(chunkPlan);     }     return new MultiBufferProductScan(chunkPlans); }
public void setHighPriority(boolean highPriority) {     _highPriority = highPriority; }
public ServerSession getServerSessionForUser(String userId) {     return userSessionMap.get(userId); }
public String getApplicationDescription() {     return this.applicationDescription; }
public List<String> getLocations() {     List<String> locations = new ArrayList<>();     for (String location : locationPositions.keySet()) {         locations.add(location);     }     return locations; }
public Object getValue(String fldname) {     if (groupfields.contains(fldname)) {         return groupval.get(fldname);     } else {         for (AggregationFn fn : aggfns) {             if (fn.getFieldName().equals(fldname)) {                 return fn.getValue();             }         }     }     return null; }
public String getTestData() {     return this.testData; }
public Builder addConfiguration(PropertyKey key, String value) {     mConfiguration.put(key, value);     return this; }
public String getValidInputOverWhiteListPatterns(String input, String... whiteListPatterns) throws IdentityValidationException {     for (String pattern : whiteListPatterns) {         String regex = getRegex(pattern);         if (input.matches(regex)) {             return input;         }     }     throw new IdentityValidationException(String.format("%s%s%s", msgSection1, msgSection2, getPatternString(whiteListPatterns))); }
public Schema schema() {     return srcplan.schema(); }
public Result filterOut(List<String> sources) {     Result filteredResult = new Result();     for (ResultEntry entry : log) {         if (!sources.contains(entry.getSource())) {             filteredResult.add(entry);         }     }     for (Map.Entry<ResultObserver, ResultObserverSettings> observer : observers.entrySet()) {         List<String> observerSources = observer.getValue().sources;         if (observerSources.isEmpty() || Collections.disjoint(observerSources, sources)) {             observer.getKey().update(filteredResult);         }     }     return filteredResult; }
public Map<T, String> getRandomColorMap(Set<T> keys) {     Map<T, String> colorMap = new HashMap<>();     ColorFactory colorFactory = new ColorFactory();     Color baseColor = colorFactory.getRandomColor();     for (T key : keys) {         Color color = colorFactory.getRandomColor();         color = colorFactory.tintColor(color, colorFactory.FIXED_TINT_FACTOR);         String colorString = colorFactory.getColorString(color);         colorMap.put(key, colorString);     }     return colorMap; }
public void setPopulationSize(int size) {     this.POPULATION_SIZE = size; } public void setIterations(int cnt) {     this.ITERATIONS = cnt; }
void writeDomains(Document document, Element rootElement) {     Element domainsElement = document.createElement("domains");     for (DomainSpec domainSpec : document.getDomainSpecs()) {         Element domainElement = document.createElement("domain");         domainElement.setAttribute("name", domainSpec.getName());         domainElement.setAttribute("description", domainSpec.getDescription());         for (String attr : domainSpec.getAttributes()) {             Element attributeElement = document.createElement("attribute");             attributeElement.setTextContent(attr);             domainElement.appendChild(attributeElement);         }         domainsElement.appendChild(domainElement);     }     rootElement.appendChild(domainsElement); }
public int getValuesCount() {     return values.size(); }
private String inputSourceEncoding; public void setEncoding(String encoding) {     this.inputSourceEncoding = encoding; } public String getEncoding() {     return inputSourceEncoding; }
public void logMessage(String colorCode, String message) {     messages.add(colorCode + message); }
public MetadataEditorCompat putInt(int key, int value) {     if (HAS_REMOTE_CONTROL_APIS) {         if (mActualMetadataEditor != null) {             try {                 Method putIntMethod = mActualMetadataEditor.getClass().getMethod("putInt", int.class, int.class);                 putIntMethod.invoke(mActualMetadataEditor, key, value);             } catch (Exception e) {                 e.printStackTrace();             }         }     } else {         // do nothing     }     return this; }
public void spinLeft() {     cmd.spinLeft(spinSpeed);     waitFor(spinTime);     cmd.stop();     threadTimer += spinTime; }
@GetMapping("/ingredients/{id}") public ResponseEntity<Ingredient> getIngredient(@PathVariable String id) {     log.debug("REST request to get Ingredient : {}", id);     Optional<Ingredient> ingredient = ingredientService.findOne(id);     return ingredient.map(response -> ResponseEntity.ok().body(response))             .orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND)); }
@Override void testNode(Node aNode, NodeTest forTest) {     // Delegating to a custom logic     // Add your own custom logic here }
public String getStringValue(String query) {     String result = "";     try {         Statement stmt = connection.createStatement();         ResultSet rs = stmt.executeQuery(query);         if (rs.next()) {             result = rs.getString(1);             if (result == null || result.isEmpty()) {                 result = "{Empty}";             }         }         rs.close();         stmt.close();     } catch (SQLException e) {         e.printStackTrace();     }     return result; }
public static String packageName(String classFullName) {     int lastDotIndex = classFullName.lastIndexOf('.');     return (lastDotIndex != -1) ? classFullName.substring(0, lastDotIndex) : ""; }
/** * {@inheritDoc} * Additionally - two {@link SimpleTypedNameDeclaration} are equal, if they contain types, that can be cast into each other. */ @Override public boolean equals(Object obj) {     if (this == obj) {         return true;     }     if (!(obj instanceof SimpleTypedNameDeclaration)) {         return false;     }     SimpleTypedNameDeclaration other = (SimpleTypedNameDeclaration) obj;     if (type == null) {         if (other.type != null) {             return false;         }     } else if (!type.isAssignableFrom(other.type) && !other.type.isAssignableFrom(type)) {         return false;     }     if (next == null) {         if (other.next != null) {             return false;         }     } else if (!next.equals(other.next)) {         return false;     }     return true; }
public String getItemDescription() {     return lineItem.getPartNumber(); }
public void setSkipBytes(int bytesToSkip) {     this.skipBytes = bytesToSkip; }
public int getGlobalTileID() {     // You'd probably want to call setGlobalTileID instead.     throw new UnsupportedOperationException("You'd probably want to call setGlobalTileID instead."); }
@Test public void testGetCapacityBytes() {     long expectedCapacityBytes = mMetadataManager.getBlockStoreCapacity();     assertEquals(expectedCapacityBytes, mBlockStoreMeta.getCapacityBytes()); }
void handleLine(String line, String end) {     int len = line.length();     int pos = 0;     char[] buffer = new char[len];     while (pos < len) {         char c = line.charAt(pos++);         if (c == '\n') {             buffer[pos - 1] = '\0';             String currentLine = new String(buffer, 0, pos - 1);             lines.add(currentLine);             return;         } else if (c == '\r') {             buffer[pos - 1] = '\0';             String currentLine = new String(buffer, 0, pos - 1);             lines.add(currentLine);             if (pos < len && line.charAt(pos) == '\n') {                 pos++;             }             return;         }         buffer[pos - 1] = c;         if (pos == len) {             lineBuf.setIncompleteLine(buffer, pos);         }     } }
@Test public void testSetSentenceCount() {     int count = 3;     gsv.setSentenceCount(count);     assertEquals(count, gsv.getSentenceCount()); }
public void setIconPath(String iconPath) {     this.iconPath = iconPath; }
public boolean isProxyEnabled() {     if (authentication != null && authentication.getUsername() != null && authentication.getPassword() != null) {         return true;     }     for (RemoteRepository remoteRepository : remoteRepositories) {         if (remoteRepository.getProxy() != null && remoteRepository.getProxy().getUsername() != null                 && remoteRepository.getProxy().getPassword() != null) {             return true;         }     }     return false; }
public void parse(InputStream inputStream) throws IOException {     try (PushbackInputStream pushbackInputStream = new PushbackInputStream(inputStream)) {         handleEvent(DOCUMENT_START);         int data;         while ((data = pushbackInputStream.read()) != -1) {             state.advance(pushbackInputStream, data);         }         handleEvent(DOCUMENT_END);     } }
public Result filterOut(List<String> sources) {     Result result = new Result();     for (ResultEntry entry : log) {         if (!sources.contains(entry.getSource())) {             result.add(entry);         }     }     for (ResultObserver observer : observers.keySet()) {         ResultObserverSettings settings = observers.get(observer);         List<String> observerSources = settings.getSources();         if (observerSources != null && !observerSources.isEmpty()) {             List<String> filteredSources = new ArrayList<>(observerSources);             filteredSources.retainAll(sources);             if (!filteredSources.isEmpty()) {                 result.addObserverLogSource(observer, filteredSources);             }         } else {             result.registerObserver(observer);         }         ResultLevel level = settings.getLevel();         if (level != null) {             result.setObserverLevel(observer, level);         }     }     return result; }
public class TestNormOps {     DenseMatrix64F unzeroVector = new DenseMatrix64F(5, 1, true, 0.3, 1, -2, 3, 4);     Random rand = new Random(234);     DenseMatrix64F zeroMatrix = new DenseMatrix64F(3, 4);     DenseMatrix64F unzeroMatrix = new DenseMatrix64F(3, 2, true, 0.2, 1, -2, 3, 6, 5);     DenseMatrix64F squareMatrix = new DenseMatrix64F(2, 2, true, 0.2, 1, -2, 3);     void inducedP2() {         // implementation     }     void checkUncountable(double val) {         // implementation     }     void inducedP1() {         // implementation     }     void normF() {         // implementation     }     void conditionP() {         // implementation     }     void normP2() {         // implementation     }     void fastNormP2() {         // implementation     }     void normalizeF() {         // implementation     }     void fastNormP() {         // implementation     }     void normP() {         // implementation     }     void fastElementP() {         // implementation     }     void fastNormF() {         // implementation     }     void normPInf() {         // implementation     }     void elementP() {         // implementation     }     void inducedPInf() {         // implementation     }     void normP1() {         // implementation     }     void testConditionNumber() {         double[][] matrixData = {{0.2, 1}, {-2, 3}};         DenseMatrix64F matrix = new DenseMatrix64F(matrixData);         double cond = NormOps.conditionP(matrix);         System.out.println("Condition number: " + cond);     } }
/**  * Test case for {@link OSSUnderFileSystem#delete(String,boolean)}.  * Tests the behavior of the method when encountering service exceptions.  * Deletes the path recursively.  */ public void deleteRecursiveOnServiceException() {     try {         // create a test file to delete         String testFile = PATH + "/test_file";         mOSSUnderFileSystem.create(testFile);         // delete the test file and make sure it's deleted         assertTrue(mOSSUnderFileSystem.delete(testFile, false));         assertFalse(mOSSUnderFileSystem.exists(testFile));         // create a test directory to delete         String testDir = PATH + "/test_dir";         mOSSUnderFileSystem.mkdirs(testDir);         // create a subdirectory and a file inside it         String subDir = testDir + "/sub_dir";         mOSSUnderFileSystem.mkdirs(subDir);         String subFile = subDir + "/sub_file";         mOSSUnderFileSystem.create(subFile);         // delete the test directory recursively and make sure it's deleted         assertTrue(mOSSUnderFileSystem.delete(testDir, true));         assertFalse(mOSSUnderFileSystem.exists(testDir));     } catch (IOException e) {         fail("Unexpected exception: " + e.getMessage());     } }
public List<Language> getLanguagesOfFile(File sourceFile) {     List<Language> languages = new ArrayList<>();     String fileName = sourceFile.getName();     String extension = getExtension(fileName);     LanguageVersion defaultLanguageVersion = getDefaultLanguageVersionForFile(sourceFile);     for (Language language : languageToLanguageVersion.keySet()) {         LanguageVersion languageVersion = getDefaultLanguageVersion(language);         if (languageVersion == null) {             continue;         }         if (language.getExtension().equals(extension) && languageVersion.equals(defaultLanguageVersion)) {             languages.add(language);         }     }     return languages; }
public B suppressTests(Method... methods) {     suppressedTests.addAll(Arrays.asList(methods));     return self(); }
/**  * Registers the instance of RemoteControlClient with the AudioManager.  *  * @param audioManager The AudioManager instance to register with.  * @param remoteControlClient The RemoteControlClientCompat instance to register.  */ public void unregisterRemoteControlClient(AudioManager audioManager, RemoteControlClientCompat remoteControlClient) {     if (sHasRemoteControlAPIs) {         audioManager.unregisterRemoteControlClient(remoteControlClient.getRemoteControlClient());     } }
public void incrementMessagesSent() {     synchronized (this) {         messagesSent += 1;     } }   public void incrementMessagesSent(MessageContext mc) {     synchronized (this) {         incrementMessagesSent();     } }   public long getMessagesSent() {     return messagesSent; }
public lalr_item remove() {     if (_all.isEmpty()) {         return null;     }     Iterator<Map.Entry<lalr_item, lalr_item>> iterator = _all.entrySet().iterator();     lalr_item item = iterator.next().getKey();     iterator.remove();     return item; }
public URI getURI() {     return theURI; }
@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)         throws IOException, ServletException {     if (!(request instanceof HttpServletRequest)) {         chain.doFilter(request, response);         return;     }     HttpServletRequest httpRequest = (HttpServletRequest) request;     String requestURI = httpRequest.getRequestURI();     String themeName = getThemeName(requestURI);     if (themeName == null) {         chain.doFilter(request, response);         return;     }     if (!cache.containsKey(themeName)) {         compileLess(themeName);     }     chain.doFilter(request, response); } private String getThemeName(String requestURI) {     Matcher matcher = PATTERN_THEME_REQUEST_PARTS.matcher(requestURI);     if (matcher.matches()) {         return matcher.group(3);     }     matcher = PATTERN_THEME_REQUEST.matcher(requestURI);     if (matcher.matches()) {         return matcher.group(1);     }     return null; } private void compileLess(String themeName) {     String sourcePath = LESS_PATH + themeName + "/library.less";     String css = load(sourcePath);     if (css == null) {         log("Unable to load source file: " + sourcePath);         return;     }     Scriptable scope = compileCSS(css, sourcePath, false, false, "library");     String result = scope.get("css", scope).toString();     cache.put(themeName, result);     log("LessFilter: Compiled theme " + themeName); }
null
@Test public void testGetSatelliteInfo() {     // Create some sample data     String sentence = "$GPGSV,3,2,12,15,56,182,51,17,38,163,47,18,63,058,50,21,53,329,47*73";     GSVTest gsvTest = new GSVTest(new GSVSentence(sentence), sentence, new GSVSentence());     // Get satellite info from the parser     List<SatelliteInfo> satelliteInfoList = gsvTest.gsv.getSatelliteInfo();     // Assert that the number of satellites is correct     assertEquals(4, satelliteInfoList.size());     // Assert that the first satellite info is correct     SatelliteInfo si = satelliteInfoList.get(0);     assertEquals(15, si.getId());     assertEquals(56, si.getElevation());     assertEquals(182, si.getAzimuth());     assertEquals(51, si.getNoise()); }
public class DataByteBufferTest {     ByteBuffer mBuffer = null;     int LENGTH = 5;          void length() {         // implementation code here     }          void readOnlyByteBuffer() {         // implementation code here     }          void before() {         // implementation code here     }          void testGetNettyOutput() {         // implementation code here     } }
public boolean isLoggingEnabled() {     return loggingEnabled; }
public RegisteredClient getClientConfiguredForIssuer(String issuer) {     for (RegisteredClient client : clients.values()) {         if (client.getIssuer().equals(issuer)) {             return client;         }     }     return null; }
public String getFilenameWithoutExtension(String filename) {     int dotIndex = filename.lastIndexOf(".");     if (dotIndex > 0 && dotIndex < filename.length() - 1) {         return filename.substring(0, dotIndex);     } else {         return filename;     } }
public boolean classDeclaresFieldWithNameAndSignature(String name, FieldSignature signatureMask) {     for (Map.Entry<FieldSignature, Set<String>> entry : fields.entrySet()) {         FieldSignature fieldSignature = entry.getKey();         Set<String> classNames = entry.getValue();         if (fieldSignature.matches(signatureMask) && classNames.contains(name)) {             return true;         }     }     return false; }
void firePathLeafStateChanged(TreePath path) {     TreeModelEvent event = new TreeModelEvent(this, path);     Object[] listenersArray = listeners.getListenerList();     for (int i = listenersArray.length - 2; i >= 0; i -= 2) {         if (listenersArray[i] == TreeModelListener.class) {             ((TreeModelListener) listenersArray[i + 1]).treePathChanged(event);         }     } }
void onServiceUnregistration(ServiceID id, int flags, int prefixBits, InetAddress addr) {     // implementation logic goes here     // called as a result of a previous service removal request     // add your code here }
public class FeedConfigResponse {     private String testId;     private String batchId;     private String runStatus;     private String reason;     private String feedId;          // Constructor and other member functions          public void setRunStatus(String runStatus) {         this.runStatus = runStatus;     }          public void setFeedId(String feedId) {         this.feedId = feedId;     }          public String getRunStatus() {         return runStatus;     }          public String getBatchId() {         return batchId;     }          public String toString() {         // Implementation for toString() method     }          public String getFeedId() {         return feedId;     }          public boolean isFeedRunnable() {         // Implementation for isFeedRunnable() method     }          public String getReason() {         return reason;     }          public void setReason(String reason) {         this.reason = reason;     }          public void setBatchId(String batchId) {         this.batchId = batchId;     }          public String getTestId() {         return testId;     }          // Member function implementation for "Sets the test id."     public void setTestId(String testId) {         this.testId = testId;     } }
public void close() {     LOG.debug("Closing all connections to remote hosts associated with this TURN client");     for (InetSocketAddress remoteAddress : m_connections.keySet()) {         IoSession session = m_connections.get(remoteAddress);         if (session != null) {             session.closeNow();         }     }     m_connections.clear(); }
public class JsonWorkflowJob {     // member variables          public void setActions(List<? extends JsonWorkflowAction> nodes) {         this.actions = nodes;     }          public JSONObject toJSONObject() {         // implementation details     }          public List<WorkflowJob> fromJSONArray(JSONArray array) {         // implementation details     }          // other member functions          public JSONArray workflowsToJSONArray(List<JsonWorkflowJob> workflows) {         JSONArray jsonArray = new JSONArray();         for (JsonWorkflowJob workflow : workflows) {             jsonArray.add(workflow.toJSONObject());         }         return jsonArray;     }          // other member functions }
public boolean isMRNADownRegulated() {     if (mrnaValue == null) {         return false;     }     return mrnaValue.getFoldChange() < 1; }
public Verb getAccessTokenVerb() {     return Verb.POST; }
public class DeleteLineageOptions {     private boolean mCascade;     public DeleteLineageOptions() {         this.mCascade = false;     }     @Override     public int hashCode() {         final int prime = 31;         int result = 1;         result = prime * result + (mCascade ? 1231 : 1237);         return result;     }     @Override     public boolean equals(Object obj) {         if (this == obj)             return true;         if (obj == null)             return false;         if (getClass() != obj.getClass())             return false;         DeleteLineageOptions other = (DeleteLineageOptions) obj;         if (mCascade != other.mCascade)             return false;         return true;     }     public boolean isCascade() {         return mCascade;     }     public void setCascade(boolean cascade) {         this.mCascade = cascade;     }     @Override     public String toString() {         return "DeleteLineageOptions [mCascade=" + mCascade + "]";     } }
public boolean isMRNAUpregulated() {     if (mrnaValue != null) {         return mrnaValue.getFoldChange() > 1.0;     }     return false; }
public String wf_group() {     WorkflowJobBean wf = getWorkflow();     String wfId = wf.getId();     String rerunFlag = wf.getConf().get("oozie.wf.rerun.failnodes");     if (rerunFlag != null && !rerunFlag.isEmpty()) {         return wfId + "_" + rerunFlag;     }     return "1"; }
public void insertKey(List<ChildNumber> path, DeterministicKey key) {     if (path.isEmpty()) {         throw new IllegalArgumentException("Path may not be empty");     }     if (!keys.isEmpty()) {         ImmutableList<ChildNumber> prevPath = lastChildNumbers.keySet().iterator().next();         if (prevPath.compareTo(path) >= 0) {             throw new IllegalArgumentException("Keys must be inserted in order");         }     }     ImmutableList<ChildNumber> parentPath = path.subList(0, path.size() - 1);     ChildNumber childNumber = path.get(path.size() - 1);     lastChildNumbers.put(parentPath, childNumber);     keys.put(ImmutableList.copyOf(path), key); }
public List<TestResultDTO> getTestResultLst() {     return testResultLst; }
public EncryptedKeyElement getEncryptedKeyElement() {     if (m_EncryptedKeyElement == null && m_KeyInfoEl != null) {         NodeList encryptedKeyNodes = m_KeyInfoEl.getElementsByTagNameNS(EncryptionConstants.EncryptionSpecNS, EncryptionConstants._TAG_ENCRYPTEDKEY);         if (encryptedKeyNodes.getLength() == 1) {             try {                 m_EncryptedKeyElement = new EncryptedKeyElement((Element) encryptedKeyNodes.item(0), "");             } catch (XMLEncryptionException e) {                 LOG.error("Error retrieving EncryptedKeyElement: " + e.getMessage());             }         }     }     return m_EncryptedKeyElement; }
public boolean failed(String img) {     return !failedImages.add(img); }
public void setCurrentScenario(boolean currentScenario) {     this.isCurrentScenario = currentScenario; }
public void readIgnoreWordsFile(File ignoreWordsFile) throws IOException {     try (BufferedReader reader = new BufferedReader(new FileReader(ignoreWordsFile))) {         String line;         while ((line = reader.readLine()) != null) {             _ignoreWords.add(line.trim());         }     } catch (IOException e) {         throw e;     } }
public void setChecksum(String checksum) {     this.checksum = checksum; }
public <R> R transform() {     try {         TransformerFactory transformerFactory = TransformerFactory.newInstance();         Transformer transformer = transformerFactory.newTransformer(transformation);         transformer.setErrorListener(errorListener);         transformer.setURIResolver(uriResolver);         transformer.setOutputProperties(outputProperties);         transformer.transform(new StreamSource(PWD.getAbsolutePath()), getResult());         return trans.result();     } catch (TransformerException e) {         throw new RuntimeException("Error while performing transformation", e);     } }
public boolean removeNode(Node node) {     if (node == null || !nodesByIds.containsKey(node.getId())) {         return false;     }     Set<Edge> edgesToRemove = new HashSet<>(graph.getOutEdges(node));     edgesToRemove.addAll(graph.getInEdges(node));     for (Edge edge : edgesToRemove) {         removeEdge(edge);     }     nodesByIds.remove(node.getId());     graph.removeVertex(node);     return true; }
public void addRuleSet(RuleSet ruleSet) {     if (ruleSet == null) {         return;     }     Language language = ruleSet.getLanguage();     if (language == null) {         language = Language.JAVA;     }     for (RuleSet existingRuleSet : ruleSets) {         if (existingRuleSet.getLanguage() == language) {             return;         }     }     ruleSets.add(ruleSet);     ruleChain.addRuleSet(ruleSet); }
public void update(XmlCursor cursor, ObjArray declarations) {     Object[] inScopeNamespaces = inScopeNamespaces(lib, cursor);     getNamespaces(cursor, prefixToURI);     for (int i = 0; i < declarations.size(); i++) {         XmlCursor.TokenType t = cursor.toNextToken();         switch (t) {             case START:                 declareNamespace((String) declarations.get(i), cursor.namespaceForPrefix((String) declarations.get(i)), declarations);                 break;             case NAMESPACE:                 removeNamespace(cursor, cursor.getName().getLocalPart());                 declareNamespace(cursor.getName().getLocalPart(), cursor.getTextValue(), declarations);                 break;             default:                 // do nothing         }     } }
public GetOfferDetailsResponse.Return.DetailOfferData createGetOfferDetailsResponseReturnDetailOfferData() {     GetOfferDetailsResponse.Return.DetailOfferData detailOfferData = new GetOfferDetailsResponse.Return.DetailOfferData();     return detailOfferData; }
public Supplier<T> synchronizedSupplier(Supplier<T> delegate) {     return () -> {         synchronized (delegate) {             return delegate.get();         }     }; }
/**  * Convert a Categorical Distribution into a column vector in Matrix form.  *  * @param categoricalDist the categorical distribution to be converted  * @return a column vector in Matrix form  */ public Matrix convertCategoricalDistToMatrix(CategoricalDistribution categoricalDist) {     double[] values = new double[stateVariableDomain.size()];     int index = 0;     for (Object value : stateVariableDomain) {         values[index++] = categoricalDist.getProbability(value);     }     return new Matrix(values); }
public List<Node> getEvaluationResults() {     return evaluationResults; }
public boolean isStarted() {     synchronized (lock) {         return pendingActions != null;     } }
private void ensureCapacity(int additionalBytes) {     int remainingBytes = mBuffer.length - mWriter.position();     if (remainingBytes < additionalBytes) {         int newCapacity = mBuffer.length + additionalBytes - remainingBytes;         ByteBuffer newBuffer = ByteBuffer.allocate(newCapacity);         mWriter.flip();         newBuffer.put(mWriter);         mWriter = newBuffer;         mBuffer = newBuffer.array();     } }
public String eatStringConstant() {     if (matchStringConstant()) {         String value = tok.sval;         nextToken();         return value;     } else {         throw new RuntimeException("Expected string constant.");     } }
/**  * A proxy method that adds the node {@code n} to the graph being tested.  * In case of Immutablegraph implementations, this method should add {@code n}  * to the graph builder and build a new graph with the current builder state.  */ public void addNodeProxy(Integer n) {     // If graph is an ImmutableGraph implementation, add node to builder     if (graph instanceof ImmutableGraph) {         ImmutableGraph.Builder<Integer> builder = ImmutableGraph.<Integer>builder().addNode(n);         for (Integer node : graph.nodes()) {             builder.addNode(node);         }         for (EndpointPair<Integer> edge : graph.edges()) {             builder.putEdge(edge.nodeU(), edge.nodeV());         }         graph = builder.build();     } else {         // If graph is not an ImmutableGraph implementation, simply add node to graph         graph.addNode(n);     } }
public List<String> getProduceMediaTypes() {     return produceMediaTypes; }
public Message parseOuterJSONObjectToMessage(Object parsed) {     if (!(parsed instanceof JSONObject)) {         throw new IllegalArgumentException("Parsed object is not an instance of JSONObject");     }     JSONObject outerObject = (JSONObject) parsed;     // Parse the command field     validateObjectField(outerObject);     String commandStr = outerObject.getString("command");     Command command = Command.fromString(commandStr);     // Parse the payload field     Object payloadObj = outerObject.opt("payload");     Payload payload = parsePayload(command, payloadObj);     return new Message(command, payload); }
public DenseMatrix64F handleU(DenseMatrix64F U, boolean transpose, boolean compact, int m, int n, int min) {     if (U == null) {         if (compact) {             U = new DenseMatrix64F(m, min);         } else {             U = new DenseMatrix64F(m, n);         }     } else if (compact) {         U.reshape(m, min);     } else {         U.reshape(m, n);     }     if (transpose) {         CommonOps.transpose(this.u, U);     } else {         U.set(this.u);     }     return U; }
public String label() {     return _label; }
/**  * Returns the URL of an image for the {@link MediaInfo} at the given index.  * Index should be a number between 0 and {@code n-1} where {@code n} is the number of images  * for that given item.  *  * @param info   The {@link MediaInfo} containing the images.  * @param level  The index of the image to retrieve.  * @return The URL of the specified image.  */ public static Uri getImageUri(MediaInfo info, int level) {     if (info == null || level < 0 || level >= info.getImages().size()) {         return null;     }     Image image = info.getImages().get(level);     return image.getUrl(); }
public long getTotalElapsed() {     return totalElapsed.get(); }
/**  * Skips any comment lines and retrieves a data line from the unmapped file (created by liftOver).  *  * @param unmappedLine the current line to be processed from the unmapped file  * @param record       the MafRecord instance for the current record  * @return true if the current line is an unmapped line, false otherwise  * @throws IOException if an I/O error occurs while reading the file  */ public boolean isUnmapped(MafRecord record, String unmappedLine) throws IOException {     // check if the current line is a comment line, if so skip it     while (unmappedLine.startsWith("#") || unmappedLine.trim().isEmpty()) {         unmappedLine = record.getNextLine();         if (unmappedLine == null) {             return false;         }     }     // check if the current line is an unmapped line     if (unmappedLine.startsWith("unmapped")) {         return true;     }     return false; }
// Test method for setMagneticCourse(double) public void testSetMagneticCourse() {     double course = 123.45;     vtg.setMagneticCourse(course);     assertEquals(course, vtg.getMagneticCourse(), 0.1); }
public void setMessageContext(MessageContext mc) {     this.mc = mc; }
@Override public int hashCode() {     final int prime = 31;     int result = 1;     result = prime * result + ((mFiles == null) ? 0 : mFiles.hashCode());     result = prime * result + (int) (mTtlIntervalStartTimeMs ^ (mTtlIntervalStartTimeMs >>> 32));     result = prime * result + (int) (sTtlIntervalMs ^ (sTtlIntervalMs >>> 32));     return result; }
public double getSingularValue(int index) {     return svd.getSingularValue(index); }
public Set<RuleSet> getAllRuleSets() {     return new HashSet<>(ruleSets); }
public long getLong(String param) {     if (params.containsKey(param)) {         String value = params.get(param);         try {             return Long.parseLong(value);         } catch (NumberFormatException e) {             // Handle exception if value cannot be parsed as long         }     }     // Return default value if parameter not found or cannot be parsed as long     return 0L; }
public boolean implies(Bits that) {     Bits o = this.mOtherBits.and(that.mOtherBits.not());     Bits g = this.mGroupBits.and(that.mGroupBits.not());     Bits u = this.mOwnerBits.and(that.mOwnerBits.not());     return o.equals(Bits.NONE) && g.equals(Bits.NONE) && u.equals(Bits.NONE); }
public void beforeDisconnect() {     // Add any additional operations here to be performed before disconnecting }
public void setIsActive(String isActive) {     this.isActive = isActive; }
public int nextInt() {     String str = pg.getString(pos);     int end = str.indexOf(",", pos);     if (end < 0) {         end = str.length();     }     int value = Integer.parseInt(str.substring(pos, end));     pos = end + 1;     return value; }
public CascadedStyle createLayoutStyle(IdentValue display) {     PropertyDeclaration displayDeclaration = createLayoutPropertyDeclaration(CSSName.DISPLAY, display);     PropertyDeclaration[] decls = new PropertyDeclaration[] { displayDeclaration };     return createLayoutStyle(emptyCascadedStyle, decls); }
public String getMessage() {     return message; }
public int put(Object key, int value) {     if (key == null) {         throw new NullPointerException("Key cannot be null");     }     if (_size + 1 >= _keys.length * 3 / 4) {         resize(_keys.length * 2);     }     int hash = key.hashCode() & _mask;     Object existingKey = _keys[hash];     int i = 1;     while (existingKey != null) {         if (existingKey == DELETED || existingKey.equals(key)) {             _values[hash] = value;             return value;         }         hash = (hash + i * i) & _mask;         existingKey = _keys[hash];         i++;     }     _keys[hash] = key;     _values[hash] = value;     _size++;     return value; }
public int getPlacementHint() {     return this.placementHint; }
public String resolveServiceContractLocation(QName qname) {     for (ServiceContractResolver resolver : resolvers) {         String location = resolver.resolveServiceContractLocation(qname);         if (location != null) {             return location;         }     }     return null; }
public boolean isFinished() {     return !hasMoves(OthelloSide.BLACK) && !hasMoves(OthelloSide.WHITE); }
null
void executeFirst(Runnable task) {     synchronized(internalLock) {         queue.addFirst(task);         if (!isWorkerRunning && suspensions == 0) {             startQueueWorker();         }     } }
public void setExpires(Date expires) {     this.expires = expires; }
/**  * Ideally this should be configurable. For the moment, hard code the priority.  */ public void setDefaultPriority() {     this.priority = DEFAULT_PRIORITY; }
public static int divideUnsigned(int dividend, int divisor) {     long unsignedDividend = ((long) dividend) & INT_MASK;     long unsignedDivisor = ((long) divisor) & INT_MASK;     return (int) (unsignedDividend / unsignedDivisor); }
public static <T> ParameterizedType insistParameterizedType(Type type) {     if (type instanceof ParameterizedType) {         ParameterizedType pType = (ParameterizedType) type;         if (pType.getActualTypeArguments().length == 1) {             return pType;         }     }     throw new IllegalArgumentException("Type must be a parameterized type with exactly one parameter."); }
public static AegisType getWriteType(AegisContext globalContext, Object value, AegisType type) {     if (value == null) {         throw new NullPointerException("value parameter was null.");     }     if (type == null) {         throw new NullPointerException("type parameter was null.");     }     Class<?> clazz = value.getClass();     if (Collection.class.isAssignableFrom(clazz)) {         Type genericType = type.getType();         if (genericType instanceof ParameterizedType) {             ParameterizedType paramType = (ParameterizedType) genericType;             Type[] typeArgs = paramType.getActualTypeArguments();             if (typeArgs.length == 1) {                 Type elementType = typeArgs[0];                 AegisType collectionType = globalContext.getWriteType(elementType);                 return new CollectionType(collectionType);             } else {                 throw new IllegalArgumentException("Collection type must have exactly one type parameter.");             }         } else {             throw new IllegalArgumentException("Collection type must be a parameterized type.");         }     } else {         return type;     } }
public int generateSequence() {     return getManager().getRMAssertion().getSequence().getIdentifier(); }
public int distinctValues() {     try {         tx.startTransaction();         Scan scan = open();         String fldname = scan.getSchema().fields().get(0);         int distinctVals = 0;         Constant val = scan.getVal(fldname);         while (scan.next()) {             if (!val.equals(scan.getVal(fldname))) {                 distinctVals++;                 val = scan.getVal(fldname);             }         }         scan.close();         tx.commit();         return distinctVals + 1; // add 1 for the last value     } catch (Exception e) {         tx.rollback();         throw new RuntimeException(e);     } }
private byte fingerprint(ByteBuffer key) {     HashCode hashCode = FINGERPRINT_HASHER.hashBytes(key.array(), key.arrayOffset(), key.remaining());     int fingerprint = hashCode.asInt() & 0xFF;     return (byte) (fingerprint == 0 ? 1 : fingerprint); }
@Test public void lockBlock() {     long sessionId = TEST_SESSION_ID;     long blockId = TEST_BLOCK_ID;     LockHandle lock = mLockManager.acquireBlockLock(sessionId, blockId);     assertNotNull(lock);     assertFalse(mLockManager.releaseLock(lock)); }
public static String padEnd(String string, int minLength, char padChar) {     if (string == null) {         string = "";     }     if (string.length() >= minLength) {         return string;     }     StringBuilder sb = new StringBuilder(minLength);     sb.append(string);     while (sb.length() < minLength) {         sb.append(padChar);     }     return sb.toString(); }
public boolean hasWorkingPressureSensor() {     boolean hasWorkingPressureSensor = false;     if (mHasPressureSensor) {         // Check if the pen event reports pressure         if (mPenEvent != null) {             hasWorkingPressureSensor = mPenEvent.getPressure() > 0;         }     }     return hasWorkingPressureSensor; }
public void registerItem(int itemName, int[] itemUtility) {     int remainingUtility = calculateRemainingUtility(itemUtility);     matrixItemUtility[itemName] = itemUtility;     matrixItemRemainingUtility[itemName] = remainingUtility;     itemNames[swu] = itemName;     swu++; }
public void restoreErrorLevel() {     this.errorLevelFolder = 1; }
public String getPartStringAllowEmpty(int index, String[] parts) {     if (index < 0 || index >= parts.length || parts[index].isEmpty()) {         return NA_STRING;     }     return parts[index]; }
public void setExpectedDataUnitId(Long expectedDataUnitId) {     this.expectedDataUnitId = expectedDataUnitId; }
private void checkNotNull(Object obj) {     if (obj == null) {         throw new internal_error("Parameter cannot be null");     } }
public void saveNow() {     if (savePending.compareAndSet(false, true)) {         executor.schedule(() -> {             try {                 saveNowInternal();             } finally {                 savePending.set(false);             }         }, delay, delayTimeUnit);     } }
void checkSymmRankNMinus_U(int lengthA, int heightB) {     for (int n = 1; n <= N; n++) {         int rowsA = lengthA + n;         int colsB = heightB + n;         int rowsB = colsB;         double[][] A = new double[rowsA][rowsA];         double[][] B = new double[rowsB][colsB];         // Initialize matrices A and B with random values         for (int i = 0; i < rowsA; i++) {             for (int j = 0; j < rowsA; j++) {                 A[i][j] = rand.nextDouble();             }         }         for (int i = 0; i < rowsB; i++) {             for (int j = 0; j < colsB; j++) {                 B[i][j] = rand.nextDouble();             }         }         // Compute symmRankNMinus_U for A and B         double[][] C = TestBlockInnerRankUpdate.symmRankNMinus_U(A, B);         // Compute the expected result using a naive algorithm         double[][] expectedC = new double[rowsA][colsB];         for (int i = 0; i < rowsA; i++) {             for (int j = 0; j < colsB; j++) {                 double sum = 0.0;                 for (int k = 0; k < rowsB; k++) {                     sum += A[i][k] * B[k][j];                 }                 expectedC[i][j] = sum;             }         }         // Compare the computed result with the expected result         for (int i = 0; i < rowsA; i++) {             for (int j = 0; j < colsB; j++) {                 if (Math.abs(C[i][j] - expectedC[i][j]) > 1e-8) {                     throw new AssertionError("symmRankNMinus_U failed with matrix size " + rowsA + "x" + colsB);                 }             }         }     } }
public boolean conflictsWith(Goal other) {     for (Goal g : prerequisites) {         if (other.prerequisites.contains(g) || other.corequisites.contains(g)) {             return true;         }     }     for (Goal g : corequisites) {         if (other.prerequisites.contains(g) || other.corequisites.contains(g)) {             return true;         }     }     return false; }
public String getWorkflowImplId() {     return workflowImplId; }
public void setIgnoreExceptions(boolean ignore) {     ignoreExceptions = ignore; }
public String getValidInput(String input, String[] whiteListPatterns, String[] blackListPatterns) throws IdentityValidationException {     if (isValidOverWhiteListPatterns(input, whiteListPatterns)) {         return input;     } else {         throw new IdentityValidationException(msgSection1 + msgSection2 + getPatternString(whiteListPatterns));     } }
public void testSetSpeed() {     mwv.setSpeed(5.5);     assertEquals(5.5, mwv.getSpeed(), 0.01); }
public ThrottleResponse setDelay(long d) {     this.delay = d;     return this; }
public void testSetLongitude() {     double longitude = 45.6789;     instance.setLongitude(longitude);     assertEquals(longitude, instance.getLongitude(), 0.0); }
public <T> Iterable<T> filter(final Iterable<T> sequence, final Predicate<? super T> filter) {     return new Iterable<T>() {         @Override         public Iterator<T> iterator() {             return new Iterator<T>() {                 final Iterator<T> iterator = sequence.iterator();                 T lookahead = null;                 @Override                 public boolean hasNext() {                     while (lookahead == null && iterator.hasNext()) {                         lookahead = iterator.next();                         if (!filter.test(lookahead)) {                             lookahead = null;                         }                     }                     return lookahead != null;                 }                 @Override                 public T next() {                     if (!hasNext()) {                         throw new NoSuchElementException();                     }                     T result = lookahead;                     lookahead = null;                     return result;                 }                 @Override                 public void remove() {                     iterator.remove();                 }             };         }     }; }
public List<CoordinatorActionBean> getActions() {     return actions; }
public void createSchedule(@ModelAttribute Schedule schedule) {     repository.save(schedule); }
public void waitForFxEventsAndRun(Runnable runnable, long timeoutMillis) throws TimeoutException, InterruptedException {     CountDownLatch latch = new CountDownLatch(1);     Platform.runLater(() -> {         try {             runnable.run();         } finally {             latch.countDown();         }     });     if (!latch.await(timeoutMillis, TimeUnit.MILLISECONDS)) {         throw new TimeoutException();     } }
public void setLogger(Logger logger) {     this.logger = logger; }
@Test public void testSetSeconds() {     Time t = new Time(10, 30, 0);     t.setSeconds(45);     assertEquals(45, t.getSeconds()); }
public static ByteBuffer getIncreasingByteBuffer(int len) {     ByteBuffer buf = ByteBuffer.allocate(len);     for (int i = 0; i < len; i++) {         buf.put((byte) i);     }     buf.flip();     return buf; } public static ByteBuffer getIncreasingByteBuffer(int start, int len) {     ByteBuffer buf = ByteBuffer.allocate(len);     for (int i = start; i < start + len; i++) {         buf.put((byte) i);     }     buf.flip();     return buf; }
public Sentence createParserImpl(String sid, Object param) {     // Look up the parser for the specified talker and sentence type     Class<? extends SentenceParser> parserClass = parsers.get(sid);     // If a parser is found, create an instance of it and return it     if (parserClass != null) {         try {             Constructor<? extends SentenceParser> constructor = parserClass.getConstructor(Object.class);             return (Sentence) constructor.newInstance(param);         } catch (Exception e) {             throw new RuntimeException("Failed to create parser for " + sid, e);         }     } else {         throw new IllegalArgumentException("No parser registered for " + sid);     } }
public void setFeedId(BigDecimal feedId) {     this.feedId = feedId; }
@Test public void testEncodeAndDecode() {     RPCBlockReadResponse expectedResp = new RPCBlockReadResponse(BLOCK_ID, LOCK_ID, OFFSET, LENGTH, STATUS, mBuffer);     ByteBuf buffer = Unpooled.buffer();     expectedResp.encode(buffer);     RPCBlockReadResponse actualResp = RPCBlockReadResponse.decode(buffer);     Assert.assertEquals(expectedResp.getBlockId(), actualResp.getBlockId());     Assert.assertEquals(expectedResp.getLockId(), actualResp.getLockId());     Assert.assertEquals(expectedResp.getOffset(), actualResp.getOffset());     Assert.assertEquals(expectedResp.getLength(), actualResp.getLength());     Assert.assertEquals(expectedResp.getStatus(), actualResp.getStatus());     Assert.assertArrayEquals(expectedResp.getPayloadDataBuffer().array(), actualResp.getPayloadDataBuffer().array()); }
public BasePriceType getTheItemPrice() {     return lineItem.getPrice(); }
public AtomicLongMap() {     map = new ConcurrentHashMap<>();     asMap = createAsMap(); }
public void setLoggingEnabled(boolean enabled) {     loggingEnabled = enabled; }
public boolean validCascadingPlan(long bytesToBeAvailable, EvictionPlan plan, BlockMetadataManager metaManager) {     if (plan.getTierEvictionPlans().size() == 0) {         return false;     }     long totalBytesEvicted = 0;     for (TierEvictionPlan tierPlan : plan.getTierEvictionPlans()) {         long tierBytesEvicted = 0;         for (BlockEvictionPlan blockPlan : tierPlan.getBlockEvictionPlans()) {             if (!metaManager.containsBlock(blockPlan.getBlockId())) {                 return false;             }             tierBytesEvicted += blockPlan.getBytesToEvict();         }         if (tierBytesEvicted > tierPlan.getTierSize()) {             return false;         }         totalBytesEvicted += tierBytesEvicted;         if (totalBytesEvicted >= bytesToBeAvailable) {             break;         }     }     return totalBytesEvicted >= bytesToBeAvailable; }
public GetOfferDetailsResponse.Return createGetOfferDetailsResponseReturn() {     return new GetOfferDetailsResponse.Return(); }
public static Element parseXml(InputStream inputStream) throws JDOMException, IOException {     SAXBuilder builder = new SAXBuilder();     Document document = builder.build(inputStream);     return document.getRootElement(); }
@Bean public SimpleJobLauncher synchJobLauncher() throws Exception {     SimpleJobLauncher jobLauncher = new SimpleJobLauncher();     jobLauncher.setJobRepository(jobRepository);     jobLauncher.setTaskExecutor(new SimpleAsyncTaskExecutor());     jobLauncher.afterPropertiesSet();     return jobLauncher; }
public static void notEmpty(Object[] array, String message) {     if (array == null || array.length == 0) {         throw new IllegalArgumentException(message);     } } public static void notEmpty(Object[] array) {     notEmpty(array, "The array must not be empty"); }
public boolean isUseKeyIdentifier() {     return useKeyIdentifier; }
public Iterator gen2(Object o) {     if (o == null) {         throw new IllegalArgumentException("Object parameter cannot be null.");     }     if (!(o instanceof ParentGenUML)) {         throw new IllegalArgumentException("Object parameter must be an instance of ParentGenUML.");     }     ParentGenUML parent = (ParentGenUML) o;     List<ChildGenUML> children = parent.getChildren();     return Collections.enumeration(children); }
public boolean isFull() {     return count >= limit; }
/**  * Returns a string representation of the host specifier suitable for inclusion in a URI.  * If the host specifier is a domain name, the string will be normalized to all lower case.  * If the specifier was an IPv6 address without brackets, brackets are added so that  * the result will be usable in the host part of a URI.  */ @Override public String toString() {     String specifier = canonicalForm;     // Normalize domain name to all lower case     if (isValid(specifier) && specifier.matches(DOMAIN_NAME_PATTERN)) {         specifier = specifier.toLowerCase();     }     // Add brackets to IPv6 address if necessary     if (isValid(specifier) && specifier.indexOf(':') >= 0 && !specifier.startsWith("[") && !specifier.endsWith("]")) {         specifier = "[" + specifier + "]";     }     return specifier; }
public void createDefaultDiagrams() {     currentProject = new Project(NO_PROJECT);     firePropertyChanged(CURRENT_PROJECT_PROPERTY_NAME, null, currentProject);     clienteEnvia.connect(currentProject); }
public String generateCreateTableSQL() {     StringBuilder sql = new StringBuilder();     sql.append("CREATE TABLE ");     sql.append(table.getName());     sql.append(" (");     List<Column> columns = TABLE_COLUMNS.get(table);     for (int i = 0; i < columns.size(); i++) {         Column column = columns.get(i);         sql.append(column.columnName());         sql.append(" ");         sql.append(column.getType().getSimpleName());         if (column.getLength() > 0) {             sql.append("(");             sql.append(column.getLength());             sql.append(")");         }         if (column.isPrimaryKey()) {             sql.append(" PRIMARY KEY");         }         if (i < columns.size() - 1) {             sql.append(", ");         }     }     sql.append(")");     return sql.toString(); }
public String resolveURI(String uri) {     if (_uriResolver == null) {         return uri;     }     return _uriResolver.resolveURI(uri); }
public void removeFishTagging() {     if (ids.length > 0) {         ids = Arrays.copyOf(ids, ids.length - 1);     } }
public void equals() {     Mode mode = new Mode(0644);     Mode copy = new Mode(mode);     assertTrue("Copied mode should be equal to the original mode", mode.equals(copy)); }
public String getElem1() {     return this.elem1; }
public void addRepeatField(RepeatField repeatField) {     repeatList.add(repeatField); }
null
public boolean isWellFormed(byte[] bytes, int off, int end) {     int i = off;     while (i < end) {         int byte1 = bytes[i++] & 0xff;         if (byte1 < 0x80) {             continue;         } else if (byte1 < 0xc2 || byte1 > 0xf4) {             return false;         } else if (byte1 < 0xe0) {             if (i >= end || (bytes[i++] & 0xc0) != 0x80) {                 return false;             }         } else if (byte1 < 0xf0) {             if (i + 1 >= end || (bytes[i++] & 0xc0) != 0x80 || (bytes[i++] & 0xc0) != 0x80) {                 return false;             }         } else {             if (i + 2 >= end || (bytes[i++] & 0xc0) != 0x80 || (bytes[i++] & 0xc0) != 0x80 || (bytes[i++] & 0xc0) != 0x80) {                 return false;             }         }     }     return true; }
public void setCallbackHandler(CallbackHandler callbackHandler) {     this.callbackHandler = callbackHandler; }
public void processMatrix() {     matrix = new String[caseIdList.size() + 1][geneList.size() + 1];     matrix[0][0] = "Gene_Symbol\\Case_ID";     for (int i = 0; i < geneList.size(); i++) {         matrix[0][i + 1] = geneList.get(i);     }     for (int i = 0; i < caseIdList.size(); i++) {         matrix[i + 1][0] = caseIdList.get(i);     }     for (int i = 0; i < geneList.size(); i++) {         for (int j = 0; j < caseIdList.size(); j++) {             String key = createKey(geneList.get(i), caseIdList.get(j));             String value = mapFromGeneAndCaseToGeneProperties.get(key);             if (value != null) {                 ValueParser parser = getValueParsed(geneList.get(i), caseIdList.get(j), geneticProfile.getzScoreThreshold());                 double parsedValue = parser.parseValue(value);                 matrix[j + 1][i + 1] = String.valueOf(parsedValue);             } else {                 matrix[j + 1][i + 1] = "NA";             }         }     } }
public void setWorkDirectory(String workDirectory) {     mWorkDirectory = workDirectory; }
public boolean isUserAuthenticated(HttpServletRequest request) {     String userEmail = (String) request.getSession().getAttribute(EMAIL);     return userEmail != null; }
public String readAsciiString(final ByteBuffer buf) {     CharsetDecoder decoder = DECODER.reset();     CharBuffer charBuffer = null;     try {         charBuffer = decoder.decode(buf);     } catch (CharacterCodingException e) {         LOG.error("Error while decoding ASCII string", e);     }     return charBuffer != null ? charBuffer.toString() : ""; }
public void fireReadingStopped() {     for (List<SentenceListener> listenerList : listeners.values()) {         for (SentenceListener listener : listenerList) {             try {                 listener.readingStopped();             } catch (Exception e) {                 LOGGER.log(Level.SEVERE, LOG_MSG, e);             }         }     } }
public Object invokeMethod(Object instance, String methodName, Class[] classTypes, Object... args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {     Method method = instance.getClass().getMethod(methodName, classTypes);     return method.invoke(instance, args); }
public void testSetHour() {     TimeTest timeTest = new TimeTest();     Time time = timeTest.time;     // Test setting valid hour     time.setHour(10);     assertEquals(10, time.getHour());     // Test setting negative hour     try {         time.setHour(-10);         fail("Expected IllegalArgumentException");     } catch (IllegalArgumentException e) {         // Expected exception thrown     }     // Test setting hour greater than 23     try {         time.setHour(24);         fail("Expected IllegalArgumentException");     } catch (IllegalArgumentException e) {         // Expected exception thrown     } }
public List<Book> getAllBooks() {     return bookRepository.findAll(); }
public static StoredBlock createNewStoredBlock(StoredBlock prev, Block block, BigInteger chainWork) {     int height = prev.getHeight() + 1;     Block header = block.cloneAsHeader();     header.setPrevBlock(prev.getHeader().getHash());     header.setDifficultyTarget(Block.EASIEST_DIFFICULTY_TARGET);     header.setTime(Math.max(prev.getHeader().getTimeSeconds() + 1, block.getTimeSeconds()));     BigInteger cumulativeChainWork = prev.getChainWork().add(chainWork);     return new StoredBlock(header, cumulativeChainWork, height); }
public Object getClassifier() {     return this.classifier; }
public Vector getRepeatTimes(boolean create) {     if (create && repeatList == null) {         repeatList = new Vector();     }     return repeatList; }
/**  * Called when a line is complete.  *  * @param line the complete line  * @param end  the end of line delimiter  */ public void handleLine(String line, String end) {     // Do something with the complete line     // ... }
public static ScopeKind forName(String name) {     for (ScopeKindEnum kind : values()) {         if (kind.literalName.equals(name)) {             return kind;         }     }     throw new IllegalArgumentException("No enum constant for name: " + name); }
public void setObjectType(ObjectType objectType) {     this.objectType = objectType; }
public void setFetcherStartTimestamp(Timestamp fetcherStartTimestamp) {     this.fetcherStartTimestamp = fetcherStartTimestamp; }
public void setSource(String source) {     this.source = source; }
public boolean isFileDownloaded() {     // implementation logic goes here }
public static SearchConditionBuilder query() {     return new SearchConditionBuilder(); }
public File getSourceCodeFile() {     return sourceCodeFile; }
public void setAttachinfo(DataHandler value) {     this.attachinfo = value; }
public String randomString() {     // implementation code here }
null
public String createAutoMergeQuery(String graphName, String sdd, String user, String commitMessage, String branchNameA, String branchNameB) {     String query = String.format("MERGE INTO <%s> USING <%s> ON ?subject ?predicate ?object\n", graphName, sdd);     query += String.format("FROM <%s>\n", branchNameA);     query += "FROM (SELECT ?subject ?predicate ?object\n";     query += String.format("FROM <%s>\n", branchNameB);     query += "MINUS {\n";     query += String.format("SELECT ?subject ?predicate ?object\nFROM <%s>\n", branchNameA);     query += "})\n";     query += "WHERE { ?subject ?predicate ?object }\n";     query += String.format("INSERT DATA { GRAPH <%s> { ?subject ?predicate ?object } }\n", graphName);     query += String.format("WITH <%s>\n", branchNameB);     query += String.format("DELETE { GRAPH <%s> { ?subject ?predicate ?object } }\n", branchNameA);     query += String.format("WHERE { GRAPH <%s> { ?subject ?predicate ?object } }\n", branchNameA);     query += String.format("USING <%s>\n", sdd);     query += String.format("MESSAGE '%s'\n", commitMessage);     query += String.format("AUTHOR '%s'", user);     return query; }
/**  * Return a workflow store instance with an existing transaction.  * The workflow store has to be committed and then closed to commit changes,  * if only close it rolls back.  *  * @return A workflow store instance with an existing transaction.  */ public WorkflowStoreService getWorkflowStoreWithTxn() {     WorkflowStoreService wss = Services.get().get(WorkflowStoreService.class);     try {         wss.beginTrx();         return wss;     } catch (WorkflowException e) {         throw new RuntimeException("Error creating workflow store instance with transaction", e);     } }
public byte[] getChainCode() {     return chainCode; }
public void suspend() {     synchronized (internalLock) {         suspensions++;     } }
@Override public Verb getAccessTokenVerb() {     return Verb.POST; }
public static UnderFileSystem mockUnderFileSystem(String ufsPath) throws Exception {     // implementation goes here }
public BigInteger getProofOfWorkLimit() {     Block storedBlock = blockStore.getChainHead();     Block lastBlock = storedBlock;     for (int i = 0; i < this.getInterval() - 1; i++) {         if (lastBlock.getPrevBlockHash() == null) {             // This should never happen. If it does, it means we are following an incorrect or busted chain             throw new RuntimeException("Difficulty calculation error: previous block hash not available");         }         lastBlock = blockStore.get(lastBlock.getPrevBlockHash());     }     return lastBlock.getDifficultyTargetAsInteger(); }
public void closeConnection() {     try {         socket.close();     } catch (IOException e) {         log.error("Error while closing socket: {}", e.getMessage());     } finally {         vCloseRequested = true;         StreamParser.getInstance().connectionClosed();     } }
public byte hashKey(byte[] key) {     HashCode fingerprint = FINGERPRINT_HASHER.hashBytes(key);     byte result = (byte) (fingerprint.asInt() & 0xFF);     return result != 0 ? result : 1; }
public File getBaseFolder() {     if (System.getenv("CLOUD_PROVIDER") != null && System.getenv("CLOUD_PROVIDER").equals("MY_CLOUD")) {         return new File("/my/cloud/folder/path");     } else {         return baseFolder;     } }
public double computeQuality() {     int m = QR.numRows;     int n = QR.numCols;     double max = Math.min(m, n);     double sum = 0.0;     for (int i = 0; i < max; i++) {         double r = QR.unsafe_get(i, i);         if (r != 0.0) {             sum += Math.abs(r);         }     }     return sum / max; }
/**  * Writes encoded data to muxer.  */ public void writeSampleData(int trackIndex, ByteBuffer byteBuf, MediaCodec.BufferInfo bufferInfo) {     if (!mIsStarted) {         Log.e(TAG, "Muxer hasn't been started");         throw new IllegalStateException("Muxer hasn't been started");     }     mMediaMuxer.writeSampleData(trackIndex, byteBuf, bufferInfo); }
public static Filter<File> toFileFilter(final FilenameFilter filter) {     return new Filter<File>() {         @Override         public boolean accept(File file) {             return filter.accept(file.getParentFile(), file.getName());         }     }; }
public static QualifiedName parseQNameToString(String value, int closingBrace) {     int index = value.indexOf('{');     if (index != -1) {         String nsURI = value.substring(index + 1, closingBrace);         String localName = value.substring(closingBrace + 1);         return new QualifiedName(localName, nsURI);     } else {         String[] parts = value.split(":");         if (parts.length != 2) {             throw new IllegalArgumentException("Invalid QName string: " + value);         }         String prefix = parts[0];         String localName = parts[1];         String nsURI = "";         NamespaceContext ctx = new SimpleNamespaceContext();         if (ctx != null) {             nsURI = ctx.getNamespaceURI(prefix);         }         return new QualifiedName(localName, nsURI);     } } public static QualifiedName parsePrefixFormat(String value, int colon, NamespaceContext ctx) {     String prefix = value.substring(0, colon);     String localName = value.substring(colon + 1);     String nsURI = "";     if (ctx != null) {         nsURI = ctx.getNamespaceURI(prefix);     }     return new QualifiedName(localName, nsURI); }
public static String constructPredicate(Attribute attribute) {     String value = attribute.getValue();     if (value.contains("'")) {         // Escape single quotes with double quotes         value = value.replace("'", "''");         return "[@" + attribute.getName() + "=\"" + value + "\"]";     } else {         return "[@" + attribute.getName() + "='" + value + "']";     } }
@Override public Constant getVal(String fldname) {     if (lhsscan.hasField(fldname)) {         return lhsscan.getVal(fldname);     } else if (rhsscan != null && rhsscan.hasField(fldname)) {         return rhsscan.getVal(fldname);     } else {         return prodscan.getVal(fldname);     } }
public String getUrl() {     String urlWithQueryParams = getSanitizedUrl();     if (!getQueryStringParams().isEmpty()) {         urlWithQueryParams += "?" + getQueryStringParams().encode();     }     return urlWithQueryParams; }
public void setRelyingParty(String relyingParty) {     this.relyingParty = relyingParty; }
@SuppressWarnings("unchecked") public <T> T getProperty(String propertyName, Class<T> returnType) {     Object propertyValue = jsObject.getMember(propertyName);     if (propertyValue == null) {         return null;     } else if (returnType.isAssignableFrom(propertyValue.getClass())) {         return (T) propertyValue;     } else if (returnType == Boolean.class) {         return (T) checkBoolean(propertyValue, null);     } else if (returnType == Integer.class) {         return (T) checkInteger(propertyValue, null);     } else if (returnType == String.class) {         return (T) propertyValue.toString();     } else {         throw new IllegalArgumentException("Unsupported return type: " + returnType.getName());     } }
public String[] getActivePeers() {     List<String> peers = new ArrayList<>();     for (String seed : dnsSeeds) {         try {             InetAddress[] addresses = InetAddress.getAllByName(seed);             for (InetAddress address : addresses) {                 peers.add(address.getHostAddress());             }         } catch (UnknownHostException e) {             // Ignore and move to next seed         }     }     return peers.toArray(new String[0]); }
public Map<String, String> generateParametersMap() {     return new HashMap<>(); }
public void checkOwnerPermission(LockedInodePath inodePath) {     String user = getClientUser();     List<String> groups = getGroups(user);     Inode<?> inode = inodePath.getInodeOrNull();     if (inode != null) {         checkInode(user, groups, inode, Mode.Bits.WRITE, inodePath.getUri().getPath());         if (!inode.getOwner().equals(user)) {             throw new AccessControlException(toExceptionMessage(user, Mode.Bits.WRITE, inodePath.getUri().getPath(), inode));         }     } }
public void testConstructorFromString() {     // Create a Time object from a valid string     Time t = new Time("125959");          // Verify that the hour, minute, and second values are correct     assertEquals(12, t.getHour());     assertEquals(59, t.getMinutes());     assertEquals(59, t.getSeconds());          // Create a Time object from an invalid string     try {         t = new Time("invalid");         fail("Expected IllegalArgumentException was not thrown");     } catch (IllegalArgumentException e) {         // Expected exception was thrown     } }
public Socket getSocket() {     return m_socket; }
public boolean usesTypeResolution(Language language) {     for (RuleSet ruleSet : ruleSets) {         if (ruleSet.applies(language)) {             for (Rule rule : ruleSet.getRules()) {                 if (rule instanceof AbstractJavaRule) {                     AbstractJavaRule javaRule = (AbstractJavaRule) rule;                     if (javaRule.isTypeResolutionEnabled()) {                         return true;                     }                 }             }         }     }     return false; }
public boolean isTokenProviderFor(String tokenType, String realm) {     // Ignoring realm since it's not used by this token provider     return true; }
public String getContentType() {     return propertyName; }
null
public static void waitForAsync(long millis, Runnable runnable) throws TimeoutException, InterruptedException {     Future<?> future = async(runnable);     try {         future.get(millis, TimeUnit.MILLISECONDS);     } catch (ExecutionException e) {         // Unwrap ExecutionException and throw the underlying cause         Throwable cause = e.getCause();         if (cause instanceof RuntimeException) {             throw (RuntimeException) cause;         } else if (cause instanceof Error) {             throw (Error) cause;         } else {             throw new IllegalStateException(cause);         }     } catch (TimeoutException e) {         future.cancel(true);         throw e;     } }
public DecisionTree decisionTreeLearning(DataSet ds, List<String> attributeNames, ConstantDecisionTree defaultTree) {     if (ds.isEmpty()) {         return defaultTree;     } else if (allExamplesHaveSameClassification(ds)) {         return new ConstantDecisionTree(ds.getExamples().get(0).getClassification());     } else if (attributeNames.isEmpty()) {         return majorityValue(ds);     } else {         String chosenAttribute = chooseAttribute(ds, attributeNames);         DecisionTree tree = new DecisionTree(chosenAttribute);         List<String> remainingAttributes = new ArrayList<>(attributeNames);         remainingAttributes.remove(chosenAttribute);         for (String value : ds.getPossibleAttributeValues(chosenAttribute)) {             DataSet subSet = ds.getSubset(chosenAttribute, value);             DecisionTree subTree = decisionTreeLearning(subSet, remainingAttributes, majorityValue(ds));             tree.addBranch(value, subTree);         }         return tree;     } }
public void activateWriteInterest() {     m_selectorManager.execute(new Runnable() {         @Override         public void run() {             SelectionKey key = m_socketChannel.keyFor(m_selectorManager.getSelector());             if (key != null && key.isValid()) {                 int interestOps = key.interestOps() | SelectionKey.OP_WRITE;                 key.interestOps(interestOps);             }         }     }); }
public OutStreamOptions setTtl(long ttl) {     mTtl = ttl;     return this; }
public void applyClassifierAndUpdateTree(BoundingBox bb) {     entityClassifier.update();     entityTree.clear();     for (MapNode node : nodes.values()) {         if (bb.contains(node.getPosition())) {             entityTree.add(node);         }     }     for (MapWay way : ways.values()) {         if (bb.intersects(way.getBoundingBox())) {             entityTree.add(way);         }     }     for (MapEntity entity : pois) {         if (bb.contains(entity.getPosition())) {             entityTree.add(entity);         }     }     for (Track track : tracks) {         entityTree.add(track);     } }
@Test public void testSetVariation() {     double variation = 1.5;     hdg.setVariation(variation);     assertEquals(variation, hdg.getVariation(), 0.01); }
public void setDataUnitId(Long dataUnitId) {     this.dataUnitId = dataUnitId; }
public void setFailLifetimeExceedance(boolean failLifetimeExceedance) {     this.failLifetimeExceedance = failLifetimeExceedance; } public boolean isFailLifetimeExceedance() {     return failLifetimeExceedance; } public void setMaxLifetime(long maxLifetime) {     this.maxLifetime = maxLifetime; } public long getMaxLifetime() {     return maxLifetime; } public void setLifetime(long lifetime) {     this.lifetime = lifetime; } public long getLifetime() {     return lifetime; } public void setAcceptClientLifetime(boolean acceptClientLifetime) {     this.acceptClientLifetime = acceptClientLifetime; } public boolean isAcceptClientLifetime() {     return acceptClientLifetime; } public long getFutureTimeToLive() {     return futureTimeToLive; } public void setFutureTimeToLive(long futureTimeToLive) {     this.futureTimeToLive = futureTimeToLive; } public ConditionsBean getConditions(TokenProviderParameters providerParameters) {     // Implementation here } public List<AudienceRestrictionBean> createAudienceRestrictions(TokenProviderParameters providerParameters) {     // Implementation here } public String extractAddressFromParticipantsEPR(Object participants) {     // Implementation here }
public Exception cancel(Exception error) {     this.cancelled = true;     this.error = error;     return error; }
public HashCodeBuilder appendChar(char value) {     iTotal = 31 * iTotal + value;     return this; }
@Override public String getDataSourceName() {     return dataSourceName; }
public void setIdentityMapper(IdentityMapper identityMapper) {     this.identityMapper = identityMapper; }
public boolean decompose(DenseMatrix64F orig) {     if (!decomp.decompose(orig))         return false;     final int N = orig.numCols;     if (values.length < N) {         values = new double[N];     }     decomp.getDiagonal(values);     return true; }
public String getClaimDialect() {     return claimDialect; }
@Test public void convertToClockTimeWithOneHour10Minutes45Seconds() {     long ms = 1L * 60 * 60 * 1000 + 10L * 60 * 1000 + 45L * 1000;     String expected = "1:10:45";     String actual = WebUtils.convertMsToClockTime(ms);     assertEquals(expected, actual); }
public void setBufferedImageType(int type) {     this.bufferedImageType = type;     if (outputImage != null) {         outputImage.flush();     }     outputImage = createBufferedImage(width, height); }
public void clearAndAppendToLogFile() {     mypage.clear();     append(mypage.getCompactPage()); }
public List<String> getAllUsernames() {     return userService.getAllUsernames(); }
public double getDecompositionQuality() {     DenseMatrix64F reconstructed = new DenseMatrix64F(mat.numRows, mat.numCols);     CommonOps.mult(eig.getV(), CommonOps.mult(eig.getD(), CommonOps.transpose(eig.getV())), reconstructed);     double errorNorm = NormOps.normF(mat) - NormOps.normF(reconstructed);     double maxNorm = Math.max(NormOps.normF(mat), NormOps.normF(reconstructed));     return errorNorm / maxNorm; }
public boolean isSecurityEnabled() {     // Implement logic to check if security is enabled     // Return true if security is enabled, false otherwise }
public void trackNodeReferences(boolean track) {     if (trackNodeReferences != track) {         if (track) {             if (nodeReferenceMap == null) {                 nodeReferenceMap = new IdentityHashMap<Node, Integer>();             } else {                 nodeReferenceMap.clear();             }             for (TrackingEntry level : levels) {                 for (Node node : level.nodes) {                     nodeReferenceMap.put(node, nextIndex++);                 }             }         } else {             nodeReferenceMap = null;             nextIndex = 0;         }         trackNodeReferences = track;     } }
public int getItemUtility(int row, int column) {     MatrixPosition position = new MatrixPosition(row, column);     if (!positions.contains(position)) {         throw new IllegalArgumentException("Invalid cell position: " + position);     }     return originalMatrix.getValue(row, column) + getRemainingUtility(row, column); }
void testSetHeading() {     // Initialize an HDTParser object with the EXAMPLE sentence     HDTParser parser = new HDTParser(EXAMPLE);          // Test setting a too high heading value     double tooHigh = 361.0;     parser.setHeading(tooHigh);     assertTrue(parser.getHeading() == 0.0);          // Test setting a valid heading value     double validHeading = 90.1;     parser.setHeading(validHeading);     assertTrue(parser.getHeading() == validHeading);          // Test setting a negative heading value     double negativeHeading = -45.0;     parser.setHeading(negativeHeading);     assertTrue(parser.getHeading() == 315.0); }
public int getSubmatrixElementIndex() {     if (rowMajor) {         return (subRow + (index / submatrixStride)) * a.numCols + (subCol + (index % submatrixStride));     } else {         return (subRow + (index % submatrixStride)) * a.numCols + (subCol + (index / submatrixStride));     } }
@Override public String toString() {     return literalName; }
public int getColumn() {     return this.column; }
public void setSignatureCrypto(Crypto signatureCrypto) {     this.signatureCrypto = signatureCrypto; }
/**  * Test method for {@link net.sf.marineapi.nmea.parser.RMCParser#setCourse(double)}.  */ public void testSetCourse() {     double course = 45.67;     rmc.setCourse(course);     assertEquals(course, rmc.getCourse(), 0.01); }
public int getMaxValue() {     return this.maxValue; }
public void setTime(Date date) {     Calendar cal = Calendar.getInstance();     cal.setTime(date);     this.hour = cal.get(Calendar.HOUR_OF_DAY);     this.minutes = cal.get(Calendar.MINUTE);     this.seconds = cal.get(Calendar.SECOND) + cal.get(Calendar.MILLISECOND) / 1000.0; }
private int closeTags(Stack<Tag> tags, String tag, int start) {     int end = builder.length();     while (!tags.isEmpty()) {         Tag t = tags.peek();         if (t.tag.equals(tag)) {             t.closeTag = end;             builder.append(t.style.closeTag);             tags.pop();             return end;         } else {             int offset = getOffset(t, builder.subSequence(start, end));             t.closeTag = end + offset;             builder.insert(end, t.style.closeTag);             end += t.style.closeTag.length() + offset;             tags.pop();         }     }     return end; }
public String[] getSearchModeNames() {     String[] searchModeNames = {"TREE_SEARCH", "DF_SEARCH", "GRAPH_SEARCH", "BF_SEARCH", "UC_SEARCH", "ID_SEARCH", "ASTAR_SEARCH", "GBF_SEARCH", "RBF_SEARCH", "HILL_SEARCH"};     return searchModeNames; }
public void setObject(String object) {     this.object = object; }
/** * Adds an unnamed value to the formatted output. * It is strongly encouraged to use {@link #add(String,long)} instead and give value a readable name. */ public ToStringHelper add(long value) {     ValueHolder valueHolder = addHolder();     valueHolder.value = value;     return this; }
public Conduit getConduit() {     Endpoint endpoint = getEndpoint();     if (endpoint == null) {         throw new IllegalStateException("Endpoint must be set before getting the conduit");     }     Conduit conduit = conduitSelector.selectConduit(endpoint);     if (conduit == null) {         throw new IllegalStateException("Could not find conduit for endpoint: " + endpoint);     }     prepareConduitSelector(conduit.getTarget());     return conduit; }
public int capacity() {     return buffer.capacity() - buffer.position(); }
public String getKeyAlias() {     String alias = this.keyAlias;     if (alias == null || alias.isEmpty()) {         alias = ServerConfig.getInstance().getKeyAlias();     }     return alias; }
public static float getTrapezoidArea(double topLength, double bottomLength, double height) {     double area = ((topLength + bottomLength) / 2) * height;     return (float) area; }
public Map<String, String> getStrings(String key) {     Map<String, String> stringMap = new HashMap<>();     for (String propertyKey : overrides.stringPropertyNames()) {         if (propertyKey.startsWith(key)) {             stringMap.put(propertyKey, overrides.getProperty(propertyKey));         }     }     return stringMap; }
public ActionUndo getUndoAction() {     return undoAction; }
public void dispatchTPVEvent(TPVEvent event) {     for (ProviderListener<T> listener : listeners) {         listener.handleTPVEvent(event);     } }
public class CollectionUtil {     private static TypeMap COLLECTION_CLASSES_BY_NAMES = new TypeMap(new Class[]{java.util.ArrayList.class, java.util.LinkedList.class, java.util.Vector.class, java.util.HashMap.class, java.util.LinkedHashMap.class, java.util.TreeMap.class, java.util.TreeSet.class, java.util.HashSet.class, java.util.LinkedHashSet.class, java.util.Hashtable.class});     private static TypeMap COLLECTION_INTERFACES_BY_NAMES = new TypeMap(new Class[]{java.util.List.class, java.util.Collection.class, java.util.Map.class, java.util.Set.class});     // Add elements from the source to the target as long as they don't already exist there.     // Return the number of items actually added.     public static <T> int addElementsIfNotExist(Set<T> target, T[] source) {         int count = 0;         for (T item : source) {             if (!target.contains(item)) {                 target.add(item);                 count++;             }         }         return count;     } }
public void setWord(O word, int multiplicity) {     DocumentElement<O> element = data.get(word);     if (element != null) {         element.incrementMultiplicity(multiplicity);     } else {         element = new DocumentElement<>(word, multiplicity);         data.put(word, element);     }     wordCountMultiSet += multiplicity; }
public void setHandlerClass(FullyQualifiedClassType handlerClass) {    this.handlerClass = handlerClass; }
public String getIndividualUri() {     return this.individualUri; }
void info(String str) {     logger.info(str);     JOptionPane.showMessageDialog(null, str, appName, JOptionPane.INFORMATION_MESSAGE); }
public int getApproximateElementCount() {     int count = 0;     for (int i = formatOff; i < format.length(); i++) {         char c = format.charAt(i);         if (Character.isDigit(c)) {             while (i < format.length() && Character.isDigit(format.charAt(i))) {                 i++;             }             count++;         } else if (c == 's') {             count++;         } else if (c == 'x' || c == 'X' || c == 'b' || c == 'B') {             // Skip the format specifier             i++;         } else if (c == '{') {             int end = format.indexOf('}', i);             if (end == -1) {                 // Syntax error in format string                 return -1;             }             i = end;         }     }     return count; }
public void setUp() throws Exception {     mThrown = ExpectedException.none();     mPlainSaslServer = new PlainSaslServer(new CallbackHandler() {         @Override         public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {             for (Callback callback : callbacks) {                 if (callback instanceof NameCallback) {                     ((NameCallback) callback).setName(user);                 } else if (callback instanceof PasswordCallback) {                     ((PasswordCallback) callback).setPassword(password.toCharArray());                 } else {                     throw new UnsupportedCallbackException(callback);                 }             }         }     }); }
public List<SequenceWithUtility> getSequences() {     return sequences; }
public boolean getBooleanValue(int index) {     Object value = values.get(index);     if (value instanceof Boolean) {         return ((Boolean) value).booleanValue();     } else if (value instanceof Integer) {         return ((Integer) value).intValue() != 0;     } else if (value instanceof Double) {         return ((Double) value).doubleValue() != 0.0;     } else if (value instanceof String) {         String s = (String) value;         return s.equalsIgnoreCase("true") || s.equals("1");     }     return false; }
public void setDragDropEnabled(boolean enabled) {     this.enabled = enabled; }
public static CommandHandler safeValueOf(String name) {     try {         return CommandHandler.valueOf(name);     } catch (IllegalArgumentException e) {         return null;     } }
public void setRoleClassifierType(String roleClassifierType) {     this.roleClassifierType = roleClassifierType; }
private URL loadResource(String path) {     URL resource = findResource(path);     if (resource == null) {         ClassLoader classLoader = getClass().getClassLoader();         resource = classLoader.getResource(path);     }     return resource; }
public class MainRegistry {     private ServerProxy proxy;     private static MainRegistry modInstance;     public void preInit(FMLPreInitializationEvent event) {         System.out.println("Pre-Initialization Phase called.");     }     public void postInit(FMLPostInitializationEvent event) {         System.out.println("Post-Initialization Phase called.");     } }
public static BigInteger findGCD(final BigInteger a, final BigInteger b) {     if (b.equals(BigInteger.ZERO)) {         return a;     } else {         return findGCD(b, a.mod(b));     } }
public Integer getSize() {     if (items != null) {         return items.size();     } else {         return 0;     } }
public void setFeedId(String feedId) {     this.feedId = feedId; }
public short getPrimitiveType() {     return primitiveType; }
public int getRemainingUtility(int row, int column) {     MatrixPosition position = new MatrixPosition(row, column);     return originalMatrix.getUtility(position) - getLocalSequenceUtility(position); }
public void addRepositoryPermissions(Collection<String> roles) {     for (String role : roles) {         String[] parts = role.split(":");         String repositoryName = parts[0].endsWith(".git") ? parts[0] : parts[0] + ".git";         AccessPermission permission = AccessPermission.fromSymbol(parts.length == 2 ? parts[1] : "RW+");         setRepositoryPermission(repositoryName, permission);     } }
public static <T> List<T> list(List<T> l, T o) {     if (l == null) {         l = new ArrayList<>();     }     l.add(o);     return l; }
public boolean isChainWorkHigher(StoredBlock other) {     return this.getChainWork().compareTo(other.getChainWork()) > 0; }
/**  * Sets the Id for a place to tag with this content.  *   * @param placeId The Id of the place to tag.  * @return An instance of ShareContent with the placeId set.  */ public E setPlaceId(String placeId) {     this.placeId = placeId;     return (E) this; }
public void setTypedTime(boolean flag) {     // set whether to generate "a=rtpmap:" attributes for static RTP/AVP format strings     // true: generate attributes, false: don't generate attributes     // the default is false     // set the flag value accordingly     // flag=true: generate attributes, flag=false: don't generate attributes     this.typedTime = flag; }
public static ByteBuffer stringToByteBuffer(String str) {     Charset charset = Charset.forName("US-ASCII");     ByteBuffer buffer = charset.encode(str);     return buffer; }
/**  * Requests a block from the server. This call will read the full block.  */ public void read() throws Exception {     AlluxioURI uri = new AlluxioURI("/testFile");     BlockInfo block = getFirstBlockInfo(uri);     long offset = 0;     long length = block.getLength();     RemoteBlockReader client = new RemoteBlockReader("localhost", mLocalAlluxioClusterResource.get().getWorkerAddress().getPort(),             mBlockWorkerClient, mBlockMasterClient, sManuallySchedule);     ByteBuffer data = readRemotely(client, block, (int) length);     assertValid(DataServerMessage.createBlockResponseMessage(offset, length, blockId, false, data),             data, blockId, offset, length); }
public boolean isExpired() {     Date now = new Date();     return now.after(expires); }
public Builder setUnsafeReplacement(String unsafeReplacement) {     this.unsafeReplacement = unsafeReplacement;     return this; }
public void printPassInfo(boolean pass) {     // Your example code here }
public static void appendNewBlock(Transaction tx, TableInfo ti, int flag) {     // Create a new block     Block blk = ti.fileMgr().append(ti.fileName());     // Pin the new block     BTreePage newPage = new BTreePage(tx, ti, blk, flag);     // Set the number of records to 0     newPage.setNumRecs(0);     // Unpin the new page     newPage.close(); }
public boolean finished() {     // TODO: implement method     return false; // replace with actual implementation }
protected void finalize() {     disconnect(); }
public void freeDbConnection(Connection con) {     if (con != null) {         try {             con.close();         } catch (SQLException e) {             LOG.error("Error while closing connection", e);         }     } }
public List<String> getRoles() {     return roles; }
/**  * Applies umask to the mode bits.  *  * @return A new Permission object with mode bits adjusted for umask.  */ public Permission applyUMask() {     int umask = FILE_UMASK.getBits();     int mode = mMode.getBits() & ~umask;     return new Permission(new Mode(mode), mOwner, mGroup); }
public void nextStep() {     futa.nextStep(); }
public int getSupport() {     int support = 0;     for (Element element : elements) {         if (element.getItems().contains(item)) {             support += element.getFrequency();         }     }     return support; }
/**  * Right Move the drone a little to the right.  */ void right() {     cmd.move(0, speed, 0, 0);     waitFor(spinTime);     cmd.move(0, -speed, 0, 0);     waitFor(spinTime);     cmd.hover(hoverTime); }
public static ELEvaluator getCurrent() {     return current.get(); }
public boolean isNewDatabase() {     return isNew; }
/**  * Returns a function that ignores its input and always returns {@code value}.  * Java 8 users: use the lambda expression {@code o -> value} instead.  */ public static <T, V> Function<T, V> constant(final V value) {     return new Function<T, V>() {         @Override         public V apply(T t) {             return value;         }     }; }
public String getWsse11TokenType() {     return wsse11TokenType; }
public void setResultCode(String resultCode) {     this.resultCode = resultCode; }
public RpcConnection createRpcConnection(String type) {     switch (type) {         case "msf":             return new RpcConnection();         case "jsonrpc":             return new JsonRpcConnection();         case "xmlrpc":             return new XmlRpcConnection();         default:             throw new IllegalArgumentException("Unsupported RPC type: " + type);     } }
@Test public void testFindBlacklistedSites() {     // Initialize the mock repository with some test data     mockRepository.save(site1);     mockRepository.save(site2);     // Call the service to find blacklisted sites     Set<BlacklistedSite> blacklistedSites = service.findBlacklistedSites();     // Verify that the returned set contains the expected blacklisted sites     assertTrue(blacklistedSites.contains(site1));     assertTrue(blacklistedSites.contains(site2));     assertFalse(blacklistedSites.contains(new BlacklistedSite(uri3))); }
public static int parseUnsignedInt(String stringValue, int radix) {     if (stringValue == null) {         throw new NumberFormatException("null");     }     if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX) {         throw new NumberFormatException("illegal radix: " + radix);     }     int length = stringValue.length();     if (length == 0) {         throw new NumberFormatException("empty string");     }     int i = 0;     int result = 0;     while (i < length) {         int digit = Character.digit(stringValue.charAt(i++), radix);         if (digit < 0) {             throw new NumberFormatException(stringValue);         }         result = result * radix + digit;     }     return result; }
public AuthenticationHolderEntity getAuthenticationHolder() {     return authenticationHolder; } public void setAuthenticationHolder(AuthenticationHolderEntity authenticationHolder) {     this.authenticationHolder = authenticationHolder; }
@Test public void testSetSentenceCount() {     RTETest rteTest = new RTETest();     RTEParser parser = new RTEParser(rteTest.rte);     int expected = 3;     parser.setSentenceCount(expected);     assertEquals(expected, rteTest.rte.getSentenceCount()); }
public Script createP2SHMultiSigInputScript(@Nullable List<TransactionSignature> signatures, Script multisigProgram) {     ScriptBuilder inputScriptBuilder = new ScriptBuilder();     // Append each signature to the input script     if (signatures != null) {         for (TransactionSignature signature : signatures) {             inputScriptBuilder.data(signature.encodeToBitcoin());         }     }     // Append the OP_CHECKMULTISIG opcode to the input script     inputScriptBuilder.smallNum(signatures != null ? signatures.size() : 0);     List<byte[]> chunks = multisigProgram.getChunks();     for (byte[] chunk : chunks) {         inputScriptBuilder.data(chunk);     }     inputScriptBuilder.smallNum(chunks.size());     inputScriptBuilder.op(OP_CHECKMULTISIG);     // Append the P2SH script program bytes to the input script     if (multisigProgram.isPayToScriptHash()) {         inputScriptBuilder.data(multisigProgram.getProgram());     }     return inputScriptBuilder.build(); }
public static boolean isAuthenticationEnabled() {     // implementation logic here     // return true if authentication is enabled, false otherwise     return true; }
public void setReferencedRevisionLabelB(String referencedRevisionLabelB) {     this.referencedRevisionLabelB = referencedRevisionLabelB; }
public double[] calculateAbsoluteValues(double[] z) {     double[] absValues = new double[z.length];     for (int i = 0; i < z.length; i++) {         absValues[i] = Math.abs(z[i]);     }     return absValues; }
public Builder setSafeRange(char safeMin, char safeMax) {     if (safeMax < safeMin) {         safeMin = Character.MAX_VALUE;         safeMax = Character.MIN_VALUE;     }     this.safeMin = safeMin;     this.safeMax = safeMax;     return this; }
public void addListener(LineListener listener) {     synchronized (listeners) {         listeners.add(listener);     } }
public long timeElapsed() {     if (startTime == null || stopTime == null) {         return -1;     }     return stopTime.getTime() - startTime.getTime(); }
public void applyRenderingHints(Graphics2D g2d) {     Map renderingHints = getRenderingHints();     if (renderingHints != null) {         g2d.setRenderingHints(renderingHints);     } }
public String getClassnamePrefix() {     return classnamePrefix; }
public void parseMap(InputStream inputStream, MapBuilder consumer) {     try {         SAXParser parser = createParser();         parser.parse(inputStream, new OsmContentHandler(consumer));     } catch (Exception e) {         LOG.log(Level.SEVERE, "Error parsing OSM file", e);     } finally {         try {             inputStream.close();         } catch (IOException e) {             LOG.log(Level.WARNING, "Error closing OSM input stream", e);         }     } }
public byte[] getBytesValue(int index) {     Object value = values.get(index);     if (value instanceof byte[]) {         return (byte[]) value;     } else {         throw new IllegalArgumentException("Value at index " + index + " is not binary data.");     } }
@Test(timeout = 1000) public void lockBlockHangs() throws Exception {     mThrown.expect(BlockLockedException.class);     mLockManager.lockBlock(TEST_SESSION_ID, TEST_BLOCK_ID, BlockLockType.WRITE); }
public boolean removeAll(Collection<?> c) {     boolean modified = false;     for (Iterator<Type> iterator = v.iterator(); iterator.hasNext();) {         Type type = iterator.next();         if (type != topType && isSubtype(type, o)) {             iterator.remove();             modified = true;         }     }     return modified; } private boolean isSubtype(Type subtype, Type supertype) {     return ts.isSubtype(subtype, supertype); }
public EndpointReferenceType getFaultTo() {     return this.faultTo; }
public void setName(String name) {     this.name = name; }
public void onNakFeedback() {     // Implementation goes here }
/**  * Set the Subject Role Classifier to use. If this value is not specified, then it tries to get roles from the   * supplied JAAS Subject (if not null) using the DefaultSecurityContext in cxf-rt-core. Otherwise it uses this value   * in combination with the SUBJECT_ROLE_CLASSIFIER_TYPE to get the roles from the Subject.  *  * @param roleClassifier The role classifier to use  */ public void setRoleClassifier(String roleClassifier) {     this.roleClassifier = roleClassifier; }
@Test public void byteArrayWrite() throws Exception {     for (int i = 0; i < BLOCK_LENGTH; i++) {         mTestStream.write(INCREASING_BYTES[i]);     }     mTestStream.flush();     byte[] output = mTestStream.toByteArray();     Assert.assertArrayEquals(INCREASING_BYTES, output); }
public BufferedByteWriter put16(short value) {     ensureCapacity(2);     mBuffer[mWriter.position()] = (byte) (value >> 8);     mBuffer[mWriter.position() + 1] = (byte) value;     mWriter.position(mWriter.position() + 2);     return this; }
void removeFileFromBucket(InodeFile file) {     TtlBucket bucket = getBucketContaining(file);     if (bucket != null) {         bucket.removeFile(file);     } }
public String getNoRun() {     return noRun; }
public void checkPermission(String user, Mode.Bits bits, String path) {   if (!mPermissionCheckEnabled) {     return;   }   if (!mInodeTree.validPath(path)) {     return;   }   try {     LockedInodePath inodePath = mInodeTree.lockInodePath(path, InodeTree.LockMode.READ);     try {       checkInode(user, getGroups(user), inodePath.getInode(), bits, path);     } finally {       inodePath.unlock();     }   } catch (Exception e) {     throw new AccessControlException(toExceptionMessage(user, bits, path, null));   } }
public void executeDeleteQuery(String user, String message, String graphName, String revision, String triples) {     try {         String query = String.format("DELETE DATA FROM <%s> { %s }", graphName, triples);         ep.update(query);         logger.info(String.format("User %s successfully executed DELETE query for graph %s in revision %s with message: %s",                 user, graphName, revision, message));     } catch (Exception e) {         logger.error(String.format("Error executing DELETE query for graph %s in revision %s with message: %s",                 graphName, revision, message), e);     } }
@Test public void deleteNonExistingLineage() throws Exception {     mThrown.expect(LineageDoesNotExistException.class);     mThrown.expectMessage("Lineage 1 does not exist");     // Attempt to delete a non-existing lineage with ID 1     mLineageStore.deleteLineage(1L); }
null
public CString getHandlerName() {     return handlerName; }
public void disconnected(SshDisconnectedEvent ev) {     // implementation here }
public long getMessageNumber() {     return messageNumber; }
public List<String> getIssuerConstraints(CertificateConstraintsType certConstraints) {     if (certConstraints == null || certConstraints.getIssuerConstraints() == null) {         return Collections.emptyList();     }     return certConstraints.getIssuerConstraints().getRegularExpression(); }
public void setRegisteredAudiences(List<String> registeredAudiences) {     this.registeredAudiences = registeredAudiences; }
public Script createMultiSigProgram(List<ECKey> pubKeys, int threshold) {     ScriptBuilder builder = new ScriptBuilder();     // Add threshold and public keys to script     builder.smallNum(threshold);     for (ECKey key : pubKeys) {         builder.data(key.getPubKey());     }     // Add OP_CHECKMULTISIG opcode     builder.smallNum(pubKeys.size());     builder.op(OP_CHECKMULTISIG);     return builder.build(); }
public static long toUnsignedLong(int value) {     return value & INT_MASK; }
public Object getOption(int optID) {     if (optID == StandardSocketOptions.SO_FILE_DESCRIPTOR) {         return this.fd;     }     return null; }
public Site findOne(String id) {     return siteRepository.findById(id).orElse(null); }
/**  * Gets a {@link ByteBuffer} containing an increasing sequence of bytes starting at the given value.  *  * @param start the starting byte value  * @param len the length of the sequence  * @return a {@link ByteBuffer} containing the increasing byte sequence  */ public static ByteBuffer getIncreasingByteBuffer(int start, int len) {     byte[] arr = getIncreasingByteArray(start, len);     ByteBuffer buffer = ByteBuffer.wrap(arr);     return buffer; }
public void testGetStatus() {     ttm.setStatus("A");     assertEquals("A", ttm.getStatus());     empty.setStatus("");     assertEquals("", empty.getStatus()); }
public boolean isWindowsPath() {     String path = mUri.getPath();     if (path.length() > 2 && path.charAt(0) == SEPARATOR.charAt(0) && Character.isLetter(path.charAt(1)) && path.charAt(2) == ':') {         return true;     }     return false; }
/**  * Final computation for a single row of 'v': v = y - (1/2)gamma(y^Tu)u.  * @param blockLength the block size  * @param A the tridiagonal matrix  * @param V the matrix for storing reflectors  * @param row the row of 'v' to compute  * @param gamma the value of gamma  */ public void computeY(final int blockLength, final D1Submatrix64F A, final D1Submatrix64F V, int row, double gamma) {     // Get the submatrices for the rows     D1Submatrix64F Y = A.colRange(row, row + 1);     D1Submatrix64F U = V.colRange(row, row + 1);     // Compute the inner product of y and u     double yTu = innerProdRowSymm(blockLength, A, row, V, row, 1);     // Compute the scalar factor     double scalar = -0.5 * gamma * yTu;     // Compute v = y - (1/2)gamma(y^Tu)u     for (int i = 0; i < blockLength; i++) {         double yVal = Y.get(i, 0);         double uVal = U.get(i, 0);         U.set(i, 0, uVal + scalar * yVal);     } }
public String getBaseUrl() {     try {         URL url = new URL(this.url);         String baseUrl = url.getProtocol() + "://" + url.getHost();         if (url.getPort() != -1) {             baseUrl += ":" + url.getPort();         }         return baseUrl;     } catch (MalformedURLException e) {         // Handle exception         return null;     } }
public int countWhite() {     return 64 - countBlack() - taken.cardinality(); }
public BookPreview getPreview(UUID uuid) {     for (BookPreview preview : data) {         if (preview.getUUID().equals(uuid)) {             return preview;         }     }     return null; }
public boolean isEmpty() {     return allNodes.isEmpty(); }
public DagEngine getDagEngine(String user, String authToken) {     if (user == null || user.isEmpty()) {         throw new IllegalArgumentException("System user must be specified");     }     // Perform authentication with the given auth token     // Check if user belongs to any group     return new DagEngine(user); }
public InputStream getResourceStream(String resourcePath) {     ClassLoader classLoader = getClass().getClassLoader();     if (classLoader != null) {         return classLoader.getResourceAsStream(resourcePath);     } else {         return ClassLoader.getSystemResourceAsStream(resourcePath);     } }
public void offerAll(Iterable<? extends T> elements) {     for (T elem : elements) {         offer(elem);     } }
public ProjectValidation createProjectValidation() {     return new ProjectValidation(); }
public boolean putMapNotNullKeyAndValue(Map<K, V> map, K key, V value) {     if (key != null && !key.toString().isEmpty() && value != null && !value.toString().isEmpty()) {         map.put(key, value);         return true;     } else {         return false;     } }
public Object firstNotNull(Object o1, Object o2) {     if(o1 != null) {         return o1;     } else {         return o2;     } }
public String getCsr() {    return csr; }
public class URLogs {   private static final String TAG_CONTENT_PRINT = "%s:%s.%s:%d";   private static boolean sIsLogEnabled = true;   private static String sApplicationTag = "Chen";      public void e(String msg) {     if (sIsLogEnabled) {       String tagContent = getTagContentPrint();       Log.e(tagContent, msg);     }   }      // other member functions (getters, setters, log functions) implementation goes here    }
public Set<String> getRecentlyGrantedPermissions() {     return recentlyGrantedPermissions; }
public boolean isLessThan(final Fiat other) {     return this.compareTo(other) < 0; }
public void setType(String type) {     this.type = type; }
public class DaoTextCache {     // member variables here     // member function headers:     void purgeOldKeys(Date date) {         // implementation here     }     int cacheText(String key, String text) {         // implementation here     }     void deleteAllKeys() {         // implementation here     }     String getText(String key) {         // implementation here     }     String generateMD5Key(String text) {         try {             MessageDigest md = MessageDigest.getInstance("MD5");             md.update(text.getBytes());             byte[] bytes = md.digest();             StringBuilder sb = new StringBuilder();             for (byte b : bytes) {                 sb.append(Integer.toHexString(b & 0xff));             }             return sb.toString();         } catch (NoSuchAlgorithmException e) {             e.printStackTrace();             return null;         }     } }
public BufferedByteWriter put32(int value) {     ensureCapacity(4);     mWriter.order(ByteOrder.BIG_ENDIAN);     mWriter.putInt(value);     return this; }
public String generateFinal(Object modelElement, Map args) {     if(modelElement instanceof Field) {         Field field = (Field) modelElement;         if(Modifier.isFinal(field.getModifiers())) {             return "final ";         }     } else if(modelElement instanceof Method) {         Method method = (Method) modelElement;         if(Modifier.isFinal(method.getModifiers())) {             return "final ";         }     }     return ""; }
public class SimpleSVD {     private SingularValueDecomposition<DenseMatrix64F> svd;     private DenseMatrix64F mat;     private T U;     private T V;     private T W;     public SimpleSVD(DenseMatrix64F mat) {         this.mat = mat;         this.svd = DecompositionFactory.svd(mat.numRows, mat.numCols, true, true, false);         if (!DecompositionFactory.decomposeSafe(svd, mat)) {             throw new IllegalArgumentException("Matrix cannot be decomposed");         }     }     public double getSingleValue(int index) {         return svd.getSingularValue(index);     }     public int rank() {         return svd.rank();     }     public SimpleMatrix nullSpace() {         return new SimpleMatrix(svd.getV(null, true));     }     public int nullity() {         return mat.numCols - svd.rank();     }     public T getU() {         return (T) new SimpleMatrix(svd.getU(null, false));     }     public double quality() {         return svd.quality();     }     public T getV() {         return (T) new SimpleMatrix(svd.getV(null, true));     }     public SingularValueDecomposition getSVD() {         return svd;     }     public SimpleMatrix getSingularValues() {         double[] singularValues = svd.getSingularValues();         int n = singularValues.length;         SimpleMatrix singularValuesMat = new SimpleMatrix(n, n);         for (int i = 0; i < n; i++) {             singularValuesMat.set(i, i, singularValues[i]);         }         return singularValuesMat;     } }
private static final OpenIDClaimMapper instance = new OpenIDClaimMapper(); public static OpenIDClaimMapper getInstance() {     return instance; } private OpenIDClaimMapper() {     // Load claim mapper from file     URL resourceUrl = getClass().getResource(OPENID_CLAIM_MAPPER_FILE_PATH);     OMElement element = null;     try {         element = new StAXOMBuilder(resourceUrl.openStream()).getDocumentElement();     } catch (IOException e) {         throw new RuntimeException(e);     } catch (XMLStreamException e) {         throw new RuntimeException(e);     }          // Process initial claims     process(element); } public void process(String filePath) {     // Load claim mapper from file     OMElement element = null;     try {         element = new StAXOMBuilder(new FileInputStream(filePath)).getDocumentElement();     } catch (FileNotFoundException e) {         throw new RuntimeException(e);     } catch (XMLStreamException e) {         throw new RuntimeException(e);     }          // Process initial claims     process(element); } public void process(OMElement initialClaims) {     // Process claim mappings     OMElement sregElement = initialClaims.getFirstChildWithName(new QName(LN_CLAIM_MAPPER, LN_SREG));     if (sregElement != null) {         Iterator<?> sregIterator = sregElement.getChildElements();         while (sregIterator.hasNext()) {             OMElement mapping = (OMElement) sregIterator.next();             String sregUri = mapping.getAttributeValue(new QName("uri"));             String claimAlias = mapping.getText();             sregMapping.put(sregUri, claimAlias);         }     }          OMElement axElement = initialClaims.getFirstChildWithName(new QName(LN_CLAIM_MAPPER, LN_AXSCHEMA));     if (axElement != null) {         Iterator<?> axIterator = axElement.getChildElements();         while (axIterator.hasNext()) {             OMElement mapping = (OMElement) axIterator.next();             String axUri = mapping.getAttributeValue(new QName("uri"));             String claimAlias = mapping.getText();             axMapping.put(axUri, claimAlias);         }     }          OMElement openidElement = initialClaims.getFirstChildWithName(new QName(LN_CLAIM_MAPPER, LN_OPENID_SCHEMA));     if (openidElement != null) {         Iterator<?> openidIterator = openidElement.getChildElements();         while (openidIterator.hasNext()) {             OMElement mapping = (OMElement) openidIterator.next();             String openidUri = mapping.getAttributeValue(new QName("uri"));             String claimAlias = mapping.getText();             openidMapping.put(openidUri, claimAlias);         }     } }
public void freeHessian2Input(Hessian2Input in) {     if (in != null) {         in.reset();         _freeHessian2Input.free(in);     } }
public static void main(String[] args) {     SshExample sshExample = new SshExample();     SshClient client = SshClient.setUpDefaultClient();     client.start();     try {         ConnectFuture future = client.connect("localhost", 22);         future.await();         SshSession session = future.getSession();         session.addPasswordIdentity("password");         session.auth().verify();         session.addSshListener(sshExample);         sshExample.connected = true;         BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));         String line;         while (sshExample.connected && (line = reader.readLine()) != null) {             session.channel(SshConstants.SSH_CHANNEL_EXEC, line).open().waitFor();         }     } catch (Exception e) {         e.printStackTrace();     } finally {         client.stop();     } }
private String removePunctuation(String post) {     String cleanedPost = post.replaceAll("\\p{Punct}", "");      return cleanedPost; } private String[] cleanPost(String post) {     String cleanedPost = removePunctuation(post);     // remove stop words and perform any additional cleaning here     String[] cleanTokens = cleanedPost.split("\\s+");     return cleanTokens; }
public Abstraction getAbstraction() {     return abstraction; }
public int compareTo(TtlBucket otherBucket) {     long otherStartTime = otherBucket.getTtlIntervalStartTimeMs();     long thisStartTime = this.getTtlIntervalStartTimeMs();     if (thisStartTime < otherStartTime) {         return -1;     } else if (thisStartTime == otherStartTime) {         return 0;     } else {         return 1;     } }
public Document extractAll(InputStream in, LuceneDocumentMetadata documentMetadata, boolean extractContent, boolean extractMetadata) throws IOException, TikaException {     if (documentMetadata == null) {         documentMetadata = defaultDocumentMetadata;     }     // Validate media type using detector     MediaType mediaType = detector.detect(in, new Metadata());     if (!extractor.isSupported(mediaType)) {         return null;     }     // Extract metadata     Document doc = extractMetadata(in, documentMetadata);     // Extract content if specified     if (extractContent) {         Field contentField = getContentField(documentMetadata, extractContent(in));         doc.add(contentField);     }     return doc; }
public List<T> getTopK() {     PriorityQueue<T> pq = new PriorityQueue<>(k, comparator);     for (int i = 0; i < buffer.length; i++) {         if (buffer[i] != null) {             pq.offer(buffer[i]);             if (pq.size() > k) {                 pq.poll();             }         }     }     List<T> result = new ArrayList<>(pq.size());     while (!pq.isEmpty()) {         result.add(pq.poll());     }     return Collections.unmodifiableList(result); }
public void testGetTime() {     try {         // Parse the example string         zda.parse(EXAMPLE);                  // Ensure that the time is correct         assertEquals(new Time(3, 29, 15), zda.getTime());              } catch (Exception e) {         fail("Unexpected exception: " + e.getMessage());     } }
public void testGetDay() {     int day = 15;     instance.setDay(day);     assertEquals(day, instance.getDay()); }
public void testFindVersionsForLanguageNameAndVersion() {     LanguageVersion result = LanguageRegistry.findLanguageVersionByTerseNameAndVersion(terseName, version);     assertEquals("Expected language version not found for terse name and version combination.", expected, result); }
public static String escape(String str) {     if (str == null) {         return null;     }     return SPECIAL_REGEX_CHARS.matcher(str).replaceAll("\\\\$0"); }
public void setExpDataUnitId(BigDecimal expDataUnitId) {     this.expDataUnitId = expDataUnitId; }
public OperationMetric getCalculator() {     return calculator; }
@Test public void testGetSentenceIndex() {     GSVParser parser = new GSVParser();     int index = 3;     parser.setSentenceIndex(index);     assertEquals(index, parser.getSentenceIndex()); }
public void save(SiteUrl siteUrl) {     siteUrlRepository.save(siteUrl); }
public DataServerMessage createDefaultBlockRequestMessage() {     // Allocate the message header     ByteBuffer header = ByteBuffer.allocate(REQUEST_HEADER_LENGTH);          // Create the message object with header and default values     DataServerMessage message = new DataServerMessage();     message.mHeader = header;     message.mMessageType = RPCMessage.Type.REQUEST;     message.mToSendData = false;     message.mLength = 0;     message.mSessionId = 0;     message.mBlockId = 0;     message.mIsMessageReady = false;     message.mData = null;     message.mStatus = RPCResponse.Status.OK;     message.mLockId = -1L;     message.mOffset = 0L;          return message; }
public boolean isTransactionActive() {     return entityManager.getTransaction().isActive(); }
public void testGetTimeToCPA() {     double expected = 7.0;     TTMParser ttm = new TTMParser(EXAMPLE);     double actual = ttm.getTimeToCPA();     assertEquals(expected, actual, 0.01); }
public void disconnected(SshDisconnectedEvent ev) {     // TODO: add implementation }
public String getValue() {     return this.value; }
public boolean next() {     while (idx.next()) {         if (idx.getVal().equals(val)) {             ts.moveToRid(idx.getDataRid());             return true;         }     }     return false; }
public void testSeekLastBlock() throws Exception {     // Create a temporary file and write some data to it     mFile = mFolder.newFile(TEST_FILENAME);     try (OutputStream os = new FileOutputStream(mFile)) {         byte[] data = new byte[(int) FILE_LENGTH];         os.write(data);     }     // Create a block stream for the file     mBlockStream = new UnderStoreBlockInStream(mFile, BLOCK_LENGTH);     // Seek to the start of the last block     long lastBlockStart = (FILE_LENGTH / BLOCK_LENGTH - 1) * BLOCK_LENGTH;     mBlockStream.seek(lastBlockStart);     // Verify that the position is correct     assertEquals(lastBlockStart, mBlockStream.getPosition()); }
public void testSetMonth() {     instance.setMonth(12);     assertEquals(12, instance.getMonth());     instance.setMonth(2);     assertEquals(2, instance.getMonth());     instance.setMonth(6);     assertEquals(6, instance.getMonth()); }
public String retrieveBestIndividual(Set<String> population, FitnessFunction fitnessFn) {     String bestIndividual = null;     double bestScore = Double.NEGATIVE_INFINITY;     for (int i = 0; i < getIterations(); i++) {         String individual = randomSelection(population, fitnessFn);         individual = reproduce(individual, randomSelection(population, fitnessFn));         individual = mutate(individual);         if (fitnessFn.apply(individual) > bestScore) {             bestIndividual = individual;             bestScore = fitnessFn.apply(individual);         }     }     return bestIndividual; }
public RPPA getRPPAValue() {     return rppaValue; }
void navigateToAttribute(QName attribute) {     Level current = path.peek();     current.setType(Node.ATTRIBUTE_NODE);     current.setName(attribute);     attributes.put(attribute, current); }
public EncryptionProperties getEncryptionProperties() {     return this.encryptionProperties; }
public AccessToken getAccessTokenForUser(List<String> permissions, Mode mode, String uniqueUserTag) {     JSONObject testAccount = findOrCreateSharedTestAccount(permissions, mode, uniqueUserTag);     String sharedTestAccountId = getSharedTestAccountIdentifier(permissions, uniqueUserTag);     String accessToken = getAppAccessToken();     AccessToken.AccessTokenBuilder builder = new AccessToken.AccessTokenBuilder()             .setToken(accessToken)             .setPermissions(permissions)             .setExpiresIn(DEFAULT_TIMEOUT);     builder.setUserId(testAccount.optString("id"));     builder.setApplicationId(getTestApplicationId());     builder.setDeclinedPermissions(new ArrayList<String>());     builder.setSource(AccessTokenSource.TEST_USER);     builder.setLastRefresh(null);     builder.setDataAccessExpirationTime(null);     builder.setGraphDomain(null);     builder.setApplicationSecret(getTestApplicationSecret());     builder.setAccessTokenExpiresAt(new Date().getTime() + DEFAULT_TIMEOUT * 1000);     builder.setRefreshToken(null);     builder.setTokenType(TokenType.USER);     builder.setSourceApplication(null);     builder.setExpiresInSeconds(DEFAULT_TIMEOUT);     builder.setProfilingEnabled(false);     builder.setSharedTestAccountCredentials(sharedTestAccountId, testApplicationSecret);     return builder.build(); }
public class Closeables {     private static final Logger logger = Logger.getLogger(Closeables.class.getName());     public static void closeQuietly(@Nullable Closeable closeable, boolean swallowIOException) {         if (closeable == null) {             return;         }         try {             closeable.close();         } catch (IOException e) {             if (swallowIOException) {                 logger.log(Level.WARNING, "IOException thrown while closing Closeable", e);             } else {                 throw new RuntimeException(e);             }         }     } }
public void setProperty(final String key, final String value) {     logger.debug("Setting property key: {}, value: {}", key, value);     properties.setProperty(key, value); }
public String getLanguage() {     return this._language; } public String getTitle() {     return this._title; } public String get_image() {     return this._image; } public String getDescription() {     return this._description; } public String getRSSLink() {     return this._rss_link; } public String getLink() {     return this._link; }
public void addItemStack(ItemStack stack) {     int amount = stack.getAmount();     Item item = stack.getItem();     if (amount <= 0 || item == null) {         return;     }     Integer currentAmount = invMap.get(item);     if (currentAmount == null) {         currentAmount = 0;     }     int remainingSpace = limit - count;     if (amount > remainingSpace) {         amount = remainingSpace;     }     if (amount > 0) {         invMap.put(item, currentAmount + amount);         count += amount;     } }
@Test public void testDateConstructor() {     Date date = new Date();     assertNotNull(date); }
public boolean empty() {     return vstack.empty(); } public void pop() {     vstack.pop();     real_stack.pop(); } public void get_from_real() {     real_next = real_stack.peek().parse_state; } public void push(int state_num) {     vstack.push(state_num);     real_stack.push(parser.tStack[parser.tStackTop]); }
public String pathDecode(String value) {     if (value == null) {         return null;     }     int index = value.lastIndexOf('/');     if (index < 0) {         return value;     }     try {         String path = value.substring(0, index + 1);         String decodedPath = urlDecode(path, "UTF-8");         return decodedPath;     } catch (UnsupportedEncodingException e) {         throw new RuntimeException(e);     } }
public void equalsTest() {     SetAttributeOptions options1 = SetAttributeOptions.defaults();     SetAttributeOptions options2 = SetAttributeOptions.defaults();          assertTrue(options1.equals(options2)); }
public int i() {     if (hasHardenedBit(i)) {         return i;     } else {         return i & (~HARDENED_BIT);     } }
public void setProduceMediaTypes(List<String> types) {     if (types != null) {         this.produceMediaTypes = types;     } }
public boolean isValidCommand() {     return !this.command.trim().isEmpty(); }
/**  * Test case for {@link S3AUnderFileSystem#delete(String, boolean)}.  */ public void deleteNonRecursiveOnAmazonClientException() {     // TODO: Implement test case } /**  * Renames a file/directory after an Amazon client exception occurs.  */ public void renameOnAmazonClientException() {     // TODO: Implement rename logic after Amazon client exception occurs } /**  * Sets up the test environment before running the test case.  */ public void before() {     // TODO: Implement setup logic for S3AUnderFileSystem delete test case }
public synchronized void setRequestedCameraId(int cameraId) {     requestedCameraId = cameraId;     camera = null; }
public static List<ByteBuffer> cloneByteBufferList(List<ByteBuffer> bufferList) {     List<ByteBuffer> clonedList = new ArrayList<>(bufferList.size());     for (ByteBuffer buffer : bufferList) {         clonedList.add(cloneByteBuffer(buffer));     }     return clonedList; } public static ByteBuffer cloneByteBuffer(ByteBuffer buf) {     ByteBuffer clone = ByteBuffer.allocate(buf.capacity());     buf.rewind();     clone.put(buf);     clone.flip();     return clone; }
public String getTitle() {     return title; }
public void addDirectedEdge(VertexLabelType from, VertexLabelType to, EdgeLabelType label) {     if (!isVertexLabel(from)) {         addVertex(from);     }     if (!isVertexLabel(to)) {         addVertex(to);     }     Hashtable<VertexLabelType, EdgeLabelType> edgeLookup = globalEdgeLookup.get(from);     if (edgeLookup == null) {         edgeLookup = checkForNewVertex(from);     }     edgeLookup.put(to, label); }
public class AsyncStorageErrorUtil {   // member variables   // member functions   public WritableMap getInvalidValueError(@Nullable String key) {     WritableMap error = new WritableNativeMap();     error.putString("message", "Invalid value for key " + key);     error.putString("key", key);     error.putString("type", "InvalidValue");     return error;   }   public WritableMap getDBError(@Nullable String key) {     WritableMap error = new WritableNativeMap();     error.putString("message", "Database Error: " + key);     error.putString("key", key);     error.putString("type", "DBError");     return error;   }   public WritableMap getInvalidKeyError(@Nullable String key) {     WritableMap error = new WritableNativeMap();     error.putString("message", "Invalid key: " + key);     error.putString("key", key);     error.putString("type", "InvalidKey");     return error;   } }
public List<String> getAllLoggerNames() {     return LOGGER_NAMES; }
public synchronized void groupFinished(JobsGroup jobsGroup, Context ctx) {     if (jobs.containsKey(jobsGroup.getId())) {         jobs.remove(jobsGroup.getId());     } } public synchronized void finishRunningJobs(Context ctx) {     JobsGroup runningGroup = controller.getRunningJobsGroup();     if (runningGroup != null && jobs.containsKey(runningGroup.getId())) {         JobsGroup group = jobs.get(runningGroup.getId());         if (group != null) {             group.finishRunningJobs(ctx);         }     } } public synchronized void addJobsGroup(JobsGroup jobsGroup, Context ctx) {     finishRunningJobs(ctx);     jobs.put(jobsGroup.getId(), jobsGroup);     jobsGroup.execute(ctx); }
public int getStart() {     return start; }
public void setPackagePrefixes(UriPrefixPair[] packagePrefixes) {     this.packagePrefixes = packagePrefixes; }
public void setSeqId(long seqId) {     this.seqId = seqId; }
public ProfileData getMergedProfileData() {     HashMap<String, String> map = new HashMap<String, String>();     ArrayList<ProfileData> profileList = new ArrayList<ProfileData>();     ArrayList<String> caseList = new ArrayList<String>();     ArrayList<String> geneList = new ArrayList<String>();     mergeProfiles(map, profileList, caseList, geneList);     createUnion(profileList, caseList, geneList);     ProfileData mergedProfileData = new ProfileData();     for (String gene : geneList) {         for (String caseId : caseList) {             String key = createKey(gene, caseId);             String value = map.get(key);             String alteredStatus = determineAlteredStatus(profileList, gene, caseId);             if (value != null) {                 mergedProfileData.setValue(gene, caseId, value, alteredStatus);             } else {                 mergedProfileData.setValue(gene, caseId, "", alteredStatus);             }         }     }     return mergedProfileData; }
public static DenseMatrix64F reflector(double gamma, D1Matrix64F u) {     int N = u.getNumElements();     DenseMatrix64F Q = CommonOps.identity(N);     VectorVectorMult.householder(gamma, u, Q, Q);     CommonOps.scale(-1, Q);     CommonOps.addIdentity(Q);     return Q; }
public Mode createMaskedMode(Mode umask) {     // Get the bits of the umask     Bits u = umask.getOwnerBits();     Bits g = umask.getGroupBits();     Bits o = umask.getOtherBits();     // Apply the umask to this mode's bits     Bits newOwnerBits = this.mOwnerBits.and(u.not()).or(u.and(umask.getOwnerBits()));     Bits newGroupBits = this.mGroupBits.and(g.not()).or(g.and(umask.getGroupBits()));     Bits newOtherBits = this.mOtherBits.and(o.not()).or(o.and(umask.getOtherBits()));     // Create a new mode with the masked bits     Mode maskedMode = new Mode(newOwnerBits, newGroupBits, newOtherBits);     return maskedMode; }
public Waypoint createWaypoint() {     return new Waypoint(this.latitude, this.longitude, this.altitude, this.datum); }
public void setTestId(long testId) {     this.testId = testId; }
void setSaveW(boolean saveW) {     this.saveW = saveW; }
public void setProtocolHandler(ProtocolHandler handler) {     m_readHandler.setProtocolHandler(handler); }
/**  * Retrieves a byte array field from the stream. Creates a new byte array that is the size of the object being retrieved.  *  * @param itemLen  the length of the item to be retrieved.  * @param dest     the byte array to store the retrieved item.  * @param off      the offset in the byte array to start storing the retrieved item.  * @param destLen  the length of the byte array to store the retrieved item.  */ void getByteArrayInternal(int itemLen, byte[] dest, int off, int destLen) throws IOException {     if (itemLen > destLen) {         throw new IllegalArgumentException("Destination buffer not large enough");     }     if (value == null) {         throw new IllegalStateException("No value has been set");     }     if (valueLen - valueOff < itemLen) {         throw new EOFException("Premature end of stream");     }     System.arraycopy(value, valueOff, dest, off, itemLen);     valueOff += itemLen; }
public static LogoutRequestSender getInstance() {     return instance; }
public int getNum() {     return num; }
public String getLastPathComponent() {     String path = mUri.getPath();     if (path == null || path.isEmpty()) {         return path;     }     int index = path.lastIndexOf(SEPARATOR);     if (index < 0) {         return path;     }     if (index == path.length() - 1) {         int prevIndex = path.lastIndexOf(SEPARATOR, index - 1);         if (prevIndex < 0) {             return path.substring(0, index);         }         index = prevIndex;     }     return path.substring(index + 1); }
public ResultType copyOpaqueClientData(RequestAbstractType request, ResultType response) {     String requestId = request.getId();     response.setId(requestId);     return response; }
/**  * Gets the property value associated with the given key as an Object.  * If the property value is "undefined", this function returns null.  * @param key the key of the property  * @return the property value as an Object or null if it is "undefined"  */ public Object getProperty(String key) {     Object value = jsObject.getMember(key);     return "undefined".equals(value) ? null : value; } /**  * Gets the property value associated with the given key as an object of the specified type.  * If the property value is "undefined", this function returns null.  * @param key the key of the property  * @param type the type of the property value  * @return the property value as an object of the specified type or null if it is "undefined"  */ public <T> T getProperty(String key, Class<T> type) {     Object value = getProperty(key);     return value != null && type.isInstance(value) ? type.cast(value) : null; }
public void redrawPage() {     view.invalidate(); }
public void testSetLatitude() {     instance.setLatitude(LATITUDE);     assertEquals(LATITUDE, instance.getLatitude(), 0.01); }
public void disconnect() {     mTextView.removeTextChangedListener(mChangeListener);     mEditHistory.clear(); }
public void setHighLevelChangesRenaming(HashMap<String, HighLevelChangeRenaming> highLevelChangesRenaming) {     for (String identifier : highLevelChangesRenaming.keySet()) {         this.highLevelChangesRenaming.put(identifier, highLevelChangesRenaming.get(identifier));     } }
@Deprecated public void request(String graphPath, Bundle parameters, RequestListener listener, Object state) {     String endpoint = GRAPH_BASE_URL + graphPath;     parameters.putString("format", "json");     fb.authorize();     AsyncFacebookRunner.Request request = new AsyncFacebookRunner.Request(fb, endpoint, parameters, "GET", listener, state);     request.execute(); }
public void setRotation(Rotation rotation) {     this.rotation = rotation;     for (StateListener listener : listeners) {         listener.onRotationChanged(this);     } }
public int getMatchedTokenLength() {     if (!hasFreePart() && (endChar(' ') || endChar('\n'))) {         return match.length;     }     return 0; }
void setupByteBuffer() {     mBuffer = ByteBuffer.allocate(LENGTH); }
// Test method for net.sf.marineapi.nmea.parser.RTEParser#isFirst() public void testIsFirst() {     // set up test data     RTEParser parser = new RTEParser();     parser.parse(EXAMPLE);     RTETest rteTest = new RTETest(parser.getSentence());     // test the method     assertTrue(rteTest.isFirst()); }
public void set_image(String _image) {     this._image = _image; } public void setDescription(String _description) {     this._description = _description; } public void setLanguage(String _language) {     this._language = _language; } public void setLink(String _link) {     this._link = _link; } public void setRSSLink(String _rss_link) {     this._rss_link = _rss_link; } public void setTitle(String _title) {     this._title = _title; }
public void setGeneB(long entrezGeneId) {     this.geneB = entrezGeneId; }
@Test(expected = ClosedChannelException.class) public void append() throws Exception {     mWriter = new LocalFileBlockWriter(mTestFilePath, TEST_BLOCK_SIZE);     mWriter.getChannel().close();     mWriter.append(ByteBuffer.allocate(10)); }
@Test public void createBlockId() {     long containerId = 12345L;     long sequenceNumber = MAX_SEQUENCE_NUMBER;     BlockId blockId = BlockId.createBlockId(containerId, sequenceNumber);     assertEquals(containerId, blockId.getContainerId());     assertEquals(sequenceNumber, blockId.getSequenceNumber()); }
/**  * This tests everything that the test for the static file above tests, but it also does the full download.  */ void testFullDownload() {     // Define the searcher and result factory     RestSearcher searcher = new YahooSearcher();     RestResultFactory factory = new YahooResultFactory();     // Define the test file path and number of expected results     String testFilePath = "test.json";     int numResults = 10;     try {         // Download the search results         RestSearchResponse response = searcher.search("Java programming");         Collection<RestSearchResult> results = response.getResults(numResults);         // Verify the results         verifyResults(results);         // Convert the results to JSON and verify         JsonRestResultFactory jsonFactory = new JsonYahooResultFactory();         String json = jsonFactory.toJsonString(results);         runJsonTest(testFilePath, jsonFactory, numResults, null, null, null);     } catch (Exception e) {         LOG.error("Error testing full download", e);         fail("Error testing full download: " + e.getMessage());     } }
public Stmt parseStmt(String fmt, Object... subst) {     return parser().parseStmt(fmt, subst); }
public List<String> getRedirectUris() {     return redirectUris; }
public byte[] getErrors() {     return this.errors; }
public List<CancerStudy> isAccessibleCancerStudy(String stableStudyId) {     List<CancerStudy> accessibleStudies = new ArrayList<CancerStudy>();     for (CancerStudy study : getCancerStudies()) {         if (stableStudyId.equals(study.getStableId())) {             accessibleStudies.add(study);             break;         }     }     return accessibleStudies; }
public boolean match(final Cookie cookie, final CookieOrigin origin) {     if (cookie == null) {         throw new IllegalArgumentException("Cookie may not be null");     }     if (origin == null) {         throw new IllegalArgumentException("Cookie origin may not be null");     }     String host = origin.getHost();     String domain = cookie.getDomain();     if (domain == null) {         return false;     }     boolean match = host.equals(domain);     if (!match) {         if (!domain.startsWith(".")) {             domain = '.' + domain;         }         match = host.endsWith(domain);         if (match) {             int prefix = host.length() - domain.length();             if (prefix > 0) {                 String substring = host.substring(0, prefix);                 if (substring.indexOf('.') != -1) {                     match = false;                 }             }         }     }     return match; }
public Iterator<BasicLogRecord> iterator() {     flush();     final int end = currentblk.currentPos();     final List<BasicLogRecord> records = new ArrayList<>();     for (int pos = end - 1; pos >= 0; pos--) {         final BasicLogRecord record = new BasicLogRecord();         final byte[] bytes = new byte[LogMgr.this.size(record)];         final Block blk = findBlock(pos);         final int offset = pos == end - 1 ? currentpos : LAST_POS;         while (true) {             if (blk.read(offset, bytes) != -1) {                 break;             }             blk = blk.nextBlock();             offset = FIRST_POS;         }         record.readFromBytes(bytes);         records.add(record);     }     return records.iterator(); }
public GetOfferDetailsResponse.Return.DetailOfferData.Merchant.Addresses createGetOfferDetailsResponseReturnDetailOfferDataMerchantAddresses() {     return new GetOfferDetailsResponse.Return.DetailOfferData.Merchant.Addresses(); }
void appendToFile(File file) {     try (RandomAccessFile raf = new RandomAccessFile(file, "rw")) {         raf.seek(raf.length());         byte[] block = new byte[BLOCK_SIZE];         contents.flip();         contents.get(block);         raf.write(block);     } catch (IOException e) {         e.printStackTrace();     } }
public class CountingNodeTester {     private int actualNumNodes;     private int expectedNumNodes;     public void resetCounter() {         actualNumNodes = 0;         expectedNumNodes = 0;     }     public void noMoreNodes(NodeTest forTest) {         if(forTest == null) {             return;         }         expectedNumNodes++;         if(forTest.left() != null) {             actualNumNodes++;         }         if(forTest.right() != null) {             actualNumNodes++;         }         if(forTest.left() != null) {             noMoreNodes(forTest.left());         }         if(forTest.right() != null) {             noMoreNodes(forTest.right());         }     }     public boolean singleNodeValid(NodeTest node) {         resetCounter();         noMoreNodes(node);         return (actualNumNodes == 0 && expectedNumNodes == 1);     } }
public void setConflictsNotApproved(int conflictsNotApproved) {     this.conflictsNotApproved = conflictsNotApproved; }
public void set(VertexLabelType from, VertexLabelType to, EdgeLabelType el) {     if (globalEdgeLookup.containsKey(from) && globalEdgeLookup.get(from).containsKey(to)) {         globalEdgeLookup.get(from).remove(to);     } }
public void nextStep() {     if (hasAttackTarget()) {         double distanceSq = getDistanceSqFromTarget();         if (distanceSq > 1.5D && distanceSq < 100.0D) {             this.mob.getNavigator().tryMoveToEntityLiving(this.attackTarget, 1.0D);         }     } }
public static Map<String, String> getGitblitServerSettings(String remoteUrl) {     Map<String, String> settings = new HashMap<>();     try {         URL url = new URL(remoteUrl + "/rpc/settings");         HttpURLConnection connection = (HttpURLConnection) url.openConnection();         connection.setRequestMethod("GET");         connection.connect();         int responseCode = connection.getResponseCode();         if (responseCode == HttpURLConnection.HTTP_OK) {             InputStream inputStream = connection.getInputStream();             BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));             String line;             while ((line = bufferedReader.readLine()) != null) {                 if (line.contains("=")) {                     String[] keyValue = line.split("=", 2);                     settings.put(keyValue[0], keyValue[1]);                 }             }             bufferedReader.close();         }     } catch (Exception e) {         LOGGER.error("Failed to get Gitblit server settings from remote URL: " + remoteUrl, e);     }     return settings; }
public boolean isValidSurrogatePairStart(String string, int index) {     if (index < 0 || index >= string.length() - 1) {         return false;     }     char c1 = string.charAt(index);     char c2 = string.charAt(index + 1);     return Character.isHighSurrogate(c1) && Character.isLowSurrogate(c2); }
/**  * Gets the actual bind hostname on RPC service (used by unit test only).  *  * @return the actual bind hostname on RPC service  */ public String getRpcBindHost() {     InetSocketAddress address = getAddress();     if (address != null) {         return address.getHostName();     } else {         LOG.warn("Failed to get RPC bind address.");         return mHostname;     } }
public String stringOrNull(char[] in) {     if (in.length == 1) {         char c = in[0];         if (replacementMap.containsKey(c)) {             return replacementMap.get(c);         } else if (c < safeMin || c > safeMax) {             return unsafeReplacement;         } else {             return null;         }     } else {         return null;     } }
public class OSSUnderFileSystemTest {     private String SRC = "src";     private OSSUnderFileSystem mOSSUnderFileSystem;     private String PATH = "path";     private String BUCKET_NAME = "bucket";     private String BUCKET_PREFIX = "prefix";     private OSSClient mClient;     private String DST = "dst";     public void deleteRecursiveOnServiceException() {         // Implementation for deleteRecursiveOnServiceException     }     public void before() {         // Implementation for before     }     public void deleteNonRecursiveOnServiceException() {         // Implementation for deleteNonRecursiveOnServiceException     }     // Test case for OSSUnderFileSystem#rename(String, String)     public void testCaseForRename() {         // Implementation for the test case     } }
public ScriptBuilder addOpCode(int opcode) {     chunks.add(new ScriptChunk(opcode, null));     return this; }
public void createDefaultAllocator() {     Allocator allocator = Allocator.Factory.create(mManagerView);     assertNotNull(allocator);     assertTrue(allocator instanceof GreedyAllocator); }
public void setContentEncoding(String contentEncoding) {     this.contentEncoding = contentEncoding; }
public void processCharacters() {     int index = 0;     while (index < line.length()) {         char currentChar = line.charAt(index);         if (currentChar == '\r' || currentChar == '\n') {             // Mark that we saw a return character             sawReturn = (currentChar == '\r');             // Finish the line             boolean finishedLine = finishLine(sawReturn);             if (finishedLine) {                 // Handle the finished line                 handleLine(line.toString(), null);                 // Reset the line buffer                 line.setLength(0);                 sawReturn = false;             }         } else {             // Add the character to the line buffer             line.append(currentChar);         }         index++;     } }
public class symbol {   private String _stack_type;   private String _name;   private int _index;   private int _use_count = 0;      // other member functions      public int use_count() {     _use_count++;     return _use_count;   } }
@Override public Document<O> next() {     while (true) {         if (documents == null || i >= documents.length) {             throw new NoSuchElementException();         }         File file = documents[i++];         if (fileFilter.accept(file.getParentFile(), file.getName())) {             String id = FilenameUtils.removeExtension(file.getName());             try (Stream<String> lines = Files.lines(file.toPath())) {                 String content = lines.collect(Collectors.joining(System.lineSeparator()));                 O object = readObjectFromStringLine(content);                 return new Document<>(id, object);             } catch (IOException e) {                 logger.warn("Failed to read file: " + file, e);             } catch (IllegalArgumentException e) {                 logger.warn("Failed to parse file: " + file, e);             }         }     } }
void putTransactionHashIntoResultIntent(final Intent result, final String transactionHash) {     result.putExtra(INTENT_EXTRA_TRANSACTION_HASH, transactionHash); }
public Iterator<OrderLineItemType> getOrderLineItems() {     // implementation code goes here }
public void setCheckedFlag(FolderInfo.CheckedFlag checkedFlag) {     this.checkedFlag = checkedFlag; }
void onSaveInstanceState(Bundle state) {     // Save the current dynamic state of the Presenter instance in the provided Bundle object }
public String getString(Block blk, int offset) {     concurMgr.sLock(blk);     Buffer buff = myBuffers.getBuffer(blk);     return buff.getString(blk, offset); }
public BitcoinPacketHeader deserializeHeader(ByteBuffer in) {     byte[] headerBytes = new byte[HEADER_LENGTH];     in.get(headerBytes, 0, HEADER_LENGTH);     return new BitcoinPacketHeader(headerBytes); }
public void apply(List<Node> nodes, RuleContext ctx, Language language) {     RuleChainVisitor visitor = getRuleChainVisitor(language);     visitor.addRule(this); }
public void activate() {     for (EventAction action : actions) {         action.execute();     } }
null
